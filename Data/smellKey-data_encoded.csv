function,smellKey,smellKey_encoded
"private void updateFunction(LambdaClient lambdaClient, Exchange exchange) throws Exception{
    UpdateFunctionCodeRequest request = null;
    UpdateFunctionCodeResponse result;
    if (getConfiguration().isPojoRequest()) {
        request = exchange.getIn().getMandatoryBody(UpdateFunctionCodeRequest.class);
    } else {
        UpdateFunctionCodeRequest.Builder builder = UpdateFunctionCodeRequest.builder();
        builder.functionName(getEndpoint().getFunction());
        if (ObjectHelper.isEmpty(exchange.getIn().getBody()) && ObjectHelper.isEmpty(exchange.getIn().getHeader(Lambda2Constants.S3_BUCKET)) && ObjectHelper.isEmpty(exchange.getIn().getHeader(Lambda2Constants.S3_KEY))) {
            throw new IllegalArgumentException("At least S3 bucket/S3 key or zip file must be specified");
        }
        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(Lambda2Constants.PUBLISH))) {
            Boolean publish = exchange.getIn().getHeader(Lambda2Constants.PUBLISH, Boolean.class);
            builder.publish(publish);
        }
        request = builder.build();
    }
    try {
        result = lambdaClient.updateFunctionCode(request);
    } catch (AwsServiceException ase) {
        LOG.trace("updateFunction command returned the error code {}", ase.awsErrorDetails().errorCode());
        throw ase;
    }
    Message message = getMessageForResponse(exchange);
    message.setBody(result);
}",java:S112,4
"private void createCluster(KafkaClient mskClient, Exchange exchange) throws InvalidPayloadException{
    if (getConfiguration().isPojoRequest()) {
        Object payload = exchange.getIn().getMandatoryBody();
        if (payload instanceof CreateClusterRequest) {
            CreateClusterResponse response;
            try {
                response = mskClient.createCluster((CreateClusterRequest) payload);
            } catch (AwsServiceException ase) {
                LOG.trace(""Create Cluster command returned the error code {}"", ase.awsErrorDetails().errorCode());
                throw ase;
            }
            Message message = getMessageForResponse(exchange);
            message.setBody(response);
        }
    } else {
        CreateClusterRequest.Builder builder = CreateClusterRequest.builder();
        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MSK2Constants.CLUSTER_NAME))) {
            String name = exchange.getIn().getHeader(MSK2Constants.CLUSTER_NAME, String.class);
            builder.clusterName(name);
        } else {
            throw new IllegalArgumentException(""Cluster Name must be specified"");
        }
        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MSK2Constants.CLUSTER_KAFKA_VERSION))) {
            String version = exchange.getIn().getHeader(MSK2Constants.CLUSTER_KAFKA_VERSION, String.class);
            builder.kafkaVersion(version);
        } else {
            throw new IllegalArgumentException(""Kafka Version must be specified"");
        }
        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MSK2Constants.BROKER_NODES_NUMBER))) {
            Integer nodesNumber = exchange.getIn().getHeader(MSK2Constants.BROKER_NODES_NUMBER, Integer.class);
            builder.numberOfBrokerNodes(nodesNumber);
        } else {
            throw new IllegalArgumentException(""Kafka Version must be specified"");
        }
        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(MSK2Constants.BROKER_NODES_GROUP_INFO))) {
            BrokerNodeGroupInfo brokerNodesGroupInfo = exchange.getIn().getHeader(MSK2Constants.BROKER_NODES_GROUP_INFO, BrokerNodeGroupInfo.class);
            builder.brokerNodeGroupInfo(brokerNodesGroupInfo);
        } else {
            throw new IllegalArgumentException(""BrokerNodeGroupInfo must be specified"");
        }
        CreateClusterResponse response;
        try {
            response = mskClient.createCluster(builder.build());
        } catch (AwsServiceException ase) {
            LOG.trace(""Create Cluster command returned the error code {}"", ase.awsErrorDetails().errorCode());
            throw ase;
        }
        Message message = getMessageForResponse(exchange);
        message.setBody(response);
    }
}",java:S3776,39
"protected Queue<Exchange> createExchanges(List<S3Object> s3ObjectSummaries){
    if (LOG.isTraceEnabled()) {
        LOG.trace(""Received {} messages in this poll"", s3ObjectSummaries.size());
    }
    Collection<ResponseInputStream<GetObjectResponse>> s3Objects = new ArrayList<>();
    Queue<Exchange> answer = new LinkedList<>();
    try {
        for (S3Object s3ObjectSummary : s3ObjectSummaries) {
            Builder getRequest = GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(s3ObjectSummary.key());
            if (getConfiguration().isUseCustomerKey()) {
                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {
                    getRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());
                }
                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {
                    getRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());
                }
                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {
                    getRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());
                }
            }
            ResponseInputStream<GetObjectResponse> s3Object = getAmazonS3Client().getObject(getRequest.build(), ResponseTransformer.toInputStream());
            if (includeS3Object(s3Object)) {
                s3Objects.add(s3Object);
                Exchange exchange = createExchange(s3Object, s3ObjectSummary.key());
                answer.add(exchange);
            } else {
                IOHelper.close(s3Object);
            }
        }
    } catch (Exception e) {
        LOG.warn(""Error getting S3Object due: {}"", e.getMessage(), e);
        s3Objects.forEach(IOHelper::close);
        throw e;
    }
    return answer;
}",java:S3776,39
"public void processMultiPart(final Exchange exchange) throws Exception{
    File filePayload = null;
    Object obj = exchange.getIn().getMandatoryBody();
    if (obj instanceof WrappedFile) {
        obj = ((WrappedFile<?>) obj).getFile();
    }
    if (obj instanceof File) {
        filePayload = (File) obj;
    } else {
        throw new IllegalArgumentException(""aws2-s3: MultiPart upload requires a File input."");
    }
    Map<String, String> objectMetadata = determineMetadata(exchange);
    Long contentLength = exchange.getIn().getHeader(AWS2S3Constants.CONTENT_LENGTH, Long.class);
    if (contentLength == null || contentLength == 0) {
        contentLength = filePayload.length();
    }
    objectMetadata.put(""Content-Length"", contentLength.toString());
    final String keyName = AWS2S3Utils.determineKey(exchange, getConfiguration());
    CreateMultipartUploadRequest.Builder createMultipartUploadRequest = CreateMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName);
    String storageClass = AWS2S3Utils.determineStorageClass(exchange, getConfiguration());
    if (storageClass != null) {
        createMultipartUploadRequest.storageClass(storageClass);
    }
    String cannedAcl = exchange.getIn().getHeader(AWS2S3Constants.CANNED_ACL, String.class);
    if (cannedAcl != null) {
        ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);
        createMultipartUploadRequest.acl(objectAcl);
    }
    BucketCannedACL acl = exchange.getIn().getHeader(AWS2S3Constants.ACL, BucketCannedACL.class);
    if (acl != null) {
        createMultipartUploadRequest.acl(acl.toString());
    }
    String contentType = exchange.getIn().getHeader(AWS2S3Constants.CONTENT_TYPE, String.class);
    if (contentType != null) {
        createMultipartUploadRequest.contentType(contentType);
    }
    String cacheControl = exchange.getIn().getHeader(AWS2S3Constants.CACHE_CONTROL, String.class);
    if (cacheControl != null) {
        createMultipartUploadRequest.cacheControl(cacheControl);
    }
    String contentDisposition = exchange.getIn().getHeader(AWS2S3Constants.CONTENT_DISPOSITION, String.class);
    if (contentDisposition != null) {
        createMultipartUploadRequest.contentDisposition(contentDisposition);
    }
    String contentEncoding = exchange.getIn().getHeader(AWS2S3Constants.CONTENT_ENCODING, String.class);
    if (contentEncoding != null) {
        createMultipartUploadRequest.contentEncoding(contentEncoding);
    }
    AWS2S3Utils.setEncryption(createMultipartUploadRequest, getConfiguration());
    LOG.trace(""Initiating multipart upload [{}] from exchange [{}]..."", createMultipartUploadRequest, exchange);
    CreateMultipartUploadResponse initResponse = getEndpoint().getS3Client().createMultipartUpload(createMultipartUploadRequest.build());
    List<CompletedPart> completedParts = new ArrayList<CompletedPart>();
    long partSize = getConfiguration().getPartSize();
    CompleteMultipartUploadResponse uploadResult = null;
    long filePosition = 0;
    try {
        for (int part = 1; filePosition < contentLength; part++) {
            partSize = Math.min(partSize, contentLength - filePosition);
            UploadPartRequest uploadRequest = UploadPartRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).partNumber(part).build();
            LOG.trace(""Uploading part [{}] for {}"", part, keyName);
            try (InputStream fileInputStream = new FileInputStream(filePayload)) {
                if (filePosition > 0) {
                    long skipped = fileInputStream.skip(filePosition);
                    if (skipped == 0) {
                        LOG.warn(""While trying to upload the file {} file, 0 bytes were skipped"", keyName);
                    }
                }
                String etag = getEndpoint().getS3Client().uploadPart(uploadRequest, RequestBody.fromInputStream(fileInputStream, partSize)).eTag();
                CompletedPart partUpload = CompletedPart.builder().partNumber(part).eTag(etag).build();
                completedParts.add(partUpload);
                filePosition += partSize;
            }
        }
        CompletedMultipartUpload completeMultipartUpload = CompletedMultipartUpload.builder().parts(completedParts).build();
        CompleteMultipartUploadRequest compRequest = CompleteMultipartUploadRequest.builder().multipartUpload(completeMultipartUpload).bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build();
        uploadResult = getEndpoint().getS3Client().completeMultipartUpload(compRequest);
    } catch (Exception e) {
        getEndpoint().getS3Client().abortMultipartUpload(AbortMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build());
        throw e;
    }
    Message message = getMessageForResponse(exchange);
    message.setHeader(AWS2S3Constants.E_TAG, uploadResult.eTag());
    if (uploadResult.versionId() != null) {
        message.setHeader(AWS2S3Constants.VERSION_ID, uploadResult.versionId());
    }
    if (getConfiguration().isDeleteAfterWrite()) {
        FileUtil.deleteFile(filePayload);
    }
}",java:S3776,39
"public void processMultiPart(final Exchange exchange) throws Exception{
    File filePayload = null;
    Object obj = exchange.getIn().getMandatoryBody();
    if (obj instanceof WrappedFile) {
        obj = ((WrappedFile<?>) obj).getFile();
    }
    if (obj instanceof File) {
        filePayload = (File) obj;
    } else {
        throw new IllegalArgumentException(""aws2-s3: MultiPart upload requires a File input."");
    }
    Map<String, String> objectMetadata = determineMetadata(exchange);
    Long contentLength = exchange.getIn().getHeader(AWS2S3Constants.CONTENT_LENGTH, Long.class);
    if (contentLength == null || contentLength == 0) {
        contentLength = filePayload.length();
    }
    objectMetadata.put(""Content-Length"", contentLength.toString());
    final String keyName = AWS2S3Utils.determineKey(exchange, getConfiguration());
    CreateMultipartUploadRequest.Builder createMultipartUploadRequest = CreateMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName);
    String storageClass = AWS2S3Utils.determineStorageClass(exchange, getConfiguration());
    if (storageClass != null) {
        createMultipartUploadRequest.storageClass(storageClass);
    }
    String cannedAcl = exchange.getIn().getHeader(AWS2S3Constants.CANNED_ACL, String.class);
    if (cannedAcl != null) {
        ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);
        createMultipartUploadRequest.acl(objectAcl);
    }
    BucketCannedACL acl = exchange.getIn().getHeader(AWS2S3Constants.ACL, BucketCannedACL.class);
    if (acl != null) {
        createMultipartUploadRequest.acl(acl.toString());
    }
    String contentType = exchange.getIn().getHeader(AWS2S3Constants.CONTENT_TYPE, String.class);
    if (contentType != null) {
        createMultipartUploadRequest.contentType(contentType);
    }
    String cacheControl = exchange.getIn().getHeader(AWS2S3Constants.CACHE_CONTROL, String.class);
    if (cacheControl != null) {
        createMultipartUploadRequest.cacheControl(cacheControl);
    }
    String contentDisposition = exchange.getIn().getHeader(AWS2S3Constants.CONTENT_DISPOSITION, String.class);
    if (contentDisposition != null) {
        createMultipartUploadRequest.contentDisposition(contentDisposition);
    }
    String contentEncoding = exchange.getIn().getHeader(AWS2S3Constants.CONTENT_ENCODING, String.class);
    if (contentEncoding != null) {
        createMultipartUploadRequest.contentEncoding(contentEncoding);
    }
    AWS2S3Utils.setEncryption(createMultipartUploadRequest, getConfiguration());
    LOG.trace(""Initiating multipart upload [{}] from exchange [{}]..."", createMultipartUploadRequest, exchange);
    CreateMultipartUploadResponse initResponse = getEndpoint().getS3Client().createMultipartUpload(createMultipartUploadRequest.build());
    List<CompletedPart> completedParts = new ArrayList<CompletedPart>();
    long partSize = getConfiguration().getPartSize();
    CompleteMultipartUploadResponse uploadResult = null;
    long filePosition = 0;
    try {
        for (int part = 1; filePosition < contentLength; part++) {
            partSize = Math.min(partSize, contentLength - filePosition);
            UploadPartRequest uploadRequest = UploadPartRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).partNumber(part).build();
            LOG.trace(""Uploading part [{}] for {}"", part, keyName);
            try (InputStream fileInputStream = new FileInputStream(filePayload)) {
                if (filePosition > 0) {
                    long skipped = fileInputStream.skip(filePosition);
                    if (skipped == 0) {
                        LOG.warn(""While trying to upload the file {} file, 0 bytes were skipped"", keyName);
                    }
                }
                String etag = getEndpoint().getS3Client().uploadPart(uploadRequest, RequestBody.fromInputStream(fileInputStream, partSize)).eTag();
                CompletedPart partUpload = CompletedPart.builder().partNumber(part).eTag(etag).build();
                completedParts.add(partUpload);
                filePosition += partSize;
            }
        }
        CompletedMultipartUpload completeMultipartUpload = CompletedMultipartUpload.builder().parts(completedParts).build();
        CompleteMultipartUploadRequest compRequest = CompleteMultipartUploadRequest.builder().multipartUpload(completeMultipartUpload).bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build();
        uploadResult = getEndpoint().getS3Client().completeMultipartUpload(compRequest);
    } catch (Exception e) {
        getEndpoint().getS3Client().abortMultipartUpload(AbortMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build());
        throw e;
    }
    Message message = getMessageForResponse(exchange);
    message.setHeader(AWS2S3Constants.E_TAG, uploadResult.eTag());
    if (uploadResult.versionId() != null) {
        message.setHeader(AWS2S3Constants.VERSION_ID, uploadResult.versionId());
    }
    if (getConfiguration().isDeleteAfterWrite()) {
        FileUtil.deleteFile(filePayload);
    }
}",java:S112,4
"public void processSingleOp(final Exchange exchange) throws Exception{
    PutObjectRequest.Builder putObjectRequest = PutObjectRequest.builder();
    Map<String, String> objectMetadata = determineMetadata(exchange);
    long contentLength = exchange.getIn().getHeader(AWS2S3Constants.CONTENT_LENGTH, -1, Long.class);
    Object obj = exchange.getIn().getMandatoryBody();
    InputStream inputStream = null;
    File filePayload = null;
    try {
        if (obj instanceof WrappedFile) {
            obj = ((WrappedFile<?>) obj).getFile();
        }
        if (obj instanceof File) {
            filePayload = (File) obj;
            contentLength = filePayload.length();
        } else {
            inputStream = exchange.getIn().getMandatoryBody(InputStream.class);
            if (contentLength <= 0) {
                contentLength = AWS2S3Utils.determineLengthInputStream(inputStream);
                if (contentLength == -1) {
                    LOG.debug(""The content length is not defined. It needs to be determined by reading the data into memory"");
                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
                    IOHelper.copyAndCloseInput(inputStream, baos);
                    byte[] arr = baos.toByteArray();
                    contentLength = arr.length;
                    inputStream = new ByteArrayInputStream(arr);
                }
            }
        }
        doPutObject(exchange, putObjectRequest, objectMetadata, filePayload, inputStream, contentLength);
    } finally {
        IOHelper.close(inputStream);
    }
    if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {
        FileUtil.deleteFile(filePayload);
    }
}",java:S112,4
"private void doPutObject(Exchange exchange, PutObjectRequest.Builder putObjectRequest, Map<String, String> objectMetadata, File file, InputStream inputStream, long contentLength){
    final String bucketName = AWS2S3Utils.determineBucketName(exchange, getConfiguration());
    final String key = AWS2S3Utils.determineKey(exchange, getConfiguration());
    putObjectRequest.bucket(bucketName).key(key).metadata(objectMetadata);
    String storageClass = AWS2S3Utils.determineStorageClass(exchange, getConfiguration());
    if (storageClass != null) {
        putObjectRequest.storageClass(storageClass);
    }
    String cannedAcl = exchange.getIn().getHeader(AWS2S3Constants.CANNED_ACL, String.class);
    if (cannedAcl != null) {
        ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);
        putObjectRequest.acl(objectAcl);
    }
    String contentType = exchange.getIn().getHeader(AWS2S3Constants.CONTENT_TYPE, String.class);
    if (contentType != null) {
        putObjectRequest.contentType(contentType);
    }
    String cacheControl = exchange.getIn().getHeader(AWS2S3Constants.CACHE_CONTROL, String.class);
    if (cacheControl != null) {
        putObjectRequest.cacheControl(cacheControl);
    }
    String contentDisposition = exchange.getIn().getHeader(AWS2S3Constants.CONTENT_DISPOSITION, String.class);
    if (contentDisposition != null) {
        putObjectRequest.contentDisposition(contentDisposition);
    }
    String contentEncoding = exchange.getIn().getHeader(AWS2S3Constants.CONTENT_ENCODING, String.class);
    if (contentEncoding != null) {
        putObjectRequest.contentEncoding(contentEncoding);
    }
    if (contentLength > 0) {
        putObjectRequest.contentLength(contentLength);
    }
    BucketCannedACL acl = exchange.getIn().getHeader(AWS2S3Constants.ACL, BucketCannedACL.class);
    if (acl != null) {
        putObjectRequest.acl(acl.toString());
    }
    String contentMd5 = exchange.getIn().getHeader(AWS2S3Constants.CONTENT_MD5, String.class);
    if (contentMd5 != null) {
        putObjectRequest.contentMD5(contentMd5);
    }
    if (getConfiguration().isUseAwsKMS()) {
        if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {
            putObjectRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());
            putObjectRequest.serverSideEncryption(ServerSideEncryption.AWS_KMS);
        }
    }
    if (getConfiguration().isUseSSES3()) {
        putObjectRequest.serverSideEncryption(ServerSideEncryption.AES256);
    }
    if (getConfiguration().isUseCustomerKey()) {
        if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {
            putObjectRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());
        }
        if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {
            putObjectRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());
        }
        if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {
            putObjectRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());
        }
    }
    LOG.trace(""Put object [{}] from exchange [{}]..."", putObjectRequest, exchange);
    RequestBody rb;
    if (file != null) {
        rb = RequestBody.fromFile(file);
    } else {
        rb = RequestBody.fromInputStream(inputStream, contentLength);
    }
    PutObjectResponse putObjectResult = getEndpoint().getS3Client().putObject(putObjectRequest.build(), rb);
    LOG.trace(""Received result [{}]"", putObjectResult);
    Message message = getMessageForResponse(exchange);
    message.setHeader(AWS2S3Constants.E_TAG, putObjectResult.eTag());
    if (putObjectResult.versionId() != null) {
        message.setHeader(AWS2S3Constants.VERSION_ID, putObjectResult.versionId());
    }
}",java:S3776,39
"private void copyObject(S3Client s3Client, Exchange exchange) throws InvalidPayloadException{
    final String bucketName = AWS2S3Utils.determineBucketName(exchange, getConfiguration());
    final String sourceKey = AWS2S3Utils.determineKey(exchange, getConfiguration());
    final String destinationKey = exchange.getIn().getHeader(AWS2S3Constants.DESTINATION_KEY, String.class);
    final String bucketNameDestination = exchange.getIn().getHeader(AWS2S3Constants.BUCKET_DESTINATION_NAME, String.class);
    if (getConfiguration().isPojoRequest()) {
        Object payload = exchange.getIn().getMandatoryBody();
        if (payload instanceof CopyObjectRequest) {
            CopyObjectResponse result;
            result = s3Client.copyObject((CopyObjectRequest) payload);
            Message message = getMessageForResponse(exchange);
            message.setBody(result);
        }
    } else {
        if (ObjectHelper.isEmpty(bucketNameDestination)) {
            throw new IllegalArgumentException(""Bucket Name Destination must be specified for copyObject Operation"");
        }
        if (ObjectHelper.isEmpty(destinationKey)) {
            throw new IllegalArgumentException(""Destination Key must be specified for copyObject Operation"");
        }
        CopyObjectRequest.Builder copyObjectRequest = CopyObjectRequest.builder().destinationBucket(bucketNameDestination).destinationKey(destinationKey).sourceBucket(bucketName).sourceKey(sourceKey);
        if (getConfiguration().isUseAwsKMS()) {
            if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {
                copyObjectRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());
                copyObjectRequest.serverSideEncryption(ServerSideEncryption.AWS_KMS);
            }
        }
        if (getConfiguration().isUseSSES3()) {
            copyObjectRequest.serverSideEncryption(ServerSideEncryption.AES256);
        }
        if (getConfiguration().isUseCustomerKey()) {
            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {
                copyObjectRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());
            }
            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {
                copyObjectRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());
            }
            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {
                copyObjectRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());
            }
        }
        CopyObjectResponse copyObjectResult = s3Client.copyObject(copyObjectRequest.build());
        Message message = getMessageForResponse(exchange);
        if (copyObjectResult.versionId() != null) {
            message.setHeader(AWS2S3Constants.VERSION_ID, copyObjectResult.versionId());
        }
    }
}",java:S3776,39
"private String fileNameToUpload(String fileName, AWSS3NamingStrategyEnum strategy, String ext, AtomicInteger part, UUID id){
    String dynamicKeyName;
    switch(strategy) {
        case progressive:
            if (part.get() > 0) {
                if (ObjectHelper.isNotEmpty(ext)) {
                    dynamicKeyName = fileName + ""-"" + part + ext;
                } else {
                    dynamicKeyName = fileName + ""-"" + part;
                }
            } else {
                if (ObjectHelper.isNotEmpty(ext)) {
                    dynamicKeyName = fileName + ext;
                } else {
                    dynamicKeyName = fileName;
                }
            }
            break;
        case random:
            if (part.get() > 0) {
                if (ObjectHelper.isNotEmpty(ext)) {
                    dynamicKeyName = fileName + ""-"" + id.toString() + ext;
                } else {
                    dynamicKeyName = fileName + ""-"" + id.toString();
                }
            } else {
                if (ObjectHelper.isNotEmpty(ext)) {
                    dynamicKeyName = fileName + ext;
                } else {
                    dynamicKeyName = fileName;
                }
            }
            break;
        default:
            throw new IllegalArgumentException(""Unsupported operation"");
    }
    return dynamicKeyName;
}",java:S3776,39
"private software.amazon.awssdk.services.ses.model.RawMessage createRawMessage(Exchange exchange) throws Exception{
    software.amazon.awssdk.services.ses.model.RawMessage.Builder message = software.amazon.awssdk.services.ses.model.RawMessage.builder();
    jakarta.mail.Message content = exchange.getIn().getBody(jakarta.mail.Message.class);
    OutputStream byteOutput = new ByteArrayOutputStream();
    try {
        content.writeTo(byteOutput);
    } catch (Exception e) {
        LOG.error(""Cannot write to byte Array"");
        throw e;
    }
    byte[] messageByteArray = ((ByteArrayOutputStream) byteOutput).toByteArray();
    message.data(SdkBytes.fromByteBuffer(ByteBuffer.wrap(messageByteArray)));
    return message.build();
}",java:S112,4
" Map<String, MessageAttributeValue> translateAttributes(Map<String, Object> headers, Exchange exchange){
    Map<String, MessageAttributeValue> result = new HashMap<>();
    HeaderFilterStrategy headerFilterStrategy = getEndpoint().getHeaderFilterStrategy();
    for (Entry<String, Object> entry : headers.entrySet()) {
        if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), exchange)) {
            Object value = entry.getValue();
            if (value instanceof String && !((String) value).isEmpty()) {
                MessageAttributeValue.Builder mav = MessageAttributeValue.builder();
                mav.dataType(""String"");
                mav.stringValue((String) value);
                result.put(entry.getKey(), mav.build());
            } else if (value instanceof Number) {
                MessageAttributeValue.Builder mav = MessageAttributeValue.builder();
                mav.dataType(""String"");
                mav.stringValue(value.toString());
                result.put(entry.getKey(), mav.build());
            } else if (value instanceof ByteBuffer) {
                MessageAttributeValue.Builder mav = MessageAttributeValue.builder();
                mav.dataType(""Binary"");
                mav.binaryValue(SdkBytes.fromByteBuffer((ByteBuffer) value));
                result.put(entry.getKey(), mav.build());
            } else if (value instanceof byte[]) {
                MessageAttributeValue.Builder mav = MessageAttributeValue.builder();
                mav.dataType(""Binary"");
                mav.binaryValue(SdkBytes.fromByteArray((byte[]) value));
                result.put(entry.getKey(), mav.build());
            } else if (value instanceof Date) {
                MessageAttributeValue.Builder mav = MessageAttributeValue.builder();
                mav.dataType(""String"");
                mav.stringValue(value.toString());
                result.put(entry.getKey(), mav.build());
            } else if (value instanceof List) {
                String resultString = ((List<?>) value).stream().map(o -> o instanceof String ? String.format(""\""%s\"""", o) : Objects.toString(o)).collect(Collectors.joining("", ""));
                MessageAttributeValue.Builder mav = MessageAttributeValue.builder();
                mav.dataType(""String.Array"");
                mav.stringValue(""["" + resultString + ""]"");
                result.put(entry.getKey(), mav.build());
            } else {
                LOG.warn(""Cannot put the message header key={}, value={} into Sns MessageAttribute"", entry.getKey(), entry.getValue());
            }
        }
    }
    return result;
}",java:S3776,39
"protected void createQueue(SqsClient client) throws IOException{
    if (queueExists(client)) {
        return;
    }
    LOG.trace(""Creating the a queue named '{}'"", configuration.getQueueName());
    CreateQueueRequest.Builder request = CreateQueueRequest.builder().queueName(configuration.getQueueName());
    Map<QueueAttributeName, String> attributes = new EnumMap<>(QueueAttributeName.class);
    if (getConfiguration().isFifoQueue()) {
        attributes.put(QueueAttributeName.FIFO_QUEUE, String.valueOf(true));
        boolean useContentBasedDeduplication = getConfiguration().getMessageDeduplicationIdStrategy() instanceof NullMessageDeduplicationIdStrategy;
        attributes.put(QueueAttributeName.CONTENT_BASED_DEDUPLICATION, String.valueOf(useContentBasedDeduplication));
    }
    if (getConfiguration().getDefaultVisibilityTimeout() != null) {
        attributes.put(QueueAttributeName.VISIBILITY_TIMEOUT, String.valueOf(getConfiguration().getDefaultVisibilityTimeout()));
    }
    if (getConfiguration().getMaximumMessageSize() != null) {
        attributes.put(QueueAttributeName.MAXIMUM_MESSAGE_SIZE, String.valueOf(getConfiguration().getMaximumMessageSize()));
    }
    if (getConfiguration().getMessageRetentionPeriod() != null) {
        attributes.put(QueueAttributeName.MESSAGE_RETENTION_PERIOD, String.valueOf(getConfiguration().getMessageRetentionPeriod()));
    }
    if (getConfiguration().getPolicy() != null) {
        InputStream s = ResourceHelper.resolveMandatoryResourceAsInputStream(this.getCamelContext(), getConfiguration().getPolicy());
        String policy = IOUtils.toString(s, Charset.defaultCharset());
        attributes.put(QueueAttributeName.POLICY, policy);
    }
    if (getConfiguration().getReceiveMessageWaitTimeSeconds() != null) {
        attributes.put(QueueAttributeName.RECEIVE_MESSAGE_WAIT_TIME_SECONDS, String.valueOf(getConfiguration().getReceiveMessageWaitTimeSeconds()));
    }
    if (getConfiguration().getDelaySeconds() != null && getConfiguration().isDelayQueue()) {
        attributes.put(QueueAttributeName.DELAY_SECONDS, String.valueOf(getConfiguration().getDelaySeconds()));
    }
    if (getConfiguration().getRedrivePolicy() != null) {
        attributes.put(QueueAttributeName.REDRIVE_POLICY, getConfiguration().getRedrivePolicy());
    }
    if (getConfiguration().isServerSideEncryptionEnabled()) {
        if (getConfiguration().getKmsMasterKeyId() != null) {
            attributes.put(QueueAttributeName.KMS_MASTER_KEY_ID, getConfiguration().getKmsMasterKeyId());
        }
        if (getConfiguration().getKmsDataKeyReusePeriodSeconds() != null) {
            attributes.put(QueueAttributeName.KMS_DATA_KEY_REUSE_PERIOD_SECONDS, String.valueOf(getConfiguration().getKmsDataKeyReusePeriodSeconds()));
        }
    }
    LOG.trace(""Trying to create queue [{}] with request [{}]..."", configuration.getQueueName(), request);
    request.attributes(attributes);
    try {
        CreateQueueResponse queueResult = client.createQueue(request.build());
        queueUrl = queueResult.queueUrl();
    } catch (SqsException e) {
        if (queueExists(client)) {
            LOG.warn(""The queue may have been created since last check and could not be created"");
            LOG.debug(""AWS SDK error preventing queue creation: {}"", e.getMessage(), e);
        } else {
            throw e;
        }
    }
    LOG.trace(""Queue created and available at: {}"", queueUrl);
}",java:S3776,39
"public static MessageAttributeValue toMessageAttributeValue(Object value){
    if (value instanceof String && !((String) value).isEmpty()) {
        MessageAttributeValue.Builder mav = MessageAttributeValue.builder();
        mav.dataType(""String"");
        mav.stringValue((String) value);
        return mav.build();
    } else if (value instanceof ByteBuffer) {
        MessageAttributeValue.Builder mav = MessageAttributeValue.builder();
        mav.dataType(""Binary"");
        mav.binaryValue(SdkBytes.fromByteBuffer((ByteBuffer) value));
        return mav.build();
    } else if (value instanceof byte[]) {
        MessageAttributeValue.Builder mav = MessageAttributeValue.builder();
        mav.dataType(""Binary"");
        mav.binaryValue(SdkBytes.fromByteArray((byte[]) value));
        return mav.build();
    } else if (value instanceof Boolean) {
        MessageAttributeValue.Builder mav = MessageAttributeValue.builder();
        mav.dataType(""Number.Boolean"");
        mav.stringValue(Boolean.TRUE.equals(value) ? ""1"" : ""0"");
        return mav.build();
    } else if (value instanceof Number) {
        MessageAttributeValue.Builder mav = MessageAttributeValue.builder();
        final String dataType;
        if (value instanceof Integer) {
            dataType = ""Number.int"";
        } else if (value instanceof Byte) {
            dataType = ""Number.byte"";
        } else if (value instanceof Double) {
            dataType = ""Number.double"";
        } else if (value instanceof Float) {
            dataType = ""Number.float"";
        } else if (value instanceof Long) {
            dataType = ""Number.long"";
        } else if (value instanceof Short) {
            dataType = ""Number.short"";
        } else {
            dataType = ""Number"";
        }
        mav.dataType(dataType);
        mav.stringValue(value.toString());
        return mav.build();
    } else if (value instanceof Date) {
        MessageAttributeValue.Builder mav = MessageAttributeValue.builder();
        mav.dataType(""String"");
        mav.stringValue(value.toString());
        return mav.build();
    }
    return null;
}",java:S3776,39
"public static Object fromMessageAttributeValue(MessageAttributeValue mav){
    if (mav == null) {
        return null;
    }
    if (mav.binaryValue() != null) {
        return mav.binaryValue();
    } else if (mav.stringValue() != null) {
        String s = mav.stringValue();
        String dt = mav.dataType();
        if (dt == null || ""String"".equals(dt)) {
            return s;
        } else if (""Number.Boolean"".equals(dt)) {
            return ""1"".equals(s) ? Boolean.TRUE : Boolean.FALSE;
        } else if (""Number.int"".equals(dt)) {
            return Integer.valueOf(s);
        } else if (""Number.byte"".equals(dt)) {
            return Byte.valueOf(s);
        } else if (""Number.double"".equals(dt)) {
            return Double.valueOf(s);
        } else if (""Number.float"".equals(dt)) {
            return Float.valueOf(s);
        } else if (""Number.long"".equals(dt)) {
            return Long.valueOf(s);
        } else if (""Number.short"".equals(dt)) {
            return Short.valueOf(s);
        }
        return s;
    }
    return null;
}",java:S3776,39
" Map<String, MessageAttributeValue> translateAttributes(Map<String, Object> headers, Exchange exchange){
    Map<String, MessageAttributeValue> result = new HashMap<>();
    HeaderFilterStrategy headerFilterStrategy = getEndpoint().getHeaderFilterStrategy();
    for (Entry<String, Object> entry : headers.entrySet()) {
        if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), exchange)) {
            if (result.size() < MAX_ATTRIBUTES) {
                MessageAttributeValue mav = Sqs2MessageHelper.toMessageAttributeValue(entry.getValue());
                if (mav != null) {
                    result.put(entry.getKey(), mav);
                }
            } else {
                String action = getConfiguration().getMessageHeaderExceededLimit();
                if (""WARN"".equalsIgnoreCase(action) || ""WARN_ONCE"".equalsIgnoreCase(action)) {
                    LOG.warn(""Cannot put message header with key={} due: {}"", entry.getKey(), MAX_MESSAGE);
                    if (""WARN_ONCE"".equalsIgnoreCase(action)) {
                        break;
                    }
                } else if (""IGNORE"".equalsIgnoreCase(action)) {
                    break;
                } else if (""FAIL"".equalsIgnoreCase(action)) {
                    throw new IllegalArgumentException(MAX_MESSAGE);
                }
            }
        }
    }
    return result;
}",java:S3776,39
"private void translateText(TranslateClient translateClient, Exchange exchange) throws InvalidPayloadException{
    if (getConfiguration().isPojoRequest()) {
        Object payload = exchange.getIn().getMandatoryBody();
        if (payload instanceof TranslateTextRequest) {
            TranslateTextResponse result;
            try {
                result = translateClient.translateText((TranslateTextRequest) payload);
            } catch (AwsServiceException ase) {
                LOG.trace(""Translate Text command returned the error code {}"", ase.awsErrorDetails().errorCode());
                throw ase;
            }
            Message message = getMessageForResponse(exchange);
            message.setBody(result.translatedText());
        }
    } else {
        Builder request = TranslateTextRequest.builder();
        if (!getConfiguration().isAutodetectSourceLanguage()) {
            if (ObjectHelper.isEmpty(getConfiguration().getSourceLanguage()) && ObjectHelper.isEmpty(getConfiguration().getTargetLanguage())) {
                String source = exchange.getIn().getHeader(Translate2Constants.SOURCE_LANGUAGE, String.class);
                String target = exchange.getIn().getHeader(Translate2Constants.TARGET_LANGUAGE, String.class);
                if (ObjectHelper.isEmpty(source) || ObjectHelper.isEmpty(target)) {
                    throw new IllegalArgumentException(""Source and target language must be specified as headers or endpoint options"");
                }
                request.sourceLanguageCode(source);
                request.targetLanguageCode(target);
            } else {
                request.sourceLanguageCode(getConfiguration().getSourceLanguage());
                request.targetLanguageCode(getConfiguration().getTargetLanguage());
            }
        } else {
            String source = ""auto"";
            if (ObjectHelper.isEmpty(getConfiguration().getTargetLanguage())) {
                String target = exchange.getIn().getHeader(Translate2Constants.TARGET_LANGUAGE, String.class);
                if (ObjectHelper.isEmpty(source) || ObjectHelper.isEmpty(target)) {
                    throw new IllegalArgumentException(""Target language must be specified when autodetection of source language is enabled"");
                }
                request.sourceLanguageCode(source);
                request.targetLanguageCode(target);
            } else {
                request.sourceLanguageCode(source);
                request.targetLanguageCode(getConfiguration().getTargetLanguage());
            }
        }
        if (!ObjectHelper.isEmpty(exchange.getIn().getHeader(Translate2Constants.TERMINOLOGY_NAMES, Collection.class))) {
            Collection<String> terminologies = exchange.getIn().getHeader(Translate2Constants.TERMINOLOGY_NAMES, Collection.class);
            request.terminologyNames(terminologies);
        }
        request.text(exchange.getMessage().getBody(String.class));
        TranslateTextResponse result;
        try {
            result = translateClient.translateText(request.build());
        } catch (AwsServiceException ase) {
            LOG.trace(""Translate Text command returned the error code {}"", ase.awsErrorDetails().errorCode());
            throw ase;
        }
        Message message = getMessageForResponse(exchange);
        message.setBody(result.translatedText());
    }
}",java:S3776,39
"private void onEventListener(final List<Map<String, ?>> record){
    final Exchange exchange = createAzureCosmosDbExchange(record);
    exchange.getExchangeExtension().addOnCompletion(onCompletion);
    getAsyncProcessor().process(exchange, EmptyAsyncCallback.get());
}",java:S6213,47
"private Exchange createAzureCosmosDbExchange(final List<Map<String, ?>> record){
    final Exchange exchange = createExchange(true);
    final Message message = exchange.getIn();
    message.setBody(record);
    return exchange;
}",java:S6213,47
"private boolean storeFile(String name, String targetName, Exchange exchange) throws GenericFileOperationFailedException{
    boolean existFile = false;
    if (endpoint.getFileExist() == GenericFileExist.Ignore || endpoint.getFileExist() == GenericFileExist.Fail) {
        existFile = existsFile(targetName);
        if (existFile && endpoint.getFileExist() == GenericFileExist.Ignore) {
            log.trace(""An existing file already exists: {}. Ignore and do not override it."", name);
            return true;
        } else if (existFile && endpoint.getFileExist() == GenericFileExist.Fail) {
            throw new GenericFileOperationFailedException(""File already exist: "" + name + "". Cannot write new file."");
        }
    }
    InputStream is = null;
    int length = 0;
    if (exchange.getIn().getBody() == null) {
        if (endpoint.isAllowNullBody()) {
            log.trace(""Writing empty file."");
            is = new ByteArrayInputStream(new byte[] {});
        } else {
            throw new GenericFileOperationFailedException(""Cannot write null body to file: "" + name);
        }
    }
    try {
        if (is == null) {
            var knownLength = exchange.getIn().getHeader(Exchange.FILE_LENGTH, Long.class);
            if (knownLength != null) {
                is = exchange.getIn().getMandatoryBody(InputStream.class);
                length = knownLength.intValue();
            } else {
                log.warn(""No file length header, so converting body to byte[].  It might be memory intensive."");
                var bytes = exchange.getIn().getMandatoryBody(byte[].class);
                length = bytes.length;
                is = new ByteArrayInputStream(bytes);
            }
        }
        final StopWatch watch = new StopWatch();
        boolean answer = false;
        log.debug(""About to store file: {} length: {} using stream: {}"", targetName, length, is);
        if (existFile && endpoint.getFileExist() == GenericFileExist.Append) {
            assert false;
        } else {
            var cwd = cwd();
            var file = cwd.getFileClient(targetName);
            if (deleteRemote(cwd, targetName) && createRemote(file, length)) {
                storeRemote(file, is);
                answer = true;
            }
        }
        if (log.isDebugEnabled()) {
            long time = watch.taken();
            log.debug(""Took {} ({} millis) to store: {} and files client returned: {}"", TimeUtils.printDuration(time, true), time, targetName, answer);
        }
        return answer;
    } catch (InvalidPayloadException | IOException e) {
        throw new GenericFileOperationFailedException(""Cannot store file: "" + name, e);
    } finally {
        IOHelper.close(is, ""store: "" + name, log);
    }
}",java:S3776,39
" BaseModel<?> model(Kind kind, String name){
    switch(kind) {
        case component:
            return componentModel(name);
        case dataformat:
            return dataFormatModel(name);
        case language:
            return languageModel(name);
        case other:
            return otherModel(name);
        case eip:
            return eipModel(name);
        default:
            throw new IllegalArgumentException(""Unexpected kind "" + kind);
    }
}",java:S1452,23
" static String encodeTokenValue(String value) throws URISyntaxException{
    return URISupport.createQueryString(Collections.singletonMap(""x"", value)).substring(2).replace(""+"", ""%2B"").replace(""%3A"", "":"");
}",java:S1130,7
"protected void onEventListener(final EventContext eventContext){
    boolean triggerReloading = false;
    ObjectMapper mapper = new ObjectMapper();
    final JsonNode actualObj = retrieveEventData(eventContext, mapper);
    for (int i = 0; i < actualObj.size(); i++) {
        String secret = actualObj.get(i).get(""subject"").textValue();
        String eventType = actualObj.get(i).get(""eventType"").textValue();
        if (ObjectHelper.isNotEmpty(secret) && ObjectHelper.isNotEmpty(eventType)) {
            if (eventType.equalsIgnoreCase(SECRET_VERSION_ADD)) {
                if (matchSecret(secret)) {
                    if (ObjectHelper.isNotEmpty(eventContext.getEventData().getEnqueuedTime())) {
                        updates.put(secret, eventContext.getEventData().getEnqueuedTime());
                    }
                    if (isReloadEnabled()) {
                        LOG.info(""Update for Azure secret: {} detected, triggering CamelContext reload"", secret);
                        triggerReloading = true;
                    }
                }
            }
        }
    }
    if (triggerReloading) {
        ContextReloadStrategy reload = camelContext.hasService(ContextReloadStrategy.class);
        if (reload != null) {
            lastReloadTime = Instant.now();
            reload.onReload(this);
        }
    }
}",java:S3776,39
"public Response<BlockBlobItem> uploadBlockBlob(final InputStream data, final long length, final BlobHttpHeaders headers, final Map<String, String> metadata, AccessTier tier, final byte[] contentMd5, final BlobRequestConditions requestConditions, final Duration timeout){
    Flux<ByteBuffer> dataBuffer = Utility.convertStreamToByteBuffer(data, length, 4194304, false);
    BlockBlobSimpleUploadOptions uploadOptions = new BlockBlobSimpleUploadOptions(dataBuffer, length).setHeaders(headers).setMetadata(metadata).setTier(tier).setContentMd5(contentMd5).setRequestConditions(requestConditions);
    return getBlockBlobClient().uploadWithResponse(uploadOptions, timeout, Context.NONE);
}",java:S107,1
"public static BlobOperationResponse create(final Response<?> response){
    return buildResponse(response, false);
}",java:S3740,38
"public static BlobOperationResponse createWithEmptyBody(final Response<?> response){
    return buildResponse(response, true);
}",java:S3740,38
"public Response<PathProperties> downloadToFileWithResponse(final String filePath, final FileRange fileRange, final ParallelTransferOptions parallelTransferOptions, final DownloadRetryOptions downloadRetryOptions, final DataLakeRequestConditions requestConditions, final boolean rangeGetContentMd5, final Set<OpenOption> openOptions, final Duration timeout){
    return client.readToFileWithResponse(filePath, fileRange, parallelTransferOptions, downloadRetryOptions, requestConditions, rangeGetContentMd5, openOptions, timeout, Context.NONE);
}",java:S107,1
"private void printImage(final Exchange exchange, final Object graph, final OutputStream stream) throws Exception{
    final String payload = ExchangeHelper.convertToMandatoryType(exchange, String.class, graph);
    final MultiFormatWriter writer = new MultiFormatWriter();
    final String type = this.params.getType().toString();
    final BitMatrix matrix = writer.encode(payload, this.params.getFormat(), this.params.getWidth(), this.params.getHeight(), writerHintMap);
    MatrixToImageWriter.writeToStream(matrix, type, stream);
}",java:S112,4
"private String readImage(final Exchange exchange, final InputStream stream) throws Exception{
    final MultiFormatReader reader = new MultiFormatReader();
    final BufferedInputStream in = exchange.getContext().getTypeConverter().mandatoryConvertTo(BufferedInputStream.class, stream);
    final BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(new BufferedImageLuminanceSource(ImageIO.read(in))));
    final Result result = reader.decode(bitmap, readerHintMap);
    exchange.getOut().setHeader(Barcode.BARCODE_FORMAT, result.getBarcodeFormat());
    if (result.getResultMetadata() != null) {
        result.getResultMetadata().forEach((k, v) -> {
            exchange.getOut().setHeader(k.toString(), v);
        });
    }
    return result.getText();
}",java:S112,4
"private void marshalStreaming(Exchange exchange, Object graph, OutputStream stream) throws Exception{
    InputStream decoded = ExchangeHelper.convertToMandatoryType(exchange, InputStream.class, graph);
    Base64OutputStream base64Output = new Base64OutputStream(stream, true, lineLength, lineSeparator);
    try {
        IOHelper.copy(decoded, base64Output);
    } finally {
        IOHelper.close(decoded, base64Output);
    }
}",java:S112,4
"private void marshalUrlSafe(Exchange exchange, Object graph, OutputStream stream) throws Exception{
    byte[] decoded = ExchangeHelper.convertToMandatoryType(exchange, byte[].class, graph);
    Base64 codec = new Base64(lineLength, lineSeparator, true);
    byte[] encoded = codec.encode(decoded);
    stream.write(encoded);
    stream.flush();
}",java:S112,4
"protected Object doInvoke(final Method method, final Exchange exchange) throws Throwable{
    final boolean isFuture = method.getReturnType() == Future.class;
    FutureTask<Object> task = new FutureTask<>(new Callable<Object>() {

        public Object call() throws Exception {
            LOG.trace(""Proxied method call {} invoking producer: {}"", method.getName(), producer);
            producer.process(exchange);
            Object answer = afterInvoke(method, exchange, isFuture);
            LOG.trace(""Proxied method call {} returning: {}"", method.getName(), answer);
            return answer;
        }
    });
    if (isFuture) {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Submitting task for exchange id {}"", exchange.getExchangeId());
        }
        getExecutorService(exchange.getContext()).submit(task);
        return task;
    } else {
        try {
            task.run();
            return task.get();
        } catch (ExecutionException e) {
            throw e.getCause();
        }
    }
}",java:S112,4
"protected Object afterInvoke(Method method, Exchange exchange, boolean isFuture) throws Exception{
    Exception cause = exchange.getException();
    if (cause != null) {
        Throwable found = findSuitableException(cause, method);
        if (found != null) {
            if (found instanceof Exception) {
                throw (Exception) found;
            } else {
                throw new CamelExchangeException(""Error processing exchange"", exchange, cause);
            }
        }
        if (cause instanceof RuntimeCamelException) {
            if (cause.getCause() instanceof RuntimeException) {
                throw (RuntimeException) cause.getCause();
            }
            throw cause;
        }
        throw cause;
    }
    Class<?> to = isFuture ? getGenericType(exchange.getContext(), method.getGenericReturnType()) : method.getReturnType();
    if (to == Void.TYPE) {
        return null;
    }
    return getBody(exchange, to);
}",java:S112,4
"public static Class<?> getValidParameterType(String value){
    if (ObjectHelper.isEmpty(value)) {
        return null;
    }
    value = value.trim();
    if (value.startsWith(""'"") && value.endsWith(""'"")) {
        return String.class;
    }
    if (value.startsWith(""\"""") && value.endsWith(""\"""")) {
        return String.class;
    }
    if (value.equals(""true"") || value.equals(""false"")) {
        return Boolean.class;
    }
    if (value.equals(""null"")) {
        return Object.class;
    }
    if (StringHelper.hasStartToken(value, ""simple"")) {
        return Object.class;
    }
    boolean numeric = true;
    char[] chars = value.toCharArray();
    for (int i = 0; i < chars.length; i++) {
        char ch = chars[i];
        if (i == 0 && ch == '-') {
            continue;
        }
        if (!Character.isDigit(ch)) {
            numeric = false;
            break;
        }
    }
    if (numeric) {
        return Number.class;
    }
    return null;
}",java:S3776,39
"public MethodInvocation createInvocation(Object pojo, Exchange exchange) throws AmbiguousMethodCallException, MethodNotFoundException{
    MethodInfo methodInfo = null;
    String methodName = exchange.getIn().getHeader(BeanConstants.BEAN_METHOD_NAME, String.class);
    if (methodName != null) {
        String name = methodName;
        if (methodName.contains(""("")) {
            name = StringHelper.before(methodName, ""("");
            if (!methodName.endsWith("")"")) {
                throw new IllegalArgumentException(""Method should end with parenthesis, was "" + methodName);
            }
            if (StringHelper.betweenOuterPair(methodName, '(', ')') == null) {
                throw new IllegalArgumentException(""Method should have even pair of parenthesis, was "" + methodName);
            }
        }
        boolean emptyParameters = methodName.endsWith(""()"");
        if (""class"".equals(name) || ""getClass"".equals(name)) {
            try {
                Method method = pojo.getClass().getMethod(""getClass"");
                methodInfo = new MethodInfo(exchange.getContext(), pojo.getClass(), method, Collections.<ParameterInfo>emptyList(), Collections.<ParameterInfo>emptyList(), false, false);
            } catch (NoSuchMethodException e) {
                throw new MethodNotFoundException(exchange, pojo, ""getClass"");
            }
        } else if (""length"".equals(name) && pojo.getClass().isArray()) {
            try {
                Method method = org.apache.camel.util.ObjectHelper.class.getMethod(""arrayLength"", Object[].class);
                ParameterInfo pi = new ParameterInfo(0, Object[].class, null, ExpressionBuilder.mandatoryBodyExpression(Object[].class, true));
                List<ParameterInfo> lpi = new ArrayList<>(1);
                lpi.add(pi);
                methodInfo = new MethodInfo(exchange.getContext(), pojo.getClass(), method, lpi, lpi, false, false);
                exchange.getIn().setBody(pojo);
            } catch (NoSuchMethodException e) {
                throw new MethodNotFoundException(exchange, pojo, ""getClass"");
            }
        } else {
            List<MethodInfo> methods = getOperations(name);
            if (methods != null && methods.size() == 1) {
                methodInfo = methods.get(0);
                if (emptyParameters && methodInfo.hasParameters()) {
                    throw new MethodNotFoundException(exchange, pojo, methodName, ""(with no parameters)"");
                }
            } else if (methods != null) {
                methodInfo = chooseMethod(pojo, exchange, methodName);
                if (emptyParameters) {
                    if (methodInfo == null || methodInfo.hasParameters()) {
                        throw new MethodNotFoundException(exchange, pojo, methodName, ""(with no parameters)"");
                    }
                }
                if (methodInfo == null || !name.equals(methodInfo.getMethod().getName())) {
                    throw new AmbiguousMethodCallException(exchange, methods);
                }
            } else {
                throw new MethodNotFoundException(exchange, pojo, methodName);
            }
        }
    }
    if (methodInfo == null && methodMap.size() >= 2) {
        methodInfo = chooseMethod(pojo, exchange, null);
    }
    if (methodInfo == null) {
        methodInfo = defaultMethod;
    }
    if (methodInfo != null) {
        LOG.trace(""Chosen method to invoke: {} on bean: {}"", methodInfo, pojo);
        return methodInfo.createMethodInvocation(pojo, methodInfo.hasParameters(), exchange);
    }
    LOG.debug(""Cannot find suitable method to invoke on bean: {}"", pojo);
    return null;
}",java:S3776,39
"protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) throws AmbiguousMethodCallException{
    List<MethodInfo> localOperationsWithBody = null;
    if (!operationsWithBody.isEmpty()) {
        localOperationsWithBody = new ArrayList<>(operationsWithBody);
    }
    List<MethodInfo> localOperationsWithNoBody = null;
    if (!operationsWithNoBody.isEmpty()) {
        localOperationsWithNoBody = new ArrayList<>(operationsWithNoBody);
    }
    List<MethodInfo> localOperationsWithCustomAnnotation = null;
    if (!operationsWithCustomAnnotation.isEmpty()) {
        localOperationsWithCustomAnnotation = new ArrayList<>(operationsWithCustomAnnotation);
    }
    List<MethodInfo> localOperationsWithHandlerAnnotation = null;
    if (!operationsWithHandlerAnnotation.isEmpty()) {
        localOperationsWithHandlerAnnotation = new ArrayList<>(operationsWithHandlerAnnotation);
    }
    if (localOperationsWithBody != null) {
        removeAllAbstractMethods(localOperationsWithBody);
    }
    if (localOperationsWithNoBody != null) {
        removeAllAbstractMethods(localOperationsWithNoBody);
    }
    if (localOperationsWithCustomAnnotation != null) {
        removeAllAbstractMethods(localOperationsWithCustomAnnotation);
    }
    if (localOperationsWithHandlerAnnotation != null) {
        removeAllAbstractMethods(localOperationsWithHandlerAnnotation);
    }
    if (name != null) {
        if (localOperationsWithHandlerAnnotation != null) {
            removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);
        }
        if (localOperationsWithCustomAnnotation != null) {
            removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);
        }
        if (localOperationsWithBody != null) {
            removeNonMatchingMethods(localOperationsWithBody, name);
        }
        if (localOperationsWithNoBody != null) {
            removeNonMatchingMethods(localOperationsWithNoBody, name);
        }
    } else {
        if (localOperationsWithHandlerAnnotation != null) {
            removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);
        }
        if (localOperationsWithCustomAnnotation != null) {
            removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);
        }
        if (localOperationsWithBody != null) {
            removeAllSetterOrGetterMethods(localOperationsWithBody);
        }
        if (localOperationsWithNoBody != null) {
            removeAllSetterOrGetterMethods(localOperationsWithNoBody);
        }
    }
    if (localOperationsWithHandlerAnnotation != null && localOperationsWithHandlerAnnotation.size() > 1) {
        throw new AmbiguousMethodCallException(exchange, localOperationsWithHandlerAnnotation);
    }
    if (localOperationsWithHandlerAnnotation != null && localOperationsWithHandlerAnnotation.size() == 1) {
        return localOperationsWithHandlerAnnotation.get(0);
    } else if (localOperationsWithCustomAnnotation != null && localOperationsWithCustomAnnotation.size() == 1) {
        return localOperationsWithCustomAnnotation.get(0);
    }
    boolean noParameters = name != null && name.endsWith(""()"");
    if (noParameters && localOperationsWithNoBody != null && localOperationsWithNoBody.size() == 1) {
        return localOperationsWithNoBody.get(0);
    } else if (!noParameters && localOperationsWithBody != null && localOperationsWithBody.size() == 1 && localOperationsWithCustomAnnotation == null) {
        return localOperationsWithBody.get(0);
    }
    if (localOperationsWithBody != null || localOperationsWithCustomAnnotation != null) {
        Collection<MethodInfo> possibleOperations = new ArrayList<>();
        if (localOperationsWithBody != null) {
            possibleOperations.addAll(localOperationsWithBody);
        }
        if (localOperationsWithCustomAnnotation != null) {
            possibleOperations.addAll(localOperationsWithCustomAnnotation);
        }
        if (!possibleOperations.isEmpty()) {
            MethodInfo answer = null;
            if (name != null) {
                String parameters = StringHelper.between(name, ""("", "")"");
                if (parameters != null) {
                    LOG.trace(""Choosing best matching method matching parameters: {}"", parameters);
                    answer = chooseMethodWithMatchingParameters(exchange, parameters, possibleOperations);
                }
            }
            if (answer == null) {
                answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation);
            }
            if (answer == null && possibleOperations.size() > 1) {
                answer = getSingleCovariantMethod(possibleOperations);
            }
            if (answer == null) {
                throw new AmbiguousMethodCallException(exchange, possibleOperations);
            } else {
                return answer;
            }
        }
    }
    return null;
}",java:S3776,39
"private MethodInfo chooseBestPossibleMethod(Exchange exchange, String parameters, boolean allowConversion, List<MethodInfo> operations, List<MethodInfo> candidates){
    MethodInfo fallbackCandidate = null;
    for (MethodInfo info : operations) {
        Iterator<?> it = ObjectHelper.createIterator(parameters, "","", false);
        int index = 0;
        boolean matches = true;
        while (it.hasNext()) {
            String parameter = (String) it.next();
            if (parameter != null) {
                parameter = parameter.trim();
            }
            Class<?> parameterType = BeanHelper.getValidParameterType(parameter);
            Class<?> expectedType = info.getParameters().get(index).getType();
            if (parameterType != null && expectedType != null) {
                if (StringHelper.hasStartToken(parameter, ""simple"")) {
                    LOG.trace(""Evaluating simple expression for parameter #{}: {} to determine the class type of the parameter"", index, parameter);
                    Object out = getCamelContext().resolveLanguage(""simple"").createExpression(parameter).evaluate(exchange, Object.class);
                    if (out != null) {
                        parameterType = out.getClass();
                    }
                }
                if (Object.class.equals(expectedType)) {
                    fallbackCandidate = info;
                    matches = false;
                    break;
                }
                boolean matchingTypes = isParameterMatchingType(parameterType, expectedType);
                if (!matchingTypes && allowConversion) {
                    matchingTypes = getCamelContext().getTypeConverterRegistry().lookup(expectedType, parameterType) != null;
                }
                if (!matchingTypes) {
                    matches = false;
                    break;
                }
            }
            index++;
        }
        if (matches) {
            candidates.add(info);
        }
    }
    return fallbackCandidate;
}",java:S3776,39
"private MethodInfo chooseMethodWithMatchingBody(Exchange exchange, Collection<MethodInfo> operationList, List<MethodInfo> operationsWithCustomAnnotation) throws AmbiguousMethodCallException{
    Message in = exchange.getIn();
    Object body = in.getBody();
    if (body != null) {
        Class<?> bodyType = body.getClass();
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Matching for method with a single parameter that matches type: {}"", bodyType.getCanonicalName());
        }
        List<MethodInfo> possibles = new ArrayList<>();
        List<MethodInfo> possiblesWithException = null;
        for (MethodInfo methodInfo : operationList) {
            boolean out = exchange.getPattern().isOutCapable();
            if (out && methodInfo.isReturnTypeVoid()) {
                continue;
            }
            if (methodInfo.bodyParameterMatches(bodyType)) {
                LOG.trace(""Found a possible method: {}"", methodInfo);
                if (methodInfo.hasExceptionParameter()) {
                    if (possiblesWithException == null) {
                        possiblesWithException = new ArrayList<>();
                    }
                    possiblesWithException.add(methodInfo);
                } else {
                    possibles.add(methodInfo);
                }
            }
        }
        return chooseBestPossibleMethodInfo(exchange, operationList, body, possibles, possiblesWithException, operationsWithCustomAnnotation);
    }
    return null;
}",java:S3776,39
"private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<MethodInfo> operationList, Object body, List<MethodInfo> possibles, List<MethodInfo> possiblesWithException, List<MethodInfo> possibleWithCustomAnnotation) throws AmbiguousMethodCallException{
    Exception exception = ExpressionBuilder.exchangeExceptionExpression().evaluate(exchange, Exception.class);
    if (exception != null && possiblesWithException != null && possiblesWithException.size() == 1) {
        LOG.trace(""Exchange has exception set so we prefer method that also has exception as parameter"");
        return possiblesWithException.get(0);
    } else if (possibles.size() == 1) {
        return possibles.get(0);
    } else if (possibles.isEmpty()) {
        LOG.trace(""No possible methods so now trying to convert body to parameter types"");
        Object newBody = null;
        MethodInfo matched = null;
        int matchCounter = 0;
        for (MethodInfo methodInfo : operationList) {
            if (methodInfo.getBodyParameterType() != null) {
                if (methodInfo.getBodyParameterType().isInstance(body)) {
                    return methodInfo;
                }
                Object value = exchange.getContext().getTypeConverter().tryConvertTo(methodInfo.getBodyParameterType(), exchange, body);
                if (value != null) {
                    if (LOG.isTraceEnabled()) {
                        LOG.trace(""Converted body from: {} to: {}"", body.getClass().getCanonicalName(), methodInfo.getBodyParameterType().getCanonicalName());
                    }
                    matchCounter++;
                    newBody = value;
                    matched = methodInfo;
                }
            }
        }
        if (matchCounter > 1) {
            throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched, matched));
        }
        if (matched != null) {
            LOG.trace(""Setting converted body: {}"", body);
            Message in = exchange.getIn();
            in.setBody(newBody);
            return matched;
        }
    } else {
        if (possibleWithCustomAnnotation != null && possibleWithCustomAnnotation.size() == 1) {
            MethodInfo answer = possibleWithCustomAnnotation.get(0);
            LOG.trace(""There are only one method with annotations so we choose it: {}"", answer);
            return answer;
        }
        MethodInfo chosen = chooseMethodWithCustomAnnotations(possibles);
        if (chosen != null) {
            return chosen;
        }
        chosen = getSingleCovariantMethod(possibles);
        if (chosen != null) {
            return chosen;
        }
        throw new AmbiguousMethodCallException(exchange, possibles);
    }
    return null;
}",java:S3776,39
"private Expression createParameterUnmarshalExpressionForAnnotation(Method method, Class<?> parameterType, Annotation annotation){
    if (annotation instanceof ExchangeProperty) {
        ExchangeProperty propertyAnnotation = (ExchangeProperty) annotation;
        return ExpressionBuilder.exchangePropertyExpression(propertyAnnotation.value());
    } else if (annotation instanceof ExchangeProperties) {
        return ExpressionBuilder.exchangePropertiesExpression();
    } else if (annotation instanceof Header) {
        Header headerAnnotation = (Header) annotation;
        return ExpressionBuilder.headerExpression(headerAnnotation.value());
    } else if (annotation instanceof Headers) {
        return ExpressionBuilder.headersExpression();
    } else if (annotation instanceof ExchangeException) {
        return ExpressionBuilder.exchangeExceptionExpression(CastUtils.cast(parameterType, Exception.class));
    } else if (annotation instanceof PropertyInject) {
        PropertyInject propertyAnnotation = (PropertyInject) annotation;
        Expression inject = ExpressionBuilder.propertiesComponentExpression(propertyAnnotation.value(), propertyAnnotation.defaultValue());
        return ExpressionBuilder.convertToExpression(inject, parameterType);
    } else {
        LanguageAnnotation languageAnnotation = annotation.annotationType().getAnnotation(LanguageAnnotation.class);
        if (languageAnnotation != null) {
            Class<?> type = languageAnnotation.factory();
            if (type == Object.class) {
                type = DefaultAnnotationExpressionFactory.class;
            }
            Object object = camelContext.getInjector().newInstance(type);
            if (object instanceof AnnotationExpressionFactory) {
                AnnotationExpressionFactory expressionFactory = (AnnotationExpressionFactory) object;
                return expressionFactory.createExpression(camelContext, annotation, languageAnnotation, parameterType);
            } else {
                LOG.warn(""Ignoring bad annotation: {} on method: {} which declares a factory {} which does not implement {}"", languageAnnotation, method, type.getName(), AnnotationExpressionFactory.class.getName());
            }
        }
    }
    return null;
}",java:S3776,39
"private boolean matchMethod(Method method, String methodName){
    if (methodName == null) {
        return true;
    }
    if (methodName.contains(""("") && !methodName.endsWith("")"")) {
        throw new IllegalArgumentException(""Name must have both starting and ending parenthesis, was: "" + methodName);
    }
    String name = methodName;
    if (name.contains(""("")) {
        name = StringHelper.before(name, ""("");
    }
    if (name != null && !name.equals(method.getName())) {
        return false;
    }
    boolean noParameters = methodName.endsWith(""()"");
    if (noParameters) {
        return method.getParameterCount() == 0;
    }
    String types = StringHelper.betweenOuterPair(methodName, '(', ')');
    if (org.apache.camel.util.ObjectHelper.isNotEmpty(types)) {
        String[] parameters = StringQuoteHelper.splitSafeQuote(types, ',', true, true);
        Class<?>[] parameterTypes = null;
        Iterator<?> it = ObjectHelper.createIterator(parameters);
        for (int i = 0; i < method.getParameterCount(); i++) {
            if (it.hasNext()) {
                if (parameterTypes == null) {
                    parameterTypes = method.getParameterTypes();
                }
                Class<?> parameterType = parameterTypes[i];
                String qualifyType = (String) it.next();
                if (org.apache.camel.util.ObjectHelper.isEmpty(qualifyType)) {
                    continue;
                }
                qualifyType = qualifyType.trim();
                String value = qualifyType;
                int pos1 = qualifyType.indexOf(' ');
                int pos2 = qualifyType.indexOf("".class"");
                if (pos1 != -1 && pos2 != -1 && pos1 > pos2) {
                    value = qualifyType.substring(pos1);
                    value = value.trim();
                    qualifyType = qualifyType.substring(0, pos1);
                    qualifyType = qualifyType.trim();
                }
                if (""*"".equals(qualifyType)) {
                    continue;
                }
                Boolean assignable = BeanHelper.isAssignableToExpectedType(getCamelContext().getClassResolver(), qualifyType, parameterType);
                if (assignable != null && !assignable) {
                    return false;
                }
                if (!qualifyType.endsWith("".class"") && !BeanHelper.isValidParameterValue(value)) {
                    return false;
                }
            } else {
                return false;
            }
        }
        if (it.hasNext()) {
            return false;
        }
    }
    return true;
}",java:S3776,39
"private void collectMethodAnnotations(Iterator<?> it, String targetMethodName, Map<Class<?>, Annotation> annotations){
    Class<?>[] paramTypes = method.getParameterTypes();
    boolean aep = false;
    while (it.hasNext()) {
        Class<?> searchType = (Class<?>) it.next();
        Method[] methods = searchType.isInterface() ? searchType.getMethods() : searchType.getDeclaredMethods();
        for (Method method : methods) {
            if (targetMethodName.equals(method.getName()) && Arrays.equals(paramTypes, method.getParameterTypes())) {
                for (Annotation a : method.getAnnotations()) {
                    Class<?> at = a.annotationType();
                    annotations.putIfAbsent(at, a);
                    aep |= at == Pattern.class || at == InOnly.class || at == InOut.class;
                }
            }
        }
        if (!aep) {
            for (Annotation a : searchType.getAnnotations()) {
                Class<?> at = a.annotationType();
                boolean valid = at == Pattern.class || at == InOnly.class || at == InOut.class;
                if (valid && !annotations.containsKey(at)) {
                    aep = true;
                    annotations.put(at, a);
                }
            }
        }
    }
}",java:S3776,39
"public MethodInvocation createMethodInvocation(final Object pojo, boolean hasParameters, final Exchange exchange){
    final Object[] arguments = initializeArguments(hasParameters, exchange);
    return new MethodInvocation() {

        public Method getMethod() {
            return method;
        }

        public Object[] getArguments() {
            return arguments;
        }

        public boolean proceed(AsyncCallback callback) {
            try {
                MessageHelper.resetStreamCache(exchange.getIn());
                return doProceed(callback);
            } catch (InvocationTargetException e) {
                exchange.setException(e.getTargetException());
                callback.done(true);
                return true;
            } catch (Exception e) {
                exchange.setException(e);
                callback.done(true);
                return true;
            }
        }

        private boolean doProceed(AsyncCallback callback) throws Exception {
            if (dynamicRouter != null) {
                if (!ServiceHelper.isStarted(dynamicRouter)) {
                    ServiceHelper.startService(dynamicRouter);
                }
                Expression expression = new DynamicRouterExpression(pojo);
                expression.init(camelContext);
                exchange.setProperty(ExchangePropertyKey.EVALUATE_EXPRESSION_RESULT, expression);
                return dynamicRouter.process(exchange, callback);
            }
            if (LOG.isTraceEnabled()) {
                LOG.trace("">>>> invoking: {} on bean: {} with arguments: {} for exchange: {}"", method, pojo, asString(arguments), exchange);
            }
            Object result = invoke(method, pojo, arguments, exchange);
            if (result instanceof Callable) {
                LOG.trace(""Method returned Callback which will be called: {}"", result);
                Object callableResult = ((Callable) result).call();
                if (callableResult != null) {
                    result = callableResult;
                } else {
                    result = Void.TYPE;
                }
            }
            if (recipientList != null) {
                if (!ServiceHelper.isStarted(recipientList)) {
                    ServiceHelper.startService(recipientList);
                }
                exchange.setProperty(ExchangePropertyKey.EVALUATE_EXPRESSION_RESULT, result);
                return recipientList.process(exchange, callback);
            }
            if (routingSlip != null) {
                if (!ServiceHelper.isStarted(routingSlip)) {
                    ServiceHelper.startService(routingSlip);
                }
                exchange.setProperty(ExchangePropertyKey.EVALUATE_EXPRESSION_RESULT, result);
                return routingSlip.process(exchange, callback);
            }
            if (CompletionStage.class.isAssignableFrom(method.getReturnType())) {
                CompletionStage<?> completionStage = (CompletionStage<?>) result;
                completionStage.whenComplete((resultObject, e) -> {
                    if (e != null) {
                        exchange.setException(e);
                    } else if (resultObject != null) {
                        fillResult(exchange, resultObject);
                    }
                    callback.done(false);
                });
                return false;
            }
            if (result != Void.TYPE && !method.getReturnType().equals(Void.TYPE)) {
                fillResult(exchange, result);
            }
            callback.done(true);
            return true;
        }

        public Object getThis() {
            return pojo;
        }

        public AccessibleObject getStaticPart() {
            return method;
        }
    };
}",java:S3776,39
"private Object evaluateParameterValue(Exchange exchange, int index, Object parameterValue, Class<?> parameterType){
    Object answer = null;
    String exp = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, parameterValue);
    boolean valid;
    if (exp != null) {
        int pos1 = exp.indexOf(' ');
        int pos2 = exp.indexOf("".class"");
        if (pos1 != -1 && pos2 != -1 && pos1 > pos2) {
            exp = exp.substring(pos2 + 7);
        }
        valid = BeanHelper.isValidParameterValue(exp);
        if (!valid) {
            Boolean isClass = BeanHelper.isAssignableToExpectedType(exchange.getContext().getClassResolver(), exp, parameterType);
            if (isClass != null) {
                return null;
            }
        }
        Expression expression = null;
        try {
            expression = exchange.getContext().resolveLanguage(""simple"").createExpression(exp);
            parameterValue = expression.evaluate(exchange, Object.class);
            if (parameterValue == null) {
                parameterValue = ""null"";
            }
        } catch (Exception e) {
            throw new ExpressionEvaluationException(expression, ""Cannot create/evaluate simple expression: "" + exp + "" to be bound to parameter at index: "" + index + "" on method: "" + getMethod(), exchange, e);
        }
        if (""null"".equals(parameterValue)) {
            return Void.TYPE;
        }
        if (parameterType.isAssignableFrom(parameterValue.getClass())) {
            valid = true;
        } else {
            if (!valid) {
                valid = parameterValue instanceof String;
                if (!valid) {
                    exp = exchange.getContext().getTypeConverter().tryConvertTo(String.class, parameterValue);
                    valid = BeanHelper.isValidParameterValue(exp);
                }
            }
        }
        if (valid) {
            if (parameterValue instanceof String) {
                parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue);
            }
            try {
                answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange, parameterValue);
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Parameter #{} evaluated as: {} type: {}"", index, answer, org.apache.camel.util.ObjectHelper.type(answer));
                }
            } catch (Exception e) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Cannot convert from type: {} to type: {} for parameter #{}"", org.apache.camel.util.ObjectHelper.type(parameterValue), parameterType, index);
                }
                throw new ParameterBindingException(e, method, index, parameterType, parameterValue);
            }
        }
    }
    return answer;
}",java:S3776,39
"private Object invokeOgnlMethod(BeanHolder beanHolder, String beanName, String ognl, Exchange exchange){
    Object result = beanHolder.getBean(exchange);
    Exchange resultExchange = ExchangeHelper.createCopy(exchange, true);
    resultExchange.setException(null);
    resultExchange.setPattern(ExchangePattern.InOut);
    resultExchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME);
    String ognlPath = """";
    Object beanToCall = beanHolder.getBean(exchange);
    Class<?> beanType = beanHolder.getBeanInfo().getType();
    if (beanToCall == null && beanType == null) {
        throw new IllegalArgumentException(""Bean instance and bean type is null. OGNL bean expressions requires to have either a bean instance of the class name of the bean to use."");
    }
    if (ognl != null) {
        OgnlHelper.validateMethodName(ognl);
    }
    List<String> methods = OgnlHelper.splitOgnl(ognl);
    for (String methodName : methods) {
        BeanHolder holder;
        if (beanToCall != null) {
            holder = new ConstantBeanHolder(beanToCall, exchange.getContext(), parameterMappingStrategy, beanComponent);
        } else if (beanType != null) {
            holder = new ConstantTypeBeanHolder(beanType, exchange.getContext(), parameterMappingStrategy, beanComponent);
        } else {
            holder = null;
        }
        boolean nullSafe = OgnlHelper.isNullSafeOperator(methodName);
        if (holder == null) {
            String name = getBeanName(exchange, null, beanHolder);
            throw new RuntimeBeanExpressionException(exchange, name, ognl, ""last method returned null and therefore cannot continue to invoke method "" + methodName + "" on a null instance"");
        }
        ognlPath += methodName;
        methodName = OgnlHelper.removeLeadingOperators(methodName);
        String key = null;
        KeyValueHolder<String, String> index = OgnlHelper.isOgnlIndex(methodName);
        if (index != null) {
            methodName = index.getKey();
            key = index.getValue();
        }
        if (methodName != null) {
            Object newResult = invokeBean(holder, beanName, methodName, resultExchange);
            if (resultExchange.getException() != null) {
                throw new RuntimeBeanExpressionException(exchange, beanName, methodName, resultExchange.getException());
            }
            result = newResult;
        }
        if (key != null) {
            if (LanguageSupport.hasSimpleFunction(key)) {
                Expression exp = simple.createExpression(key);
                exp.init(exchange.getContext());
                key = exp.evaluate(exchange, String.class);
            }
            if (key != null) {
                result = lookupResult(resultExchange, key, result, nullSafe, ognlPath, holder.getBean(exchange));
            }
        }
        if (result == null && nullSafe) {
            return null;
        }
        beanToCall = result;
        beanType = null;
    }
    return result;
}",java:S3776,39
"private static Object lookupResult(Exchange exchange, String key, Object result, boolean nullSafe, String ognlPath, Object bean){
    StringHelper.notEmpty(key, ""key"", ""in Simple language ognl path: "" + ognlPath);
    final TypeConverter typeConverter = exchange.getContext().getTypeConverter();
    key = key.trim();
    key = StringHelper.removeLeadingAndEndingQuotes(key);
    Map<?, ?> map = typeConverter.convertTo(Map.class, result);
    if (map != null) {
        return map.get(key);
    }
    Integer num = typeConverter.tryConvertTo(Integer.class, key);
    boolean checkList = key.startsWith(""last"") || num != null;
    if (checkList) {
        List<?> list = typeConverter.convertTo(List.class, result);
        if (list != null) {
            if (key.startsWith(""last"")) {
                num = list.size() - 1;
                String after = StringHelper.after(key, ""-"");
                if (after != null) {
                    Integer redux = typeConverter.tryConvertTo(Integer.class, after.trim());
                    if (redux != null) {
                        num -= redux;
                    } else {
                        throw new ExpressionIllegalSyntaxException(key);
                    }
                }
            }
            if (num != null && num >= 0 && !list.isEmpty() && list.size() > num - 1) {
                return list.get(num);
            }
            if (!nullSafe) {
                throw new IndexOutOfBoundsException(""Index: "" + num + "", Size: "" + list.size() + "" out of bounds with List from bean: "" + bean + ""using OGNL path ["" + ognlPath + ""]"");
            }
        }
    }
    if (!nullSafe) {
        throw new IndexOutOfBoundsException(""Key: "" + key + "" not found in bean: "" + bean + "" of type: "" + ObjectHelper.classCanonicalName(bean) + "" using OGNL path ["" + ognlPath + ""]"");
    } else {
        return null;
    }
}",java:S3776,39
"public Map<String, Object> factory() throws Exception{
    Map<String, Object> mapModel = new HashMap<>();
    for (Class<?> cl : models) {
        Object obj = ObjectHelper.newInstance(cl);
        mapModel.put(obj.getClass().getName(), obj);
    }
    return mapModel;
}",java:S112,4
"private int setDataFieldValue(CamelContext camelContext, Map<String, Object> model, int line, int pos, int counterMandatoryFields, String data, DataField dataField) throws Exception{
    org.apache.camel.util.ObjectHelper.notNull(dataField, ""No position "" + pos + "" defined for the field: "" + data + "", line: "" + line);
    if (dataField.trim()) {
        data = data.trim();
    }
    if (dataField.required()) {
        ++counterMandatoryFields;
        if (data.isEmpty()) {
            throw new IllegalArgumentException(""The mandatory field defined at the position "" + pos + "" is empty for the line: "" + line);
        }
    }
    Field field = annotatedFields.get(pos);
    field.setAccessible(true);
    if (LOG.isDebugEnabled()) {
        LOG.debug(""Pos: {}, Data: {}, Field type: {}"", pos, data, field.getType());
    }
    FormattingOptions formattingOptions = ConverterUtils.convert(dataField, field.getType(), field.getAnnotation(BindyConverter.class), getLocale());
    Format<?> format = formatFactory.getFormat(formattingOptions);
    Object modelField = model.get(field.getDeclaringClass().getName());
    Object value;
    if (!data.isEmpty()) {
        try {
            if (quoting && quote != null && (data.contains(""\\"" + quote) || data.contains(quote)) && quotingEscaped) {
                value = format.parse(data.replaceAll(""\\\\"" + quote, ""\\"" + quote));
            } else if (quote != null && quote.equals(DOUBLE_QUOTES_SYMBOL) && data.contains(DOUBLE_QUOTES_SYMBOL + DOUBLE_QUOTES_SYMBOL) && !quotingEscaped) {
                value = format.parse(data.replace(DOUBLE_QUOTES_SYMBOL + DOUBLE_QUOTES_SYMBOL, DOUBLE_QUOTES_SYMBOL));
            } else {
                value = format.parse(data);
            }
        } catch (FormatException ie) {
            throw new IllegalArgumentException(ie.getMessage() + "", position: "" + pos + "", line: "" + line, ie);
        } catch (Exception e) {
            throw new IllegalArgumentException(""Parsing error detected for field defined at the position: "" + pos + "", line: "" + line, e);
        }
    } else {
        if (!dataField.defaultValue().isEmpty()) {
            value = format.parse(dataField.defaultValue());
        } else {
            value = getDefaultValueForPrimitive(field.getType());
        }
    }
    if (value != null && !dataField.method().isEmpty()) {
        Class<?> clazz;
        if (dataField.method().contains(""."")) {
            clazz = camelContext.getClassResolver().resolveMandatoryClass(dataField.method().substring(0, dataField.method().lastIndexOf('.')));
        } else {
            clazz = field.getType();
        }
        String methodName = dataField.method().substring(dataField.method().lastIndexOf('.') + 1, dataField.method().length());
        Method m = ReflectionHelper.findMethod(clazz, methodName, field.getType());
        if (m != null) {
            value = ObjectHelper.invokeMethod(m, null, value);
        } else {
            m = ReflectionHelper.findMethod(clazz, methodName);
            value = ObjectHelper.invokeMethod(m, value);
        }
    }
    field.set(modelField, value);
    return counterMandatoryFields;
}",java:S3776,39
"private List<List<String>> product(Map<Integer, List<String>> values){
    TreeMap<Integer, List<String>> sortValues = new TreeMap<>(values);
    List<List<String>> product = new ArrayList<>();
    int idx = 0;
    int idxSize;
    do {
        idxSize = 0;
        List<String> v = new ArrayList<>();
        for (int ii = 1; ii <= sortValues.lastKey(); ii++) {
            List<String> l = values.get(ii);
            if (l == null) {
                v.add("""");
                ++idxSize;
                continue;
            }
            if (l.size() >= idx + 1) {
                v.add(l.get(idx));
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Value: {}, pos: {}, at: {}"", l.get(idx), ii, idx);
                }
            } else {
                v.add(l.get(0));
                ++idxSize;
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Value: {}, pos: {}, at index: {}"", l.get(0), ii, 0);
                }
            }
        }
        if (idxSize != sortValues.lastKey()) {
            product.add(v);
        }
        ++idx;
    } while (idxSize != sortValues.lastKey());
    return product;
}",java:S3776,39
"private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception{
    String result = """";
    for (Field field : clazz.getDeclaredFields()) {
        field.setAccessible(true);
        DataField datafield = field.getAnnotation(DataField.class);
        if (datafield != null) {
            if (obj != null) {
                FormattingOptions formattingOptions = ConverterUtils.convert(datafield, field.getType(), field.getAnnotation(BindyConverter.class), getLocale());
                Format<?> format = formatFactory.getFormat(formattingOptions);
                Object value = field.get(obj);
                if (org.apache.camel.util.ObjectHelper.isNotEmpty(datafield.defaultValue()) && org.apache.camel.util.ObjectHelper.isEmpty(value)) {
                    value = datafield.defaultValue();
                }
                result = formatString(format, value);
                if (datafield.trim()) {
                    result = result.trim();
                }
                if (datafield.clip() && result.length() > datafield.length()) {
                    result = result.substring(0, datafield.length());
                }
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Value to be formatted: {}, position: {}, and its formatted value: {}"", value, datafield.pos(), result);
                }
            } else {
                result = """";
            }
            Integer key;
            if (isMessageOrdered() && obj != null) {
                Integer key1 = sections.get(obj.getClass().getName());
                Integer key2 = datafield.position();
                Integer keyGenerated = generateKey(key1, key2);
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Key generated: {}, for section: {}"", String.valueOf(keyGenerated), key1);
                }
                key = keyGenerated;
            } else {
                key = datafield.pos();
            }
            if (!results.containsKey(key)) {
                List<String> list = new LinkedList<>();
                list.add(result);
                results.put(key, list);
            } else {
                List<String> list = results.get(key);
                list.add(result);
            }
        }
        OneToMany oneToMany = field.getAnnotation(OneToMany.class);
        if (oneToMany != null) {
            isOneToMany = true;
            List<?> list = (List<?>) field.get(obj);
            if (list != null) {
                Iterator<?> it = list.iterator();
                while (it.hasNext()) {
                    Object target = it.next();
                    generateCsvPositionMap(target.getClass(), target, results);
                }
            } else {
                generateCsvPositionMap(field.getClass(), null, results);
            }
        }
    }
}",java:S3776,39
"public String generateHeader(){
    Map<Integer, DataField> dataFieldsSorted = new TreeMap<>(dataFields);
    Iterator<Integer> it = dataFieldsSorted.keySet().iterator();
    StringBuilder builderHeader = new StringBuilder();
    while (it.hasNext()) {
        DataField dataField = dataFieldsSorted.get(it.next());
        Field field = annotatedFields.get(dataField.pos());
        field.setAccessible(true);
        final String res;
        if (!dataField.columnName().isEmpty()) {
            res = dataField.columnName();
        } else {
            res = field.getName();
        }
        if (quoting && quote != null) {
            builderHeader.append(quote);
        }
        if (quoting && quote != null && (res.contains(""\\"" + quote) || res.contains(quote)) && quotingEscaped) {
            builderHeader.append(res.replaceAll(""\\"" + quote, ""\\\\"" + quote));
        } else {
            builderHeader.append(res);
        }
        if (quoting && quote != null) {
            builderHeader.append(quote);
        }
        if (it.hasNext()) {
            builderHeader.append(ConverterUtils.getCharDelimiter(separator));
        }
    }
    return builderHeader.toString();
}",java:S3776,39
"public void bind(CamelContext camelContext, String recordStr, Map<String, Object> model, int line) throws Exception{
    int pos = 1;
    int counterMandatoryFields = 0;
    DataField dataField;
    String token;
    int offset = 1;
    int length;
    String delimiter;
    Field field;
    final UnicodeHelper record = new UnicodeHelper(recordStr, (this.countGrapheme) ? UnicodeHelper.Method.GRAPHEME : UnicodeHelper.Method.CODEPOINTS);
    Collection<DataField> c = dataFields.values();
    Iterator<DataField> itr = c.iterator();
    while (itr.hasNext()) {
        dataField = itr.next();
        length = dataField.length();
        delimiter = dataField.delimiter();
        if (length == 0 && dataField.lengthPos() != 0) {
            Field lengthField = annotatedFields.get(dataField.lengthPos());
            lengthField.setAccessible(true);
            Object modelObj = model.get(lengthField.getDeclaringClass().getName());
            Object lengthObj = lengthField.get(modelObj);
            length = ((Integer) lengthObj).intValue();
        }
        if (length < 1 && delimiter == null && dataField.lengthPos() == 0) {
            throw new IllegalArgumentException(""Either length or delimiter must be specified for the field : "" + dataField.toString());
        }
        if (offset - 1 <= -1) {
            throw new IllegalArgumentException(""Offset/Position of the field "" + dataField.toString() + "" cannot be negative"");
        }
        if (dataField.pos() > offset) {
            LOG.debug(""skipping ahead [{}] chars."", dataField.pos() - offset);
            offset = dataField.pos();
        }
        if (length > 0) {
            if (record.length() < offset) {
                token = """";
            } else {
                int endIndex = offset + length - 1;
                if (endIndex > record.length()) {
                    endIndex = record.length();
                }
                token = record.substring(offset - 1, endIndex);
            }
            offset += length;
        } else if (!delimiter.isEmpty()) {
            final UnicodeHelper tempToken = new UnicodeHelper(record.substring(offset - 1, record.length()), (this.countGrapheme) ? UnicodeHelper.Method.GRAPHEME : UnicodeHelper.Method.CODEPOINTS);
            token = tempToken.substring(0, tempToken.indexOf(delimiter));
            offset += token.length() + 1;
        } else {
            token = """";
        }
        if (dataField.trim()) {
            token = trim(token, dataField, paddingChar);
        }
        if (dataField.required()) {
            ++counterMandatoryFields;
            if (token.isEmpty()) {
                throw new IllegalArgumentException(""The mandatory field defined at the position "" + pos + "" is empty for the line: "" + line);
            }
        }
        field = annotatedFields.get(dataField.pos());
        field.setAccessible(true);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Pos/Offset: {}, Data: {}, Field type: {}"", offset, token, field.getType());
        }
        FormattingOptions formattingOptions = ConverterUtils.convert(dataField, field.getType(), field.getAnnotation(BindyConverter.class), getLocale());
        Format<?> format = formatFactory.getFormat(formattingOptions);
        Object modelField = model.get(field.getDeclaringClass().getName());
        Object value;
        if (token.isEmpty()) {
            token = dataField.defaultValue();
        }
        if (!token.isEmpty()) {
            try {
                value = format.parse(token);
            } catch (FormatException ie) {
                throw new IllegalArgumentException(ie.getMessage() + "", position: "" + offset + "", line: "" + line, ie);
            } catch (Exception e) {
                throw new IllegalArgumentException(""Parsing error detected for field defined at the position/offset: "" + offset + "", line: "" + line, e);
            }
        } else {
            value = getDefaultValueForPrimitive(field.getType());
        }
        if (value != null && !dataField.method().isEmpty()) {
            Class<?> clazz;
            if (dataField.method().contains(""."")) {
                clazz = camelContext.getClassResolver().resolveMandatoryClass(dataField.method().substring(0, dataField.method().lastIndexOf('.')));
            } else {
                clazz = field.getType();
            }
            String methodName = dataField.method().substring(dataField.method().lastIndexOf('.') + 1, dataField.method().length());
            Method m = ReflectionHelper.findMethod(clazz, methodName, field.getType());
            if (m != null) {
                value = ObjectHelper.invokeMethod(m, null, value);
            } else {
                m = ReflectionHelper.findMethod(clazz, methodName);
                value = ObjectHelper.invokeMethod(m, value);
            }
        }
        field.set(modelField, value);
        ++pos;
    }
    if (offset <= record.length() && !(record.substring(offset - 1, record.length())).trim().isEmpty() && !isIgnoreTrailingChars()) {
        throw new IllegalArgumentException(""Unexpected / unmapped characters found at the end of the fixed-length record at line : "" + line);
    }
    LOG.debug(""Counter mandatory fields: {}"", counterMandatoryFields);
    if (pos < totalFields) {
        throw new IllegalArgumentException(""Some fields are missing (optional or mandatory), line: "" + line);
    }
    if (counterMandatoryFields < numberMandatoryFields) {
        throw new IllegalArgumentException(""Some mandatory fields are missing, line: "" + line);
    }
}",java:S3776,39
"private void generateFixedLengthPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception{
    String result = """";
    for (Field field : clazz.getDeclaredFields()) {
        field.setAccessible(true);
        DataField datafield = field.getAnnotation(DataField.class);
        if (datafield != null) {
            if (obj != null) {
                FormattingOptions formattingOptions = ConverterUtils.convert(datafield, field.getType(), field.getAnnotation(BindyConverter.class), getLocale());
                Format<?> format = formatFactory.getFormat(formattingOptions);
                Object value = field.get(obj);
                if (org.apache.camel.util.ObjectHelper.isNotEmpty(datafield.defaultValue()) && org.apache.camel.util.ObjectHelper.isEmpty(value)) {
                    value = datafield.defaultValue();
                }
                result = formatString(format, value);
                if (datafield.trim()) {
                    result = result.trim();
                }
                int fieldLength = datafield.length();
                if (fieldLength == 0 && datafield.lengthPos() > 0) {
                    List<String> resultVals = results.get(datafield.lengthPos());
                    fieldLength = Integer.parseInt(resultVals.get(0));
                }
                if (fieldLength <= 0 && datafield.delimiter().isEmpty() && datafield.lengthPos() == 0) {
                    throw new IllegalArgumentException(""Either a delimiter value or length for the field: "" + field.getName() + "" is mandatory."");
                }
                if (!datafield.delimiter().isEmpty()) {
                    result = result + datafield.delimiter();
                } else {
                    String align = datafield.align();
                    char padCharField = datafield.paddingChar();
                    char padChar;
                    StringBuilder temp = new StringBuilder();
                    if (result.length() < fieldLength) {
                        if (padCharField == 0) {
                            padChar = paddingChar;
                        } else {
                            padChar = padCharField;
                        }
                        if (align.contains(""R"")) {
                            temp.append(generatePaddingChars(padChar, fieldLength, result.length()));
                            temp.append(result);
                        } else if (align.contains(""L"")) {
                            temp.append(result);
                            temp.append(generatePaddingChars(padChar, fieldLength, result.length()));
                        } else if (align.contains(""B"")) {
                            temp.append(generatePaddingChars(padChar, fieldLength, result.length()));
                            temp.append(result);
                        } else {
                            throw new IllegalArgumentException(""Alignment for the field: "" + field.getName() + "" must be equal to R for RIGHT or L for LEFT or B for trimming both ends"");
                        }
                        result = temp.toString();
                    } else if (result.length() > fieldLength) {
                        if (datafield.clip()) {
                            result = result.substring(0, fieldLength);
                        } else {
                            throw new IllegalArgumentException(""Length for the "" + field.getName() + "" must not be larger than allowed, was: "" + result.length() + "", allowed: "" + fieldLength);
                        }
                    }
                }
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Value to be formatted: {}, position: {}, and its formatted value: {}"", value, datafield.pos(), result);
                }
            } else {
                result = """";
            }
            Integer key;
            key = datafield.pos();
            if (!results.containsKey(key)) {
                List<String> list = new LinkedList<>();
                list.add(result);
                results.put(key, list);
            } else {
                List<String> list = results.get(key);
                list.add(result);
            }
        }
    }
}",java:S3776,39
"private void generateModelFromKeyValueMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results, int line, Map<String, List<Object>> lists) throws Exception{
    for (Field field : clazz.getDeclaredFields()) {
        field.setAccessible(true);
        KeyValuePairField keyValuePairField = field.getAnnotation(KeyValuePairField.class);
        if (keyValuePairField != null) {
            int key = keyValuePairField.tag();
            List<String> values = results.get(key);
            String value = null;
            if (values == null) {
                if (obj != null) {
                    if (keyValuePairField.required()) {
                        throw new IllegalArgumentException(""The mandatory key/tag : "" + key + "" has not been defined !"");
                    }
                    Object result = getDefaultValueForPrimitive(field.getType());
                    try {
                        field.set(obj, result);
                    } catch (Exception e) {
                        throw new IllegalArgumentException(""Setting of field "" + field + "" failed for object : "" + obj + "" and result : "" + result);
                    }
                } else {
                    List<Object> l = lists.get(clazz.getName());
                    if (l != null) {
                        if (!l.isEmpty()) {
                            obj = l.get(0);
                        } else {
                            obj = clazz.newInstance();
                        }
                        Object result = getDefaultValueForPrimitive(field.getType());
                        try {
                            field.set(obj, result);
                        } catch (Exception e) {
                            throw new IllegalArgumentException(""Setting of field "" + field + "" failed for object : "" + obj + "" and result : "" + result);
                        }
                        if (!l.isEmpty()) {
                            l.set(0, obj);
                        } else {
                            l.add(0, obj);
                        }
                        lists.put(clazz.getName(), l);
                        obj = null;
                    } else {
                        throw new IllegalArgumentException(""The list of values is empty for the following key : "" + key + "" defined in the class : "" + clazz.getName());
                    }
                }
            } else {
                if (!values.isEmpty()) {
                    if (obj != null) {
                        value = values.get(0);
                        Object result = null;
                        if (value != null) {
                            FormattingOptions formattingOptions = ConverterUtils.convert(keyValuePairField, field.getType(), field.getAnnotation(BindyConverter.class), getLocale());
                            Format<?> format = formatFactory.getFormat(formattingOptions);
                            result = formatField(format, value, key, line);
                            LOG.debug(""Value formated : {}"", result);
                        } else {
                            result = getDefaultValueForPrimitive(field.getType());
                        }
                        try {
                            field.set(obj, result);
                        } catch (Exception e) {
                            throw new IllegalArgumentException(""Setting of field "" + field + "" failed for object : "" + obj + "" and result : "" + result);
                        }
                    } else {
                        List<Object> l = lists.get(clazz.getName());
                        if (l != null) {
                            for (int i = 0; i < values.size(); i++) {
                                if (!l.isEmpty() && l.size() > i) {
                                    obj = l.get(i);
                                } else {
                                    obj = clazz.newInstance();
                                }
                                value = values.get(i);
                                FormattingOptions formattingOptions = ConverterUtils.convert(keyValuePairField, field.getType(), field.getAnnotation(BindyConverter.class), getLocale());
                                Format<?> format = formatFactory.getFormat(formattingOptions);
                                Object result = formatField(format, value, key, line);
                                LOG.debug(""Value formated : {}"", result);
                                try {
                                    if (value != null) {
                                        field.set(obj, result);
                                    } else {
                                        field.set(obj, getDefaultValueForPrimitive(field.getType()));
                                    }
                                } catch (Exception e) {
                                    throw new IllegalArgumentException(""Setting of field "" + field + "" failed for object: "" + obj + "" and result: "" + result);
                                }
                                if (!l.isEmpty() && l.size() > i) {
                                    l.set(i, obj);
                                } else {
                                    l.add(i, obj);
                                }
                                lists.put(clazz.getName(), l);
                                obj = null;
                            }
                        } else {
                            throw new IllegalArgumentException(""The list of values is empty for the following key: "" + key + "" defined in the class: "" + clazz.getName());
                        }
                    }
                } else {
                    Object result = getDefaultValueForPrimitive(field.getType());
                    try {
                        field.set(obj, result);
                    } catch (Exception e) {
                        throw new IllegalArgumentException(""Setting of field "" + field + "" failed for object: "" + obj + "" and result: "" + result);
                    }
                }
            }
        }
        OneToMany oneToMany = field.getAnnotation(OneToMany.class);
        if (oneToMany != null) {
            String targetClass = oneToMany.mappedTo();
            if (!targetClass.isEmpty()) {
                Class<?> cl = null;
                try {
                    cl = Thread.currentThread().getContextClassLoader().loadClass(targetClass);
                } catch (ClassNotFoundException e) {
                    cl = getClass().getClassLoader().loadClass(targetClass);
                }
                if (!lists.containsKey(cl.getName())) {
                    lists.put(cl.getName(), new ArrayList<>());
                }
                generateModelFromKeyValueMap(cl, null, results, line, lists);
                field.set(obj, lists.get(cl.getName()));
            } else {
                throw new IllegalArgumentException(""No target class has been defined in @OneToMany annotation"");
            }
        }
    }
}",java:S3776,39
"public Format<?> getFormat(FormattingOptions formattingOptions) throws Exception{
    if (formattingOptions.getBindyConverter() != null) {
        return formattingOptions.getBindyConverter().value().newInstance();
    }
    return doGetFormat(formattingOptions);
}",java:S1452,23
"public Format<?> getFormat(FormattingOptions formattingOptions) throws Exception{
    if (formattingOptions.getBindyConverter() != null) {
        return formattingOptions.getBindyConverter().value().newInstance();
    }
    return doGetFormat(formattingOptions);
}",java:S112,4
"private Consumer<String> consumeFile(BindyCsvFactory factory, List<Map<String, Object>> models, String separator, Boolean removeQuotes, String quote, AtomicInteger count){
    return line -> {
        try {
            String trimmedLine;
            if (factory.isTrimLine()) {
                if (separator.equals(""\t"")) {
                    trimmedLine = line.replaceAll(""[ \\n\\x0B\\f\\r]+$"", """");
                } else {
                    trimmedLine = line.trim();
                }
            } else {
                trimmedLine = line;
            }
            count.incrementAndGet();
            Map<String, Object> model;
            model = factory.factory();
            Pattern pattern = Pattern.compile(separator);
            Matcher matcher = pattern.matcher(trimmedLine);
            List<String> separators = new ArrayList<>();
            while (matcher.find()) {
                separators.add(matcher.group());
            }
            if (!separators.isEmpty()) {
                separators.add(separators.get(separators.size() - 1));
            }
            String[] tokens = pattern.split(trimmedLine, factory.getAutospanLine() ? factory.getMaxpos() : -1);
            List<String> result = Arrays.asList(tokens);
            if (Boolean.TRUE.equals(removeQuotes)) {
                result = unquoteTokens(result, separators, quote);
            }
            if (result.isEmpty()) {
                throw new IllegalArgumentException(""No records have been defined in the CSV"");
            } else {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Size of the record splitted : {}"", result.size());
                }
                factory.bind(getCamelContext(), result, model, count.get());
                factory.link(model);
                models.add(model);
                LOG.debug(""Graph of objects created: {}"", model);
            }
        } catch (Exception e) {
            throw new WrappedException(e);
        }
    };
}",java:S3776,39
"private List<String> unquoteTokens(List<String> result, List<String> separators, String quote){
    StringBuilder current = new StringBuilder();
    boolean inProgress = false;
    List<String> answer = new ArrayList<>();
    int idxSeparator = 0;
    for (String s : result) {
        boolean canStart = false;
        boolean canClose = false;
        boolean cutStart = false;
        boolean cutEnd = false;
        if (s.startsWith(quote)) {
            if (s.length() == 1) {
                s = """";
                if (inProgress) {
                    canClose = true;
                } else {
                    canStart = true;
                }
            } else {
                cutStart = true;
                canStart = true;
            }
        }
        if (s.endsWith(quote)) {
            cutEnd = true;
            canClose = true;
        }
        if (cutEnd || cutStart) {
            s = s.substring(cutStart ? 1 : 0, cutEnd ? s.length() - 1 : s.length());
        }
        if (inProgress) {
            current.append(separators.get(idxSeparator));
            current.append(s);
            if (canClose) {
                answer.add(current.toString());
                current.setLength(0);
                inProgress = false;
            }
        } else {
            if (canStart && !canClose) {
                current.append(s);
                inProgress = true;
            } else {
                answer.add(s);
            }
        }
        idxSeparator++;
    }
    if (current.length() > 0) {
        answer.add(current.toString());
        current.setLength(0);
    }
    return answer;
}",java:S3776,39
"public BoxFile uploadFile(String parentFolderId, InputStream content, String fileName, Date created, Date modified, Long size, Boolean check, ProgressListener listener){
    try {
        LOG.debug(""Uploading file with name '{}}' to parent_folder(id={}})"", fileName, parentFolderId);
        notNull(parentFolderId, ""parentFolderId"");
        notNull(content, ""content"");
        notNull(fileName, ""fileName"");
        BoxFile boxFile = null;
        boolean uploadNewFile = true;
        if (check != null && check) {
            BoxFolder folder = null;
            try {
                folder = new BoxFolder(boxConnection, parentFolderId);
                folder.canUpload(fileName, 0);
            } catch (BoxAPIResponseException boxException) {
                if (409 == boxException.getResponseCode()) {
                    long init = System.currentTimeMillis();
                    int delayLimit = 5;
                    boolean exists = false;
                    BoxItem.Info existingFile = null;
                    if (folder != null) {
                        for (BoxItem.Info itemInfo : folder.getChildren(""name"", BoxFolder.SortDirection.ASC, ""name"", ""type"")) {
                            exists = ""file"".equals(itemInfo.getType()) && fileName.equals(itemInfo.getName());
                            if (exists) {
                                existingFile = itemInfo;
                                break;
                            }
                        }
                    }
                    long end = System.currentTimeMillis();
                    long elapsed = (end - init) / 1000;
                    if (elapsed > delayLimit) {
                        LOG.warn(""The upload operation, checks if the file exists by using the Box list folder, however it took {}"" + "" seconds to verify, try to reduce the size of the folder items for faster results."", elapsed);
                    }
                    if (exists) {
                        boxFile = uploadNewFileVersion(existingFile.getID(), content, modified, size, listener);
                        uploadNewFile = false;
                    }
                } else {
                    throw boxException;
                }
            }
        }
        if (uploadNewFile) {
            BoxFolder parentFolder = new BoxFolder(boxConnection, parentFolderId);
            FileUploadParams uploadParams = new FileUploadParams();
            uploadParams.setName(fileName);
            uploadParams.setContent(content);
            if (created != null) {
                uploadParams.setCreated(created);
            }
            if (modified != null) {
                uploadParams.setModified(modified);
            }
            if (size != null) {
                uploadParams.setSize(size);
            }
            if (listener != null) {
                uploadParams.setProgressListener(listener);
            }
            boxFile = parentFolder.uploadFile(uploadParams).getResource();
        }
        return boxFile;
    } catch (BoxAPIException e) {
        throw new RuntimeCamelException(buildErrorMessage(e), e);
    }
}",java:S3776,39
"public BoxFile uploadFile(String parentFolderId, InputStream content, String fileName, Date created, Date modified, Long size, Boolean check, ProgressListener listener){
    try {
        LOG.debug(""Uploading file with name '{}}' to parent_folder(id={}})"", fileName, parentFolderId);
        notNull(parentFolderId, ""parentFolderId"");
        notNull(content, ""content"");
        notNull(fileName, ""fileName"");
        BoxFile boxFile = null;
        boolean uploadNewFile = true;
        if (check != null && check) {
            BoxFolder folder = null;
            try {
                folder = new BoxFolder(boxConnection, parentFolderId);
                folder.canUpload(fileName, 0);
            } catch (BoxAPIResponseException boxException) {
                if (409 == boxException.getResponseCode()) {
                    long init = System.currentTimeMillis();
                    int delayLimit = 5;
                    boolean exists = false;
                    BoxItem.Info existingFile = null;
                    if (folder != null) {
                        for (BoxItem.Info itemInfo : folder.getChildren(""name"", BoxFolder.SortDirection.ASC, ""name"", ""type"")) {
                            exists = ""file"".equals(itemInfo.getType()) && fileName.equals(itemInfo.getName());
                            if (exists) {
                                existingFile = itemInfo;
                                break;
                            }
                        }
                    }
                    long end = System.currentTimeMillis();
                    long elapsed = (end - init) / 1000;
                    if (elapsed > delayLimit) {
                        LOG.warn(""The upload operation, checks if the file exists by using the Box list folder, however it took {}"" + "" seconds to verify, try to reduce the size of the folder items for faster results."", elapsed);
                    }
                    if (exists) {
                        boxFile = uploadNewFileVersion(existingFile.getID(), content, modified, size, listener);
                        uploadNewFile = false;
                    }
                } else {
                    throw boxException;
                }
            }
        }
        if (uploadNewFile) {
            BoxFolder parentFolder = new BoxFolder(boxConnection, parentFolderId);
            FileUploadParams uploadParams = new FileUploadParams();
            uploadParams.setName(fileName);
            uploadParams.setContent(content);
            if (created != null) {
                uploadParams.setCreated(created);
            }
            if (modified != null) {
                uploadParams.setModified(modified);
            }
            if (size != null) {
                uploadParams.setSize(size);
            }
            if (listener != null) {
                uploadParams.setProgressListener(listener);
            }
            boxFile = parentFolder.uploadFile(uploadParams).getResource();
        }
        return boxFile;
    } catch (BoxAPIException e) {
        throw new RuntimeCamelException(buildErrorMessage(e), e);
    }
}",java:S107,1
"public BoxGroupMembership addGroupMembership(String groupId, String userId, BoxGroupMembership.GroupRole role){
    try {
        LOG.debug(""Adding user(id={}) as member to group(id={} {})"", userId, groupId, role == null ? """" : ""with role="" + role.name());
        if (groupId == null) {
            throw new IllegalArgumentException(""Parameter 'groupId' can not be null"");
        }
        if (userId == null) {
            throw new IllegalArgumentException(""Parameter 'userId' can not be null"");
        }
        BoxGroup group = new BoxGroup(boxConnection, groupId);
        BoxUser user = new BoxUser(boxConnection, userId);
        return group.addMembership(user, role).getResource();
    } catch (BoxAPIException e) {
        throw new RuntimeCamelException(String.format(""Box API returned the error code %d%n%n%s"", e.getResponseCode(), e.getResponse()), e);
    }
}",java:S1874,25
"// compiler for some reason thinks 'if (assignTo
@SuppressWarnings(""unused"")
public BoxTask addAssignmentToTask(String taskId, BoxUser assignTo){
    try {
        if (taskId == null) {
            throw new IllegalArgumentException(""Parameter 'commentId' can not be null"");
        }
        if (assignTo == null) {
            throw new IllegalArgumentException(""Parameter 'assignTo' can not be null"");
        }
        LOG.debug(""Assigning task(id={}) to user(id={})"", taskId, assignTo.getID());
        BoxTask task = new BoxTask(boxConnection, taskId);
        task.addAssignment(assignTo);
        return task;
    } catch (BoxAPIException e) {
        throw new RuntimeCamelException(String.format(""Box API returned the error code %d%n%n%s"", e.getResponseCode(), e.getResponse()), e);
    }
}",java:S125,21
"private Logger getLogger(LogRecord record){
    String name = record.getLoggerName();
    if (name == null) {
        name = DEFAULT_LOGGER_NAME;
    }
    return LoggerFactory.getLogger(name);
}",java:S6213,47
"private String formatMessage(LogRecord record){
    String message = record.getMessage();
    if (message != null) {
        ResourceBundle bundle = record.getResourceBundle();
        if (bundle != null) {
            try {
                message = bundle.getString(message);
            } catch (MissingResourceException e) {
            }
        }
        Object[] params = record.getParameters();
        if (params != null && params.length > 0) {
            try {
                message = MessageFormat.format(message, params);
            } catch (IllegalArgumentException e) {
                return message;
            }
        }
    } else {
        message = """";
    }
    return message;
}",java:S6213,47
"public CacheLoader getCacheLoader(){
    return cacheLoader;
}",java:S3740,38
"public void setCacheLoader(CacheLoader cacheLoader){
    this.cacheLoader = cacheLoader;
}",java:S3740,38
"public RemovalListener getRemovalListener(){
    return removalListener;
}",java:S3740,38
"public void setRemovalListener(RemovalListener removalListener){
    this.removalListener = removalListener;
}",java:S3740,38
"protected Cache<?, ?> getOrCreateCache(String name, CaffeineConfiguration configuration){
    return caches.computeIfAbsent(name, key -> {
        Caffeine<?, ?> builder = Caffeine.newBuilder();
        defineBuilder(builder, configuration);
        return builder.build();
    });
}",java:S1452,23
"protected Cache<?, ?> getOrCreateCache(String name, CaffeineConfiguration configuration){
    return caches.computeIfAbsent(name, key -> {
        Caffeine<?, ?> builder = Caffeine.newBuilder();
        defineBuilder(builder, configuration);
        return builder.build();
    });
}",java:S1452,23
"private Object getKey(final Message message) throws Exception{
    String value;
    value = message.getHeader(CaffeineConstants.KEY, String.class);
    if (value == null) {
        value = configuration.getKey();
    }
    if (value == null) {
        throw new CamelExchangeException(""No value provided in header or as default value ("" + CaffeineConstants.KEY + "")"", message.getExchange());
    }
    return value;
}",java:S112,4
"private Object getValue(final Message message, final String type) throws Exception{
    Object value = message.getHeader(CaffeineConstants.VALUE);
    if (value == null) {
        if (type != null) {
            Class<?> clazz = getEndpoint().getCamelContext().getClassResolver().resolveClass(type);
            value = message.getBody(clazz);
        } else {
            value = message.getBody();
        }
    }
    if (value == null) {
        throw new CamelExchangeException(""No value provided in header or body ("" + CaffeineConstants.VALUE + "")"", message.getExchange());
    }
    return value;
}",java:S112,4
"protected LoadingCache<?, ?> getOrCreateCache(String name, CaffeineConfiguration configuration){
    return caches.computeIfAbsent(name, key -> {
        Caffeine<?, ?> builder = Caffeine.newBuilder();
        defineBuilder(builder, configuration);
        return builder.build(configuration.getCacheLoader());
    });
}",java:S1452,23
"protected LoadingCache<?, ?> getOrCreateCache(String name, CaffeineConfiguration configuration){
    return caches.computeIfAbsent(name, key -> {
        Caffeine<?, ?> builder = Caffeine.newBuilder();
        defineBuilder(builder, configuration);
        return builder.build(configuration.getCacheLoader());
    });
}",java:S1452,23
"private Object getKey(final Message message) throws Exception{
    String value = message.getHeader(CaffeineConstants.KEY, String.class);
    if (value == null) {
        value = configuration.getKey();
    }
    if (value == null) {
        throw new CamelExchangeException(""No value provided in header or as default value ("" + CaffeineConstants.KEY + "")"", message.getExchange());
    }
    return value;
}",java:S112,4
"private Object getValue(final Message message, final String type) throws Exception{
    Object value = message.getHeader(CaffeineConstants.VALUE);
    if (value == null) {
        if (type != null) {
            Class<?> clazz = getEndpoint().getCamelContext().getClassResolver().resolveClass(type);
            value = message.getBody(clazz);
        } else {
            value = message.getBody();
        }
    }
    if (value == null) {
        throw new CamelExchangeException(""No value provided in header or body ("" + CaffeineConstants.VALUE + "")"", message.getExchange());
    }
    return value;
}",java:S112,4
"public String getDeadLetterChannel(){
    return deadLetterChannel;
}",java:S4144,40
"protected Cache getCache(){
    return this.cache;
}",java:S3740,38
"protected CqlSessionBuilder createSessionBuilder(){
    CqlSessionBuilder sessionBuilder = CqlSession.builder();
    for (String host : hosts.split("","")) {
        sessionBuilder.addContactPoint(new InetSocketAddress(host, port == null ? 9042 : port));
    }
    if (username != null && !username.isEmpty() && password != null) {
        sessionBuilder.withAuthCredentials(username, password);
    }
    if (loadBalancingPolicyClass != null && !loadBalancingPolicyClass.isEmpty()) {
        DriverConfigLoader driverConfigLoader = DriverConfigLoader.programmaticBuilder().withString(DefaultDriverOption.LOAD_BALANCING_POLICY_CLASS, loadBalancingPolicyClass).build();
        sessionBuilder.withConfigLoader(driverConfigLoader);
    }
    sessionBuilder.withLocalDatacenter(datacenter);
    sessionBuilder.withKeyspace(keyspace);
    ClassLoader classLoader = getCamelContext().getApplicationContextClassLoader();
    if (classLoader != null) {
        sessionBuilder.withClassLoader(classLoader);
    }
    if (extraTypeCodecs != null) {
        String[] c = extraTypeCodecs.split("","");
        if (LOG.isDebugEnabled()) {
            LOG.debug(Arrays.toString(c));
        }
        for (String codec : c) {
            if (ObjectHelper.isNotEmpty(CassandraExtraCodecs.valueOf(codec))) {
                sessionBuilder.addTypeCodecs(CassandraExtraCodecs.valueOf(codec).codec());
            }
        }
    }
    return sessionBuilder;
}",java:S3776,39
"@Deprecated
public String getBeanRef(){
    return beanRef;
}",java:S6355,48
"@Deprecated
public void setBeanRef(String beanRef){
    this.beanRef = beanRef;
}",java:S6355,48
"public TypeCodec codec(){
    return codec;
}",java:S3740,38
"public void start(){
}",java:S1186,16
"private String doMessage(String msg) throws Exception{
    String resp = """";
    try (Socket echoSocket = new Socket(this.host, this.port)) {
        try (PrintWriter out = new PrintWriter(echoSocket.getOutputStream(), true)) {
            try (BufferedReader in = new BufferedReader(new InputStreamReader(echoSocket.getInputStream()))) {
                out.println(msg);
                resp = in.readLine();
            }
        }
    } catch (IOException e) {
        throw new Exception(""Unable to send message to ChatScript Server. Reason:"" + e.getMessage(), e);
    }
    return resp;
}",java:S112,4
"public void reset(){
}",java:S1186,16
"private ChatScriptMessage createMessage(String message) throws Exception{
    ChatScriptMessage ret = null;
    try {
        ret = mapper.readValue(message, ChatScriptMessage.class);
    } catch (Exception e) {
        throw new Exception(""Unable to parse the input message. Error Message"" + e.getMessage(), e);
    }
    return ret;
}",java:S112,4
"private ArtifactModel<?> findOtherModel(String artifactId){
    for (String name : catalog.findOtherNames()) {
        OtherModel model = catalog.otherModel(name);
        if (model != null && model.getArtifactId().equals(artifactId)) {
            return model;
        }
    }
    return null;
}",java:S3740,38
"public void setUnicodeAndMultipart(int defaultMaxNumberOfParts){
    final String msg = getMessage();
    if (CMUtils.isGsm0338Encodeable(msg)) {
        if (msg.length() > CMConstants.MAX_GSM_MESSAGE_LENGTH) {
            int parts = msg.length() / CMConstants.MAX_GSM_MESSAGE_LENGTH_PER_PART_IF_MULTIPART;
            if (msg.length() % CMConstants.MAX_GSM_MESSAGE_LENGTH_PER_PART_IF_MULTIPART != 0) {
                parts++;
            }
            setMultiparts((parts > defaultMaxNumberOfParts) ? defaultMaxNumberOfParts : parts);
        } else {
            setMultiparts(1);
        }
    } else {
        setUnicode(true);
        if (msg.length() > CMConstants.MAX_UNICODE_MESSAGE_LENGTH) {
            int parts = msg.length() / CMConstants.MAX_UNICODE_MESSAGE_LENGTH_PER_PART_IF_MULTIPART;
            if (msg.length() % CMConstants.MAX_UNICODE_MESSAGE_LENGTH_PER_PART_IF_MULTIPART != 0) {
                parts++;
            }
            setMultiparts((parts > defaultMaxNumberOfParts) ? defaultMaxNumberOfParts : parts);
        } else {
            setMultiparts(1);
        }
    }
}",java:S3776,39
"private void doHttpPost(final String urlString, final String requestString){
    final HttpPost post = new HttpPost(urlString);
    post.setEntity(new StringEntity(requestString, StandardCharsets.UTF_8));
    try {
        client.execute(post, response -> {
            final int statusCode = response.getCode();
            LOG.debug(""Response Code : {}"", statusCode);
            if (statusCode == 400) {
                throw new CMDirectException(""CM Component and CM API show some kind of inconsistency. "" + ""CM is complaining about not using a post method for the request. And this component only uses POST requests. What happens?"");
            }
            if (statusCode != 200) {
                throw new CMDirectException(""CM Component and CM API show some kind of inconsistency. The component expects the status code to be 200 or 400. New api released? "");
            }
            try (BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()))) {
                final StringBuilder result = new StringBuilder();
                String line;
                while ((line = rd.readLine()) != null) {
                    result.append(line);
                }
                line = result.toString();
                if (!line.isEmpty()) {
                    LOG.debug(""Result of the request processing: FAILED\n{}"", line);
                    if (line.contains(CMConstants.ERROR_UNKNOWN)) {
                        throw new UnknownErrorException();
                    } else if (line.contains(CMConstants.ERROR_NO_ACCOUNT) || line.contains(CMConstants.ERROR_NO_USER)) {
                        throw new NoAccountFoundForProductTokenException();
                    } else if (line.contains(CMConstants.ERROR_INSUFICIENT_BALANCE)) {
                        throw new InsufficientBalanceException();
                    } else if (line.contains(CMConstants.ERROR_UNROUTABLE_MESSAGE)) {
                        throw new UnroutableMessageException();
                    } else if (line.contains(CMConstants.ERROR_INVALID_PRODUCT_TOKEN)) {
                        throw new InvalidProductTokenException();
                    } else {
                        throw new CMResponseException(line);
                    }
                }
                LOG.debug(""Result of the request processing: Successfully submitted"");
            }
            return null;
        });
    } catch (final IOException io) {
        throw new CMDirectException(io);
    } catch (Exception t) {
        Exception exception = t;
        if (!(exception instanceof CMDirectException)) {
            exception = new CMDirectException(exception);
        }
        throw (CMDirectException) exception;
    }
}",java:S3776,39
"public synchronized CoapServer getServer(int port, CoAPEndpoint endpoint) throws IOException, GeneralSecurityException{
    CoapServer server = servers.get(port);
    if (server == null && port == -1) {
        server = getServer(DEFAULT_PORT, endpoint);
    }
    if (server == null) {
        CoapEndpoint.Builder coapBuilder = new CoapEndpoint.Builder();
        NetworkConfig config = NetworkConfig.createStandardWithoutFile();
        InetSocketAddress address = new InetSocketAddress(port);
        coapBuilder.setNetworkConfig(config);
        if (CoAPEndpoint.enableDTLS(endpoint.getUri())) {
            DTLSConnector connector = endpoint.createDTLSConnector(address, false);
            coapBuilder.setConnector(connector);
        } else if (CoAPEndpoint.enableTCP(endpoint.getUri())) {
            int tcpThreads = config.getInt(NetworkConfig.Keys.TCP_WORKER_THREADS);
            int tcpIdleTimeout = config.getInt(NetworkConfig.Keys.TCP_CONNECTION_IDLE_TIMEOUT);
            TcpServerConnector tcpConnector = null;
            if (endpoint.getUri().getScheme().startsWith(""coaps"")) {
                int tlsHandshakeTimeout = config.getInt(NetworkConfig.Keys.TLS_HANDSHAKE_TIMEOUT);
                SSLContext sslContext = endpoint.getSslContextParameters().createSSLContext(getCamelContext());
                TlsServerConnector.ClientAuthMode clientAuthMode = TlsServerConnector.ClientAuthMode.NONE;
                if (endpoint.isClientAuthenticationRequired()) {
                    clientAuthMode = TlsServerConnector.ClientAuthMode.NEEDED;
                } else if (endpoint.isClientAuthenticationWanted()) {
                    clientAuthMode = TlsServerConnector.ClientAuthMode.WANTED;
                }
                tcpConnector = new TlsServerConnector(sslContext, clientAuthMode, address, tcpThreads, tlsHandshakeTimeout, tcpIdleTimeout);
            } else {
                tcpConnector = new TcpServerConnector(address, tcpThreads, tcpIdleTimeout);
            }
            coapBuilder.setConnector(tcpConnector);
        } else {
            coapBuilder.setInetSocketAddress(address);
        }
        server = new CoapServer();
        server.addEndpoint(coapBuilder.build());
        servers.put(port, server);
        if (this.isStarted()) {
            server.start();
        }
    }
    return server;
}",java:S3776,39
"public TrustedRpkStore getTrustedRpkStore(){
    return trustedRpkStore;
}",java:S1874,25
"public void setTrustedRpkStore(TrustedRpkStore trustedRpkStore){
    this.trustedRpkStore = trustedRpkStore;
}",java:S1874,25
"public PskStore getPskStore(){
    return pskStore;
}",java:S1874,25
"public void setPskStore(PskStore pskStore){
    this.pskStore = pskStore;
}",java:S1874,25
"public DTLSConnector createDTLSConnector(InetSocketAddress address, boolean client) throws IOException{
    DtlsConnectorConfig.Builder builder = new DtlsConnectorConfig.Builder();
    if (client) {
        if (trustedRpkStore == null && sslContextParameters == null && pskStore == null) {
            throw new IllegalStateException(""Either a trustedRpkStore, sslContextParameters or pskStore object "" + ""must be configured for a TLS client"");
        }
        builder.setRecommendedCipherSuitesOnly(isRecommendedCipherSuitesOnly());
        builder.setClientOnly();
    } else {
        if (privateKey == null && sslContextParameters == null && pskStore == null) {
            throw new IllegalStateException(""Either a privateKey, sslContextParameters or pskStore object "" + ""must be configured for a TLS service"");
        }
        if (privateKey != null && publicKey == null) {
            throw new IllegalStateException(""A public key must be configured to use a Raw Public Key with TLS"");
        }
        if ((isClientAuthenticationRequired() || isClientAuthenticationWanted()) && (sslContextParameters == null || sslContextParameters.getTrustManagers() == null) && publicKey == null) {
            throw new IllegalStateException(""A truststore must be configured to support TLS client authentication"");
        }
        builder.setAddress(address);
        builder.setClientAuthenticationRequired(isClientAuthenticationRequired());
        builder.setClientAuthenticationWanted(isClientAuthenticationWanted());
        builder.setRecommendedCipherSuitesOnly(isRecommendedCipherSuitesOnly());
    }
    try {
        if (sslContextParameters != null && sslContextParameters.getKeyManagers() != null) {
            KeyManagersParameters keyManagers = sslContextParameters.getKeyManagers();
            KeyStore keyStore = keyManagers.getKeyStore().createKeyStore();
            String alias = getAlias();
            if (alias == null) {
                Enumeration<String> aliases = keyStore.aliases();
                while (aliases.hasMoreElements()) {
                    String ksAlias = aliases.nextElement();
                    if (keyStore.isKeyEntry(ksAlias)) {
                        alias = ksAlias;
                        break;
                    }
                }
            }
            if (alias == null) {
                throw new IllegalStateException(""The sslContextParameters keystore must contain a key entry"");
            }
            PrivateKey privateKey = (PrivateKey) keyStore.getKey(alias, keyManagers.getKeyPassword().toCharArray());
            builder.setIdentity(privateKey, keyStore.getCertificateChain(alias));
        } else if (privateKey != null) {
            builder.setIdentity(privateKey, publicKey);
        }
        if (pskStore != null) {
            builder.setPskStore(pskStore);
        }
        Certificate[] certs = getTrustedCerts();
        if (certs.length > 0) {
            builder.setTrustStore(certs);
        }
        if (trustedRpkStore != null) {
            builder.setTrustCertificateTypes(CertificateType.RAW_PUBLIC_KEY);
            builder.setRpkTrustStore(trustedRpkStore);
        }
    } catch (GeneralSecurityException e) {
        throw new IllegalStateException(""Error in configuring TLS"", e);
    }
    if (getConfiguredCipherSuites() != null) {
        builder.setSupportedCipherSuites(getConfiguredCipherSuites());
    }
    return new DTLSConnector(builder.build());
}",java:S3776,39
"protected ServerConnector getSslSocketConnector(Server server) throws Exception{
    ServerConnector sslSocketConnector = null;
    SSLContextParameters sslParams = this.sslContextParameters;
    if (sslParams == null) {
        sslParams = retrieveGlobalSslContextParameters();
    }
    SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
    sslContextFactory.setEndpointIdentificationAlgorithm(null);
    if (sslParams != null) {
        sslContextFactory.setSslContext(sslParams.createSSLContext(getCamelContext()));
    } else {
        sslContextFactory.setKeyStorePassword(sslKeyPassword);
        sslContextFactory.setKeyManagerPassword(sslPassword);
        if (sslKeystore != null) {
            sslContextFactory.setKeyStorePath(sslKeystore);
        }
    }
    sslSocketConnector = new ServerConnector(server, sslContextFactory);
    return sslSocketConnector;
}",java:S112,4
"@Deprecated
public String getDc(){
    return datacenter;
}",java:S6355,48
"@Deprecated
public void setDc(String dc){
    this.datacenter = dc;
}",java:S6355,48
"public String getDatacenter(){
    return datacenter;
}",java:S4144,40
"public Consul createConsulClient() throws Exception{
    return createConsulClient(null);
}",java:S112,4
"public synchronized Consul getConsul() throws Exception{
    if (consul == null && ObjectHelper.isEmpty(getConfiguration().getConsulClient())) {
        consul = configuration.createConsulClient(getCamelContext());
    } else if (ObjectHelper.isNotEmpty(getConfiguration().getConsulClient())) {
        consul = getConfiguration().getConsulClient();
    }
    return consul;
}",java:S112,4
"protected static Boolean setDocument(Collection collection, String id, int expiry, Object obj, PersistTo persistTo, ReplicateTo replicateTo, long writeQueryTimeout, long producerRetryPause){
    UpsertOptions options = UpsertOptions.upsertOptions().expiry(Duration.ofSeconds(expiry)).durability(persistTo, replicateTo).timeout(Duration.ofMillis(writeQueryTimeout)).retryStrategy(BestEffortRetryStrategy.withExponentialBackoff(Duration.ofMillis(producerRetryPause), Duration.ofMillis(producerRetryPause), 1));
    MutationResult result = collection.upsert(id, obj, options);
    if (LOG.isDebugEnabled()) {
        LOG.debug(result.toString());
    }
    return true;
}",java:S107,1
"private Bucket createClient() throws Exception{
    List<URI> hosts = Arrays.asList(makeBootstrapURI());
    String connectionString;
    if (bucket == null || bucket.isEmpty()) {
        throw new CamelException(COUCHBASE_URI_ERROR);
    }
    ClusterEnvironment.Builder cfb = ClusterEnvironment.builder();
    if (queryTimeout != DEFAULT_QUERY_TIMEOUT) {
        cfb.timeoutConfig().connectTimeout(Duration.ofMillis(connectTimeout)).queryTimeout(Duration.ofMillis(queryTimeout));
    }
    ClusterEnvironment env = cfb.build();
    String addHosts = hosts.stream().map(URI::getHost).collect(Collectors.joining("",""));
    if (!addHosts.isEmpty()) {
        connectionString = addHosts;
    } else {
        connectionString = hostname;
    }
    Cluster cluster = Cluster.connect(connectionString, ClusterOptions.clusterOptions(username, password).environment(env));
    return cluster.bucket(bucket);
}",java:S112,4
"public Certificate getCertificate(String alias) throws Exception{
    Certificate cert = null;
    if (alias != null && keystore != null) {
        cert = keystore.getCertificate(alias);
    }
    if (cert == null) {
        cert = certificate;
    }
    return cert;
}",java:S112,4
"public void calculateSignature(Exchange exchange, Signature signer) throws Exception{
    Object payload = exchange.getIn().getBody();
    if (payload != null) {
        InputStream payloadStream = ExchangeHelper.convertToMandatoryType(exchange, InputStream.class, payload);
        try {
            byte[] buffer = new byte[config.getBufferSize()];
            int read;
            while ((read = payloadStream.read(buffer)) > 0) {
                signer.update(buffer, 0, read);
            }
        } finally {
            IOHelper.close(payloadStream);
        }
    }
}",java:S112,4
"protected String getAlias(Exchange exchange) throws Exception{
    KeyStore keystore = config.getKeystore();
    if (keystore != null) {
        String alias = exchange.getIn().getHeader(DigitalSignatureConstants.KEYSTORE_ALIAS, String.class);
        if (alias == null) {
            alias = config.getAlias();
        }
        if (alias == null && keystore.size() == 1) {
            alias = keystore.aliases().nextElement();
        }
        return alias;
    }
    return null;
}",java:S112,4
"private byte[] getSignatureFromExchange(Exchange exchange) throws Exception{
    String encodedSignature = ExchangeHelper.getMandatoryHeader(exchange, config.getSignatureHeaderName(), String.class);
    if (encodedSignature == null) {
        throw new IllegalStateException(""Cannot verify exchange as no "" + config.getSignatureHeaderName() + "" header is present."");
    }
    return new Base64().decode(encodedSignature);
}",java:S112,4
"private Cipher initializeCipher(int mode, Key key, byte[] iv) throws Exception{
    Cipher cipher = cryptoProvider == null ? Cipher.getInstance(algorithm) : Cipher.getInstance(algorithm, cryptoProvider);
    if (key == null) {
        throw new IllegalStateException(""A valid encryption key is required. Either configure the CryptoDataFormat "" + ""with a key or provide one in a header using the header name 'CamelCryptoKey'"");
    }
    if (mode == ENCRYPT_MODE || mode == DECRYPT_MODE) {
        if (iv != null) {
            cipher.init(mode, key, new IvParameterSpec(iv));
        } else if (parameterSpec != null) {
            cipher.init(mode, key, parameterSpec);
        } else {
            cipher.init(mode, key);
        }
    }
    return cipher;
}",java:S112,4
"private HMACAccumulator getMessageAuthenticationCode(Key key) throws Exception{
    return shouldAppendHMAC ? new HMACAccumulator(key, macAlgorithm, cryptoProvider, bufferSize) : new HMACAccumulator() {

        byte[] empty = new byte[0];

        @Override
        public void encryptUpdate(byte[] buffer, int read) {
        }

        @Override
        public void decryptUpdate(byte[] buffer, int read) throws IOException {
            outputStream.write(buffer, 0, read);
        }

        @Override
        public void validate() {
        }

        @Override
        public byte[] getCalculatedMac() {
            return empty;
        }
    };
}",java:S112,4
"public static PGPPrivateKey findPrivateKeyWithkeyId(long keyid, String passphrase, PGPPassphraseAccessor passphraseAccessor, String provider, PGPSecretKeyRingCollection pgpSec) throws PGPException{
    for (Iterator<?> i = pgpSec.getKeyRings(); i.hasNext(); ) {
        Object data = i.next();
        if (data instanceof PGPSecretKeyRing) {
            PGPSecretKeyRing keyring = (PGPSecretKeyRing) data;
            PGPSecretKey secKey = keyring.getSecretKey(keyid);
            if (secKey != null) {
                if (passphrase == null && passphraseAccessor != null) {
                    @SuppressWarnings(""unchecked"")
                    Iterator<String> userIDs = keyring.getSecretKey().getUserIDs();
                    while (passphrase == null && userIDs.hasNext()) {
                        passphrase = passphraseAccessor.getPassphrase(userIDs.next());
                    }
                }
                if (passphrase != null) {
                    PGPPrivateKey privateKey = secKey.extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(provider).build(passphrase.toCharArray()));
                    if (privateKey != null) {
                        return privateKey;
                    }
                }
                if (passphrase == null && passphraseAccessor == null) {
                    passphrase = """";
                    PGPPrivateKey privateKey = secKey.extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(provider).build(passphrase.toCharArray()));
                    if (privateKey != null) {
                        return privateKey;
                    }
                }
            }
        }
    }
    return null;
}",java:S1845,24
"public static PGPPrivateKey findPrivateKeyWithkeyId(long keyid, String passphrase, PGPPassphraseAccessor passphraseAccessor, String provider, PGPSecretKeyRingCollection pgpSec) throws PGPException{
    for (Iterator<?> i = pgpSec.getKeyRings(); i.hasNext(); ) {
        Object data = i.next();
        if (data instanceof PGPSecretKeyRing) {
            PGPSecretKeyRing keyring = (PGPSecretKeyRing) data;
            PGPSecretKey secKey = keyring.getSecretKey(keyid);
            if (secKey != null) {
                if (passphrase == null && passphraseAccessor != null) {
                    @SuppressWarnings(""unchecked"")
                    Iterator<String> userIDs = keyring.getSecretKey().getUserIDs();
                    while (passphrase == null && userIDs.hasNext()) {
                        passphrase = passphraseAccessor.getPassphrase(userIDs.next());
                    }
                }
                if (passphrase != null) {
                    PGPPrivateKey privateKey = secKey.extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(provider).build(passphrase.toCharArray()));
                    if (privateKey != null) {
                        return privateKey;
                    }
                }
                if (passphrase == null && passphraseAccessor == null) {
                    passphrase = """";
                    PGPPrivateKey privateKey = secKey.extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(provider).build(passphrase.toCharArray()));
                    if (privateKey != null) {
                        return privateKey;
                    }
                }
            }
        }
    }
    return null;
}",java:S3776,39
"public static List<PGPSecretKeyAndPrivateKeyAndUserId> findSecretKeysWithPrivateKeyAndUserId(Map<String, String> sigKeyUserId2Password, String provider, PGPSecretKeyRingCollection pgpSec) throws PGPException{
    List<PGPSecretKeyAndPrivateKeyAndUserId> result = new ArrayList<>(sigKeyUserId2Password.size());
    for (Iterator<?> i = pgpSec.getKeyRings(); i.hasNext(); ) {
        Object data = i.next();
        if (data instanceof PGPSecretKeyRing) {
            PGPSecretKeyRing keyring = (PGPSecretKeyRing) data;
            PGPSecretKey primaryKey = keyring.getSecretKey();
            List<String> useridParts = new ArrayList<>(sigKeyUserId2Password.keySet());
            String[] foundKeyUserIdForUserIdPart = findFirstKeyUserIdContainingOneOfTheParts(useridParts, primaryKey.getPublicKey());
            if (foundKeyUserIdForUserIdPart == null) {
                LOG.debug(""No User ID found in primary key with key ID {} containing one of the parts {}"", primaryKey.getKeyID(), useridParts);
                continue;
            }
            LOG.debug(""User ID {} found in primary key with key ID {} containing one of the parts {}"", foundKeyUserIdForUserIdPart[0], primaryKey.getKeyID(), useridParts);
            for (Iterator<PGPSecretKey> iterKey = keyring.getSecretKeys(); iterKey.hasNext(); ) {
                PGPSecretKey secKey = iterKey.next();
                if (isSigningKey(secKey)) {
                    PGPPrivateKey privateKey = secKey.extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(provider).build(sigKeyUserId2Password.get(foundKeyUserIdForUserIdPart[1]).toCharArray()));
                    if (privateKey != null) {
                        result.add(new PGPSecretKeyAndPrivateKeyAndUserId(secKey, privateKey, foundKeyUserIdForUserIdPart[0]));
                        LOG.debug(""Private key with user ID {} and key ID {} added to the signing keys"", foundKeyUserIdForUserIdPart[0], privateKey.getKeyID());
                    }
                }
            }
        }
    }
    return result;
}",java:S3776,39
" CSVFormat getActiveFormat(){
    CSVFormat answer = format;
    if (commentMarkerDisabled) {
        answer = answer.withCommentMarker(null);
    } else if (commentMarker != null) {
        answer = answer.withCommentMarker(commentMarker);
    }
    if (delimiter != null) {
        answer = answer.withDelimiter(delimiter);
    }
    if (escapeDisabled) {
        answer = answer.withEscape(null);
    } else if (escape != null) {
        answer = answer.withEscape(escape);
    }
    if (headerDisabled) {
        answer = answer.withHeader((String[]) null);
    } else if (header != null) {
        if (header.indexOf(',') != -1) {
            answer = answer.withHeader(header.split("",""));
        } else {
            answer = answer.withHeader(header);
        }
    }
    if (allowMissingColumnNames != null) {
        answer = answer.withAllowMissingColumnNames(allowMissingColumnNames);
    }
    if (ignoreEmptyLines != null) {
        answer = answer.withIgnoreEmptyLines(ignoreEmptyLines);
    }
    if (ignoreSurroundingSpaces != null) {
        answer = answer.withIgnoreSurroundingSpaces(ignoreSurroundingSpaces);
    }
    if (nullStringDisabled) {
        answer = answer.withNullString(null);
    } else if (nullString != null) {
        answer = answer.withNullString(nullString);
    }
    if (quoteDisabled) {
        answer = answer.withQuote(null);
    } else if (quote != null) {
        answer = answer.withQuote(quote);
    }
    if (quoteMode != null) {
        answer = answer.withQuoteMode(quoteMode);
    }
    if (recordSeparatorDisabled) {
        answer = answer.withRecordSeparator(null);
    } else if (recordSeparator != null) {
        answer = answer.withRecordSeparator(recordSeparator);
    }
    if (skipHeaderRecord != null) {
        answer = answer.withSkipHeaderRecord(skipHeaderRecord);
    }
    if (trim != null) {
        answer = answer.withTrim(trim);
    }
    if (ignoreHeaderCase != null) {
        answer = answer.withIgnoreHeaderCase(ignoreHeaderCase);
    }
    if (trailingDelimiter != null) {
        answer = answer.withTrailingDelimiter(trailingDelimiter);
    }
    return answer;
}",java:S3776,39
"public CsvRecordConverter<?> getRecordConverter(){
    return recordConverter;
}",java:S1452,23
"public static String getStringFromInputStream(InputStream in) throws Exception{
    CachedOutputStream bos = new CachedOutputStream();
    IOUtils.copy(in, bos);
    in.close();
    bos.close();
    return bos.getOut().toString();
}",java:S112,4
"protected void setupCommonFactoryProperties(AbstractJAXRSFactoryBean factory){
    if (!getProviders().isEmpty()) {
        factory.setProviders(getProviders());
    }
    if (!getFeatures().isEmpty()) {
        factory.getFeatures().addAll(getFeatures());
    }
    if (publishedEndpointUrl != null) {
        factory.setPublishedEndpointUrl(publishedEndpointUrl);
    }
    if (!interceptorHolder.getInInterceptors().isEmpty()) {
        factory.setInInterceptors(interceptorHolder.getInInterceptors());
    }
    if (!interceptorHolder.getOutInterceptors().isEmpty()) {
        factory.setOutInterceptors(interceptorHolder.getOutInterceptors());
    }
    if (!interceptorHolder.getOutFaultInterceptors().isEmpty()) {
        factory.setOutFaultInterceptors(interceptorHolder.getOutFaultInterceptors());
    }
    if (!interceptorHolder.getInFaultInterceptors().isEmpty()) {
        factory.setInFaultInterceptors(interceptorHolder.getInFaultInterceptors());
    }
    if (getProperties() != null) {
        if (factory.getProperties() != null) {
            factory.getProperties().putAll(getProperties());
        } else {
            factory.setProperties(getProperties());
        }
        LOG.debug(""JAXRS FactoryBean: {} added properties: {}"", factory, getProperties());
    }
    if (isLoggingFeatureEnabled()) {
        LoggingFeature loggingFeature = new LoggingFeature();
        if (getLoggingSizeLimit() > 0) {
            loggingFeature.setLimit(getLoggingSizeLimit());
        }
        factory.getFeatures().add(loggingFeature);
    }
    if (this.isSkipFaultLogging()) {
        if (factory.getProperties() == null) {
            factory.setProperties(new HashMap<>());
        }
        factory.getProperties().put(FaultListener.class.getName(), new NullFaultListener());
    }
}",java:S3776,39
"public List<?> getServiceBeans(){
    return serviceBeans;
}",java:S1452,23
"public List<?> getProviders(){
    return providers;
}",java:S1452,23
"public List<Interceptor<? extends Message>> getOutFaultInterceptors(){
    return interceptorHolder.getOutFaultInterceptors();
}",java:S1452,23
"public List<Interceptor<? extends Message>> getInFaultInterceptors(){
    return interceptorHolder.getInFaultInterceptors();
}",java:S1452,23
"public List<Interceptor<? extends Message>> getInInterceptors(){
    return interceptorHolder.getInInterceptors();
}",java:S1452,23
"public List<Interceptor<? extends Message>> getOutInterceptors(){
    return interceptorHolder.getOutInterceptors();
}",java:S1452,23
"public static MethodSpec fromMethod(Method method){
    method = AnnotationUtils.getAnnotatedMethod(method.getDeclaringClass(), method);
    MethodSpec answer = new MethodSpec();
    Annotation[][] annotations = method.getParameterAnnotations();
    int paramCount = method.getParameterTypes().length;
    answer.paramNames = new String[paramCount];
    answer.multipartNames = new String[paramCount];
    answer.multipartTypes = new String[paramCount];
    for (int i = 0; i < paramCount; i++) {
        for (Annotation a : annotations[i]) {
            if (HEADER_ANNOTATIONS.contains(a.annotationType())) {
                try {
                    answer.paramNames[i] = (String) a.annotationType().getMethod(""value"", NO_PARAMETER_TYPES).invoke(a, NO_PARAMETERS);
                    answer.numberParameters++;
                } catch (Exception e) {
                }
            }
            if (Multipart.class.equals(a.annotationType())) {
                Multipart multipart = (Multipart) a;
                answer.multipart = true;
                answer.multipartNames[i] = multipart.value();
                answer.multipartTypes[i] = multipart.type();
            }
        }
    }
    if (!answer.multipart && answer.numberParameters < method.getParameterTypes().length) {
        for (int i = 0; i < answer.paramNames.length; i++) {
            if (answer.paramNames[i] == null) {
                answer.entityIndex = i;
                break;
            }
        }
    }
    return answer;
}",java:S3776,39
"protected void removeInterceptorWhichIsOutThePhases(List<Interceptor<? extends Message>> interceptors, String[] phaseNames, Set<String> needToBeKept){
    for (Interceptor<? extends Message> i : interceptors) {
        boolean outside = false;
        if (i instanceof PhaseInterceptor) {
            PhaseInterceptor<? extends Message> p = (PhaseInterceptor<? extends Message>) i;
            for (String phaseName : phaseNames) {
                if (p.getPhase().equals(phaseName)) {
                    outside = true;
                    break;
                }
            }
            if (!outside) {
                if (needToBeKept == null) {
                    getLogger().info(""removing the interceptor {}"", p);
                    interceptors.remove(p);
                } else if (!needToBeKept.contains(p.getClass().getName())) {
                    getLogger().info(""removing the interceptor {}"", p);
                    interceptors.remove(p);
                }
            }
        }
    }
}",java:S3776,39
"private void checkFailure(org.apache.camel.Exchange camelExchange, Exchange cxfExchange) throws Fault{
    Throwable t = camelExchange.getException();
    if (t == null) {
        Object body = camelExchange.getMessage().getBody();
        if (body instanceof Throwable) {
            t = (Throwable) body;
        }
    }
    if (t != null) {
        cxfExchange.getInMessage().put(FaultMode.class, FaultMode.UNCHECKED_APPLICATION_FAULT);
        if (t instanceof Fault) {
            cxfExchange.getInMessage().put(FaultMode.class, FaultMode.CHECKED_APPLICATION_FAULT);
            throw (Fault) t;
        } else {
            Fault fault = new Fault(t);
            if (fault.getMessage() == null) {
                fault.setMessage(t.getClass().getSimpleName());
            }
            WebFault faultAnnotation = t.getClass().getAnnotation(WebFault.class);
            Object faultInfo = null;
            try {
                Method method = t.getClass().getMethod(""getFaultInfo"");
                faultInfo = method.invoke(t, new Object[0]);
            } catch (Exception e) {
            }
            if (faultAnnotation != null && faultInfo == null) {
                Element detail = fault.getOrCreateDetail();
                Element faultDetails = detail.getOwnerDocument().createElementNS(faultAnnotation.targetNamespace(), faultAnnotation.name());
                detail.appendChild(faultDetails);
            }
            throw fault;
        }
    }
}",java:S3776,39
"protected void setupServerFactoryBean(ServerFactoryBean sfb, Class<?> cls){
    sfb.setAddress(getAddress());
    sfb.setServiceClass(cls);
    sfb.setInInterceptors(in);
    sfb.setOutInterceptors(out);
    sfb.setOutFaultInterceptors(outFault);
    sfb.setInFaultInterceptors(inFault);
    sfb.setFeatures(features);
    if (schemaLocations != null) {
        sfb.setSchemaLocations(schemaLocations);
    }
    if (bindingConfig != null) {
        sfb.setBindingConfig(bindingConfig);
    }
    if (dataBinding != null) {
        sfb.setDataBinding(dataBinding);
    }
    if (serviceFactoryBean != null) {
        setServiceFactory(sfb, serviceFactoryBean);
    }
    if (sfb instanceof JaxWsServerFactoryBean && handlers != null) {
        ((JaxWsServerFactoryBean) sfb).setHandlers(handlers);
    }
    if (getTransportId() != null) {
        sfb.setTransportId(getTransportId());
    }
    if (getBindingId() != null) {
        sfb.setBindingId(getBindingId());
    }
    if (getWsdlURL() != null) {
        sfb.setWsdlURL(getWsdlURL());
    }
    if (getServiceNameAsQName() != null) {
        sfb.setServiceName(getServiceNameAsQName());
    }
    if (getPortNameAsQName() != null) {
        sfb.setEndpointName(getPortNameAsQName());
    }
    if (!CxfEndpointUtils.hasAnnotation(cls, WebServiceProvider.class)) {
        if (getDataFormat() == DataFormat.PAYLOAD) {
            sfb.getFeatures().add(new PayLoadDataFormatFeature(allowStreaming));
        } else if (getDataFormat().dealias() == DataFormat.CXF_MESSAGE) {
            sfb.getFeatures().add(new CXFMessageDataFormatFeature());
            sfb.setDataBinding(new SourceDataBinding());
        } else if (getDataFormat().dealias() == DataFormat.RAW) {
            RAWDataFormatFeature feature = new RAWDataFormatFeature();
            if (this.getExchangePattern().equals(ExchangePattern.InOnly)) {
                feature.setOneway(true);
            }
            feature.addInIntercepters(getInInterceptors());
            feature.addOutInterceptors(getOutInterceptors());
            sfb.getFeatures().add(feature);
        }
    } else {
        LOG.debug(""Ignore DataFormat mode {} since SEI class is annotated with WebServiceProvider"", getDataFormat());
    }
    if (isLoggingFeatureEnabled()) {
        LoggingFeature loggingFeature = new LoggingFeature();
        if (getLoggingSizeLimit() >= -1) {
            loggingFeature.setLimit(getLoggingSizeLimit());
        }
        sfb.getFeatures().add(loggingFeature);
    }
    if (getDataFormat() == DataFormat.PAYLOAD) {
        sfb.setDataBinding(new HybridSourceDataBinding());
    }
    if (getWrappedStyle() != null && getDataFormat().dealias() != DataFormat.CXF_MESSAGE) {
        setWrapped(sfb, getWrappedStyle());
    }
    if (getProperties() != null) {
        if (sfb.getProperties() != null) {
            sfb.getProperties().putAll(getProperties());
        } else {
            sfb.setProperties(getProperties());
        }
        LOG.debug(""ServerFactoryBean: {} added properties: {}"", sfb, getProperties());
    }
    if (this.isSkipPayloadMessagePartCheck()) {
        if (sfb.getProperties() == null) {
            sfb.setProperties(new HashMap<>());
        }
        sfb.getProperties().put(""soap.no.validate.parts"", Boolean.TRUE);
    }
    if (this.isSkipFaultLogging()) {
        if (sfb.getProperties() == null) {
            sfb.setProperties(new HashMap<>());
        }
        sfb.getProperties().put(FaultListener.class.getName(), new NullFaultListener());
    }
    if (this.getSchemaValidationEnabled() != null) {
        if (sfb.getProperties() == null) {
            sfb.setProperties(new HashMap<>());
        }
        sfb.getProperties().put(Message.SCHEMA_VALIDATION_ENABLED, schemaValidationEnabled);
    }
    sfb.setBus(getBus());
    sfb.setStart(false);
    getNullSafeCxfConfigurer().configure(sfb);
}",java:S3776,39
"protected void setupClientFactoryBean(ClientFactoryBean factoryBean, Class<?> cls){
    if (cls != null) {
        factoryBean.setServiceClass(cls);
    }
    factoryBean.setInInterceptors(in);
    factoryBean.setOutInterceptors(out);
    factoryBean.setOutFaultInterceptors(outFault);
    factoryBean.setInFaultInterceptors(inFault);
    factoryBean.setFeatures(features);
    factoryBean.setTransportId(transportId);
    factoryBean.setBindingId(bindingId);
    if (bindingConfig != null) {
        factoryBean.setBindingConfig(bindingConfig);
    }
    if (dataBinding != null) {
        factoryBean.setDataBinding(dataBinding);
    }
    if (serviceFactoryBean != null) {
        setServiceFactory(factoryBean, serviceFactoryBean);
    }
    factoryBean.setAddress(getAddress());
    if (getWsdlURL() != null) {
        factoryBean.setWsdlURL(getWsdlURL());
    }
    if (getServiceNameAsQName() != null) {
        factoryBean.setServiceName(getServiceNameAsQName());
    }
    if (getPortNameAsQName() != null) {
        factoryBean.setEndpointName(getPortNameAsQName());
    }
    if (getDataFormat().dealias() == DataFormat.RAW) {
        RAWDataFormatFeature feature = new RAWDataFormatFeature();
        feature.addInIntercepters(getInInterceptors());
        feature.addOutInterceptors(getOutInterceptors());
        factoryBean.getFeatures().add(feature);
    } else if (getDataFormat().dealias() == DataFormat.CXF_MESSAGE) {
        factoryBean.getFeatures().add(new CXFMessageDataFormatFeature());
        factoryBean.setDataBinding(new SourceDataBinding());
    } else if (getDataFormat() == DataFormat.PAYLOAD) {
        factoryBean.getFeatures().add(new PayLoadDataFormatFeature(allowStreaming));
        factoryBean.setDataBinding(new HybridSourceDataBinding());
    }
    if (isLoggingFeatureEnabled()) {
        LoggingFeature loggingFeature = new LoggingFeature();
        if (getLoggingSizeLimit() >= -1) {
            loggingFeature.setLimit(getLoggingSizeLimit());
        }
        factoryBean.getFeatures().add(loggingFeature);
    }
    if (getWrappedStyle() != null) {
        setWrapped(factoryBean, getWrappedStyle());
    }
    if (getProperties() != null) {
        if (factoryBean.getProperties() != null) {
            factoryBean.getProperties().putAll(getProperties());
        } else {
            factoryBean.setProperties(getProperties());
        }
        LOG.debug(""ClientFactoryBean: {} added properties: {}"", factoryBean, getProperties());
    }
    if (ObjectHelper.isNotEmpty(username)) {
        AuthorizationPolicy authPolicy = new AuthorizationPolicy();
        authPolicy.setUserName(username);
        authPolicy.setPassword(password);
        if (factoryBean.getProperties() == null) {
            factoryBean.setProperties(new HashMap<>());
        }
        factoryBean.getProperties().put(AuthorizationPolicy.class.getName(), authPolicy);
    }
    if (this.isSkipPayloadMessagePartCheck()) {
        if (factoryBean.getProperties() == null) {
            factoryBean.setProperties(new HashMap<>());
        }
        factoryBean.getProperties().put(""soap.no.validate.parts"", Boolean.TRUE);
    }
    if (this.isSkipFaultLogging()) {
        if (factoryBean.getProperties() == null) {
            factoryBean.setProperties(new HashMap<>());
        }
        factoryBean.getProperties().put(FaultListener.class.getName(), new NullFaultListener());
    }
    if (this.getSchemaValidationEnabled() != null) {
        if (factoryBean.getProperties() == null) {
            factoryBean.setProperties(new HashMap<>());
        }
        factoryBean.getProperties().put(Message.SCHEMA_VALIDATION_ENABLED, schemaValidationEnabled);
    }
    factoryBean.setBus(getBus());
    getNullSafeCxfConfigurer().configure(factoryBean);
}",java:S3776,39
"protected ServerFactoryBean createServerFactoryBean() throws Exception{
    Class<?> cls = null;
    if (getDataFormat() == DataFormat.POJO) {
        ObjectHelper.notNull(getServiceClass(), CxfConstants.SERVICE_CLASS);
    }
    if (getWsdlURL() == null && getServiceClass() == null) {
        if (getDataFormat().equals(DataFormat.PAYLOAD)) {
            setServiceClass(org.apache.camel.component.cxf.jaxws.DefaultPayloadProviderSEI.class.getName());
        }
    }
    if (getServiceClass() != null) {
        cls = getServiceClass();
    }
    ServerFactoryBean answer = null;
    if (cls == null) {
        checkName(portName, "" endpoint/port name"");
        checkName(serviceName, "" service name"");
        answer = new JaxWsServerFactoryBean(new WSDLServiceFactoryBean());
        cls = Provider.class;
    } else if (CxfEndpointUtils.hasWebServiceAnnotation(cls)) {
        answer = new JaxWsServerFactoryBean();
    } else {
        answer = new ServerFactoryBean();
    }
    setupServerFactoryBean(answer, cls);
    return answer;
}",java:S112,4
"public List<Interceptor<? extends Message>> getOutFaultInterceptors(){
    return outFault;
}",java:S1452,23
"public List<Interceptor<? extends Message>> getInFaultInterceptors(){
    return inFault;
}",java:S1452,23
"public List<Interceptor<? extends Message>> getInInterceptors(){
    return in;
}",java:S1452,23
"public List<Interceptor<? extends Message>> getOutInterceptors(){
    return out;
}",java:S1452,23
"public void setServiceFactory(Object serviceFactoryBean){
    this.serviceFactoryBean = serviceFactoryBean;
}",java:S4144,40
"private void checkParameterSize(CxfEndpoint endpoint, Exchange exchange, Object[] parameters){
    BindingOperationInfo boi = getBindingOperationInfo(exchange);
    if (boi == null) {
        throw new RuntimeCamelException(""Can't find the binding operation information from camel exchange"");
    }
    if (!endpoint.isWrapped()) {
        if (boi.isUnwrappedCapable()) {
            boi = boi.getUnwrappedOperation();
        }
    }
    int expectMessagePartsSize = boi.getInput().getMessageParts().size();
    if (parameters.length < expectMessagePartsSize) {
        throw new IllegalArgumentException(""Get the wrong parameter size to invoke the out service, Expect size "" + expectMessagePartsSize + "", Parameter size "" + parameters.length + "". Please check if the message body matches the CXFEndpoint POJO Dataformat request."");
    }
    if (parameters.length > expectMessagePartsSize) {
        int holdersSize = 0;
        for (Object parameter : parameters) {
            if (parameter instanceof Holder) {
                holdersSize++;
            }
        }
        int soapHeadersSize = 0;
        BindingMessageInfo bmi = boi.getInput();
        if (bmi != null) {
            List<SoapHeaderInfo> headers = bmi.getExtensors(SoapHeaderInfo.class);
            if (headers != null) {
                soapHeadersSize = headers.size();
            }
        }
        if (holdersSize + expectMessagePartsSize + soapHeadersSize < parameters.length) {
            throw new IllegalArgumentException(""Get the wrong parameter size to invoke the out service, Expect size "" + (expectMessagePartsSize + holdersSize + soapHeadersSize) + "", Parameter size "" + parameters.length + "". Please check if the message body matches the CXFEndpoint POJO Dataformat request."");
        }
    }
}",java:S3776,39
"private Object[] getParams(CxfEndpoint endpoint, Exchange exchange) throws org.apache.camel.InvalidPayloadException{
    Object[] params = null;
    if (endpoint.getDataFormat() == DataFormat.POJO) {
        Object body = exchange.getIn().getBody();
        if (body == null) {
            return new Object[0];
        }
        if (body instanceof Object[]) {
            params = (Object[]) body;
        } else if (body instanceof List) {
            params = ((List<?>) body).toArray();
        } else {
            Iterator<?> it = exchange.getIn().getBody(Iterator.class);
            if (it != null && it.hasNext()) {
                List<?> list = exchange.getContext().getTypeConverter().convertTo(List.class, it);
                if (list != null) {
                    params = list.toArray();
                }
            }
            if (params == null) {
                params = new Object[1];
                params[0] = exchange.getIn().getBody();
            }
        }
        checkParameterSize(endpoint, exchange, params);
    } else if (endpoint.getDataFormat() == DataFormat.PAYLOAD) {
        params = new Object[1];
        params[0] = exchange.getIn().getMandatoryBody(CxfPayload.class);
    } else if (endpoint.getDataFormat().dealias() == DataFormat.RAW) {
        params = new Object[1];
        params[0] = exchange.getIn().getMandatoryBody(InputStream.class);
    } else if (endpoint.getDataFormat().dealias() == DataFormat.CXF_MESSAGE) {
        params = new Object[1];
        params[0] = exchange.getIn().getBody();
    }
    if (LOG.isTraceEnabled()) {
        if (params != null) {
            for (int i = 0; i < params.length; i++) {
                LOG.trace(""params[{}] = {}"", i, params[i]);
            }
        }
    }
    return params;
}",java:S3776,39
"private void walkXmlTree(Node xmlNode, RestConfigurationDetails detail){
    if (""restConfiguration"".equals(xmlNode.getNodeName())) {
        String lineNumber = (String) xmlNode.getUserData(XmlLineNumberParser.LINE_NUMBER);
        String lineNumberEnd = (String) xmlNode.getUserData(XmlLineNumberParser.LINE_NUMBER_END);
        detail.setLineNumber(lineNumber);
        detail.setLineNumberEnd(lineNumberEnd);
        NamedNodeMap map = xmlNode.getAttributes();
        detail.setComponent(extractAttribute(map, ""component""));
        detail.setApiComponent(extractAttribute(map, ""apiComponent""));
        detail.setProducerComponent(extractAttribute(map, ""producerComponent""));
        detail.setScheme(extractAttribute(map, ""scheme""));
        detail.setHost(extractAttribute(map, ""host""));
        detail.setApiHost(extractAttribute(map, ""apiHost""));
        detail.setPort(extractAttribute(map, ""port""));
        detail.setProducerApiDoc(extractAttribute(map, ""producerApiDoc""));
        detail.setContextPath(extractAttribute(map, ""contextPath""));
        detail.setApiContextPath(extractAttribute(map, ""apiContextPath""));
        detail.setApiVendorExtension(extractAttribute(map, ""apiVendorExtension""));
        detail.setHostNameResolver(extractAttribute(map, ""hostNameResolver""));
        detail.setBindingMode(extractAttribute(map, ""bindingMode""));
        detail.setSkipBindingOnErrorCode(extractAttribute(map, ""skipBindingOnErrorCode""));
        detail.setClientRequestValidation(extractAttribute(map, ""clientRequestValidation""));
        detail.setEnableCORS(extractAttribute(map, ""enableCORS""));
        detail.setJsonDataFormat(extractAttribute(map, ""jsonDataFormat""));
        detail.setXmlDataFormat(extractAttribute(map, ""xmlDataFormat""));
    }
    if (""componentProperty"".equals(xmlNode.getNodeName()) && xmlNode.getParentNode() != null && ""restConfiguration"".equals(xmlNode.getParentNode().getNodeName())) {
        NamedNodeMap map = xmlNode.getAttributes();
        String key = extractAttribute(map, ""key"");
        String value = extractAttribute(map, ""value"");
        if (key != null && value != null) {
            detail.addComponentProperty(key, value);
        }
    } else if (""endpointProperty"".equals(xmlNode.getNodeName()) && xmlNode.getParentNode() != null && ""restConfiguration"".equals(xmlNode.getParentNode().getNodeName())) {
        NamedNodeMap map = xmlNode.getAttributes();
        String key = extractAttribute(map, ""key"");
        String value = extractAttribute(map, ""value"");
        if (key != null && value != null) {
            detail.addEndpointProperty(key, value);
        }
    } else if (""consumerProperty"".equals(xmlNode.getNodeName()) && xmlNode.getParentNode() != null && ""restConfiguration"".equals(xmlNode.getParentNode().getNodeName())) {
        NamedNodeMap map = xmlNode.getAttributes();
        String key = extractAttribute(map, ""key"");
        String value = extractAttribute(map, ""value"");
        if (key != null && value != null) {
            detail.addConsumerProperty(key, value);
        }
    } else if (""dataFormatProperty"".equals(xmlNode.getNodeName()) && xmlNode.getParentNode() != null && ""restConfiguration"".equals(xmlNode.getParentNode().getNodeName())) {
        NamedNodeMap map = xmlNode.getAttributes();
        String key = extractAttribute(map, ""key"");
        String value = extractAttribute(map, ""value"");
        if (key != null && value != null) {
            detail.addDataFormatProperty(key, value);
        }
    } else if (""apiProperty"".equals(xmlNode.getNodeName()) && xmlNode.getParentNode() != null && ""restConfiguration"".equals(xmlNode.getParentNode().getNodeName())) {
        NamedNodeMap map = xmlNode.getAttributes();
        String key = extractAttribute(map, ""key"");
        String value = extractAttribute(map, ""value"");
        if (key != null && value != null) {
            detail.addApiProperty(key, value);
        }
    } else if (""corsHeaders"".equals(xmlNode.getNodeName()) && xmlNode.getParentNode() != null && ""restConfiguration"".equals(xmlNode.getParentNode().getNodeName())) {
        NamedNodeMap map = xmlNode.getAttributes();
        String key = extractAttribute(map, ""key"");
        String value = extractAttribute(map, ""value"");
        if (key != null && value != null) {
            detail.addCorsHeader(key, value);
        }
    }
    NodeList children = xmlNode.getChildNodes();
    for (int i = 0; i < children.getLength(); i++) {
        Node child = children.item(i);
        if (child.getNodeType() == Node.ELEMENT_NODE) {
            walkXmlTree(child, detail);
        }
    }
}",java:S3776,39
"protected void propagateHeadersFromCxfToCamel(Message cxfMessage, org.apache.camel.Message camelMessage, Exchange exchange){
    Map<String, List<String>> cxfHeaders = CastUtils.cast((Map<?, ?>) cxfMessage.get(CxfConstants.PROTOCOL_HEADERS));
    Map<String, Object> camelHeaders = camelMessage.getHeaders();
    camelHeaders.put(CxfConstants.CAMEL_CXF_MESSAGE, cxfMessage);
    CxfHeaderHelper.copyHttpHeadersFromCxfToCamel(headerFilterStrategy, cxfMessage, camelMessage, exchange);
    if (cxfHeaders != null) {
        for (Map.Entry<String, List<String>> entry : cxfHeaders.entrySet()) {
            if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange)) {
                if (""Content-Type"".compareToIgnoreCase(entry.getKey()) == 0 && entry.getValue().get(0) != null && entry.getValue().get(0).startsWith(""multipart/related"")) {
                    DataFormat dataFormat = exchange.getProperty(CxfConstants.DATA_FORMAT_PROPERTY, DataFormat.class);
                    if (dataFormat.equals(DataFormat.RAW)) {
                        camelHeaders.put(entry.getKey(), getContentTypeString(entry.getValue()));
                    } else {
                        String contentType = replaceMultiPartContentType(entry.getValue().get(0));
                        LOG.trace(""Find the multi-part Conent-Type, and replace it with {}"", contentType);
                        camelHeaders.put(entry.getKey(), contentType);
                    }
                } else if (SoapBindingConstants.SOAP_ACTION.compareToIgnoreCase(entry.getKey()) == 0 && entry.getValue().get(0) != null) {
                    String soapAction = entry.getValue().get(0);
                    soapAction = StringHelper.removeLeadingAndEndingQuotes(soapAction);
                    camelHeaders.put(SoapBindingConstants.SOAP_ACTION, soapAction);
                } else {
                    LOG.trace(""Populate header from CXF header={} value={}"", entry.getKey(), entry.getValue());
                    List<String> values = entry.getValue();
                    Object evalue;
                    if (values.size() > 1) {
                        final boolean headersMerged = exchange.getProperty(CxfConstants.CAMEL_CXF_PROTOCOL_HEADERS_MERGED, Boolean.FALSE, Boolean.class);
                        if (headersMerged) {
                            StringBuilder sb = new StringBuilder();
                            for (Iterator<String> it = values.iterator(); it.hasNext(); ) {
                                sb.append(it.next());
                                if (it.hasNext()) {
                                    sb.append(',').append(' ');
                                }
                            }
                            evalue = sb.toString();
                        } else {
                            evalue = values;
                        }
                    } else if (values.size() == 1) {
                        evalue = values.get(0);
                    } else {
                        evalue = null;
                    }
                    if (evalue != null) {
                        camelHeaders.put(entry.getKey(), evalue);
                    }
                }
            }
        }
    }
    String key = Header.HEADER_LIST;
    Object value = cxfMessage.get(key);
    if (value != null) {
        if (!headerFilterStrategy.applyFilterToExternalHeaders(key, value, exchange)) {
            camelHeaders.put(key, value);
            LOG.trace(""Populate header from CXF header={} value={}"", key, value);
        } else {
            ((List<?>) value).clear();
        }
    }
    String soapAction = (String) camelHeaders.get(SoapBindingConstants.SOAP_ACTION);
    if (ObjectHelper.isEmpty(soapAction) || ""\""\"""".equals(soapAction)) {
        camelHeaders.remove(SoapBindingConstants.SOAP_ACTION);
    }
    soapAction = (String) cxfMessage.get(SoapBindingConstants.SOAP_ACTION);
    if (soapAction != null) {
        if (!headerFilterStrategy.applyFilterToExternalHeaders(SoapBindingConstants.SOAP_ACTION, soapAction, exchange)) {
            camelHeaders.put(SoapBindingConstants.SOAP_ACTION, soapAction);
            LOG.trace(""Populate header from CXF header={} value={}"", SoapBindingConstants.SOAP_ACTION, soapAction);
        }
    }
}",java:S3776,39
"protected static Object getContentFromCxf(Message message, DataFormat dataFormat, String encoding){
    Set<Class<?>> contentFormats = message.getContentFormats();
    Object answer = null;
    if (contentFormats != null) {
        if (LOG.isTraceEnabled()) {
            for (Class<?> contentFormat : contentFormats) {
                LOG.trace(""Content format={} value={}"", contentFormat, message.getContent(contentFormat));
            }
        }
        if (dataFormat == DataFormat.POJO) {
            List<?> pojoMessageList = message.getContent(List.class);
            if (pojoMessageList != null && !pojoMessageList.isEmpty()) {
                answer = pojoMessageList;
            }
            if (answer == null) {
                answer = message.getContent(Object.class);
                if (answer != null) {
                    answer = new MessageContentsList(answer);
                }
            }
        } else if (dataFormat == DataFormat.PAYLOAD) {
            List<SoapHeader> headers = CastUtils.cast((List<?>) message.get(Header.HEADER_LIST));
            Map<String, String> nsMap = new HashMap<>();
            answer = new CxfPayload<>(headers, getPayloadBodyElements(message, nsMap), nsMap);
        } else if (dataFormat.dealias() == DataFormat.RAW) {
            answer = message.getContent(InputStream.class);
            if (answer == null) {
                answer = message.getContent(Reader.class);
                if (answer != null) {
                    if (encoding == null) {
                        encoding = ""UTF-8"";
                    }
                    LOG.trace(""file encoding is = {}"", encoding);
                    answer = new ReaderInputStream((Reader) answer, Charset.forName(encoding));
                }
            }
        } else if (dataFormat.dealias() == DataFormat.CXF_MESSAGE && message.getContent(List.class) != null) {
            answer = message.getContent(List.class).get(0);
        }
        LOG.trace(""Extracted body from CXF message = {}"", answer);
    }
    return answer;
}",java:S3776,39
"protected static List<Source> getPayloadBodyElements(Message message, Map<String, String> nsMap){
    Map<String, String> bodyNC = CastUtils.cast((Map<?, ?>) message.get(""soap.body.ns.context""));
    if (bodyNC != null) {
        nsMap.putAll(bodyNC);
    } else {
        Document soapEnv = (Document) message.getContent(Node.class);
        if (soapEnv != null) {
            NamedNodeMap attrs = soapEnv.getFirstChild().getAttributes();
            for (int i = 0; i < attrs.getLength(); i++) {
                Node node = attrs.item(i);
                if (!node.getNodeValue().equals(Soap11.SOAP_NAMESPACE) && !node.getNodeValue().equals(Soap12.SOAP_NAMESPACE)) {
                    nsMap.put(node.getLocalName(), node.getNodeValue());
                }
            }
        }
    }
    MessageContentsList inObjects = MessageContentsList.getContentsList(message);
    if (inObjects == null) {
        return new ArrayList<>(0);
    }
    org.apache.cxf.message.Exchange exchange = message.getExchange();
    BindingOperationInfo boi = exchange.getBindingOperationInfo();
    OperationInfo op = boi.getOperationInfo();
    if (boi.isUnwrapped()) {
        op = boi.getWrappedOperation().getOperationInfo();
    }
    List<MessagePartInfo> partInfos = null;
    boolean client = Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE));
    if (client) {
        partInfos = op.getOutput().getMessageParts();
    } else {
        partInfos = op.getInput().getMessageParts();
    }
    List<Source> answer = new ArrayList<>();
    for (MessagePartInfo partInfo : partInfos) {
        if (!inObjects.hasValue(partInfo)) {
            continue;
        }
        Object part = inObjects.get(partInfo);
        if (part instanceof Holder) {
            part = ((Holder<?>) part).value;
        }
        if (part instanceof Source) {
            Element element = null;
            if (part instanceof DOMSource) {
                element = getFirstElement(((DOMSource) part).getNode());
            }
            if (element != null) {
                addNamespace(element, nsMap);
                answer.add(new DOMSource(element));
            } else {
                answer.add((Source) part);
            }
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Extract body element {}"", element == null ? ""null"" : getXMLString(element));
            }
        } else if (part instanceof Element) {
            addNamespace((Element) part, nsMap);
            answer.add(new DOMSource((Element) part));
        } else {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Unhandled part type '{}'"", part.getClass());
            }
        }
    }
    return answer;
}",java:S3776,39
"private void walkXmlTree(Node xmlNode, RestServiceDetails detail){
    if (""rest"".equals(xmlNode.getNodeName())) {
        String lineNumber = (String) xmlNode.getUserData(XmlLineNumberParser.LINE_NUMBER);
        String lineNumberEnd = (String) xmlNode.getUserData(XmlLineNumberParser.LINE_NUMBER_END);
        detail.setLineNumber(lineNumber);
        detail.setLineNumberEnd(lineNumberEnd);
        extractAttributes(xmlNode, detail);
    }
    if (isParentRest(xmlNode)) {
        if (""delete"".equals(xmlNode.getNodeName())) {
            RestVerbDetails verb = new RestVerbDetails();
            verb.setMethod(""delete"");
            detail.addVerb(verb);
            extractAttributes(xmlNode, verb);
        } else if (""get"".equals(xmlNode.getNodeName())) {
            RestVerbDetails verb = new RestVerbDetails();
            verb.setMethod(""get"");
            detail.addVerb(verb);
            extractAttributes(xmlNode, verb);
        } else if (""head"".equals(xmlNode.getNodeName())) {
            RestVerbDetails verb = new RestVerbDetails();
            verb.setMethod(""head"");
            detail.addVerb(verb);
            extractAttributes(xmlNode, verb);
        } else if (""patch"".equals(xmlNode.getNodeName())) {
            RestVerbDetails verb = new RestVerbDetails();
            verb.setMethod(""patch"");
            detail.addVerb(verb);
            extractAttributes(xmlNode, verb);
        } else if (""post"".equals(xmlNode.getNodeName())) {
            RestVerbDetails verb = new RestVerbDetails();
            verb.setMethod(""post"");
            detail.addVerb(verb);
            extractAttributes(xmlNode, verb);
        } else if (""put"".equals(xmlNode.getNodeName())) {
            RestVerbDetails verb = new RestVerbDetails();
            verb.setMethod(""put"");
            detail.addVerb(verb);
            extractAttributes(xmlNode, verb);
        }
        if (""description"".equals(xmlNode.getNodeName())) {
            String value = xmlNode.getTextContent();
            RestVerbDetails verb = getLastVerb(detail);
            if (verb != null) {
                verb.setDescription(value);
            } else {
                detail.setDescription(value);
            }
        } else if (""to"".equals(xmlNode.getNodeName())) {
            NamedNodeMap map = xmlNode.getAttributes();
            String uri = extractAttribute(map, ""uri"");
            RestVerbDetails verb = getLastVerb(detail);
            if (verb != null) {
                verb.setTo(uri);
            }
        }
    }
    NodeList children = xmlNode.getChildNodes();
    for (int i = 0; i < children.getLength(); i++) {
        Node child = children.item(i);
        if (child.getNodeType() == Node.ELEMENT_NODE) {
            walkXmlTree(child, detail);
        }
    }
}",java:S3776,39
"@Deprecated
public ProducerTemplate getCamelTemplate(){
    if (camelTemplate == null) {
        camelTemplate = getCamelContext().createProducerTemplate();
    }
    return camelTemplate;
}",java:S6355,48
"@Deprecated
public void setCamelTemplate(ProducerTemplate template){
    camelTemplate = template;
}",java:S6355,48
"private void walkXmlTree(CamelNodeDetailsFactory nodeFactory, Node node, CamelNodeDetails parent){
    CamelNodeDetails newNode = null;
    String name = node.getNodeName();
    String prefix = node.getPrefix();
    if (prefix != null && name.startsWith(prefix + "":"")) {
        name = name.substring(prefix.length() + 1);
    }
    boolean isRoute = ""route"".equals(name) || ""from"".equals(name);
    boolean isEip = camelCatalog.findModelNames().contains(name) && (hasInput(name) || hasOutput(name));
    boolean isWhenOrOtherwise = ""when"".equals(name) || ""otherwise"".equals(name);
    if (isRoute || isEip) {
        if (!""route"".equals(name) && !isWhenOrOtherwise) {
            String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);
            String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);
            newNode = nodeFactory.newNode(parent, name);
            newNode.setRouteId(parent.getRouteId());
            newNode.setFileName(parent.getFileName());
            newNode.setLineNumber(lineNumber);
            newNode.setLineNumberEnd(lineNumberEnd);
            parent.addOutput(newNode);
        }
    }
    NodeList children = node.getChildNodes();
    for (int i = 0; i < children.getLength(); i++) {
        Node child = children.item(i);
        if (child.getNodeType() == Node.ELEMENT_NODE) {
            walkXmlTree(nodeFactory, child, newNode != null ? newNode : parent);
        }
    }
}",java:S3776,39
"public final void unregisterFactory(){
    if (null == bus) {
        return;
    }
    DestinationFactoryManager dfm = bus.getExtension(DestinationFactoryManager.class);
    if (null != dfm && getTransportIds() != null) {
        for (String ns : getTransportIds()) {
            try {
                if (dfm.getDestinationFactory(ns) == this) {
                    dfm.deregisterDestinationFactory(ns);
                }
            } catch (BusException e) {
            }
        }
    }
    ConduitInitiatorManager cim = bus.getExtension(ConduitInitiatorManager.class);
    if (cim != null && getTransportIds() != null) {
        for (String ns : getTransportIds()) {
            try {
                if (cim.getConduitInitiator(ns) == this) {
                    cim.deregisterConduitInitiator(ns);
                }
            } catch (BusException e) {
            }
        }
    }
}",java:S3776,39
"public static List<CoverageData> parseDumpRouteCoverageByRouteId(String directory, String routeId) throws Exception{
    List<CoverageData> answer = new ArrayList<>();
    if (routeId == null) {
        return answer;
    }
    File[] files = new File(directory).listFiles(f -> f.getName().endsWith("".xml""));
    if (files == null) {
        return answer;
    }
    CamelCatalog catalog = new DefaultCamelCatalog(true);
    for (File file : files) {
        try (FileInputStream fis = new FileInputStream(file)) {
            Document dom = XmlLineNumberParser.parseXml(fis);
            NodeList routes = dom.getElementsByTagName(""route"");
            for (int i = 0; i < routes.getLength(); i++) {
                Node route = routes.item(i);
                String id = route.getAttributes().getNamedItem(""id"").getNodeValue();
                String customId = route.getAttributes().getNamedItem(""customId"") != null ? route.getAttributes().getNamedItem(""customId"").getNodeValue() : ""false"";
                if (""true"".equals(customId) && routeId.equals(id)) {
                    AtomicInteger counter = new AtomicInteger();
                    parseRouteData(catalog, route, answer, counter);
                }
            }
        }
    }
    return answer;
}",java:S112,4
"private Document<?> doEvaluate(Exchange exchange){
    MediaType bodyMT = bodyMediaType;
    if (bodyMT == null && !expression.startsWith(Header.DATASONNET_HEADER)) {
        String typeHeader = exchange.getProperty(DatasonnetConstants.BODY_MEDIATYPE, exchange.getIn().getHeader(Exchange.CONTENT_TYPE), String.class);
        if (typeHeader != null) {
            bodyMT = MediaType.valueOf(typeHeader);
        }
    }
    Document<?> body;
    String bodyAsString = MessageHelper.extractBodyAsString(exchange.getMessage());
    if (exchange.getMessage().getBody() instanceof Document) {
        body = (Document<?>) exchange.getMessage().getBody();
    } else if (exchange.getMessage().getBody() == null || """".equals(bodyAsString)) {
        body = new DefaultDocument<>("""", MediaTypes.APPLICATION_JAVA);
    } else if (MediaTypes.APPLICATION_JAVA.equalsTypeAndSubtype(bodyMT) || bodyMT == null) {
        body = new DefaultDocument<>(exchange.getMessage().getBody());
    } else {
        body = new DefaultDocument<>(bodyAsString, bodyMT);
    }
    Mapper mapper = language.lookup(expression).orElseThrow(() -> new IllegalStateException(""Datasonnet expression not initialized""));
    MediaType outMT = outputMediaType;
    if (outMT == null) {
        String typeHeader = exchange.getProperty(DatasonnetConstants.OUTPUT_MEDIATYPE, exchange.getIn().getHeader(DatasonnetConstants.OUTPUT_MEDIATYPE), String.class);
        if (typeHeader != null) {
            outMT = MediaType.valueOf(typeHeader);
        } else {
            outMT = MediaTypes.ANY;
        }
    }
    Map<String, Document<?>> inputs = Collections.singletonMap(""body"", body);
    if (resultType == null || resultType.equals(Document.class)) {
        return mapper.transform(body, inputs, outMT, Object.class);
    } else {
        return mapper.transform(body, inputs, outMT, resultType);
    }
}",java:S3776,39
"public Exchange createDbzExchange(DebeziumConsumer consumer, final SourceRecord record){
    final Exchange exchange;
    if (consumer != null) {
        exchange = consumer.createExchange(false);
    } else {
        exchange = super.createExchange();
    }
    final Message message = exchange.getIn();
    final Schema valueSchema = record.valueSchema();
    final Object value = record.value();
    final Map<String, Object> sourceMetadata = extractSourceMetadataValueFromValueStruct(valueSchema, value);
    final Object operation = extractValueFromValueStruct(valueSchema, value, Envelope.FieldName.OPERATION);
    final Object before = extractValueFromValueStruct(valueSchema, value, Envelope.FieldName.BEFORE);
    final Object body = extractBodyValueFromValueStruct(valueSchema, value);
    final Object timestamp = extractValueFromValueStruct(valueSchema, value, Envelope.FieldName.TIMESTAMP);
    final Object ddl = extractValueFromValueStruct(valueSchema, value, HistoryRecord.Fields.DDL_STATEMENTS);
    message.setHeader(DebeziumConstants.HEADER_IDENTIFIER, record.topic());
    message.setHeader(DebeziumConstants.HEADER_KEY, record.key());
    message.setHeader(DebeziumConstants.HEADER_SOURCE_METADATA, sourceMetadata);
    message.setHeader(DebeziumConstants.HEADER_OPERATION, operation);
    message.setHeader(DebeziumConstants.HEADER_BEFORE, before);
    message.setHeader(DebeziumConstants.HEADER_TIMESTAMP, timestamp);
    message.setHeader(DebeziumConstants.HEADER_DDL_SQL, ddl);
    message.setHeader(Exchange.MESSAGE_TIMESTAMP, timestamp);
    message.setBody(body);
    return exchange;
}",java:S6213,47
"private void setClassFields(){
    javaClass.addField().setName(""LABEL_NAME"").setFinal(true).setStatic(true).setPrivate().setType(String.class).setLiteralInitializer(String.format(""\""consumer,%s\"""", connectorName.toLowerCase()));
    dbzConfigFields.forEach((fieldName, fieldConfig) -> {
        if (!isFieldInternalOrDeprecated(fieldConfig)) {
            final org.apache.camel.tooling.util.srcgen.Field field = javaClass.addField().setName(fieldConfig.getFieldName()).setType(fieldConfig.getRawType()).setPrivate();
            if (!fieldConfig.getRawName().equals(""database.server.id"")) {
                field.setLiteralInitializer(fieldConfig.getDefaultValueAsString());
            }
            final Annotation annotation = field.addAnnotation(UriParam.class).setLiteralValue(""label"", ""LABEL_NAME"");
            if (fieldConfig.getDefaultValue() != null && !fieldConfig.getRawName().equals(""database.server.id"")) {
                if (fieldConfig.isTimeField()) {
                    final long defaultValueAsLong = Long.parseLong(fieldConfig.getDefaultValueAsString());
                    annotation.setLiteralValue(""defaultValue"", String.format(""\""%s\"""", ConnectorConfigGeneratorUtils.toTimeAsString(defaultValueAsLong)));
                } else {
                    annotation.setLiteralValue(""defaultValue"", fieldConfig.getDefaultValueAsStringLiteral());
                }
            }
            if (fieldConfig.isTimeField()) {
                annotation.setLiteralValue(""javaType"", ""\""java.time.Duration\"""");
            }
            if (fieldConfig.isRequired()) {
                field.addAnnotation(Metadata.class).setLiteralValue(""required"", ""true"");
            }
        }
    });
}",java:S3776,39
"private static void parseRouteData(CamelCatalog catalog, Node node, List<CoverageData> data, AtomicInteger counter){
    String key = node.getNodeName();
    boolean valid = catalog.findModelNames().contains(key);
    if (!valid) {
        return;
    }
    boolean skip = ""onException"".equals(key) || ""onCompletion"".equals(key) || ""intercept"".equals(key) || ""interceptFrom"".equals(key) || ""interceptSendToEndpoint"".equals(key);
    if (skip) {
        return;
    }
    if (!""route"".equals(key) && !""policy"".equals(key) && !""transacted"".equals(key)) {
        int count = 0;
        Node total = node.getAttributes().getNamedItem(""exchangesTotal"");
        if (total != null) {
            count = Integer.parseInt(total.getNodeValue());
        }
        CoverageData holder = data.size() > counter.get() ? data.get(counter.get()) : null;
        if (holder != null && holder.getNode().equals(key)) {
            count += holder.getCount();
        }
        if (holder == null) {
            data.add(counter.get(), new CoverageData(key, count));
        } else {
            data.set(counter.get(), new CoverageData(key, count));
        }
        counter.incrementAndGet();
    }
    NodeList children = node.getChildNodes();
    if (children != null) {
        for (int i = 0; i < children.getLength(); i++) {
            Node child = children.item(i);
            if (child instanceof Element) {
                parseRouteData(catalog, child, data, counter);
            }
        }
    }
}",java:S3776,39
"protected GetOperation newGetOperation(String path, String fields, String filter, RootJunctionEnum rootJunction, Map<String, Object> queryParams){
    GetOperation getOperation = dhis2Client.get(path);
    if (fields != null) {
        getOperation.withFields(fields);
    }
    if (filter != null) {
        getOperation.withFilter(filter);
    }
    if (rootJunction != null) {
        if (rootJunction.equals(RootJunctionEnum.AND)) {
            getOperation.withAndRootJunction();
        } else {
            getOperation.withOrRootJunction();
        }
    }
    if (queryParams != null) {
        for (Map.Entry<String, Object> queryParam : queryParams.entrySet()) {
            if (queryParam.getValue() instanceof List) {
                for (String queryValue : (List<String>) queryParam.getValue()) {
                    getOperation.withParameter(queryParam.getKey(), queryValue);
                }
            } else {
                getOperation.withParameter(queryParam.getKey(), (String) queryParam.getValue());
            }
        }
    }
    return getOperation;
}",java:S3776,39
"public InputStream collection(String path, String arrayName, Boolean paging, String fields, String filter, RootJunctionEnum rootJunction, Map<String, Object> queryParams){
    GetOperation getOperation = newGetOperation(path, fields, filter, rootJunction, queryParams);
    IterableDhis2Response iteratorDhis2Response;
    if (paging == null || paging) {
        iteratorDhis2Response = getOperation.withPaging().transfer();
    } else {
        iteratorDhis2Response = getOperation.withoutPaging().transfer();
    }
    Iterable<Map> iterable = iteratorDhis2Response.returnAs(Map.class, arrayName);
    return new InputStreamIterator(new ItemTypeConverter(dhis2Client), iterable.iterator());
}",java:S107,1
"private static DefaultHandler getDefaultHandler(String rootNames, String forceNamespace, Document doc, Stack<Element> elementStack, StringBuilder textBuffer){
    return new DefaultHandler() {

        private Locator locator;

        private boolean found;

        private final Map<String, String> localNs = new HashMap<>();

        private final Map<String, String> anonymousNs = new LinkedHashMap<>();

        @Override
        public void setDocumentLocator(final Locator locator) {
            this.locator = locator;
            this.found = rootNames == null;
        }

        private boolean isRootName(String qName) {
            for (String root : rootNames.split("","")) {
                if (qName.equals(root)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public void startElement(final String uri, final String localName, final String qName, final Attributes attributes) {
            addTextIfNeeded();
            if (rootNames != null && !found) {
                if (isRootName(qName)) {
                    found = true;
                }
            }
            if (found) {
                Element el;
                if (forceNamespace != null) {
                    el = doc.createElementNS(forceNamespace, qName);
                } else {
                    String ns = null;
                    int pos = qName.indexOf(':');
                    if (pos > 0) {
                        if (attributes != null) {
                            String prefix = qName.substring(0, pos);
                            ns = attributes.getValue(""xmlns:"" + prefix);
                            if (ns != null) {
                                localNs.put(prefix, ns);
                            } else {
                                ns = localNs.get(prefix);
                            }
                        }
                    } else {
                        if (attributes != null) {
                            ns = attributes.getValue(""xmlns"");
                            if (ns != null) {
                                anonymousNs.put(qName, ns);
                            } else if (!anonymousNs.isEmpty()) {
                                List<String> values = new ArrayList<>(anonymousNs.values());
                                ns = values.get(values.size() - 1);
                            }
                        }
                    }
                    if (ns != null) {
                        el = doc.createElementNS(ns, qName);
                    } else {
                        el = doc.createElement(qName);
                    }
                }
                if (attributes != null) {
                    for (int i = 0; i < attributes.getLength(); i++) {
                        el.setAttribute(attributes.getQName(i), attributes.getValue(i));
                    }
                }
                String ln = String.valueOf(this.locator.getLineNumber());
                String cn = String.valueOf(this.locator.getColumnNumber());
                el.setUserData(LINE_NUMBER, ln, null);
                el.setUserData(COLUMN_NUMBER, cn, null);
                elementStack.push(el);
            }
        }

        @Override
        public void endElement(final String uri, final String localName, final String qName) {
            if (!found) {
                return;
            }
            addTextIfNeeded();
            final Element closedEl = elementStack.isEmpty() ? null : elementStack.pop();
            if (closedEl != null) {
                if (elementStack.isEmpty()) {
                    doc.appendChild(closedEl);
                } else {
                    final Element parentEl = elementStack.peek();
                    parentEl.appendChild(closedEl);
                }
                String ln = String.valueOf(this.locator.getLineNumber());
                String cn = String.valueOf(this.locator.getColumnNumber());
                closedEl.setUserData(LINE_NUMBER_END, ln, null);
                closedEl.setUserData(COLUMN_NUMBER_END, cn, null);
            }
            anonymousNs.remove(qName);
        }

        @Override
        public void characters(final char[] ch, final int start, final int length) {
            textBuffer.append(ch, start, length);
        }

        @Override
        public InputSource resolveEntity(String publicId, String systemId) {
            return new InputSource(new StringReader(""""));
        }

        private void addTextIfNeeded() {
            if (textBuffer.length() > 0) {
                final Element el = elementStack.isEmpty() ? null : elementStack.peek();
                if (el != null) {
                    final Node textNode = doc.createTextNode(textBuffer.toString());
                    el.appendChild(textNode);
                    textBuffer.delete(0, textBuffer.length());
                }
            }
        }
    };
}",java:S3776,39
"@Test
public void testAnalytics(){
    final Map<String, Object> headers = new HashMap<String, Object>();
    headers.put(""CamelDhis2.skipAggregate"", false);
    headers.put(""CamelDhis2.skipEvents"", false);
    headers.put(""CamelDhis2.lastYears"", 2);
    headers.put(""CamelDhis2.interval"", 10000);
    Assertions.assertDoesNotThrow(() -> requestBodyAndHeaders(""direct://ANALYTICS"", null, headers));
}",java:S2699,32
"@Deprecated
public DirectConsumer getConsumer() throws InterruptedException{
    return component.getConsumer(key, block, timeout);
}",java:S6355,48
"private void process(final SynchronizedExchange synchronizedExchange){
    try {
        Exchange exchange = synchronizedExchange.getExchange();
        final boolean ignore = exchange.hasProperties() && exchange.getProperties().containsKey(DisruptorEndpoint.DISRUPTOR_IGNORE_EXCHANGE);
        if (ignore) {
            LOGGER.trace(""Ignoring exchange {}"", exchange);
            return;
        }
        final Exchange result = prepareExchange(exchange);
        result.getExchangeExtension().addOnCompletion(new Synchronization() {

            @Override
            public void onComplete(Exchange exchange) {
                synchronizedExchange.consumed(result);
            }

            @Override
            public void onFailure(Exchange exchange) {
                synchronizedExchange.consumed(result);
            }
        });
        processor.process(result, NOOP_ASYNC_CALLBACK);
    } catch (Exception e) {
        Exchange exchange = synchronizedExchange.getExchange();
        if (exchange != null) {
            getExceptionHandler().handleException(""Error processing exchange"", exchange, e);
        } else {
            getExceptionHandler().handleException(e);
        }
    }
}",java:S3398,35
"private synchronized void shutdownDisruptor(boolean isReconfiguring){
    LOGGER.debug(""Shutting down disruptor {}, reconfiguring: {}"", this, isReconfiguring);
    Disruptor<ExchangeEvent> currentDisruptor = disruptor.getReference();
    disruptor.set(null, isReconfiguring);
    if (currentDisruptor != null) {
        if (handlers != null && handlers.length == 1 && handlers[0] instanceof BlockingExchangeEventHandler) {
            final BlockingExchangeEventHandler blockingExchangeEventHandler = (BlockingExchangeEventHandler) handlers[0];
            blockingExchangeEventHandler.unblock();
        }
        currentDisruptor.shutdown();
        for (final LifecycleAwareExchangeEventHandler eventHandler : handlers) {
            boolean eventHandlerFinished = false;
            while (!eventHandlerFinished) {
                try {
                    if (!eventHandler.awaitStopped(10, TimeUnit.SECONDS)) {
                        LOGGER.error(""Disruptor/event handler failed to shut down properly, PLEASE REPORT"");
                    }
                    eventHandlerFinished = true;
                } catch (InterruptedException e) {
                }
            }
        }
        handlers = new LifecycleAwareExchangeEventHandler[0];
    }
}",java:S3776,39
"public WaitStrategy createWaitStrategyInstance() throws Exception{
    return waitStrategyClass.getConstructor().newInstance();
}",java:S112,4
"private Map<String, Float> classify(Model model, Translator translator, File input){
    try (InputStream fileInputStream = new FileInputStream(input)) {
        Image image = ImageFactory.getInstance().fromInputStream(fileInputStream);
        return classify(model, translator, image);
    } catch (IOException e) {
        LOG.error(""Couldn't transform input into a BufferedImage"");
        throw new RuntimeCamelException(""Couldn't transform input into a BufferedImage"", e);
    }
}",java:S3740,38
"private Map<String, Float> classify(Model model, Translator translator, InputStream input){
    try {
        Image image = ImageFactory.getInstance().fromInputStream(input);
        return classify(model, translator, image);
    } catch (IOException e) {
        LOG.error(""Couldn't transform input into a BufferedImage"");
        throw new RuntimeCamelException(""Couldn't transform input into a BufferedImage"", e);
    }
}",java:S3740,38
"private Map<String, Float> classify(Model model, Translator translator, Image image){
    try (Predictor<Image, Classifications> predictor = model.newPredictor(translator)) {
        Classifications classifications = predictor.predict(image);
        List<Classifications.Classification> list = classifications.items();
        return list.stream().collect(Collectors.toMap(Classifications.Classification::getClassName, x -> (float) x.getProbability()));
    } catch (TranslateException e) {
        LOG.error(""Could not process input or output"", e);
        throw new RuntimeCamelException(""Could not process input or output"", e);
    }
}",java:S3740,38
"public DetectedObjects classify(Model model, Translator translator, Image image){
    try (Predictor<Image, DetectedObjects> predictor = model.newPredictor(translator)) {
        return predictor.predict(image);
    } catch (TranslateException e) {
        LOG.error(""Could not process input or output"", e);
        throw new RuntimeCamelException(""Could not process input or output"", e);
    }
}",java:S3740,38
"public DetectedObjects classify(Model model, Translator translator, File input){
    try (InputStream fileInputStream = new FileInputStream(input)) {
        Image image = ImageFactory.getInstance().fromInputStream(fileInputStream);
        return classify(model, translator, image);
    } catch (IOException e) {
        LOG.error(""Couldn't transform input into a BufferedImage"");
        throw new RuntimeCamelException(""Couldn't transform input into a BufferedImage"", e);
    }
}",java:S3740,38
"public DetectedObjects classify(Model model, Translator translator, InputStream input){
    try {
        Image image = ImageFactory.getInstance().fromInputStream(input);
        return classify(model, translator, image);
    } catch (IOException e) {
        LOG.error(""Couldn't transform input into a BufferedImage"");
        throw new RuntimeCamelException(""Couldn't transform input into a BufferedImage"", e);
    }
}",java:S3740,38
"private static ServiceDefinition asService(String serviceName, SRVRecord record){
    Map<String, String> meta = new HashMap<>();
    ObjectHelper.ifNotEmpty(record.getPriority(), val -> meta.put(""priority"", Integer.toString(val)));
    ObjectHelper.ifNotEmpty(record.getWeight(), val -> meta.put(""weight"", Integer.toString(val)));
    return new DefaultServiceDefinition(serviceName, record.getTarget().toString(true), record.getPort(), meta);
}",java:S6213,47
"public boolean isActive() throws Exception{
    if (resolvesTo.isEmpty()) {
        try {
            resolvesTo.addAll(getLocalIps());
        } catch (Exception e) {
            LOG.warn(""Failed to get local ips and resolvesTo not specified. Identifying as inactive."", e);
            throw e;
        }
    }
    LOG.debug(""Resolving {}"", hostname);
    List<String> hostnames = new ArrayList<>();
    hostnames.add(hostname);
    List<String> resolved = new ArrayList<>();
    while (!hostnames.isEmpty()) {
        NamingEnumeration<?> attributeEnumeration = null;
        try {
            String hostname = hostnames.remove(0);
            InetAddress inetAddress = InetAddress.getByName(hostname);
            InitialDirContext initialDirContext = new InitialDirContext();
            Attributes attributes = initialDirContext.getAttributes(""dns:/"" + inetAddress.getHostName(), DNS_TYPES);
            attributeEnumeration = attributes.getAll();
            while (attributeEnumeration.hasMore()) {
                Attribute attribute = (Attribute) attributeEnumeration.next();
                String id = attribute.getID();
                String value = (String) attribute.get();
                if (resolvesTo.contains(value)) {
                    LOG.debug(""{} = {} matched. Identifying as active."", id, value);
                    return true;
                }
                LOG.debug(""{} = {}"", id, value);
                if (id.equals(""CNAME"") && !resolved.contains(value)) {
                    hostnames.add(value);
                }
                resolved.add(value);
            }
        } catch (Exception e) {
            LOG.warn(hostname, e);
            throw e;
        } finally {
            if (attributeEnumeration != null) {
                try {
                    attributeEnumeration.close();
                } catch (Exception e) {
                    LOG.warn(""Failed to close attributeEnumeration. Memory leak possible."", e);
                }
                attributeEnumeration = null;
            }
        }
    }
    return false;
}",java:S3776,39
"private List<String> getLocalIps() throws Exception{
    List<String> localIps = new ArrayList<>();
    Enumeration<NetworkInterface> networkInterfacesEnumeration = NetworkInterface.getNetworkInterfaces();
    while (networkInterfacesEnumeration.hasMoreElements()) {
        NetworkInterface networkInterface = networkInterfacesEnumeration.nextElement();
        Enumeration<InetAddress> inetAddressesEnumeration = networkInterface.getInetAddresses();
        while (inetAddressesEnumeration.hasMoreElements()) {
            InetAddress inetAddress = inetAddressesEnumeration.nextElement();
            String ip = inetAddress.getHostAddress();
            LOG.debug(""Local ip: {}"", ip);
            localIps.add(ip);
        }
    }
    return localIps;
}",java:S112,4
"private void startRoutes(){
    for (Map.Entry<String, Route> entry : routes.entrySet()) {
        try {
            startRouteImpl(entry.getValue());
        } catch (Exception e) {
            LOG.warn(entry.getKey(), e);
        }
    }
}",java:S3398,35
"private void stopRoutes(){
    for (Map.Entry<String, Route> routeEntry : routes.entrySet()) {
        try {
            stopRouteImpl(routeEntry.getValue());
        } catch (Exception e) {
            LOG.warn(routeEntry.getKey(), e);
        }
    }
}",java:S3398,35
"private void setResponse(Exchange exchange, ResultCallbackTemplate item) throws InterruptedException{
    if (item != null) {
        exchange.getIn().setBody(item);
        item.awaitCompletion();
    }
}",java:S3740,38
"private CommitCmd executeCommitContainerRequest(DockerClient client, Message message){
    LOGGER.debug(""Executing Docker Commit Container Request"");
    String containerId = DockerHelper.getProperty(DockerConstants.DOCKER_CONTAINER_ID, configuration, message, String.class);
    ObjectHelper.notNull(containerId, ""Container ID must be specified"");
    CommitCmd commitCmd = client.commitCmd(containerId);
    String author = DockerHelper.getProperty(DockerConstants.DOCKER_AUTHOR, configuration, message, String.class);
    if (author != null) {
        commitCmd.withAuthor(author);
    }
    Boolean attachStdErr = DockerHelper.getProperty(DockerConstants.DOCKER_ATTACH_STD_ERR, configuration, message, Boolean.class);
    if (attachStdErr != null) {
        commitCmd.withAttachStderr(attachStdErr);
    }
    Boolean attachStdIn = DockerHelper.getProperty(DockerConstants.DOCKER_ATTACH_STD_IN, configuration, message, Boolean.class);
    if (attachStdIn != null) {
        commitCmd.withAttachStdin(attachStdIn);
    }
    Boolean attachStdOut = DockerHelper.getProperty(DockerConstants.DOCKER_ATTACH_STD_OUT, configuration, message, Boolean.class);
    if (attachStdOut != null) {
        commitCmd.withAttachStdout(attachStdOut);
    }
    String[] cmds = DockerHelper.parseDelimitedStringHeader(DockerConstants.DOCKER_CMD, message);
    if (cmds != null) {
        commitCmd.withCmd(cmds);
    }
    Boolean disableNetwork = DockerHelper.getProperty(DockerConstants.DOCKER_DISABLE_NETWORK, configuration, message, Boolean.class);
    if (disableNetwork != null) {
        commitCmd.withDisableNetwork(disableNetwork);
    }
    String[] envs = DockerHelper.parseDelimitedStringHeader(DockerConstants.DOCKER_ENV, message);
    if (envs != null) {
        commitCmd.withEnv(envs);
    }
    ExposedPorts exposedPorts = DockerHelper.getProperty(DockerConstants.DOCKER_EXPOSED_PORTS, configuration, message, ExposedPorts.class);
    if (exposedPorts != null) {
        commitCmd.withExposedPorts(exposedPorts);
    }
    String hostname = DockerHelper.getProperty(DockerConstants.DOCKER_HOSTNAME, configuration, message, String.class);
    if (hostname != null) {
        commitCmd.withHostname(hostname);
    }
    Integer memory = DockerHelper.getProperty(DockerConstants.DOCKER_MEMORY, configuration, message, Integer.class);
    if (memory != null) {
        commitCmd.withMemory(memory);
    }
    Integer memorySwap = DockerHelper.getProperty(DockerConstants.DOCKER_MEMORY_SWAP, configuration, message, Integer.class);
    if (memorySwap != null) {
        commitCmd.withMemorySwap(memorySwap);
    }
    String msg = DockerHelper.getProperty(DockerConstants.DOCKER_MESSAGE, configuration, message, String.class);
    if (msg != null) {
        commitCmd.withMessage(msg);
    }
    Boolean openStdIn = DockerHelper.getProperty(DockerConstants.DOCKER_OPEN_STD_IN, configuration, message, Boolean.class);
    if (openStdIn != null) {
        commitCmd.withOpenStdin(openStdIn);
    }
    Boolean pause = DockerHelper.getProperty(DockerConstants.DOCKER_PAUSE, configuration, message, Boolean.class);
    if (pause != null) {
        commitCmd.withPause(pause);
    }
    String[] portSpecs = DockerHelper.parseDelimitedStringHeader(DockerConstants.DOCKER_PORT_SPECS, message);
    if (portSpecs != null) {
        commitCmd.withPortSpecs(portSpecs);
    }
    String repository = DockerHelper.getProperty(DockerConstants.DOCKER_REPOSITORY, configuration, message, String.class);
    if (repository != null) {
        commitCmd.withRepository(repository);
    }
    Boolean stdInOnce = DockerHelper.getProperty(DockerConstants.DOCKER_STD_IN_ONCE, configuration, message, Boolean.class);
    if (stdInOnce != null) {
        commitCmd.withStdinOnce(stdInOnce);
    }
    String tag = DockerHelper.getProperty(DockerConstants.DOCKER_TAG, configuration, message, String.class);
    if (tag != null) {
        commitCmd.withTag(tag);
    }
    Boolean tty = DockerHelper.getProperty(DockerConstants.DOCKER_TTY, configuration, message, Boolean.class);
    if (tty != null) {
        commitCmd.withTty(tty);
    }
    String user = DockerHelper.getProperty(DockerConstants.DOCKER_USER, configuration, message, String.class);
    if (user != null) {
        commitCmd.withUser(user);
    }
    Volumes volumes = DockerHelper.getProperty(DockerConstants.DOCKER_VOLUMES, configuration, message, Volumes.class);
    if (volumes != null) {
        commitCmd.withVolumes(volumes);
    }
    String workingDir = DockerHelper.getProperty(DockerConstants.DOCKER_WORKING_DIR, configuration, message, String.class);
    if (workingDir != null) {
        commitCmd.withWorkingDir(workingDir);
    }
    return commitCmd;
}",java:S3776,39
"private CreateContainerCmd executeCreateContainerRequest(DockerClient client, Message message){
    LOGGER.debug(""Executing Docker Create Container Request"");
    String image = DockerHelper.getProperty(DockerConstants.DOCKER_IMAGE, configuration, message, String.class);
    ObjectHelper.notNull(image, ""Image must be specified"");
    CreateContainerCmd createContainerCmd = client.createContainerCmd(image);
    createContainerCmd.withHostConfig(newHostConfig());
    Boolean attachStdErr = DockerHelper.getProperty(DockerConstants.DOCKER_ATTACH_STD_ERR, configuration, message, Boolean.class);
    if (attachStdErr != null) {
        createContainerCmd.withAttachStderr(attachStdErr);
    }
    Boolean attachStdIn = DockerHelper.getProperty(DockerConstants.DOCKER_ATTACH_STD_IN, configuration, message, Boolean.class);
    if (attachStdIn != null) {
        createContainerCmd.withAttachStdin(attachStdIn);
    }
    Boolean attachStdOut = DockerHelper.getProperty(DockerConstants.DOCKER_ATTACH_STD_OUT, configuration, message, Boolean.class);
    if (attachStdOut != null) {
        createContainerCmd.withAttachStdout(attachStdOut);
    }
    Capability[] capAdd = DockerHelper.getArrayProperty(DockerConstants.DOCKER_CAP_ADD, message, Capability.class);
    if (capAdd != null) {
        createContainerCmd.getHostConfig().withCapAdd(capAdd);
    }
    Capability[] capDrop = DockerHelper.getArrayProperty(DockerConstants.DOCKER_CAP_DROP, message, Capability.class);
    if (capDrop != null) {
        createContainerCmd.getHostConfig().withCapDrop(capDrop);
    }
    String[] cmd = DockerHelper.parseDelimitedStringHeader(DockerConstants.DOCKER_CMD, message);
    if (cmd != null) {
        createContainerCmd.withCmd(cmd);
    }
    Integer cpuShares = DockerHelper.getProperty(DockerConstants.DOCKER_CPU_SHARES, configuration, message, Integer.class);
    if (cpuShares != null) {
        createContainerCmd.getHostConfig().withCpuShares(cpuShares);
    }
    Boolean disableNetwork = DockerHelper.getProperty(DockerConstants.DOCKER_DISABLE_NETWORK, configuration, message, Boolean.class);
    if (disableNetwork != null) {
        createContainerCmd.withNetworkDisabled(disableNetwork);
    }
    String[] dns = DockerHelper.parseDelimitedStringHeader(DockerConstants.DOCKER_DNS, message);
    if (dns != null) {
        createContainerCmd.getHostConfig().withDns(dns);
    }
    String domainName = DockerHelper.getProperty(DockerConstants.DOCKER_DOMAIN_NAME, configuration, message, String.class);
    if (domainName != null) {
        createContainerCmd.withDomainName(domainName);
    }
    String[] env = DockerHelper.parseDelimitedStringHeader(DockerConstants.DOCKER_ENV, message);
    if (env != null) {
        createContainerCmd.withEnv(env);
    }
    String[] entrypoint = DockerHelper.getArrayProperty(DockerConstants.DOCKER_ENTRYPOINT, message, String.class);
    if (entrypoint != null) {
        createContainerCmd.withEntrypoint(entrypoint);
    }
    ExposedPort[] exposedPorts = DockerHelper.getArrayProperty(DockerConstants.DOCKER_EXPOSED_PORTS, message, ExposedPort.class);
    if (exposedPorts != null) {
        createContainerCmd.withExposedPorts(exposedPorts);
    }
    HostConfig hostConfig = DockerHelper.getProperty(DockerConstants.DOCKER_HOST_CONFIG, configuration, message, HostConfig.class);
    if (hostConfig != null) {
        createContainerCmd.withHostConfig(hostConfig);
    }
    String hostName = DockerHelper.getProperty(DockerConstants.DOCKER_HOSTNAME, configuration, message, String.class);
    if (hostName != null) {
        createContainerCmd.withHostName(hostName);
    }
    Long memoryLimit = DockerHelper.getProperty(DockerConstants.DOCKER_MEMORY_LIMIT, configuration, message, Long.class);
    if (memoryLimit != null) {
        createContainerCmd.getHostConfig().withMemory(memoryLimit);
    }
    Long memorySwap = DockerHelper.getProperty(DockerConstants.DOCKER_MEMORY_SWAP, configuration, message, Long.class);
    if (memorySwap != null) {
        createContainerCmd.getHostConfig().withMemorySwap(memorySwap);
    }
    String name = DockerHelper.getProperty(DockerConstants.DOCKER_NAME, configuration, message, String.class);
    if (name != null) {
        createContainerCmd.withName(name);
    }
    String[] portSpecs = DockerHelper.parseDelimitedStringHeader(DockerConstants.DOCKER_PORT_SPECS, message);
    if (portSpecs != null) {
        createContainerCmd.withPortSpecs(portSpecs);
    }
    Boolean stdInOpen = DockerHelper.getProperty(DockerConstants.DOCKER_STD_IN_OPEN, configuration, message, Boolean.class);
    if (stdInOpen != null) {
        createContainerCmd.withStdinOpen(stdInOpen);
    }
    Boolean stdInOnce = DockerHelper.getProperty(DockerConstants.DOCKER_STD_IN_ONCE, configuration, message, Boolean.class);
    if (stdInOnce != null) {
        createContainerCmd.withStdInOnce(stdInOnce);
    }
    Boolean tty = DockerHelper.getProperty(DockerConstants.DOCKER_TTY, configuration, message, Boolean.class);
    if (tty != null) {
        createContainerCmd.withTty(tty);
    }
    String user = DockerHelper.getProperty(DockerConstants.DOCKER_USER, configuration, message, String.class);
    if (user != null) {
        createContainerCmd.withUser(user);
    }
    Volume[] volume = DockerHelper.getArrayProperty(DockerConstants.DOCKER_VOLUMES, message, Volume.class);
    if (volume != null) {
        createContainerCmd.withVolumes(volume);
    }
    Bind[] binds = DockerHelper.getArrayProperty(DockerConstants.DOCKER_BINDS, message, Bind.class);
    if (binds != null) {
        createContainerCmd.getHostConfig().withBinds(binds);
    }
    VolumesFrom[] volumesFrom = DockerHelper.getArrayProperty(DockerConstants.DOCKER_VOLUMES_FROM, message, VolumesFrom.class);
    if (volumesFrom != null) {
        createContainerCmd.getHostConfig().withVolumesFrom(volumesFrom);
    }
    String workingDir = DockerHelper.getProperty(DockerConstants.DOCKER_WORKING_DIR, configuration, message, String.class);
    if (workingDir != null) {
        createContainerCmd.withWorkingDir(workingDir);
    }
    return createContainerCmd;
}",java:S3776,39
"public List<?> queryForList(ResultSet rs) throws SQLException{
    ColumnMapRowMapper rowMapper = new ColumnMapRowMapper();
    RowMapperResultSetExtractor<Map<String, Object>> mapper = new RowMapperResultSetExtractor<>(rowMapper);
    return mapper.extractData(rs);
}",java:S1452,23
"private DropboxFileUploadResult putFile(String localPath, DropboxUploadMode mode, String dropboxPath, boolean isPresent) throws DropboxException{
    File fileLocalPath = new File(localPath);
    if (fileLocalPath.isFile()) {
        if (isPresent && !DropboxUploadMode.force.equals(mode)) {
            throw new DropboxException(dropboxPath + "" exists on dropbox. Use force upload mode to override"");
        }
        if (!isPresent && dropboxPath.endsWith(DropboxConstants.DROPBOX_FILE_SEPARATOR)) {
            dropboxPath = dropboxPath + fileLocalPath.getName();
        }
        LOG.debug(""Uploading: {},{}"", fileLocalPath, dropboxPath);
        DropboxFileUploadResult result;
        try {
            FileMetadata uploadedFile = putSingleFile(fileLocalPath, dropboxPath, mode);
            if (uploadedFile == null) {
                result = new DropboxFileUploadResult(dropboxPath, DropboxResultCode.KO);
            } else {
                result = new DropboxFileUploadResult(dropboxPath, DropboxResultCode.OK);
            }
        } catch (Exception ex) {
            result = new DropboxFileUploadResult(dropboxPath, DropboxResultCode.KO);
        }
        return result;
    } else if (fileLocalPath.isDirectory()) {
        LOG.debug(""Uploading a dir..."");
        if (isPresent && !DropboxUploadMode.force.equals(mode)) {
            throw new DropboxException(dropboxPath + "" exists on dropbox and is not a folder!"");
        }
        if (!dropboxPath.endsWith(DropboxConstants.DROPBOX_FILE_SEPARATOR)) {
            dropboxPath = dropboxPath + DropboxConstants.DROPBOX_FILE_SEPARATOR;
        }
        String oldDropboxPath = dropboxPath;
        Collection<File> listFiles = FileUtils.listFiles(fileLocalPath, null, true);
        if (listFiles.isEmpty()) {
            throw new DropboxException(localPath + "" does not contain any files"");
        }
        HashMap<String, DropboxResultCode> resultMap = new HashMap<>(listFiles.size());
        for (File file : listFiles) {
            String absPath = file.getAbsolutePath();
            int indexRemainingPath = localPath.length();
            if (!localPath.endsWith(""/"")) {
                indexRemainingPath += 1;
            }
            String remainingPath = absPath.substring(indexRemainingPath);
            dropboxPath = dropboxPath + remainingPath;
            try {
                LOG.debug(""Uploading: {},{}"", fileLocalPath, dropboxPath);
                FileMetadata uploadedFile = putSingleFile(file, dropboxPath, mode);
                if (uploadedFile == null) {
                    resultMap.put(dropboxPath, DropboxResultCode.KO);
                } else {
                    resultMap.put(dropboxPath, DropboxResultCode.OK);
                }
            } catch (Exception ex) {
                resultMap.put(dropboxPath, DropboxResultCode.KO);
            }
            dropboxPath = oldDropboxPath;
        }
        return new DropboxFileUploadResult(resultMap);
    } else {
        return null;
    }
}",java:S3776,39
"private FileMetadata putSingleFile(File inputFile, String dropboxPath, DropboxUploadMode mode) throws Exception{
    try (FileInputStream inputStream = new FileInputStream(inputFile)) {
        WriteMode uploadMode;
        if (mode == DropboxUploadMode.force) {
            uploadMode = WriteMode.OVERWRITE;
        } else {
            uploadMode = WriteMode.ADD;
        }
        return client.files().uploadBuilder(dropboxPath).withMode(uploadMode).uploadAndFinish(inputStream, inputFile.length());
    }
}",java:S112,4
"private FileMetadata putSingleBody(Exchange exchange, String dropboxPath, DropboxUploadMode mode) throws Exception{
    byte[] data = exchange.getIn().getMandatoryBody(byte[].class);
    try (InputStream is = new ByteArrayInputStream(data)) {
        final WriteMode uploadMode;
        if (mode == DropboxUploadMode.force) {
            uploadMode = WriteMode.OVERWRITE;
        } else {
            uploadMode = WriteMode.ADD;
        }
        return client.files().uploadBuilder(dropboxPath).withMode(uploadMode).uploadAndFinish(is, data.length);
    }
}",java:S112,4
"private static Properties loadProperties() throws Exception{
    URL url = DropboxPropertyManager.class.getResource(""/dropbox.properties"");
    try (InputStream inStream = url.openStream()) {
        properties = new Properties();
        try {
            properties.load(inStream);
        } catch (IOException e) {
            throw new DropboxException(""dropbox.properties can't be read"", e);
        }
    } catch (IOException e) {
        throw new DropboxException(""dropbox.properties could not be found"", e);
    }
    return properties;
}",java:S112,4
"public void setCacheConfiguration(CacheConfiguration cacheConfiguration){
    this.configuration.setConfiguration(cacheConfiguration);
}",java:S3740,38
"public CacheConfiguration getCacheConfiguration(){
    return this.configuration.getConfiguration();
}",java:S3740,38
"public Map<String, CacheConfiguration> getCachesConfigurations(){
    return configuration.getConfigurations();
}",java:S3740,38
"public void setCachesConfigurations(Map<String, CacheConfiguration> configurations){
    configuration.setConfigurations(configurations);
}",java:S3740,38
"public void addCachesConfigurations(Map<String, CacheConfiguration> configurations){
    configuration.addConfigurations(configurations);
}",java:S3740,38
"@Deprecated
public String getConfigUri(){
    return getConfigurationUri();
}",java:S6355,48
"@Deprecated
@Metadata(deprecationNote = ""use configurationUri instead"")
public void setConfigUri(String configUri){
    setConfigurationUri(configUri);
}",java:S6355,48
"public CacheConfiguration<?, ?> getConfiguration(){
    return configuration;
}",java:S1452,23
"public CacheConfiguration<?, ?> getConfiguration(){
    return configuration;
}",java:S1452,23
"public Map<String, CacheConfiguration> getConfigurations(){
    return configurations;
}",java:S3740,38
"public void setConfigurations(Map<String, CacheConfiguration> configurations){
    this.configurations = Map.class.cast(configurations);
}",java:S3740,38
"public void addConfigurations(Map<String, CacheConfiguration> configurations){
    if (this.configurations == null) {
        this.configurations = new HashMap<>();
    }
    this.configurations.putAll(configurations);
}",java:S3740,38
"private Object getKey(final Message message) throws Exception{
    Object value;
    if (configuration.getKeyType() != null) {
        Class<?> clazz = getEndpoint().getCamelContext().getClassResolver().resolveClass(configuration.getKeyType());
        value = message.getHeader(EhcacheConstants.KEY, clazz);
    } else {
        value = message.getHeader(EhcacheConstants.KEY);
    }
    if (value == null) {
        value = configuration.getKey();
    }
    if (value == null) {
        throw new CamelExchangeException(""No value provided in header or as default value ("" + EhcacheConstants.KEY + "")"", message.getExchange());
    }
    return value;
}",java:S112,4
"public String getDeadLetterChannel(){
    return deadLetterChannel;
}",java:S4144,40
"public static List<String> splitToWhiteSpaceSeparatedTokens(String input){
    if (input == null) {
        return new ArrayList<>();
    }
    StringTokenizer tokenizer = new StringTokenizer(input.trim(), QUOTE_CHAR + WHITESPACE, true);
    List<String> tokens = new ArrayList<>();
    StringBuilder quotedText = new StringBuilder();
    while (tokenizer.hasMoreTokens()) {
        String token = tokenizer.nextToken();
        if (QUOTE_CHAR.equals(token)) {
            quotedText.append(QUOTE_CHAR);
            String buffer = quotedText.toString();
            if (isSingleQuoted(buffer) || isDoubleQuoted(buffer)) {
                tokens.add(buffer.substring(1, buffer.length() - 1));
                quotedText = new StringBuilder();
            }
        } else if (WHITESPACE.equals(token)) {
            if (quotedText.length() > 0) {
                quotedText.append(WHITESPACE);
            }
        } else {
            if (quotedText.length() > 0) {
                quotedText.append(token);
            } else {
                tokens.add(token);
            }
        }
    }
    if (quotedText.length() > 0) {
        throw new IllegalArgumentException(""Invalid quoting found in args "" + quotedText);
    }
    return tokens;
}",java:S3776,39
"public Configuration getConfiguration(){
    final ConfigurationBuilder builder = new ConfigurationBuilder();
    if (oAuthAccessToken != null) {
        builder.setOAuthAccessToken(oAuthAccessToken);
    }
    if (oAuthAccessTokenURL != null) {
        builder.setOAuthAccessTokenURL(oAuthAccessTokenURL);
    }
    if (oAuthAppId != null) {
        builder.setOAuthAppId(oAuthAppId);
    }
    if (oAuthAppSecret != null) {
        builder.setOAuthAppSecret(oAuthAppSecret);
    }
    if (oAuthAuthorizationURL != null) {
        builder.setOAuthAuthorizationURL(oAuthAuthorizationURL);
    }
    if (oAuthPermissions != null) {
        builder.setOAuthPermissions(oAuthPermissions);
    }
    if (clientURL != null) {
        builder.setClientURL(clientURL);
    }
    if (clientVersion != null) {
        builder.setClientVersion(clientVersion);
    }
    if (debugEnabled != null) {
        builder.setDebugEnabled(debugEnabled);
    }
    if (gzipEnabled != null) {
        builder.setGZIPEnabled(gzipEnabled);
    }
    if (httpConnectionTimeout != null) {
        builder.setHttpConnectionTimeout(httpConnectionTimeout);
    }
    if (httpDefaultMaxPerRoute != null) {
        builder.setHttpDefaultMaxPerRoute(httpDefaultMaxPerRoute);
    }
    if (httpMaxTotalConnections != null) {
        builder.setHttpMaxTotalConnections(httpMaxTotalConnections);
    }
    if (httpProxyHost != null) {
        builder.setHttpProxyHost(httpProxyHost);
    }
    if (httpProxyPassword != null) {
        builder.setHttpProxyPassword(httpProxyPassword);
    }
    if (httpProxyPort != null) {
        builder.setHttpProxyPort(httpProxyPort);
    }
    if (httpProxyUser != null) {
        builder.setHttpProxyUser(httpProxyUser);
    }
    if (httpReadTimeout != null) {
        builder.setHttpReadTimeout(httpReadTimeout);
    }
    if (httpRetryCount != null) {
        builder.setHttpRetryCount(httpRetryCount);
    }
    if (httpRetryIntervalSeconds != null) {
        builder.setHttpRetryIntervalSeconds(httpRetryIntervalSeconds);
    }
    if (httpStreamingReadTimeout != null) {
        builder.setHttpStreamingReadTimeout(httpStreamingReadTimeout);
    }
    if (jsonStoreEnabled != null) {
        builder.setJSONStoreEnabled(jsonStoreEnabled);
    }
    if (mbeanEnabled != null) {
        builder.setMBeanEnabled(mbeanEnabled);
    }
    if (prettyDebugEnabled != null) {
        builder.setPrettyDebugEnabled(prettyDebugEnabled);
    }
    if (restBaseURL != null) {
        builder.setRestBaseURL(restBaseURL);
    }
    if (useSSL != null) {
        builder.setUseSSL(useSSL);
    }
    if (videoBaseURL != null) {
        builder.setVideoBaseURL(videoBaseURL);
    }
    return builder.build();
}",java:S3776,39
"@Deprecated
public void setCheckinUpdate(CheckinUpdate checkinUpdate){
    this.checkinUpdate = checkinUpdate;
}",java:S6355,48
"public static List<FacebookMethodsType> filterMethods(List<FacebookMethodsType> methods, MatchType matchType, String... argNames){
    List<String> argsList = Arrays.asList(argNames);
    final List<FacebookMethodsType> result = new ArrayList<>();
    final List<FacebookMethodsType> extraArgs = new ArrayList<>();
    for (FacebookMethodsType method : methods) {
        final List<String> methodArgs = method.getArgNames();
        switch(matchType) {
            case EXACT:
                if (methodArgs.containsAll(argsList) && argsList.containsAll(methodArgs)) {
                    result.add(method);
                }
                break;
            case SUBSET:
                if (methodArgs.containsAll(argsList)) {
                    result.add(method);
                }
                break;
            default:
            case SUPER_SET:
                if (argsList.containsAll(methodArgs)) {
                    if (methodArgs.containsAll(argsList)) {
                        result.add(method);
                    } else {
                        extraArgs.add(method);
                    }
                }
                break;
        }
    }
    return Collections.unmodifiableList(result.isEmpty() ? extraArgs : result);
}",java:S3776,39
"public static Object invokeMethod(Facebook facebook, FacebookMethodsType method, Map<String, Object> properties) throws RuntimeCamelException{
    LOG.debug(""Invoking {} with arguments {}"", method.getName(), properties);
    final List<String> argNames = method.getArgNames();
    final Object[] values = new Object[argNames.size()];
    final List<Class<?>> argTypes = method.getArgTypes();
    final Class<?>[] types = argTypes.toArray(new Class[0]);
    int index = 0;
    for (String name : argNames) {
        Object value = properties.get(name);
        if (value != null && types[index].isArray()) {
            Class<?> type = types[index];
            if (value instanceof Collection) {
                Collection<?> collection = (Collection<?>) value;
                Object array = Array.newInstance(type.getComponentType(), collection.size());
                if (array instanceof Object[]) {
                    collection.toArray((Object[]) array);
                } else {
                    int i = 0;
                    for (Object el : collection) {
                        Array.set(array, i++, el);
                    }
                }
                value = array;
            } else if (value.getClass().isArray() && type.getComponentType().isAssignableFrom(value.getClass().getComponentType())) {
                final int size = Array.getLength(value);
                Object array = Array.newInstance(type.getComponentType(), size);
                for (int i = 0; i < size; i++) {
                    Array.set(array, i, Array.get(value, i));
                }
                value = array;
            } else {
                throw new IllegalArgumentException(String.format(""Cannot convert %s to %s"", value.getClass(), type));
            }
        }
        values[index++] = value;
    }
    try {
        return method.getMethod().invoke(facebook, values);
    } catch (Exception e) {
        String msg;
        if (e.getCause() instanceof FacebookException) {
            msg = ((FacebookException) e.getCause()).getErrorMessage();
        } else {
            msg = e.getMessage();
        }
        throw new RuntimeCamelException(String.format(""Error invoking %s with %s: %s"", method.getName(), properties, msg), e);
    }
}",java:S3776,39
"public IBaseResource resourceById(Class<IBaseResource> resource, String stringId, String version, String ifVersionMatches, Boolean returnNull, IBaseResource returnResource, Boolean throwError, Map<ExtraParameters, Object> extraParameters){
    IReadTyped<IBaseResource> readTyped = client.read().resource(resource);
    IReadExecutable<IBaseResource> readExecutable = readWithOptionalVersion(stringId, readTyped, version);
    ExtraParameters.process(extraParameters, readExecutable);
    return processOptionalParams(ifVersionMatches, returnNull, returnResource, throwError, readExecutable);
}",java:S107,1
"public IBaseResource resourceById(String resourceClass, String stringId, String ifVersionMatches, String version, Boolean returnNull, IBaseResource returnResource, Boolean throwError, Map<ExtraParameters, Object> extraParameters){
    IReadTyped<IBaseResource> resource = client.read().resource(resourceClass);
    IReadExecutable<IBaseResource> readExecutable = readWithOptionalVersion(stringId, resource, version);
    ExtraParameters.process(extraParameters, readExecutable);
    return processOptionalParams(ifVersionMatches, returnNull, returnResource, throwError, readExecutable);
}",java:S107,1
"private Exchange prepareExchange(FileEvent event){
    Exchange exchange = createExchange(true);
    File file = event.getEventPath().toFile();
    Message message = exchange.getIn();
    message.setBody(file);
    message.setHeader(FileWatchConstants.EVENT_TYPE_HEADER, event.getEventType().name());
    message.setHeader(FileWatchConstants.FILE_NAME_ONLY, event.getEventPath().getFileName().toString());
    message.setHeader(FileWatchConstants.FILE_ABSOLUTE, true);
    final String absolutePath = PathUtils.normalizeToString(event.getEventPath().toAbsolutePath());
    message.setHeader(FileWatchConstants.FILE_ABSOLUTE_PATH, absolutePath);
    message.setHeader(FileWatchConstants.FILE_PATH, absolutePath);
    final String relativePath = PathUtils.normalizeToString(baseDirectory.relativize(event.getEventPath()));
    message.setHeader(FileWatchConstants.FILE_NAME, relativePath);
    message.setHeader(FileWatchConstants.FILE_RELATIVE_PATH, relativePath);
    message.setHeader(FileWatchConstants.FILE_NAME_CONSUMED, relativePath);
    message.setHeader(FileWatchConstants.FILE_PARENT, PathUtils.normalizeToString(event.getEventPath().getParent().toAbsolutePath()));
    message.setHeader(FileWatchConstants.FILE_LAST_MODIFIED, event.getEventDate());
    message.setHeader(Exchange.MESSAGE_TIMESTAMP, event.getEventDate());
    return exchange;
}",java:S3398,35
"private boolean matchFilters(FileEvent fileEvent){
    if (!events.isEmpty() && !events.contains(fileEvent.getEventType())) {
        return false;
    }
    if (!getEndpoint().isRecursive()) {
        try {
            if (!Files.isSameFile(fileEvent.getEventPath().getParent(), this.baseDirectory)) {
                return false;
            }
        } catch (IOException e) {
            LOG.warn(String.format(""Exception occurred during executing filter. Filtering file %s out."", fileEvent.getEventPath()), e);
            return false;
        }
    }
    String pattern = getEndpoint().getAntInclude();
    if (pattern == null || pattern.trim().isEmpty()) {
        return true;
    }
    return antPathMatcher.match(getEndpoint().getAntInclude(), PathUtils.normalizeToString(baseDirectory.relativize(fileEvent.getEventPath())));
}",java:S3398,35
"private boolean pollDirectory(File directory, List<GenericFile<File>> fileList, int depth){
    depth++;
    if (LOG.isTraceEnabled()) {
        LOG.trace(""Polling directory: {}, absolute path: {}"", directory.getPath(), directory.getAbsolutePath());
    }
    final File[] files = listFiles(directory);
    if (files == null || files.length == 0) {
        return true;
    }
    if (getEndpoint().isPreSort()) {
        Arrays.sort(files, Comparator.comparing(File::getAbsoluteFile));
    }
    for (File file : files) {
        if (!canPollMoreFiles(fileList)) {
            return false;
        }
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Found file: {} [isAbsolute: {}, isDirectory: {}, isFile: {}, isHidden: {}]"", file, file.isAbsolute(), file.isDirectory(), file.isFile(), file.isHidden());
        }
        GenericFile<File> gf = asGenericFile(endpointPath, file, getEndpoint().getCharset(), getEndpoint().isProbeContentType());
        if (resumeStrategy != null) {
            ResumeAdapter adapter = resumeStrategy.getAdapter();
            LOG.trace(""Checking the resume adapter: {}"", adapter);
            if (adapter instanceof FileOffsetResumeAdapter) {
                LOG.trace(""The resume adapter is for offsets: {}"", adapter);
                ((FileOffsetResumeAdapter) adapter).setResumePayload(gf);
                adapter.resume();
            }
            if (adapter instanceof DirectoryEntriesResumeAdapter) {
                LOG.trace(""Running the resume process for file {}"", file);
                if (((DirectoryEntriesResumeAdapter) adapter).resume(file)) {
                    LOG.trace(""Skipping file {} because it has been marked previously consumed"", file);
                    continue;
                }
            }
        }
        if (file.isDirectory()) {
            if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(gf, true, files)) {
                boolean canPollMore = pollDirectory(file, fileList, depth);
                if (!canPollMore) {
                    return false;
                }
            }
        } else {
            if (depth >= endpoint.minDepth && isValidFile(gf, false, files)) {
                LOG.trace(""Adding valid file: {}"", file);
                if (extendedAttributes != null) {
                    Path path = file.toPath();
                    Map<String, Object> allAttributes = new HashMap<>();
                    for (String attribute : extendedAttributes) {
                        readAttributes(file, path, allAttributes, attribute);
                    }
                    gf.setExtendedAttributes(allAttributes);
                }
                fileList.add(gf);
            }
        }
    }
    return true;
}",java:S3776,39
"public boolean isIncludeHiddenFiles(){
    return includeHiddenFiles;
}",java:S4144,40
"public void populateHeaders(GenericFileMessage<T> message, boolean isProbeContentTypeFromEndpoint){
    if (message != null) {
        message.setHeader(FileConstants.FILE_NAME_ONLY, getFileNameOnly());
        message.setHeader(FileConstants.FILE_NAME, getFileName());
        message.setHeader(FileConstants.FILE_NAME_CONSUMED, getFileName());
        message.setHeader(FileConstants.FILE_ABSOLUTE, isAbsolute());
        message.setHeader(FileConstants.FILE_ABSOLUTE_PATH, getAbsoluteFilePath());
        if (extendedAttributes != null) {
            message.setHeader(FileConstants.FILE_EXTENDED_ATTRIBUTES, extendedAttributes);
        }
        if ((isProbeContentTypeFromEndpoint || probeContentType) && file instanceof File) {
            File f = (File) file;
            Path path = f.toPath();
            try {
                message.setHeader(FileConstants.FILE_CONTENT_TYPE, Files.probeContentType(path));
            } catch (Exception e) {
            }
        }
        if (isAbsolute()) {
            message.setHeader(FileConstants.FILE_PATH, getAbsoluteFilePath());
        } else {
            String path = normalizePathToProtocol(getEndpointPath() + File.separator + getRelativeFilePath());
            message.setHeader(FileConstants.FILE_PATH, path);
        }
        message.setHeader(FileConstants.FILE_RELATIVE_PATH, getRelativeFilePath());
        message.setHeader(FileConstants.FILE_PARENT, getParent());
        if (getFileLength() >= 0) {
            message.setHeader(FileConstants.FILE_LENGTH, getFileLength());
        }
        if (getLastModified() > 0) {
            message.setHeader(FileConstants.FILE_LAST_MODIFIED, getLastModified());
            message.setHeader(Exchange.MESSAGE_TIMESTAMP, getLastModified());
        }
    }
}",java:S3776,39
"public void changeFileName(String newName){
    LOG.trace(""Changing name to: {}"", newName);
    String newFileName = FileUtil.normalizePath(newName);
    String newEndpointPath = FileUtil.normalizePath(endpointPath.endsWith(String.valueOf(File.separatorChar)) ? endpointPath : endpointPath + File.separatorChar);
    LOG.trace(""Normalized endpointPath: {}"", newEndpointPath);
    LOG.trace(""Normalized newFileName: {}"", newFileName);
    File file = new File(newFileName);
    if (!absolute) {
        if (ObjectHelper.isNotEmpty(newEndpointPath) && newFileName.startsWith(newEndpointPath)) {
            if (newEndpointPath.endsWith(String.valueOf(File.separatorChar))) {
                newFileName = StringHelper.after(newFileName, newEndpointPath);
            } else {
                newFileName = StringHelper.after(newFileName, newEndpointPath + File.separatorChar);
            }
            file = new File(newFileName);
        }
    }
    setFileNameOnly(file.getName());
    setFileName(file.getName());
    if (file.getParent() != null) {
        setRelativeFilePath(file.getParent() + getFileSeparator() + file.getName());
    } else {
        setRelativeFilePath(file.getName());
    }
    if (isAbsolute(newFileName)) {
        setAbsolute(true);
        setAbsoluteFilePath(newFileName);
    } else {
        setAbsolute(false);
        String path = ObjectHelper.isEmpty(endpointPath) ? """" : endpointPath + getFileSeparator();
        setAbsoluteFilePath(path + getRelativeFilePath());
    }
    if (LOG.isTraceEnabled()) {
        LOG.trace(""FileNameOnly: {}"", getFileNameOnly());
        LOG.trace(""FileName: {}"", getFileName());
        LOG.trace(""Absolute: {}"", isAbsolute());
        LOG.trace(""Relative path: {}"", getRelativeFilePath());
        LOG.trace(""Absolute path: {}"", getAbsoluteFilePath());
        LOG.trace(""Name changed to: {}"", this);
    }
}",java:S3776,39
"protected boolean prePollCheck() throws Exception{
    return true;
}",java:S112,4
"protected boolean processExchange(final Exchange exchange){
    GenericFile<T> file = getExchangeFileProperty(exchange);
    LOG.trace(""Processing file: {}"", file);
    String absoluteFileName = file.getAbsoluteFilePath();
    Exception beginCause = null;
    boolean begin = false;
    try {
        begin = processStrategy.begin(operations, endpoint, exchange, file);
    } catch (Exception e) {
        beginCause = e;
    }
    if (!begin) {
        Exception abortCause = null;
        LOG.debug(""{} cannot begin processing file: {}"", endpoint, file);
        try {
            processStrategy.abort(operations, endpoint, exchange, file);
        } catch (Exception e) {
            abortCause = e;
        } finally {
            endpoint.getInProgressRepository().remove(absoluteFileName);
        }
        if (beginCause != null) {
            String msg = endpoint + "" cannot begin processing file: "" + file + "" due to: "" + beginCause.getMessage();
            handleException(msg, exchange, beginCause);
        }
        if (abortCause != null) {
            String msg2 = endpoint + "" cannot abort processing file: "" + file + "" due to: "" + abortCause.getMessage();
            handleException(msg2, exchange, abortCause);
        }
        return false;
    }
    final GenericFile<T> target = getExchangeFileProperty(exchange);
    updateFileHeaders(target, exchange.getIn());
    final String name = target.getAbsoluteFilePath();
    try {
        if (isRetrieveFile()) {
            LOG.trace(""Retrieving file: {} from: {}"", name, endpoint);
            boolean retrieved;
            Exception cause = null;
            try {
                retrieved = operations.retrieveFile(name, exchange, target.getFileLength());
            } catch (Exception e) {
                retrieved = false;
                cause = e;
            }
            if (!retrieved) {
                if (ignoreCannotRetrieveFile(name, exchange, cause)) {
                    LOG.trace(""Cannot retrieve file {} maybe it does not exists. Ignoring."", name);
                    endpoint.getInProgressRepository().remove(absoluteFileName);
                    return false;
                } else {
                    if (cause instanceof GenericFileOperationFailedException) {
                        throw cause;
                    } else {
                        throw new GenericFileOperationFailedException(""Cannot retrieve file: "" + file + "" from: "" + endpoint, cause);
                    }
                }
            }
            LOG.trace(""Retrieved file: {} from: {}"", name, endpoint);
        } else {
            LOG.trace(""Skipped retrieval of file: {} from: {}"", name, endpoint);
            exchange.getIn().setBody(null);
        }
        exchange.getExchangeExtension().addOnCompletion(new GenericFileOnCompletion<>(endpoint, operations, processStrategy, target, absoluteFileName));
        LOG.debug(""About to process file: {} using exchange: {}"", target, exchange);
        if (endpoint.isSynchronous()) {
            getProcessor().process(exchange);
        } else {
            getAsyncProcessor().process(exchange, EmptyAsyncCallback.get());
        }
    } catch (Exception e) {
        endpoint.getInProgressRepository().remove(absoluteFileName);
        String msg = ""Error processing file "" + file + "" due to "" + e.getMessage();
        handleException(msg, exchange, e);
    }
    return true;
}",java:S3776,39
"protected boolean isMatchedHiddenFile(GenericFile<T> file, boolean isDirectory){
    String name = file.getFileNameOnly();
    if (name.startsWith(""."")) {
        return false;
    }
    return true;
}",java:S1172,13
"protected boolean isMatched(GenericFile<T> file, boolean isDirectory, T[] files){
    String name = file.getFileNameOnly();
    if (!isMatchedHiddenFile(file, isDirectory)) {
        return false;
    }
    if (name.endsWith(FileComponent.DEFAULT_LOCK_FILE_POSTFIX)) {
        return false;
    }
    if (endpoint.getFilter() != null) {
        if (!endpoint.getFilter().accept(file)) {
            return false;
        }
    }
    if (endpoint.getAntFilter() != null) {
        if (!endpoint.getAntFilter().accept(file)) {
            return false;
        }
    }
    if (isDirectory && endpoint.getFilterDirectory() != null) {
        Exchange dummy = endpoint.createExchange(file);
        boolean matches = endpoint.getFilterDirectory().matches(dummy);
        if (!matches) {
            return false;
        }
    }
    if (isDirectory) {
        return true;
    }
    if (excludePattern != null) {
        if (excludePattern.matcher(name).matches()) {
            return false;
        }
    }
    if (excludeExt != null) {
        String fname = file.getFileName().toLowerCase();
        for (String exclude : excludeExt) {
            if (fname.endsWith(""."" + exclude)) {
                return false;
            }
        }
    }
    if (includePattern != null) {
        if (!includePattern.matcher(name).matches()) {
            return false;
        }
    }
    if (includeExt != null) {
        String fname = file.getFileName().toLowerCase();
        boolean any = false;
        for (String include : includeExt) {
            any |= fname.endsWith(""."" + include);
        }
        if (!any) {
            return false;
        }
    }
    if (endpoint.getFileName() != null) {
        Exchange dummy = endpoint.createExchange(file);
        String result = evaluateFileExpression(dummy);
        if (result != null) {
            if (!name.equals(result)) {
                return false;
            }
        }
    }
    if (endpoint.getFilterFile() != null) {
        Exchange dummy = endpoint.createExchange(file);
        boolean matches = endpoint.getFilterFile().matches(dummy);
        if (!matches) {
            return false;
        }
    }
    if (endpoint.getDoneFileName() != null) {
        String doneFileName = endpoint.createDoneFileName(file.getAbsoluteFilePath());
        StringHelper.notEmpty(doneFileName, ""doneFileName"", endpoint);
        if (endpoint.isDoneFile(file.getFileNameOnly())) {
            LOG.trace(""Skipping done file: {}"", file);
            return false;
        }
        if (!isMatched(file, doneFileName, files)) {
            return false;
        }
    }
    return true;
}",java:S3776,39
"public static String asExclusiveReadLockKey(GenericFile file, String key){
    String path = file.getCopyFromAbsoluteFilePath() != null ? file.getCopyFromAbsoluteFilePath() : file.getAbsoluteFilePath();
    return asExclusiveReadLockKey(path, key);
}",java:S3740,38
"protected int doReceive(long timeout){
    int retryCounter = -1;
    boolean done = false;
    Throwable cause = null;
    int polledMessages = 0;
    PollingConsumerPollStrategy pollStrategy = getConsumer().getPollStrategy();
    boolean sendEmptyMessageWhenIdle = getConsumer().isSendEmptyMessageWhenIdle();
    StopWatch watch = new StopWatch();
    while (!done) {
        try {
            cause = null;
            done = true;
            if (isRunAllowed()) {
                if (retryCounter == -1) {
                    LOG.trace(""Starting to poll: {}"", this.getEndpoint());
                } else {
                    LOG.debug(""Retrying attempt {} to poll: {}"", retryCounter, this.getEndpoint());
                }
                boolean begin = pollStrategy.begin(getConsumer(), getEndpoint());
                if (begin) {
                    retryCounter++;
                    polledMessages = getConsumer().poll();
                    LOG.trace(""Polled {} messages"", polledMessages);
                    if (polledMessages == 0 && sendEmptyMessageWhenIdle) {
                        processEmptyMessage();
                        polledMessages = 1;
                    } else if (polledMessages == 0 && timeout > 0) {
                        done = false;
                    }
                    pollStrategy.commit(getConsumer(), getEndpoint(), polledMessages);
                } else {
                    LOG.debug(""Cannot begin polling as pollStrategy returned false: {}"", pollStrategy);
                }
            }
            LOG.trace(""Finished polling: {}"", this.getEndpoint());
        } catch (Exception e) {
            try {
                boolean retry = pollStrategy.rollback(getConsumer(), getEndpoint(), retryCounter, e);
                if (retry) {
                    done = false;
                } else {
                    cause = e;
                    done = true;
                }
            } catch (Exception t) {
                cause = t;
                done = true;
            }
        }
        if (!done && timeout > 0) {
            long left = timeout - watch.taken();
            long min = Math.min(left, delay);
            if (min > 0) {
                try {
                    sleep(min);
                } catch (InterruptedException e) {
                }
            } else {
                done = true;
            }
        }
    }
    if (cause != null) {
        throw RuntimeCamelException.wrapRuntimeCamelException(cause);
    }
    return polledMessages;
}",java:S3776,39
"protected void processExchange(Exchange exchange, String target) throws Exception{
    LOG.trace(""Processing file: {} for exchange: {}"", target, exchange);
    try {
        preWriteCheck(exchange);
        boolean writeAsTempAndRename = ObjectHelper.isNotEmpty(endpoint.getTempFileName());
        String tempTarget = null;
        boolean targetExists;
        if (writeAsTempAndRename) {
            tempTarget = createTempFileName(exchange, target);
            LOG.trace(""Writing using tempNameFile: {}"", tempTarget);
            if (endpoint.getFileExist() != GenericFileExist.TryRename && endpoint.isEagerDeleteTargetFile()) {
                targetExists = operations.existsFile(target);
                if (targetExists) {
                    LOG.trace(""EagerDeleteTargetFile, target exists"");
                    if (endpoint.getFileExist() == GenericFileExist.Ignore) {
                        LOG.trace(""An existing file already exists: {}. Ignore and do not override it."", target);
                        return;
                    } else if (endpoint.getFileExist() == GenericFileExist.Fail) {
                        throw new GenericFileOperationFailedException(""File already exist: "" + target + "". Cannot write new file."");
                    } else if (endpoint.getFileExist() == GenericFileExist.Move) {
                        this.endpoint.getMoveExistingFileStrategy().moveExistingFile(endpoint, operations, target);
                    } else if (endpoint.isEagerDeleteTargetFile() && endpoint.getFileExist() == GenericFileExist.Override) {
                        LOG.trace(""Eagerly deleting existing file: {}"", target);
                        if (!operations.deleteFile(target)) {
                            throw new GenericFileOperationFailedException(""Cannot delete file: "" + target);
                        }
                    }
                }
            }
            if (endpoint.getFileExist() != GenericFileExist.TryRename && operations.existsFile(tempTarget)) {
                LOG.trace(""Deleting existing temp file: {}"", tempTarget);
                if (!operations.deleteFile(tempTarget)) {
                    throw new GenericFileOperationFailedException(""Cannot delete file: "" + tempTarget);
                }
            }
        }
        writeFile(exchange, tempTarget != null ? tempTarget : target);
        if (tempTarget != null) {
            if (endpoint.getFileExist() != GenericFileExist.TryRename && !endpoint.isEagerDeleteTargetFile()) {
                targetExists = operations.existsFile(target);
                if (targetExists) {
                    LOG.trace(""Not using EagerDeleteTargetFile, target exists"");
                    if (endpoint.getFileExist() == GenericFileExist.Ignore) {
                        LOG.trace(""An existing file already exists: {}. Ignore and do not override it."", target);
                        return;
                    } else if (endpoint.getFileExist() == GenericFileExist.Fail) {
                        throw new GenericFileOperationFailedException(""File already exist: "" + target + "". Cannot write new file."");
                    } else if (endpoint.getFileExist() == GenericFileExist.Override) {
                        LOG.trace(""Deleting existing file: {}"", target);
                        if (!operations.deleteFile(target)) {
                            throw new GenericFileOperationFailedException(""Cannot delete file: "" + target);
                        }
                    }
                }
            }
            LOG.trace(""Renaming file: [{}] to: [{}]"", tempTarget, target);
            boolean renamed = operations.renameFile(tempTarget, target);
            if (!renamed) {
                throw new GenericFileOperationFailedException(""Cannot rename file from: "" + tempTarget + "" to: "" + target);
            }
        }
        if (endpoint.getDoneFileName() != null) {
            String doneFileName = endpoint.createDoneFileName(target);
            StringHelper.notEmpty(doneFileName, ""doneFileName"", endpoint);
            Exchange empty = new DefaultExchange(exchange);
            empty.getIn().setBody("""");
            LOG.trace(""Writing done file: [{}]"", doneFileName);
            if (operations.existsFile(doneFileName)) {
                if (!operations.deleteFile(doneFileName)) {
                    throw new GenericFileOperationFailedException(""Cannot delete existing done file: "" + doneFileName);
                }
            }
            writeFile(empty, doneFileName);
        }
        exchange.getIn().setHeader(FileConstants.FILE_NAME_PRODUCED, target);
    } catch (Exception e) {
        handleFailedWrite(exchange, e);
    }
    postWriteCheck(exchange);
}",java:S3776,39
"public void handleFailedWrite(Exchange exchange, Exception exception) throws Exception{
    throw exception;
}",java:S112,4
"public void preWriteCheck(Exchange exchange) throws Exception{
}",java:S112,4
"public String createFileName(Exchange exchange){
    String answer;
    Object value;
    Object overrule = exchange.getIn().getHeader(FileConstants.OVERRULE_FILE_NAME);
    if (overrule != null) {
        if (overrule instanceof Expression) {
            value = overrule;
        } else {
            value = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, overrule);
        }
    } else {
        value = exchange.getIn().getHeader(FileConstants.FILE_NAME);
    }
    if (overrule != null) {
        exchange.getIn().setHeader(FileConstants.FILE_NAME, value);
    }
    if (value instanceof String && StringHelper.hasStartToken((String) value, ""simple"")) {
        LOG.warn(""Simple expression: {} detected in header: {} of type String. This feature has been removed (see CAMEL-6748)."", value, FileConstants.FILE_NAME);
    }
    Expression expression = endpoint.getFileName();
    if (value instanceof Expression) {
        expression = (Expression) value;
    }
    String name;
    if (expression != null) {
        LOG.trace(""Filename evaluated as expression: {}"", expression);
        name = expression.evaluate(exchange, String.class);
    } else {
        name = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, value);
    }
    if (name != null && endpoint.isFlatten()) {
        int pos = Math.max(name.lastIndexOf('/'), name.lastIndexOf(""\\""));
        if (pos != -1) {
            name = name.substring(pos + 1);
        }
    }
    String endpointPath = endpoint.getConfiguration().getDirectory();
    String baseDir = """";
    if (endpointPath.length() > 0) {
        baseDir = endpointPath;
        boolean trailingSlash = endpointPath.endsWith(""/"") || endpointPath.endsWith(""\\"");
        if (!trailingSlash) {
            baseDir += getFileSeparator();
        }
    }
    if (name != null) {
        answer = baseDir + name;
    } else {
        answer = baseDir + endpoint.getGeneratedFileName(exchange.getIn());
    }
    if (endpoint.isJailStartingDirectory()) {
        String compatchAnswer = FileUtil.compactPath(answer);
        String compatchBaseDir = FileUtil.compactPath(baseDir);
        if (!compatchAnswer.startsWith(compatchBaseDir)) {
            throw new IllegalArgumentException(""Cannot write file with name: "" + compatchAnswer + "" as the filename is jailed to the starting directory: "" + compatchBaseDir);
        }
    }
    if (endpoint.getConfiguration().needToNormalize()) {
        answer = normalizePath(answer);
    }
    return answer;
}",java:S3776,39
"private void closeInternal() throws Exception{
    if (task != null) {
        task.cancel(true);
    }
    if (lock != null) {
        lock.release();
    }
    closeLockFile();
}",java:S112,4
"@Deprecated
public Object getLastOffset(){
    return offset;
}",java:S6355,48
"@Deprecated
public Object getLastOffset(){
    return files;
}",java:S6355,48
"public GenericFileProcessStrategy<File> createGenericFileProcessStrategy(CamelContext context, Map<String, Object> params){
    Expression moveExpression = (Expression) params.get(""move"");
    Expression moveFailedExpression = (Expression) params.get(""moveFailed"");
    Expression preMoveExpression = (Expression) params.get(""preMove"");
    boolean isNoop = params.get(""noop"") != null;
    boolean isDelete = params.get(""delete"") != null;
    boolean isMove = moveExpression != null || preMoveExpression != null || moveFailedExpression != null;
    if (isDelete) {
        GenericFileDeleteProcessStrategy<File> strategy = new GenericFileDeleteProcessStrategy<>();
        strategy.setExclusiveReadLockStrategy(getExclusiveReadLockStrategy(params));
        if (preMoveExpression != null) {
            GenericFileExpressionRenamer<File> renamer = new GenericFileExpressionRenamer<>();
            renamer.setExpression(preMoveExpression);
            strategy.setBeginRenamer(renamer);
        }
        if (moveFailedExpression != null) {
            GenericFileExpressionRenamer<File> renamer = new GenericFileExpressionRenamer<>();
            renamer.setExpression(moveFailedExpression);
            strategy.setFailureRenamer(renamer);
        }
        return strategy;
    } else if (isMove || isNoop) {
        GenericFileRenameProcessStrategy<File> strategy = new GenericFileRenameProcessStrategy<>();
        strategy.setExclusiveReadLockStrategy(getExclusiveReadLockStrategy(params));
        if (!isNoop) {
            if (moveExpression != null) {
                GenericFileExpressionRenamer<File> renamer = new GenericFileExpressionRenamer<>();
                renamer.setExpression(moveExpression);
                strategy.setCommitRenamer(renamer);
            } else {
                strategy.setCommitRenamer(getDefaultCommitRenamer(context));
            }
        }
        if (preMoveExpression != null) {
            GenericFileExpressionRenamer<File> renamer = new GenericFileExpressionRenamer<>();
            renamer.setExpression(preMoveExpression);
            strategy.setBeginRenamer(renamer);
        }
        if (moveFailedExpression != null) {
            GenericFileExpressionRenamer<File> renamer = new GenericFileExpressionRenamer<>();
            renamer.setExpression(moveFailedExpression);
            strategy.setFailureRenamer(renamer);
        }
        return strategy;
    } else {
        GenericFileRenameProcessStrategy<File> strategy = new GenericFileRenameProcessStrategy<>();
        strategy.setExclusiveReadLockStrategy(getExclusiveReadLockStrategy(params));
        strategy.setCommitRenamer(getDefaultCommitRenamer(context));
        return strategy;
    }
}",java:S3776,39
"protected void doReleaseExclusiveReadLock(GenericFile<File> file, Exchange exchange) throws Exception{
    if (!markerFile) {
        return;
    }
    boolean acquired = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_FILE_ACQUIRED), false, Boolean.class);
    if (acquired) {
        String lockFileName = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_FILE_NAME), String.class);
        File lock = new File(lockFileName);
        if (lock.exists()) {
            LOG.trace(""Unlocking file: {}"", lockFileName);
            boolean deleted = FileUtil.deleteFile(lock);
            LOG.trace(""Lock file: {} was deleted: {}"", lockFileName, deleted);
        }
    }
}",java:S112,4
"private static void deleteLockFiles(File dir, boolean recursive, boolean hiddenFilesEnabled, String endpointPath, GenericFileFilter<T> filter, GenericFileFilter<T> antFilter, Pattern excludePattern, Pattern includePattern){
    File[] files = dir.listFiles();
    if (files == null || files.length == 0) {
        return;
    }
    for (File file : files) {
        if (!hiddenFilesEnabled && file.getName().startsWith(""."")) {
            continue;
        }
        if (filter != null || antFilter != null || excludePattern != null || includePattern != null) {
            File targetFile = file;
            if (file.getName().endsWith(FileComponent.DEFAULT_LOCK_FILE_POSTFIX)) {
                String target = file.getName().substring(0, file.getName().length() - FileComponent.DEFAULT_LOCK_FILE_POSTFIX.length());
                if (file.getParent() != null) {
                    targetFile = new File(file.getParent(), target);
                } else {
                    targetFile = new File(target);
                }
            }
            boolean accept = acceptFile(targetFile, endpointPath, filter, antFilter, excludePattern, includePattern);
            if (!accept) {
                continue;
            }
        }
        if (file.getName().endsWith(FileComponent.DEFAULT_LOCK_FILE_POSTFIX)) {
            LOG.warn(""Deleting orphaned lock file: {}"", file);
            FileUtil.deleteFile(file);
        } else if (recursive && file.isDirectory()) {
            deleteLockFiles(file, true, hiddenFilesEnabled, endpointPath, filter, antFilter, excludePattern, includePattern);
        }
    }
}",java:S3776,39
"private static void deleteLockFiles(File dir, boolean recursive, boolean hiddenFilesEnabled, String endpointPath, GenericFileFilter<T> filter, GenericFileFilter<T> antFilter, Pattern excludePattern, Pattern includePattern){
    File[] files = dir.listFiles();
    if (files == null || files.length == 0) {
        return;
    }
    for (File file : files) {
        if (!hiddenFilesEnabled && file.getName().startsWith(""."")) {
            continue;
        }
        if (filter != null || antFilter != null || excludePattern != null || includePattern != null) {
            File targetFile = file;
            if (file.getName().endsWith(FileComponent.DEFAULT_LOCK_FILE_POSTFIX)) {
                String target = file.getName().substring(0, file.getName().length() - FileComponent.DEFAULT_LOCK_FILE_POSTFIX.length());
                if (file.getParent() != null) {
                    targetFile = new File(file.getParent(), target);
                } else {
                    targetFile = new File(target);
                }
            }
            boolean accept = acceptFile(targetFile, endpointPath, filter, antFilter, excludePattern, includePattern);
            if (!accept) {
                continue;
            }
        }
        if (file.getName().endsWith(FileComponent.DEFAULT_LOCK_FILE_POSTFIX)) {
            LOG.warn(""Deleting orphaned lock file: {}"", file);
            FileUtil.deleteFile(file);
        } else if (recursive && file.isDirectory()) {
            deleteLockFiles(file, true, hiddenFilesEnabled, endpointPath, filter, antFilter, excludePattern, includePattern);
        }
    }
}",java:S3740,38
"private static void deleteLockFiles(File dir, boolean recursive, boolean hiddenFilesEnabled, String endpointPath, GenericFileFilter<T> filter, GenericFileFilter<T> antFilter, Pattern excludePattern, Pattern includePattern){
    File[] files = dir.listFiles();
    if (files == null || files.length == 0) {
        return;
    }
    for (File file : files) {
        if (!hiddenFilesEnabled && file.getName().startsWith(""."")) {
            continue;
        }
        if (filter != null || antFilter != null || excludePattern != null || includePattern != null) {
            File targetFile = file;
            if (file.getName().endsWith(FileComponent.DEFAULT_LOCK_FILE_POSTFIX)) {
                String target = file.getName().substring(0, file.getName().length() - FileComponent.DEFAULT_LOCK_FILE_POSTFIX.length());
                if (file.getParent() != null) {
                    targetFile = new File(file.getParent(), target);
                } else {
                    targetFile = new File(target);
                }
            }
            boolean accept = acceptFile(targetFile, endpointPath, filter, antFilter, excludePattern, includePattern);
            if (!accept) {
                continue;
            }
        }
        if (file.getName().endsWith(FileComponent.DEFAULT_LOCK_FILE_POSTFIX)) {
            LOG.warn(""Deleting orphaned lock file: {}"", file);
            FileUtil.deleteFile(file);
        } else if (recursive && file.isDirectory()) {
            deleteLockFiles(file, true, hiddenFilesEnabled, endpointPath, filter, antFilter, excludePattern, includePattern);
        }
    }
}",java:S3740,38
"private static void deleteLockFiles(File dir, boolean recursive, boolean hiddenFilesEnabled, String endpointPath, GenericFileFilter<T> filter, GenericFileFilter<T> antFilter, Pattern excludePattern, Pattern includePattern){
    File[] files = dir.listFiles();
    if (files == null || files.length == 0) {
        return;
    }
    for (File file : files) {
        if (!hiddenFilesEnabled && file.getName().startsWith(""."")) {
            continue;
        }
        if (filter != null || antFilter != null || excludePattern != null || includePattern != null) {
            File targetFile = file;
            if (file.getName().endsWith(FileComponent.DEFAULT_LOCK_FILE_POSTFIX)) {
                String target = file.getName().substring(0, file.getName().length() - FileComponent.DEFAULT_LOCK_FILE_POSTFIX.length());
                if (file.getParent() != null) {
                    targetFile = new File(file.getParent(), target);
                } else {
                    targetFile = new File(target);
                }
            }
            boolean accept = acceptFile(targetFile, endpointPath, filter, antFilter, excludePattern, includePattern);
            if (!accept) {
                continue;
            }
        }
        if (file.getName().endsWith(FileComponent.DEFAULT_LOCK_FILE_POSTFIX)) {
            LOG.warn(""Deleting orphaned lock file: {}"", file);
            FileUtil.deleteFile(file);
        } else if (recursive && file.isDirectory()) {
            deleteLockFiles(file, true, hiddenFilesEnabled, endpointPath, filter, antFilter, excludePattern, includePattern);
        }
    }
}",java:S107,1
"private static String asReadLockKey(GenericFile file, String key){
    String path = file.getCopyFromAbsoluteFilePath() != null ? file.getCopyFromAbsoluteFilePath() : file.getAbsoluteFilePath();
    return path + ""-"" + key;
}",java:S3740,38
"private static void putValues(Map<String, Object> map, Record record){
    String[] columns = record.getColumns();
    for (String column : columns) {
        String value = record.getString(column);
        map.put(column, value);
    }
}",java:S6213,47
"public Parser createParser(Exchange exchange) throws Exception{
    Reader bodyReader = null;
    try {
        if (FlatpackType.fixed == type) {
            bodyReader = exchange.getIn().getMandatoryBody(Reader.class);
            return createFixedParser(resourceUri, bodyReader);
        } else {
            return createDelimitedParser(exchange);
        }
    } catch (Exception e) {
        IOHelper.close(bodyReader);
        throw e;
    }
}",java:S112,4
"protected DataSet resolveDataSet(Exchange exchange){
    if (exchange.getIn().getHeader(FlinkConstants.FLINK_DATASET_HEADER) != null) {
        return (DataSet) exchange.getIn().getHeader(FlinkConstants.FLINK_DATASET_HEADER);
    } else if (getEndpoint().getDataSet() != null) {
        return getEndpoint().getDataSet();
    } else {
        throw new IllegalStateException(""No DataSet defined"");
    }
}",java:S3740,38
"protected DataSetCallback resolveDataSetCallback(Exchange exchange){
    if (exchange.getIn().getHeader(FlinkConstants.FLINK_DATASET_CALLBACK_HEADER) != null) {
        return (DataSetCallback) exchange.getIn().getHeader(FlinkConstants.FLINK_DATASET_CALLBACK_HEADER);
    } else if (getEndpoint().getDataSetCallback() != null) {
        return getEndpoint().getDataSetCallback();
    } else {
        throw new IllegalStateException(""Cannot resolve DataSet callback."");
    }
}",java:S3740,38
"protected DataStream resolveDataStream(Exchange exchange){
    if (exchange.getIn().getHeader(FlinkConstants.FLINK_DATASTREAM_HEADER) != null) {
        return (DataStream) exchange.getIn().getHeader(FlinkConstants.FLINK_DATASTREAM_HEADER);
    } else if (getEndpoint().getDataStream() != null) {
        return getEndpoint().getDataStream();
    } else {
        throw new IllegalArgumentException(""No DataStream defined"");
    }
}",java:S3740,38
"protected DataStreamCallback resolveDataStreamCallback(Exchange exchange){
    if (exchange.getIn().getHeader(FlinkConstants.FLINK_DATASTREAM_CALLBACK_HEADER) != null) {
        return (DataStreamCallback) exchange.getIn().getHeader(FlinkConstants.FLINK_DATASTREAM_CALLBACK_HEADER);
    } else if (getEndpoint().getDataStreamCallback() != null) {
        return getEndpoint().getDataStreamCallback();
    } else {
        throw new IllegalArgumentException(""Cannot resolve DataStream callback."");
    }
}",java:S3740,38
"public HttpCoreContext send(String ediMessage, String requestUri, String subject, String from, String as2From, String as2To, AS2MessageStructure as2MessageStructure, ContentType ediMessageContentType, String ediMessageTransferEncoding, AS2SignatureAlgorithm signingAlgorithm, Certificate[] signingCertificateChain, PrivateKey signingPrivateKey, AS2CompressionAlgorithm compressionAlgorithm, String dispositionNotificationTo, String[] signedReceiptMicAlgorithms, AS2EncryptionAlgorithm encryptingAlgorithm, Certificate[] encryptingCertificateChain, String attachedFileName) throws HttpException{
    ObjectHelper.notNull(ediMessage, ""EDI Message"");
    ObjectHelper.notNull(requestUri, ""Request URI"");
    ObjectHelper.notNull(subject, ""Subject"");
    ObjectHelper.notNull(from, ""From"");
    ObjectHelper.notNull(as2From, ""AS2From"");
    ObjectHelper.notNull(as2To, ""AS2To"");
    ObjectHelper.notNull(as2MessageStructure, ""AS2 Message Structure"");
    ObjectHelper.notNull(ediMessageContentType, ""EDI Message Content Type"");
    HttpCoreContext httpContext = HttpCoreContext.create();
    httpContext.setAttribute(AS2ClientManager.REQUEST_URI, requestUri);
    httpContext.setAttribute(AS2ClientManager.SUBJECT, subject);
    httpContext.setAttribute(AS2ClientManager.FROM, from);
    httpContext.setAttribute(AS2ClientManager.AS2_FROM, as2From);
    httpContext.setAttribute(AS2ClientManager.AS2_TO, as2To);
    httpContext.setAttribute(AS2ClientManager.AS2_MESSAGE_STRUCTURE, as2MessageStructure);
    httpContext.setAttribute(AS2ClientManager.EDI_MESSAGE_CONTENT_TYPE, ediMessageContentType);
    httpContext.setAttribute(AS2ClientManager.EDI_MESSAGE_TRANSFER_ENCODING, ediMessageTransferEncoding);
    httpContext.setAttribute(AS2ClientManager.SIGNING_ALGORITHM, signingAlgorithm);
    httpContext.setAttribute(AS2ClientManager.SIGNING_CERTIFICATE_CHAIN, signingCertificateChain);
    httpContext.setAttribute(AS2ClientManager.SIGNING_PRIVATE_KEY, signingPrivateKey);
    httpContext.setAttribute(AS2ClientManager.COMPRESSION_ALGORITHM, compressionAlgorithm);
    httpContext.setAttribute(AS2ClientManager.DISPOSITION_NOTIFICATION_TO, dispositionNotificationTo);
    httpContext.setAttribute(AS2ClientManager.SIGNED_RECEIPT_MIC_ALGORITHMS, signedReceiptMicAlgorithms);
    httpContext.setAttribute(AS2ClientManager.ENCRYPTING_ALGORITHM, encryptingAlgorithm);
    httpContext.setAttribute(AS2ClientManager.ENCRYPTING_CERTIFICATE_CHAIN, encryptingCertificateChain);
    BasicHttpEntityEnclosingRequest request = new BasicHttpEntityEnclosingRequest(""POST"", requestUri);
    httpContext.setAttribute(HTTP_REQUEST, request);
    ApplicationEntity applicationEntity;
    try {
        applicationEntity = EntityUtils.createEDIEntity(ediMessage, ediMessageContentType, ediMessageTransferEncoding, false, attachedFileName);
    } catch (Exception e) {
        throw new HttpException(""Failed to create EDI message entity"", e);
    }
    switch(as2MessageStructure) {
        case PLAIN:
            {
                applicationEntity.setMainBody(true);
                EntityUtils.setMessageEntity(request, applicationEntity);
                break;
            }
        case SIGNED:
            {
                AS2SignedDataGenerator signingGenerator = createSigningGenerator(httpContext);
                MultipartSignedEntity multipartSignedEntity = new MultipartSignedEntity(applicationEntity, signingGenerator, StandardCharsets.US_ASCII.name(), AS2TransferEncoding.BASE64, true, null);
                EntityUtils.setMessageEntity(request, multipartSignedEntity);
                break;
            }
        case ENCRYPTED:
            {
                CMSEnvelopedDataGenerator envelopedDataGenerator = createEncryptingGenerator(httpContext);
                OutputEncryptor encryptor = createEncryptor(httpContext);
                ApplicationPkcs7MimeEnvelopedDataEntity pkcs7MimeEnvelopedDataEntity = new ApplicationPkcs7MimeEnvelopedDataEntity(applicationEntity, envelopedDataGenerator, encryptor, AS2TransferEncoding.BASE64, true);
                EntityUtils.setMessageEntity(request, pkcs7MimeEnvelopedDataEntity);
                break;
            }
        case SIGNED_ENCRYPTED:
            {
                AS2SignedDataGenerator signingGenrator = createSigningGenerator(httpContext);
                MultipartSignedEntity multipartSignedEntity = new MultipartSignedEntity(applicationEntity, signingGenrator, StandardCharsets.US_ASCII.name(), AS2TransferEncoding.BASE64, false, null);
                CMSEnvelopedDataGenerator envelopedDataGenerator = createEncryptingGenerator(httpContext);
                OutputEncryptor encryptor = createEncryptor(httpContext);
                ApplicationPkcs7MimeEnvelopedDataEntity pkcs7MimeEnvelopedDataEntity = new ApplicationPkcs7MimeEnvelopedDataEntity(multipartSignedEntity, envelopedDataGenerator, encryptor, AS2TransferEncoding.BASE64, true);
                EntityUtils.setMessageEntity(request, pkcs7MimeEnvelopedDataEntity);
                break;
            }
        case PLAIN_COMPRESSED:
            {
                CMSCompressedDataGenerator compressedDataGenerator = createCompressorGenerator();
                OutputCompressor compressor = createCompressor(httpContext);
                ApplicationPkcs7MimeCompressedDataEntity pkcs7MimeCompressedDataEntity = new ApplicationPkcs7MimeCompressedDataEntity(applicationEntity, compressedDataGenerator, compressor, AS2TransferEncoding.BASE64, true);
                EntityUtils.setMessageEntity(request, pkcs7MimeCompressedDataEntity);
                break;
            }
        case SIGNED_COMPRESSED:
            {
                AS2SignedDataGenerator signingGenrator = createSigningGenerator(httpContext);
                MultipartSignedEntity multipartSignedEntity = new MultipartSignedEntity(applicationEntity, signingGenrator, StandardCharsets.US_ASCII.name(), AS2TransferEncoding.BASE64, false, null);
                CMSCompressedDataGenerator compressedDataGenerator = createCompressorGenerator();
                OutputCompressor compressor = createCompressor(httpContext);
                ApplicationPkcs7MimeCompressedDataEntity pkcs7MimeCompressedDataEntity = new ApplicationPkcs7MimeCompressedDataEntity(multipartSignedEntity, compressedDataGenerator, compressor, AS2TransferEncoding.BASE64, true);
                EntityUtils.setMessageEntity(request, pkcs7MimeCompressedDataEntity);
                break;
            }
        case ENCRYPTED_COMPRESSED:
            {
                CMSCompressedDataGenerator compressedDataGenerator = createCompressorGenerator();
                OutputCompressor compressor = createCompressor(httpContext);
                ApplicationPkcs7MimeCompressedDataEntity pkcs7MimeCompressedDataEntity = new ApplicationPkcs7MimeCompressedDataEntity(applicationEntity, compressedDataGenerator, compressor, AS2TransferEncoding.BASE64, false);
                CMSEnvelopedDataGenerator envelopedDataGenerator = createEncryptingGenerator(httpContext);
                OutputEncryptor encryptor = createEncryptor(httpContext);
                ApplicationPkcs7MimeEnvelopedDataEntity pkcs7MimeEnvelopedDataEntity = new ApplicationPkcs7MimeEnvelopedDataEntity(pkcs7MimeCompressedDataEntity, envelopedDataGenerator, encryptor, AS2TransferEncoding.BASE64, true);
                EntityUtils.setMessageEntity(request, pkcs7MimeEnvelopedDataEntity);
                break;
            }
        case ENCRYPTED_COMPRESSED_SIGNED:
            {
                AS2SignedDataGenerator signingGenrator = createSigningGenerator(httpContext);
                MultipartSignedEntity multipartSignedEntity = new MultipartSignedEntity(applicationEntity, signingGenrator, StandardCharsets.US_ASCII.name(), AS2TransferEncoding.BASE64, false, null);
                CMSCompressedDataGenerator compressedDataGenerator = createCompressorGenerator();
                OutputCompressor compressor = createCompressor(httpContext);
                ApplicationPkcs7MimeCompressedDataEntity pkcs7MimeCompressedDataEntity = new ApplicationPkcs7MimeCompressedDataEntity(multipartSignedEntity, compressedDataGenerator, compressor, AS2TransferEncoding.BASE64, false);
                CMSEnvelopedDataGenerator envelopedDataGenerator = createEncryptingGenerator(httpContext);
                OutputEncryptor encryptor = createEncryptor(httpContext);
                ApplicationPkcs7MimeEnvelopedDataEntity pkcs7MimeEnvelopedDataEntity = new ApplicationPkcs7MimeEnvelopedDataEntity(pkcs7MimeCompressedDataEntity, envelopedDataGenerator, encryptor, AS2TransferEncoding.BASE64, true);
                EntityUtils.setMessageEntity(request, pkcs7MimeEnvelopedDataEntity);
                break;
            }
        default:
            throw new HttpException(""Unknown AS2 Message Structure"");
    }
    HttpResponse response;
    try {
        httpContext.setAttribute(AS2_CONNECTION, as2ClientConnection);
        response = as2ClientConnection.send(request, httpContext);
        EntityParser.parseAS2MessageEntity(response);
    } catch (IOException e) {
        throw new HttpException(""Failed to send http request message"", e);
    } catch (ExecutionException | InterruptedException ex) {
        throw new HttpException(""Retrieving connection from Pool failed or timed out"", ex);
    }
    httpContext.setAttribute(HTTP_RESPONSE, response);
    return httpContext;
}",java:S107,1
"public DataSet getDataSet(){
    return ds;
}",java:S3740,38
"public void setDataSet(DataSet ds){
    this.ds = ds;
}",java:S3740,38
"public DataStream getDataStream(){
    return dataStream;
}",java:S3740,38
"public void setDataStream(DataStream dataStream){
    this.dataStream = dataStream;
}",java:S3740,38
"public DataSetCallback getDataSetCallback(){
    return dataSetCallback;
}",java:S3740,38
"public void setDataSetCallback(DataSetCallback dataSetCallback){
    this.dataSetCallback = dataSetCallback;
}",java:S3740,38
"public DataStreamCallback getDataStreamCallback(){
    return dataStreamCallback;
}",java:S3740,38
"public void setDataStreamCallback(DataStreamCallback dataStreamCallback){
    this.dataStreamCallback = dataStreamCallback;
}",java:S3740,38
"public DataSet getDataSet(){
    return dataSet;
}",java:S3740,38
"public DataStream getDataStream(){
    return dataStream;
}",java:S3740,38
"public void setDataSet(DataSet ds){
    this.dataSet = ds;
}",java:S3740,38
"public void setDataStream(DataStream ds){
    this.dataStream = ds;
}",java:S3740,38
"public DataSetCallback getDataSetCallback(){
    return dataSetCallback;
}",java:S3740,38
"public DataStreamCallback getDataStreamCallback(){
    return dataStreamCallback;
}",java:S3740,38
"public void setDataSetCallback(DataSetCallback dataSetCallback){
    this.dataSetCallback = dataSetCallback;
}",java:S3740,38
"public void setDataStreamCallback(DataStreamCallback dataStreamCallback){
    this.dataStreamCallback = dataStreamCallback;
}",java:S3740,38
"public void setConfiguration(Configuration configuration){
    this.configuration = configuration;
}",java:S2886,33
"private FTPFileEntryParser createFileEntryParser(String key, FTPClientConfig config){
    FTPFileEntryParser parser = null;
    if (JAVA_QUALIFIED_NAME_PATTERN.matcher(key).matches()) {
        Class<?> parserClass = ocr.resolveClass(key);
        try {
            parser = (FTPFileEntryParser) parserClass.newInstance();
        } catch (ClassCastException e) {
            throw new ParserInitializationException(parserClass.getName() + "" does not implement the interface "" + ""org.apache.commons.net.ftp.FTPFileEntryParser."", e);
        } catch (Exception | ExceptionInInitializerError e) {
            throw new ParserInitializationException(""Error initializing parser"", e);
        }
    }
    if (parser == null) {
        final String ukey = key.toUpperCase(java.util.Locale.ENGLISH);
        if (ukey.indexOf(FTPClientConfig.SYST_UNIX_TRIM_LEADING) >= 0) {
            parser = new UnixFTPEntryParser(config, true);
        } else if (ukey.indexOf(FTPClientConfig.SYST_UNIX) >= 0 || ukey.indexOf(""LINUX"") >= 0) {
            parser = new UnixFTPEntryParser(config, false);
        } else if (ukey.indexOf(FTPClientConfig.SYST_VMS) >= 0) {
            parser = new VMSVersioningFTPEntryParser(config);
        } else if (ukey.indexOf(FTPClientConfig.SYST_NT) >= 0 || ukey.indexOf(""WIN32"") >= 0) {
            parser = createNTFTPEntryParser(config);
        } else if (ukey.indexOf(FTPClientConfig.SYST_OS2) >= 0) {
            parser = new OS2FTPEntryParser(config);
        } else if (ukey.indexOf(FTPClientConfig.SYST_OS400) >= 0 || ukey.indexOf(FTPClientConfig.SYST_AS400) >= 0) {
            parser = createOS400FTPEntryParser(config);
        } else if (ukey.indexOf(FTPClientConfig.SYST_MVS) >= 0) {
            parser = new MVSFTPEntryParser();
        } else if (ukey.indexOf(FTPClientConfig.SYST_NETWARE) >= 0) {
            parser = new NetwareFTPEntryParser(config);
        } else if (ukey.indexOf(FTPClientConfig.SYST_MACOS_PETER) >= 0) {
            parser = new MacOsPeterFTPEntryParser(config);
        } else if (ukey.indexOf(FTPClientConfig.SYST_L8) >= 0) {
            parser = new UnixFTPEntryParser(config);
        } else {
            throw new ParserInitializationException(""Unknown parser type: "" + key);
        }
    }
    if (parser instanceof Configurable) {
        ((Configurable) parser).configure(config);
    }
    return parser;
}",java:S3776,39
"private FTPFileEntryParser createFileEntryParser(String key, FTPClientConfig config){
    FTPFileEntryParser parser = null;
    if (JAVA_QUALIFIED_NAME_PATTERN.matcher(key).matches()) {
        Class<?> parserClass = ocr.resolveClass(key);
        try {
            parser = (FTPFileEntryParser) parserClass.newInstance();
        } catch (ClassCastException e) {
            throw new ParserInitializationException(parserClass.getName() + "" does not implement the interface "" + ""org.apache.commons.net.ftp.FTPFileEntryParser."", e);
        } catch (Exception | ExceptionInInitializerError e) {
            throw new ParserInitializationException(""Error initializing parser"", e);
        }
    }
    if (parser == null) {
        final String ukey = key.toUpperCase(java.util.Locale.ENGLISH);
        if (ukey.indexOf(FTPClientConfig.SYST_UNIX_TRIM_LEADING) >= 0) {
            parser = new UnixFTPEntryParser(config, true);
        } else if (ukey.indexOf(FTPClientConfig.SYST_UNIX) >= 0 || ukey.indexOf(""LINUX"") >= 0) {
            parser = new UnixFTPEntryParser(config, false);
        } else if (ukey.indexOf(FTPClientConfig.SYST_VMS) >= 0) {
            parser = new VMSVersioningFTPEntryParser(config);
        } else if (ukey.indexOf(FTPClientConfig.SYST_NT) >= 0 || ukey.indexOf(""WIN32"") >= 0) {
            parser = createNTFTPEntryParser(config);
        } else if (ukey.indexOf(FTPClientConfig.SYST_OS2) >= 0) {
            parser = new OS2FTPEntryParser(config);
        } else if (ukey.indexOf(FTPClientConfig.SYST_OS400) >= 0 || ukey.indexOf(FTPClientConfig.SYST_AS400) >= 0) {
            parser = createOS400FTPEntryParser(config);
        } else if (ukey.indexOf(FTPClientConfig.SYST_MVS) >= 0) {
            parser = new MVSFTPEntryParser();
        } else if (ukey.indexOf(FTPClientConfig.SYST_NETWARE) >= 0) {
            parser = new NetwareFTPEntryParser(config);
        } else if (ukey.indexOf(FTPClientConfig.SYST_MACOS_PETER) >= 0) {
            parser = new MacOsPeterFTPEntryParser(config);
        } else if (ukey.indexOf(FTPClientConfig.SYST_L8) >= 0) {
            parser = new UnixFTPEntryParser(config);
        } else {
            throw new ParserInitializationException(""Unknown parser type: "" + key);
        }
    }
    if (parser instanceof Configurable) {
        ((Configurable) parser).configure(config);
    }
    return parser;
}",java:S2177,28
"private FTPFileEntryParser createNTFTPEntryParser(final FTPClientConfig config){
    if (config != null && FTPClientConfig.SYST_NT.equals(config.getServerSystemKey())) {
        return new NTFTPEntryParser(config);
    }
    final FTPClientConfig config2 = config != null ? new FTPClientConfig(config) : null;
    return new CompositeFileEntryParser(new FTPFileEntryParser[] { new NTFTPEntryParser(config), new UnixFTPEntryParser(config2, config2 != null && FTPClientConfig.SYST_UNIX_TRIM_LEADING.equals(config2.getServerSystemKey())) });
}",java:S2177,28
"private FTPFileEntryParser createOS400FTPEntryParser(final FTPClientConfig config){
    if (config != null && FTPClientConfig.SYST_OS400.equals(config.getServerSystemKey())) {
        return new OS400FTPEntryParser(config);
    }
    final FTPClientConfig config2 = config != null ? new FTPClientConfig(config) : null;
    return new CompositeFileEntryParser(new FTPFileEntryParser[] { new OS400FTPEntryParser(config), new UnixFTPEntryParser(config2, config2 != null && FTPClientConfig.SYST_UNIX_TRIM_LEADING.equals(config2.getServerSystemKey())) });
}",java:S2177,28
"public static String getAS2AlgorithmName(String jdkAlgorithmName){
    switch(jdkAlgorithmName) {
        case Constants.MD5_JDK_ALGORITHM_NAME:
            return Constants.MD5_AS2_ALGORITHM_NAME;
        case Constants.SHA_1_JDK_ALGORITHM_NAME:
            return Constants.SHA_1_AS2_ALGORITHM_NAME;
        default:
            return null;
    }
}",java:S1845,24
"protected FTPClient createFtpClient() throws Exception{
    FTPClient client = new FTPClient();
    ClassResolver cr = getCamelContext().getClassResolver();
    client.setParserFactory(new CamelFTPParserFactory(cr));
    return client;
}",java:S112,4
"protected boolean doConnect(RemoteFileConfiguration configuration, Exchange exchange) throws GenericFileOperationFailedException{
    log.trace(""Connecting using FTPClient: {}"", client);
    String host = configuration.getHost();
    String username = configuration.getUsername();
    String account = ((FtpConfiguration) configuration).getAccount();
    if (clientConfig != null) {
        log.trace(""Configuring FTPClient with config: {}"", clientConfig);
        client.configure(clientConfig);
    }
    if (endpoint.getSoTimeout() > 0) {
        client.setDefaultTimeout(endpoint.getSoTimeout());
    }
    if (log.isTraceEnabled()) {
        log.trace(""Connecting to {} using connection timeout: {}"", configuration.remoteServerInformation(), client.getConnectTimeout());
    }
    BlockingTask task = Tasks.foregroundTask().withBudget(Budgets.iterationBudget().withMaxIterations(Budgets.atLeastOnce(endpoint.getMaximumReconnectAttempts())).withInterval(Duration.ofMillis(endpoint.getReconnectDelay())).build()).build();
    TaskPayload payload = new TaskPayload(configuration);
    if (!task.run(this::tryConnect, payload)) {
        if (exchange != null) {
            exchange.getIn().setHeader(FtpConstants.FTP_REPLY_CODE, client.getReplyCode());
            exchange.getIn().setHeader(FtpConstants.FTP_REPLY_STRING, client.getReplyString());
        }
        if (payload.exception != null) {
            if (payload.exception instanceof GenericFileOperationFailedException) {
                throw (GenericFileOperationFailedException) payload.exception;
            } else {
                throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), payload.exception.getMessage(), payload.exception);
            }
        } else {
            throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), ""Server refused connection"");
        }
    }
    clientActivityListener.onConnected(host);
    if (configuration.isPassiveMode()) {
        log.trace(""Using passive mode connections"");
        client.enterLocalPassiveMode();
    }
    if (endpoint.getSoTimeout() > 0) {
        log.trace(""Using SoTimeout={}"", endpoint.getSoTimeout());
        try {
            client.setSoTimeout(endpoint.getSoTimeout());
        } catch (IOException e) {
            throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);
        }
    }
    try {
        clientActivityListener.onLogin(host);
        boolean login;
        if (username != null) {
            if (account != null) {
                log.trace(""Attempting to login user: {} using password: ******** and account: {}"", username, account);
                login = client.login(username, configuration.getPassword(), account);
            } else {
                log.trace(""Attempting to login user: {} using password: ********"", username);
                login = client.login(username, configuration.getPassword());
            }
        } else {
            if (account != null) {
                log.trace(""Attempting to login anonymous using account: {}"", account);
                login = client.login(""anonymous"", """", account);
            } else {
                log.trace(""Attempting to login anonymous"");
                login = client.login(""anonymous"", """");
            }
        }
        log.trace(""User {} logged in: {}"", username != null ? username : ""anonymous"", login);
        if (!login) {
            String replyString = client.getReplyString();
            int replyCode = client.getReplyCode();
            clientActivityListener.onLoginFailed(replyCode, replyString);
            client.disconnect();
            throw new GenericFileOperationFailedException(replyCode, replyString);
        }
        clientActivityListener.onLoginComplete(host);
        client.setFileType(configuration.isBinary() ? FTP.BINARY_FILE_TYPE : FTP.ASCII_FILE_TYPE);
    } catch (IOException e) {
        throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);
    } finally {
        if (exchange != null) {
            exchange.getIn().setHeader(FtpConstants.FTP_REPLY_CODE, client.getReplyCode());
            exchange.getIn().setHeader(FtpConstants.FTP_REPLY_STRING, client.getReplyString());
        }
    }
    if (endpoint.getConfiguration().getSiteCommand() != null) {
        Iterator<?> it = ObjectHelper.createIterator(endpoint.getConfiguration().getSiteCommand(), ""\n"");
        while (it.hasNext()) {
            Object next = it.next();
            String command = endpoint.getCamelContext().getTypeConverter().convertTo(String.class, next);
            log.trace(""Site command to send: {}"", command);
            if (command != null) {
                boolean result = sendSiteCommand(command);
                if (!result) {
                    throw new GenericFileOperationFailedException(""Site command: "" + command + "" returned false"");
                }
            }
        }
    }
    return true;
}",java:S3776,39
"private boolean doStoreFile(String name, String targetName, Exchange exchange) throws GenericFileOperationFailedException{
    log.trace(""doStoreFile({})"", targetName);
    boolean existFile = false;
    if (endpoint.getFileExist() == GenericFileExist.Ignore || endpoint.getFileExist() == GenericFileExist.Fail || endpoint.getFileExist() == GenericFileExist.Move || endpoint.getFileExist() == GenericFileExist.Append) {
        existFile = existsFile(targetName);
        if (existFile && endpoint.getFileExist() == GenericFileExist.Ignore) {
            log.trace(""An existing file already exists: {}. Ignore and do not override it."", name);
            return true;
        } else if (existFile && endpoint.getFileExist() == GenericFileExist.Fail) {
            throw new GenericFileOperationFailedException(""File already exist: "" + name + "". Cannot write new file."");
        } else if (existFile && endpoint.getFileExist() == GenericFileExist.Move) {
            this.endpoint.getMoveExistingFileStrategy().moveExistingFile(endpoint, this, targetName);
        }
    }
    InputStream is = null;
    if (exchange.getIn().getBody() == null) {
        if (endpoint.isAllowNullBody()) {
            log.trace(""Writing empty file."");
            is = new ByteArrayInputStream(new byte[] {});
        } else {
            throw new GenericFileOperationFailedException(""Cannot write null body to file: "" + name);
        }
    }
    try {
        if (is == null) {
            String charset = endpoint.getCharset();
            if (charset != null) {
                is = new ByteArrayInputStream(exchange.getIn().getMandatoryBody(String.class).getBytes(charset));
                log.trace(""Using InputStream {} with charset {}."", is, charset);
            } else {
                is = exchange.getIn().getMandatoryBody(InputStream.class);
            }
        }
        final StopWatch watch = new StopWatch();
        boolean answer;
        log.debug(""About to store file: {} using stream: {}"", targetName, is);
        if (existFile && endpoint.getFileExist() == GenericFileExist.Append) {
            log.trace(""Client appendFile: {}"", targetName);
            answer = client.appendFile(targetName, is);
        } else {
            log.trace(""Client storeFile: {}"", targetName);
            answer = client.storeFile(targetName, is);
        }
        if (log.isDebugEnabled()) {
            long time = watch.taken();
            log.debug(""Took {} ({} millis) to store file: {} and FTP client returned: {}"", TimeUtils.printDuration(time, true), time, targetName, answer);
        }
        exchange.getIn().setHeader(FtpConstants.FTP_REPLY_CODE, client.getReplyCode());
        exchange.getIn().setHeader(FtpConstants.FTP_REPLY_STRING, client.getReplyString());
        String chmod = endpoint.getConfiguration().getChmod();
        if (org.apache.camel.util.ObjectHelper.isNotEmpty(chmod)) {
            log.debug(""Setting chmod: {} on file: {}"", chmod, targetName);
            String command = ""chmod "" + chmod + "" "" + targetName;
            log.trace(""Client sendSiteCommand: {}"", command);
            boolean success = client.sendSiteCommand(command);
            log.trace(""Client sendSiteCommand successful: {}"", success);
        }
        return answer;
    } catch (IOException e) {
        throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);
    } catch (InvalidPayloadException e) {
        throw new GenericFileOperationFailedException(""Cannot store file: "" + name, e);
    } finally {
        IOHelper.close(is, ""store: "" + name, log);
    }
}",java:S3776,39
"public static String compactPath(String path){
    if (path == null) {
        return null;
    }
    if (path.indexOf(File.separator) == -1) {
        return path;
    }
    boolean endsWithSlash = path.endsWith(""/"") || path.endsWith(""\\"");
    boolean startsWithSlash = path.startsWith(""/"") || path.startsWith(""\\"");
    Deque<String> stack = new ArrayDeque<>();
    String separatorRegex = File.separator;
    if (FileUtil.isWindows()) {
        separatorRegex = ""\\\\"";
    }
    String[] parts = path.split(separatorRegex);
    for (String part : parts) {
        if (part.equals("".."") && !stack.isEmpty() && !"".."".equals(stack.peek())) {
            stack.pop();
        } else if (part.equals(""."") || part.isEmpty()) {
        } else {
            stack.push(part);
        }
    }
    StringBuilder sb = new StringBuilder();
    if (startsWithSlash) {
        sb.append(File.separator);
    }
    for (Iterator<String> it = stack.descendingIterator(); it.hasNext(); ) {
        sb.append(it.next());
        if (it.hasNext()) {
            sb.append(File.separator);
        }
    }
    if (endsWithSlash && !stack.isEmpty()) {
        sb.append(File.separator);
    }
    if (sb.length() >= 2) {
        boolean firstSlash = sb.charAt(0) == '/' || sb.charAt(0) == '\\';
        boolean secondSlash = sb.charAt(1) == '/' || sb.charAt(1) == '\\';
        if (firstSlash && secondSlash) {
            sb = sb.replace(1, 2, """");
        }
    }
    return sb.toString();
}",java:S3776,39
"@Deprecated
public String getPrivateKeyFilePassphrase(){
    return privateKeyPassphrase;
}",java:S6355,48
"@Deprecated
public void setPrivateKeyFilePassphrase(String privateKeyFilePassphrase){
    this.privateKeyPassphrase = privateKeyFilePassphrase;
}",java:S6355,48
"private RemoteFile<SftpRemoteFile> asRemoteFile(String absolutePath, SftpRemoteFile file, String charset){
    RemoteFile<SftpRemoteFile> answer = new RemoteFile<>();
    answer.setCharset(charset);
    answer.setEndpointPath(endpointPath);
    answer.setFile(file);
    answer.setFileNameOnly(file.getFilename());
    answer.setFileLength(file.getFileLength());
    answer.setLastModified(file.getLastModified());
    answer.setHostname(((RemoteFileConfiguration) endpoint.getConfiguration()).getHost());
    answer.setDirectory(file.isDirectory());
    boolean absolute = FileUtil.hasLeadingSeparator(absolutePath);
    answer.setAbsolute(absolute);
    String dir = FileUtil.stripTrailingSeparator(absolutePath);
    String absoluteFileName = FileUtil.stripLeadingSeparator(dir + ""/"" + file.getFilename());
    if (absolute) {
        absoluteFileName = ""/"" + absoluteFileName;
    }
    answer.setAbsoluteFilePath(absoluteFileName);
    String relativePath = StringHelper.after(absoluteFileName, endpointPath);
    relativePath = FileUtil.stripLeadingSeparator(relativePath);
    answer.setRelativeFilePath(relativePath);
    answer.setFileName(answer.getRelativeFilePath());
    return answer;
}",java:S3740,38
"private RemoteFile<SftpRemoteFile> asRemoteFile(String absolutePath, SftpRemoteFile file, String charset){
    RemoteFile<SftpRemoteFile> answer = new RemoteFile<>();
    answer.setCharset(charset);
    answer.setEndpointPath(endpointPath);
    answer.setFile(file);
    answer.setFileNameOnly(file.getFilename());
    answer.setFileLength(file.getFileLength());
    answer.setLastModified(file.getLastModified());
    answer.setHostname(((RemoteFileConfiguration) endpoint.getConfiguration()).getHost());
    answer.setDirectory(file.isDirectory());
    boolean absolute = FileUtil.hasLeadingSeparator(absolutePath);
    answer.setAbsolute(absolute);
    String dir = FileUtil.stripTrailingSeparator(absolutePath);
    String absoluteFileName = FileUtil.stripLeadingSeparator(dir + ""/"" + file.getFilename());
    if (absolute) {
        absoluteFileName = ""/"" + absoluteFileName;
    }
    answer.setAbsoluteFilePath(absoluteFileName);
    String relativePath = StringHelper.after(absoluteFileName, endpointPath);
    relativePath = FileUtil.stripLeadingSeparator(relativePath);
    answer.setRelativeFilePath(relativePath);
    answer.setFileName(answer.getRelativeFilePath());
    return answer;
}",java:S3740,38
"private boolean tryConnect(TaskPayload payload){
    if (LOG.isTraceEnabled()) {
        LOG.trace(""Reconnect attempt to {}"", payload.configuration.remoteServerInformation());
    }
    try {
        if (channel == null || !channel.isConnected()) {
            if (session == null || !session.isConnected()) {
                LOG.trace(""Session isn't connected, trying to recreate and connect."");
                session = createSession(payload.configuration);
                if (endpoint.getConfiguration().getConnectTimeout() > 0) {
                    LOG.trace(""Connecting use connectTimeout: {} ..."", endpoint.getConfiguration().getConnectTimeout());
                    session.connect(endpoint.getConfiguration().getConnectTimeout());
                } else {
                    LOG.trace(""Connecting ..."");
                    session.connect();
                }
            }
            LOG.trace(""Channel isn't connected, trying to recreate and connect."");
            channel = (ChannelSftp) session.openChannel(""sftp"");
            if (endpoint.getConfiguration().getFilenameEncoding() != null) {
                Charset ch = Charset.forName(endpoint.getConfiguration().getFilenameEncoding());
                LOG.trace(""Using filename encoding: {}"", ch);
                channel.setFilenameEncoding(ch);
            }
            if (endpoint.getConfiguration().getConnectTimeout() > 0) {
                LOG.trace(""Connecting use connectTimeout: {} ..."", endpoint.getConfiguration().getConnectTimeout());
                channel.connect(endpoint.getConfiguration().getConnectTimeout());
            } else {
                LOG.trace(""Connecting ..."");
                channel.connect();
            }
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connected to {}"", payload.configuration.remoteServerInformation());
            }
        }
    } catch (JSchException e) {
        payload.exception = e;
        return false;
    }
    return true;
}",java:S3776,39
"protected Session createSession(final RemoteFileConfiguration configuration) throws JSchException{
    final JSch jsch = new JSch();
    JSch.setLogger(new JSchLogger(endpoint.getConfiguration().getJschLoggingLevel()));
    SftpConfiguration sftpConfig = (SftpConfiguration) configuration;
    if (isNotEmpty(sftpConfig.getCiphers())) {
        LOG.debug(""Using ciphers: {}"", sftpConfig.getCiphers());
        Hashtable<String, String> ciphers = new Hashtable<>();
        ciphers.put(""cipher.s2c"", sftpConfig.getCiphers());
        ciphers.put(""cipher.c2s"", sftpConfig.getCiphers());
        JSch.setConfig(ciphers);
    }
    if (isNotEmpty(sftpConfig.getKeyExchangeProtocols())) {
        LOG.debug(""Using KEX: {}"", sftpConfig.getKeyExchangeProtocols());
        JSch.setConfig(""kex"", sftpConfig.getKeyExchangeProtocols());
    }
    if (isNotEmpty(sftpConfig.getPrivateKeyFile())) {
        LOG.debug(""Using private keyfile: {}"", sftpConfig.getPrivateKeyFile());
        if (isNotEmpty(sftpConfig.getPrivateKeyPassphrase())) {
            jsch.addIdentity(sftpConfig.getPrivateKeyFile(), sftpConfig.getPrivateKeyPassphrase());
        } else {
            jsch.addIdentity(sftpConfig.getPrivateKeyFile());
        }
    }
    if (sftpConfig.getPrivateKey() != null) {
        LOG.debug(""Using private key information from byte array"");
        byte[] passphrase = null;
        if (isNotEmpty(sftpConfig.getPrivateKeyPassphrase())) {
            passphrase = sftpConfig.getPrivateKeyPassphrase().getBytes(StandardCharsets.UTF_8);
        }
        jsch.addIdentity(""ID"", sftpConfig.getPrivateKey(), null, passphrase);
    }
    if (sftpConfig.getPrivateKeyUri() != null) {
        LOG.debug(""Using private key uri : {}"", sftpConfig.getPrivateKeyUri());
        byte[] passphrase = null;
        if (isNotEmpty(sftpConfig.getPrivateKeyPassphrase())) {
            passphrase = sftpConfig.getPrivateKeyPassphrase().getBytes(StandardCharsets.UTF_8);
        }
        try {
            InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(endpoint.getCamelContext(), sftpConfig.getPrivateKeyUri());
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            IOHelper.copyAndCloseInput(is, bos);
            jsch.addIdentity(""ID"", bos.toByteArray(), null, passphrase);
        } catch (IOException e) {
            throw new JSchException(""Cannot read resource: "" + sftpConfig.getPrivateKeyUri(), e);
        }
    }
    if (sftpConfig.getKeyPair() != null) {
        LOG.debug(""Using private key information from key pair"");
        KeyPair keyPair = sftpConfig.getKeyPair();
        if (keyPair.getPrivate() != null) {
            StringBuilder sb = new StringBuilder(256);
            sb.append(""-----BEGIN PRIVATE KEY-----"").append(""\n"");
            sb.append(Base64.getEncoder().encodeToString(keyPair.getPrivate().getEncoded())).append(""\n"");
            sb.append(""-----END PRIVATE KEY-----"").append(""\n"");
            jsch.addIdentity(""ID"", sb.toString().getBytes(StandardCharsets.UTF_8), null, null);
        } else {
            LOG.warn(""PrivateKey in the KeyPair must be filled"");
        }
    }
    if (isNotEmpty(sftpConfig.getKnownHostsFile())) {
        LOG.debug(""Using knownhosts file: {}"", sftpConfig.getKnownHostsFile());
        jsch.setKnownHosts(sftpConfig.getKnownHostsFile());
    }
    if (isNotEmpty(sftpConfig.getKnownHostsUri())) {
        LOG.debug(""Using known hosts uri: {}"", sftpConfig.getKnownHostsUri());
        try {
            InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(endpoint.getCamelContext(), sftpConfig.getKnownHostsUri());
            jsch.setKnownHosts(is);
        } catch (IOException e) {
            throw new JSchException(""Cannot read resource: "" + sftpConfig.getKnownHostsUri(), e);
        }
    }
    if (sftpConfig.getKnownHosts() != null) {
        LOG.debug(""Using known hosts information from byte array"");
        jsch.setKnownHosts(new ByteArrayInputStream(sftpConfig.getKnownHosts()));
    }
    String knownHostsFile = sftpConfig.getKnownHostsFile();
    if (knownHostsFile == null && sftpConfig.isUseUserKnownHostsFile()) {
        knownHostsFile = System.getProperty(""user.home"") + ""/.ssh/known_hosts"";
        LOG.info(""Known host file not configured, using user known host file: {}"", knownHostsFile);
    }
    if (ObjectHelper.isNotEmpty(knownHostsFile)) {
        LOG.debug(""Using known hosts information from file: {}"", knownHostsFile);
        jsch.setKnownHosts(knownHostsFile);
    }
    final Session session = jsch.getSession(configuration.getUsername(), configuration.getHost(), configuration.getPort());
    if (isNotEmpty(sftpConfig.getStrictHostKeyChecking())) {
        LOG.debug(""Using StrictHostKeyChecking: {}"", sftpConfig.getStrictHostKeyChecking());
        session.setConfig(""StrictHostKeyChecking"", sftpConfig.getStrictHostKeyChecking());
    }
    session.setServerAliveInterval(sftpConfig.getServerAliveInterval());
    session.setServerAliveCountMax(sftpConfig.getServerAliveCountMax());
    if (sftpConfig.getCompression() > 0) {
        LOG.debug(""Using compression: {}"", sftpConfig.getCompression());
        session.setConfig(""compression.s2c"", ""zlib@openssh.com,zlib,none"");
        session.setConfig(""compression.c2s"", ""zlib@openssh.com,zlib,none"");
        session.setConfig(""compression_level"", Integer.toString(sftpConfig.getCompression()));
    }
    if (sftpConfig.getPreferredAuthentications() != null) {
        LOG.debug(""Using PreferredAuthentications: {}"", sftpConfig.getPreferredAuthentications());
        session.setConfig(""PreferredAuthentications"", sftpConfig.getPreferredAuthentications());
    }
    if (sftpConfig.getServerHostKeys() != null) {
        LOG.debug(""Using ServerHostKeys: {}"", sftpConfig.getServerHostKeys());
        session.setConfig(""server_host_key"", sftpConfig.getServerHostKeys());
    }
    if (sftpConfig.getPublicKeyAcceptedAlgorithms() != null) {
        LOG.debug(""Using PublicKeyAcceptedAlgorithms: {}"", sftpConfig.getPublicKeyAcceptedAlgorithms());
        session.setConfig(""PubkeyAcceptedAlgorithms"", sftpConfig.getPublicKeyAcceptedAlgorithms());
    }
    session.setUserInfo(new ExtendedUserInfo() {

        public String getPassphrase() {
            return null;
        }

        public String getPassword() {
            return configuration.getPassword();
        }

        public boolean promptPassword(String s) {
            return true;
        }

        public boolean promptPassphrase(String s) {
            return true;
        }

        public boolean promptYesNo(String s) {
            LOG.warn(""Server asks for confirmation (yes|no): {}. Camel will answer no."", s);
            return false;
        }

        public void showMessage(String s) {
            LOG.trace(""Message received from Server: {}"", s);
        }

        public String[] promptKeyboardInteractive(String destination, String name, String instruction, String[] prompt, boolean[] echo) {
            if (configuration.getPassword() == null) {
                return new String[0];
            } else {
                return new String[] { configuration.getPassword() };
            }
        }
    });
    if (sftpConfig.getServerAliveInterval() == 0) {
        if (configuration.getSoTimeout() > 0) {
            session.setTimeout(configuration.getSoTimeout());
        }
    } else {
        LOG.debug(""The Server Alive Internal is already set, the socket timeout won't be considered to avoid overidding the provided Server alive interval value"");
    }
    if (proxy != null) {
        session.setProxy(proxy);
    }
    if (isNotEmpty(sftpConfig.getBindAddress())) {
        session.setSocketFactory(new SocketFactory() {

            @Override
            public OutputStream getOutputStream(Socket socket) throws IOException {
                return socket.getOutputStream();
            }

            @Override
            public InputStream getInputStream(Socket socket) throws IOException {
                return socket.getInputStream();
            }

            @Override
            public Socket createSocket(String host, int port) throws IOException {
                return createSocketUtil(host, port, sftpConfig.getBindAddress(), session.getTimeout());
            }
        });
    }
    return session;
}",java:S3776,39
"private boolean doStoreFile(String name, String targetName, Exchange exchange) throws GenericFileOperationFailedException{
    LOG.trace(""doStoreFile({})"", targetName);
    if (endpoint.getFileExist() == GenericFileExist.Ignore || endpoint.getFileExist() == GenericFileExist.Fail || endpoint.getFileExist() == GenericFileExist.Move) {
        boolean existFile = existsFile(targetName);
        if (existFile && endpoint.getFileExist() == GenericFileExist.Ignore) {
            LOG.trace(""An existing file already exists: {}. Ignore and do not override it."", name);
            return true;
        } else if (existFile && endpoint.getFileExist() == GenericFileExist.Fail) {
            throw new GenericFileOperationFailedException(""File already exist: "" + name + "". Cannot write new file."");
        } else if (existFile && endpoint.getFileExist() == GenericFileExist.Move) {
            this.endpoint.getMoveExistingFileStrategy().moveExistingFile(endpoint, this, targetName);
        }
    }
    InputStream is = null;
    if (exchange.getIn().getBody() == null) {
        if (endpoint.isAllowNullBody()) {
            LOG.trace(""Writing empty file."");
            is = new ByteArrayInputStream(new byte[] {});
        } else {
            throw new GenericFileOperationFailedException(""Cannot write null body to file: "" + name);
        }
    }
    try {
        if (is == null) {
            String charset = endpoint.getCharset();
            if (charset != null) {
                is = new ByteArrayInputStream(exchange.getIn().getMandatoryBody(String.class).getBytes(charset));
                LOG.trace(""Using InputStream {} with charset {}."", is, charset);
            } else {
                is = exchange.getIn().getMandatoryBody(InputStream.class);
            }
        }
        final StopWatch watch = new StopWatch();
        LOG.debug(""About to store file: {} using stream: {}"", targetName, is);
        if (endpoint.getFileExist() == GenericFileExist.Append) {
            LOG.trace(""Client appendFile: {}"", targetName);
            channel.put(is, targetName, ChannelSftp.APPEND);
        } else {
            LOG.trace(""Client storeFile: {}"", targetName);
            channel.put(is, targetName);
        }
        if (LOG.isDebugEnabled()) {
            long time = watch.taken();
            LOG.debug(""Took {} ({} millis) to store file: {} and FTP client returned: true"", TimeUtils.printDuration(time, true), time, targetName);
        }
        String mode = endpoint.getConfiguration().getChmod();
        if (ObjectHelper.isNotEmpty(mode)) {
            int permissions = Integer.parseInt(mode, 8);
            LOG.trace(""Setting chmod: {} on file: {}"", mode, targetName);
            channel.chmod(permissions, targetName);
        }
        createResultHeadersFromExchange(null, exchange);
        return true;
    } catch (SftpException e) {
        createResultHeadersFromExchange(e, exchange);
        throw new GenericFileOperationFailedException(""Cannot store file: "" + name, e);
    } catch (UnsupportedEncodingException | InvalidPayloadException e) {
        throw new GenericFileOperationFailedException(""Cannot store file: "" + name, e);
    } finally {
        IOHelper.close(is, ""store: "" + name, LOG);
    }
}",java:S3776,39
"protected void processCurrentLocation(Exchange exchange) throws Exception{
    LOG.debug(""Geolocation for current location"");
    GeolocationPayload payload = new GeolocationPayload();
    payload.considerIp = true;
    GeolocationResult result = GeolocationApi.geolocate(context, payload).await();
    LOG.debug(""Geolocation response {}"", result);
    exchange.getIn().setHeader(GeoCoderConstants.STATUS, GeocoderStatus.OK);
    String resLatlng = result.location.toString();
    exchange.getIn().setHeader(GeoCoderConstants.LATLNG, resLatlng);
    LOG.debug(""Geocode - reverse geocode for location {}"", resLatlng);
    GeocodingResult[] results = GeocodingApi.reverseGeocode(context, result.location).await();
    LOG.debug(""Geocode response {}"", results);
    if (results != null) {
        extractGeoResult(results, exchange);
    }
}",java:S112,4
"protected void doClone(String operation) throws GitAPIException{
    Git result = null;
    if (ObjectHelper.isEmpty(endpoint.getLocalPath())) {
        throw new IllegalArgumentException(""Local path must specified to execute "" + operation);
    }
    try {
        File localRepo = new File(endpoint.getLocalPath(), """");
        if (!localRepo.exists()) {
            if (ObjectHelper.isNotEmpty(endpoint.getUsername()) && ObjectHelper.isNotEmpty(endpoint.getPassword())) {
                UsernamePasswordCredentialsProvider credentials = new UsernamePasswordCredentialsProvider(endpoint.getUsername(), endpoint.getPassword());
                if (ObjectHelper.isEmpty(endpoint.getBranchName())) {
                    result = Git.cloneRepository().setCredentialsProvider(credentials).setURI(endpoint.getRemotePath()).setDirectory(new File(endpoint.getLocalPath(), """")).call();
                } else {
                    result = Git.cloneRepository().setCredentialsProvider(credentials).setURI(endpoint.getRemotePath()).setDirectory(new File(endpoint.getLocalPath(), """")).setBranch(endpoint.getBranchName()).call();
                }
            } else {
                if (ObjectHelper.isEmpty(endpoint.getBranchName())) {
                    result = Git.cloneRepository().setURI(endpoint.getRemotePath()).setDirectory(new File(endpoint.getLocalPath(), """")).call();
                } else {
                    result = Git.cloneRepository().setURI(endpoint.getRemotePath()).setDirectory(new File(endpoint.getLocalPath(), """")).setBranch(endpoint.getBranchName()).call();
                }
            }
        } else {
            throw new IllegalArgumentException(""The local repository directory already exists"");
        }
    } catch (GitAPIException e) {
        LOG.error(""There was an error in Git {} operation"", operation);
        throw e;
    } finally {
        if (ObjectHelper.isNotEmpty(result)) {
            result.close();
        }
    }
}",java:S3776,39
"private GoogleCredentials createFromFile() throws Exception{
    if (camelContext == null) {
        throw new CamelException(""CamelContext is null, but must be set when creating GoogleBigQueryConnectionFactory."");
    }
    try (InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext, serviceAccountKeyFile)) {
        GoogleCredentials credentials = GoogleCredentials.fromStream(is);
        if (credentials.createScopedRequired()) {
            credentials = credentials.createScoped(BigqueryScopes.all());
        }
        return credentials;
    }
}",java:S112,4
"private GoogleCredentials createDefault() throws Exception{
    GoogleCredentials credentials = GoogleCredentials.getApplicationDefault();
    Collection<String> scopes = Collections.singletonList(BigqueryScopes.BIGQUERY);
    if (credentials.createScopedRequired()) {
        credentials = credentials.createScoped(scopes);
    }
    return credentials;
}",java:S112,4
"private int process(String tableId, String partitionDecorator, String suffix, List<Exchange> exchanges, String exchangeId) throws Exception{
    String tableIdWithPartition = Strings.isNullOrEmpty(partitionDecorator) ? tableId : (tableId + ""$"" + partitionDecorator);
    List<InsertAllRequest.RowToInsert> apiRequestRows = new ArrayList<>();
    for (Exchange ex : exchanges) {
        Object entryObject = ex.getIn().getBody();
        if (entryObject instanceof List) {
            for (Map<String, Object> entry : (List<Map<String, Object>>) entryObject) {
                apiRequestRows.add(createRowRequest(null, entry));
            }
        } else if (entryObject instanceof Map) {
            apiRequestRows.add(createRowRequest(ex, (Map<String, Object>) entryObject));
        } else {
            ex.setException(new IllegalArgumentException(""Cannot handle body type "" + entryObject.getClass()));
        }
    }
    if (apiRequestRows.isEmpty()) {
        return 0;
    }
    InsertAllRequest.Builder builder = InsertAllRequest.newBuilder(configuration.getDatasetId(), tableIdWithPartition).setRows(apiRequestRows);
    if (ObjectHelper.isNotEmpty(suffix)) {
        builder.setTemplateSuffix(suffix);
    }
    InsertAllRequest insertAllRequest = builder.build();
    if (LOG.isTraceEnabled()) {
        LOG.trace(""Sending {} messages to bigquery table {}, suffix {}, partition {}"", apiRequestRows.size(), tableId, suffix, partitionDecorator);
    }
    InsertAllResponse apiResponse = bigquery.insertAll(insertAllRequest);
    if (apiResponse.getInsertErrors() != null && !apiResponse.getInsertErrors().isEmpty()) {
        throw new Exception(""InsertAll into "" + tableId + "" failed: "" + apiResponse.getInsertErrors());
    }
    if (LOG.isTraceEnabled()) {
        LOG.trace(""Sent {} messages to bigquery table {}, suffix {}, partition {}"", apiRequestRows.size(), tableId, suffix, partitionDecorator);
    }
    if (LOG.isDebugEnabled()) {
        LOG.debug(""uploader thread/id: {} / {} . api call completed."", Thread.currentThread().getId(), exchangeId);
    }
    return insertAllRequest.getRows().size();
}",java:S3776,39
"private Long executeSQL(JobId jobId, String translatedQuery, Map<String, Object> queryParameters) throws Exception{
    QueryJobConfiguration.Builder builder = QueryJobConfiguration.newBuilder(translatedQuery).setUseLegacySql(false);
    setQueryParameters(queryParameters, builder);
    QueryJobConfiguration queryJobConfiguration = builder.build();
    try {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Sending query to bigquery standard sql: {}"", translatedQuery);
        }
        JobId queryJobId;
        if (ObjectHelper.isNotEmpty(jobId)) {
            queryJobId = jobId;
        } else {
            queryJobId = JobId.of(configuration.getProjectId(), UUID.randomUUID().toString());
        }
        Job job = bigquery.create(JobInfo.of(queryJobId, queryJobConfiguration)).waitFor();
        JobStatistics.QueryStatistics statistics = job.getStatistics();
        TableResult result = job.getQueryResults();
        Long numAffectedRows = statistics.getNumDmlAffectedRows();
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Query {} - Affected rows {} - Result {}"", translatedQuery, numAffectedRows, result);
        }
        if (numAffectedRows != null) {
            return numAffectedRows;
        }
        return result.getTotalRows();
    } catch (JobException e) {
        throw new Exception(""Query "" + translatedQuery + "" failed: "" + e.getErrors(), e);
    } catch (BigQueryException e) {
        throw new Exception(""Query "" + translatedQuery + "" failed: "" + e.getError(), e);
    }
}",java:S112,4
"public ContentType createMultipartSignedContentType(String boundary){
    StringBuilder header = new StringBuilder(AS2MediaType.MULTIPART_SIGNED);
    header.append(""; boundary="").append(boundary);
    Set<String> micAlgSet = new HashSet<>();
    for (@SuppressWarnings(""rawtypes"") Iterator it = _signers.iterator(); it.hasNext(); ) {
        SignerInformation signer = (SignerInformation) it.next();
        ASN1ObjectIdentifier digestOID = signer.getDigestAlgorithmID().getAlgorithm();
        String micAlg = STANDARD_MICALGS.get(digestOID);
        if (micAlg == null) {
            micAlgSet.add(""unknown"");
        } else {
            micAlgSet.add(micAlg);
        }
    }
    for (@SuppressWarnings(""rawtypes"") Iterator it = signerGens.iterator(); it.hasNext(); ) {
        SignerInfoGenerator signerInfoGen = (SignerInfoGenerator) it.next();
        ASN1ObjectIdentifier digestOID = signerInfoGen.getDigestAlgorithm().getAlgorithm();
        String micAlg = STANDARD_MICALGS.get(digestOID);
        if (micAlg == null) {
            micAlgSet.add(""unknown"");
        } else {
            micAlgSet.add(micAlg);
        }
    }
    int count = 0;
    for (String micAlg : micAlgSet) {
        if (count == 0) {
            if (micAlgSet.size() != 1) {
                header.append(""; micalg=\"""");
            } else {
                header.append(""; micalg="");
            }
        } else {
            header.append(',');
        }
        header.append(micAlg);
        count++;
    }
    if (count != 0) {
        if (micAlgSet.size() != 1) {
            header.append('\""');
        }
    }
    return ContentType.parse(header.toString());
}",java:S3776,39
"private static Drive getClient(Exchange exchange){
    GoogleDriveComponent component = exchange.getContext().getComponent(""google-drive"", GoogleDriveComponent.class);
    return component.getClient(component.getConfiguration());
}",java:S1144,10
"private void synchronousPull(String subscriptionName) throws ExecutionException, InterruptedException{
    while (isRunAllowed() && !isSuspendingOrSuspended()) {
        ApiFuture<PullResponse> synchronousPullResponseFuture = null;
        try (SubscriberStub subscriber = endpoint.getComponent().getSubscriberStub(endpoint)) {
            PullRequest pullRequest = PullRequest.newBuilder().setMaxMessages(endpoint.getMaxMessagesPerPoll()).setReturnImmediately(false).setSubscription(subscriptionName).build();
            synchronousPullResponseFuture = subscriber.pullCallable().futureCall(pullRequest);
            pendingSynchronousPullResponses.add(synchronousPullResponseFuture);
            PullResponse pullResponse = synchronousPullResponseFuture.get();
            for (ReceivedMessage message : pullResponse.getReceivedMessagesList()) {
                PubsubMessage pubsubMessage = message.getMessage();
                Exchange exchange = createExchange(true);
                exchange.getIn().setBody(pubsubMessage.getData().toByteArray());
                exchange.getIn().setHeader(GooglePubsubConstants.ACK_ID, message.getAckId());
                exchange.getIn().setHeader(GooglePubsubConstants.MESSAGE_ID, pubsubMessage.getMessageId());
                exchange.getIn().setHeader(GooglePubsubConstants.PUBLISH_TIME, pubsubMessage.getPublishTime());
                if (null != pubsubMessage.getAttributesMap()) {
                    exchange.getIn().setHeader(GooglePubsubConstants.ATTRIBUTES, pubsubMessage.getAttributesMap());
                }
                if (endpoint.getAckMode() != GooglePubsubConstants.AckMode.NONE) {
                    exchange.getExchangeExtension().addOnCompletion(new AcknowledgeSync(() -> endpoint.getComponent().getSubscriberStub(endpoint), subscriptionName));
                }
                try {
                    processor.process(exchange);
                } catch (Exception e) {
                    getExceptionHandler().handleException(e);
                }
            }
        } catch (CancellationException e) {
            localLog.debug(""PubSub synchronous pull request cancelled"", e);
        } catch (IOException e) {
            localLog.error(""I/O exception while getting messages from PubSub. Reconnecting."", e);
        } catch (ExecutionException e) {
            if (e.getCause() instanceof ApiException && ((ApiException) (e.getCause())).isRetryable()) {
                localLog.error(""Retryable API exception in getting messages from PubSub"", e.getCause());
            } else {
                throw e;
            }
        } finally {
            if (synchronousPullResponseFuture != null) {
                pendingSynchronousPullResponses.remove(synchronousPullResponseFuture);
            }
        }
    }
}",java:S3776,39
"private void send(Exchange exchange) throws Exception{
    GooglePubsubEndpoint endpoint = (GooglePubsubEndpoint) getEndpoint();
    String topicName = String.format(""projects/%s/topics/%s"", endpoint.getProjectId(), endpoint.getDestinationName());
    Publisher publisher = endpoint.getComponent().getPublisher(topicName, endpoint);
    Object body = exchange.getIn().getBody();
    ByteString byteString;
    if (body instanceof String) {
        byteString = ByteString.copyFromUtf8((String) body);
    } else if (body instanceof byte[]) {
        byteString = ByteString.copyFrom((byte[]) body);
    } else {
        byteString = ByteString.copyFrom(endpoint.getSerializer().serialize(body));
    }
    PubsubMessage.Builder messageBuilder = PubsubMessage.newBuilder().setData(byteString);
    Map<String, String> attributes = exchange.getIn().getHeader(ATTRIBUTES, Map.class);
    if (attributes != null) {
        for (Map.Entry<String, String> attribute : attributes.entrySet()) {
            if (!attribute.getKey().startsWith(RESERVED_GOOGLE_CLIENT_ATTRIBUTE_PREFIX)) {
                messageBuilder.putAttributes(attribute.getKey(), attribute.getValue());
            }
        }
    }
    String orderingKey = exchange.getIn().getHeader(ORDERING_KEY, String.class);
    if (orderingKey != null) {
        messageBuilder.setOrderingKey(orderingKey);
    }
    PubsubMessage message = messageBuilder.build();
    ApiFuture<String> messageIdFuture = publisher.publish(message);
    exchange.getIn().setHeader(GooglePubsubConstants.MESSAGE_ID, messageIdFuture.get());
}",java:S112,4
"public static Storage create(CamelContext context, GoogleCloudStorageConfiguration configuration) throws Exception{
    if (!Strings.isNullOrEmpty(configuration.getServiceAccountKey())) {
        InputStream resolveMandatoryResourceAsInputStream = ResourceHelper.resolveMandatoryResourceAsInputStream(context, configuration.getServiceAccountKey());
        return StorageOptions.newBuilder().setCredentials(ServiceAccountCredentials.fromStream(resolveMandatoryResourceAsInputStream)).build().getService();
    } else {
        return StorageOptions.getDefaultInstance().getService();
    }
}",java:S112,4
"protected void createMessageListenerContainer() throws Exception{
    listenerContainer = getEndpoint().createMessageListenerContainer();
    getEndpoint().configureListenerContainer(listenerContainer, this);
    listenerContainer.setMessageListener(getEndpointMessageListener());
}",java:S112,4
"protected void createMessageListenerContainer() throws Exception{
    listenerContainer = getEndpoint().createMessageListenerContainer();
    getEndpoint().configureListenerContainer(listenerContainer, this);
    listenerContainer.setMessageListener(getEndpointMessageListener());
}",java:S1130,7
"public void configureListenerContainer(AbstractMessageListenerContainer listenerContainer, JmsConsumer consumer){
    if (destinationName != null) {
        String target = destinationName;
        if (getConfiguration().getArtemisConsumerPriority() != 0) {
            target += ""?consumer-priority="" + getConfiguration().getArtemisConsumerPriority();
        }
        listenerContainer.setDestinationName(target);
        LOG.debug(""Using destinationName: {} on listenerContainer: {}"", destinationName, listenerContainer);
    } else {
        DestinationResolver resolver = getDestinationResolver();
        if (resolver != null) {
            listenerContainer.setDestinationResolver(resolver);
        } else {
            throw new IllegalArgumentException(""Neither destination, destinationName or destinationResolver are specified on this endpoint!"");
        }
        LOG.debug(""Using destinationResolver: {} on listenerContainer: {}"", resolver, listenerContainer);
    }
    listenerContainer.setPubSubDomain(pubSubDomain);
    String consumerName = getThreadName();
    if (configuration.getTaskExecutor() != null) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Using custom TaskExecutor: {} on listener container: {}"", configuration.getTaskExecutor(), listenerContainer);
        }
        setContainerTaskExecutor(listenerContainer, configuration.getTaskExecutor());
        if (configuration.getTaskExecutor() instanceof ExecutorService) {
            consumer.setListenerContainerExecutorService((ExecutorService) configuration.getTaskExecutor(), false);
        }
    } else if (!(listenerContainer instanceof DefaultJmsMessageListenerContainer) || configuration.getDefaultTaskExecutorType() == null) {
        ExecutorService executor = getCamelContext().getExecutorServiceManager().newCachedThreadPool(consumer, consumerName);
        setContainerTaskExecutor(listenerContainer, executor);
        consumer.setListenerContainerExecutorService(executor, true);
    } else {
        LOG.debug(""Deferring creation of TaskExecutor for listener container: {} as per policy: {}"", listenerContainer, getDefaultTaskExecutorType());
    }
    if (configuration.getTransactionName() == null) {
        if (listenerContainer instanceof DefaultMessageListenerContainer) {
            ((DefaultMessageListenerContainer) listenerContainer).setTransactionName(consumerName);
        }
    }
    if (configuration.getDurableSubscriptionName() != null) {
        listenerContainer.setDurableSubscriptionName(configuration.getDurableSubscriptionName());
    } else if (configuration.isSubscriptionDurable()) {
        listenerContainer.setSubscriptionDurable(true);
    }
    if (configuration.getSubscriptionName() != null) {
        listenerContainer.setSubscriptionName(configuration.getSubscriptionName());
    }
    listenerContainer.setSubscriptionShared(configuration.isSubscriptionShared());
}",java:S3776,39
"protected void initReplyManager(){
    if (!started.get()) {
        synchronized (this) {
            if (started.get()) {
                return;
            }
            ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
            ClassLoader ac = endpoint.getCamelContext().getApplicationContextClassLoader();
            try {
                if (ac != null) {
                    Thread.currentThread().setContextClassLoader(ac);
                }
                if (endpoint.getReplyToType() != null) {
                    if (endpoint.getReplyTo() != null && endpoint.getReplyToType().equals(ReplyToType.Temporary.name())) {
                        throw new IllegalArgumentException(""ReplyToType "" + ReplyToType.Temporary + "" is not supported when replyTo "" + endpoint.getReplyTo() + "" is also configured."");
                    }
                }
                if (endpoint.getReplyTo() != null) {
                    replyManager = createReplyManager(endpoint.getReplyTo());
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Using JmsReplyManager: {} to process replies from: {}"", replyManager, endpoint.getReplyTo());
                    }
                } else {
                    replyManager = createReplyManager();
                    LOG.debug(""Using JmsReplyManager: {} to process replies from temporary queue"", replyManager);
                }
            } catch (Exception e) {
                throw new FailedToCreateProducerException(endpoint, e);
            } finally {
                Thread.currentThread().setContextClassLoader(oldClassLoader);
            }
            started.set(true);
        }
    }
}",java:S3776,39
"protected boolean processInOut(final Exchange exchange, final AsyncCallback callback){
    final org.apache.camel.Message in = exchange.getIn();
    String destinationName = in.getHeader(JmsConstants.JMS_DESTINATION_NAME, String.class);
    in.removeHeader(JmsConstants.JMS_DESTINATION_NAME);
    if (destinationName == null) {
        destinationName = endpoint.getDestinationName();
    }
    Destination destination = in.getHeader(JmsConstants.JMS_DESTINATION, Destination.class);
    in.removeHeader(JmsConstants.JMS_DESTINATION);
    if (destination != null) {
        destinationName = null;
    }
    initReplyManager();
    final long timeout = exchange.getIn().getHeader(JmsConstants.JMS_REQUEST_TIMEOUT, endpoint.getRequestTimeout(), long.class);
    final JmsConfiguration configuration = endpoint.getConfiguration();
    final boolean msgIdAsCorrId = configuration.isUseMessageIDAsCorrelationID();
    final String provisionalCorrelationId = msgIdAsCorrId ? getUuidGenerator().generateUuid() : null;
    MessageSentCallback messageSentCallback = null;
    if (msgIdAsCorrId) {
        messageSentCallback = new UseMessageIdAsCorrelationIdMessageSentCallback(replyManager, provisionalCorrelationId, timeout);
    }
    final String correlationProperty = configuration.getCorrelationProperty();
    final String correlationPropertyToUse = ofNullable(correlationProperty).orElse(JmsConstants.JMS_HEADER_CORRELATION_ID);
    final String originalCorrelationId = in.getHeader(correlationPropertyToUse, String.class);
    boolean generateFreshCorrId = ObjectHelper.isEmpty(originalCorrelationId) && !msgIdAsCorrId || originalCorrelationId != null && originalCorrelationId.startsWith(GENERATED_CORRELATION_ID_PREFIX);
    if (generateFreshCorrId) {
        in.setHeader(correlationPropertyToUse, GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid());
    }
    MessageCreator messageCreator = new MessageCreator() {

        public Message createMessage(Session session) throws JMSException {
            Message answer = endpoint.getBinding().makeJmsMessage(exchange, in, session, null);
            Destination replyTo = null;
            String replyToOverride = configuration.getReplyToOverride();
            if (replyToOverride != null) {
                replyTo = resolveOrCreateDestination(replyToOverride, session);
            } else {
                replyTo = replyManager.getReplyTo();
            }
            if (replyTo == null) {
                throw new RuntimeExchangeException(""Failed to resolve replyTo destination"", exchange);
            }
            JmsMessageHelper.setJMSReplyTo(answer, replyTo);
            replyManager.setReplyToSelectorHeader(in, answer);
            String correlationId = determineCorrelationId(answer, provisionalCorrelationId);
            replyManager.registerReply(replyManager, exchange, callback, originalCorrelationId, correlationId, timeout);
            if (correlationProperty != null) {
                replyManager.setCorrelationProperty(correlationProperty);
            }
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Using {}: {}, JMSReplyTo destination: {}, with request timeout: {} ms."", correlationPropertyToUse, correlationId, replyTo, timeout);
            }
            LOG.trace(""Created jakarta.jms.Message: {}"", answer);
            return answer;
        }
    };
    doSend(true, destinationName, destination, messageCreator, messageSentCallback);
    return false;
}",java:S3776,39
"protected boolean processInOnly(final Exchange exchange, final AsyncCallback callback){
    final org.apache.camel.Message in = exchange.getIn();
    String destinationName = in.getHeader(JmsConstants.JMS_DESTINATION_NAME, String.class);
    if (destinationName != null) {
        in.removeHeader(JmsConstants.JMS_DESTINATION_NAME);
    }
    if (destinationName == null) {
        destinationName = endpoint.getDestinationName();
    }
    Destination destination = in.getHeader(JmsConstants.JMS_DESTINATION, Destination.class);
    if (destination != null) {
        in.removeHeader(JmsConstants.JMS_DESTINATION);
    }
    if (destination != null) {
        destinationName = null;
    }
    final String to = destinationName != null ? destinationName : String.valueOf(destination);
    MessageSentCallback messageSentCallback = getEndpoint().getConfiguration().isIncludeSentJMSMessageID() ? new InOnlyMessageSentCallback(exchange) : null;
    MessageCreator messageCreator = new MessageCreator() {

        public Message createMessage(Session session) throws JMSException {
            Message answer = endpoint.getBinding().makeJmsMessage(exchange, in, session, null);
            Object jmsReplyTo = JmsMessageHelper.getJMSReplyTo(answer);
            if (endpoint.isDisableReplyTo()) {
                LOG.trace(""ReplyTo is disabled on endpoint: {}"", endpoint);
                JmsMessageHelper.setJMSReplyTo(answer, null);
            } else {
                if (jmsReplyTo == null) {
                    jmsReplyTo = exchange.getIn().getHeader(JmsConstants.JMS_HEADER_REPLY_TO, String.class);
                    if (jmsReplyTo == null) {
                        jmsReplyTo = endpoint.getReplyTo();
                    }
                }
            }
            if (jmsReplyTo != null && !(endpoint.isPreserveMessageQos() || endpoint.isExplicitQosEnabled())) {
                LOG.debug(""Disabling JMSReplyTo: {} for destination: {}. Use preserveMessageQos=true to force Camel to keep the JMSReplyTo on endpoint: {}"", jmsReplyTo, to, endpoint);
                jmsReplyTo = null;
            }
            if (jmsReplyTo instanceof String) {
                String replyTo = (String) jmsReplyTo;
                jmsReplyTo = resolveOrCreateDestination(replyTo, session);
            }
            Destination replyTo = null;
            String replyToOverride = endpoint.getConfiguration().getReplyToOverride();
            if (replyToOverride != null) {
                replyTo = resolveOrCreateDestination(replyToOverride, session);
            } else if (jmsReplyTo instanceof Destination) {
                replyTo = (Destination) jmsReplyTo;
            }
            if (replyTo != null) {
                LOG.debug(""Using JMSReplyTo destination: {}"", replyTo);
                JmsMessageHelper.setJMSReplyTo(answer, replyTo);
            } else {
                LOG.trace(""Not using JMSReplyTo"");
                JmsMessageHelper.setJMSReplyTo(answer, null);
            }
            LOG.trace(""Created jakarta.jms.Message: {}"", answer);
            return answer;
        }
    };
    doSend(false, destinationName, destination, messageCreator, messageSentCallback);
    setMessageId(exchange);
    callback.done(true);
    return true;
}",java:S3776,39
"protected ReplyManager createReplyManager() throws Exception{
    ReplyManager replyManager = new TemporaryQueueReplyManager(getEndpoint().getCamelContext());
    replyManager.setEndpoint(getEndpoint());
    String name = ""JmsReplyManagerTimeoutChecker["" + getEndpoint().getEndpointConfiguredDestinationName() + ""]"";
    ScheduledExecutorService replyManagerScheduledExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(name, name);
    replyManager.setScheduledExecutorService(replyManagerScheduledExecutorService);
    name = ""JmsReplyManagerOnTimeout["" + getEndpoint().getEndpointConfiguredDestinationName() + ""]"";
    int max = getEndpoint().getReplyToOnTimeoutMaxConcurrentConsumers();
    if (max <= 0) {
        throw new IllegalArgumentException(""The option replyToOnTimeoutMaxConcurrentConsumers must be >= 1"");
    }
    ExecutorService replyManagerExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newThreadPool(replyManager, name, 0, max);
    replyManager.setOnTimeoutExecutorService(replyManagerExecutorService);
    ServiceHelper.startService(replyManager);
    return replyManager;
}",java:S112,4
"protected ReplyManager createReplyManager(String replyTo) throws Exception{
    ReplyManager replyManager = new QueueReplyManager(getEndpoint().getCamelContext());
    replyManager.setEndpoint(getEndpoint());
    String name = ""JmsReplyManagerTimeoutChecker["" + replyTo + ""]"";
    ScheduledExecutorService replyManagerScheduledExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(name, name);
    replyManager.setScheduledExecutorService(replyManagerScheduledExecutorService);
    name = ""JmsReplyManagerOnTimeout["" + replyTo + ""]"";
    int max = getEndpoint().getReplyToOnTimeoutMaxConcurrentConsumers();
    if (max <= 0) {
        throw new IllegalArgumentException(""The option replyToOnTimeoutMaxConcurrentConsumers must be >= 1"");
    }
    ExecutorService replyManagerExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newThreadPool(replyManager, name, 0, max);
    replyManager.setOnTimeoutExecutorService(replyManagerExecutorService);
    ServiceHelper.startService(replyManager);
    return replyManager;
}",java:S112,4
"protected AbstractMessageListenerContainer createSimpleListenerContainer(){
    SimpleJmsMessageListenerContainer answer;
    ReplyToType type = endpoint.getConfiguration().getReplyToType();
    if (type == null) {
        type = ReplyToType.Shared;
    }
    if (ReplyToType.Shared == type) {
        String replyToSelectorName = endpoint.getReplyToDestinationSelectorName();
        if (replyToSelectorName != null) {
            replyToSelectorValue = ""ID:"" + new BigInteger(24 * 8, new Random()).toString(16);
            String fixedMessageSelector = replyToSelectorName + ""='"" + replyToSelectorValue + ""'"";
            answer = new SharedQueueSimpleMessageListenerContainer(endpoint, fixedMessageSelector);
            log.debug(""Using shared queue: {} with fixed message selector [{}] as reply listener: {}"", endpoint.getReplyTo(), fixedMessageSelector, answer);
        } else {
            throw new IllegalArgumentException(""ReplyToDestinationSelectorName must be configured when using Simple ReplyToConsumerType"");
        }
    } else if (ReplyToType.Exclusive == type) {
        answer = new ExclusiveQueueSimpleMessageListenerContainer(endpoint);
        log.debug(""Using exclusive queue: {} as reply listener: {}"", endpoint.getReplyTo(), answer);
    } else {
        throw new IllegalArgumentException(""ReplyToType "" + type + "" is not supported for reply queues"");
    }
    DestinationResolver resolver = endpoint.getDestinationResolver();
    if (resolver == null) {
        resolver = answer.getDestinationResolver();
    }
    answer.setDestinationResolver(new DestinationResolverDelegate(resolver));
    answer.setDestinationName(endpoint.getReplyTo());
    answer.setAutoStartup(true);
    answer.setMessageListener(this);
    answer.setPubSubDomain(false);
    answer.setSubscriptionDurable(false);
    answer.setConcurrentConsumers(endpoint.getReplyToConcurrentConsumers());
    answer.setConnectionFactory(endpoint.getConfiguration().getOrCreateConnectionFactory());
    String clientId = endpoint.getClientId();
    if (clientId != null) {
        clientId += "".CamelReplyManager"";
        answer.setClientId(clientId);
    }
    answer.setSessionTransacted(false);
    if (endpoint.getExceptionListener() != null) {
        answer.setExceptionListener(endpoint.getExceptionListener());
    }
    if (endpoint.getErrorHandler() != null) {
        answer.setErrorHandler(endpoint.getErrorHandler());
    } else {
        answer.setErrorHandler(new DefaultSpringErrorHandler(endpoint.getCamelContext(), QueueReplyManager.class, endpoint.getErrorHandlerLoggingLevel(), endpoint.isErrorHandlerLogStackTrace()));
    }
    if (endpoint.getTaskExecutor() != null) {
        log.debug(""Using custom TaskExecutor: {} on listener container: {}"", endpoint.getTaskExecutor(), answer);
        answer.setTaskExecutor(endpoint.getTaskExecutor());
    }
    String name = ""QueueReplyManager["" + answer.getDestinationName() + ""]"";
    answer.setBeanName(name);
    if (endpoint.getReplyToConcurrentConsumers() > 1) {
        if (ReplyToType.Shared == type) {
            log.warn(""Using {} concurrent consumer on {} with shared queue {} may not work properly with all message brokers."", endpoint.getReplyToConcurrentConsumers(), name, endpoint.getReplyTo());
        } else {
            log.info(""Using {} concurrent consumers on {}"", endpoint.getReplyToConcurrentConsumers(), name);
        }
    }
    return answer;
}",java:S3776,39
"protected DefaultMessageListenerContainer createDefaultListenerContainer() throws Exception{
    DefaultMessageListenerContainer answer;
    ReplyToType type = endpoint.getConfiguration().getReplyToType();
    if (type == null) {
        type = ReplyToType.Shared;
    }
    if (ReplyToType.Shared == type) {
        String replyToSelectorName = endpoint.getReplyToDestinationSelectorName();
        if (replyToSelectorName != null) {
            replyToSelectorValue = ""ID:"" + new BigInteger(24 * 8, new Random()).toString(16);
            String fixedMessageSelector = replyToSelectorName + ""='"" + replyToSelectorValue + ""'"";
            answer = new SharedQueueMessageListenerContainer(endpoint, fixedMessageSelector);
            log.debug(""Using shared queue: {} with fixed message selector [{}] as reply listener: {}"", endpoint.getReplyTo(), fixedMessageSelector, answer);
        } else {
            dynamicMessageSelector = new MessageSelectorCreator(correlation);
            answer = new SharedQueueMessageListenerContainer(endpoint, dynamicMessageSelector);
            log.debug(""Using shared queue: {} with dynamic message selector as reply listener: {}"", endpoint.getReplyTo(), answer);
        }
        log.warn(""{} is using a shared reply queue, which is not as fast as alternatives."" + "" See more detail at the section 'Request-reply over JMS' in the JMS component documentation"", endpoint);
    } else if (ReplyToType.Exclusive == type) {
        answer = new ExclusiveQueueMessageListenerContainer(endpoint);
        log.debug(""Using exclusive queue: {} as reply listener: {}"", endpoint.getReplyTo(), answer);
    } else {
        throw new IllegalArgumentException(""ReplyToType "" + type + "" is not supported for reply queues"");
    }
    String replyToCacheLevelName = endpoint.getConfiguration().getReplyToCacheLevelName();
    if (replyToCacheLevelName != null) {
        answer.setCacheLevelName(replyToCacheLevelName);
        log.debug(""Setting the replyCacheLevel to be {}"", replyToCacheLevelName);
    }
    DestinationResolver resolver = endpoint.getDestinationResolver();
    if (resolver == null) {
        resolver = answer.getDestinationResolver();
    }
    answer.setDestinationResolver(new DestinationResolverDelegate(resolver));
    answer.setDestinationName(endpoint.getReplyTo());
    answer.setAutoStartup(true);
    answer.setIdleConsumerLimit(endpoint.getIdleConsumerLimit());
    answer.setIdleTaskExecutionLimit(endpoint.getIdleTaskExecutionLimit());
    if (endpoint.getMaxMessagesPerTask() >= 0) {
        answer.setMaxMessagesPerTask(endpoint.getMaxMessagesPerTask());
    }
    answer.setMessageListener(this);
    answer.setPubSubDomain(false);
    answer.setSubscriptionDurable(false);
    answer.setConcurrentConsumers(endpoint.getReplyToConcurrentConsumers());
    if (endpoint.getReplyToMaxConcurrentConsumers() > 0) {
        answer.setMaxConcurrentConsumers(endpoint.getReplyToMaxConcurrentConsumers());
    }
    answer.setConnectionFactory(endpoint.getConfiguration().getOrCreateConnectionFactory());
    setupClientId(endpoint, answer);
    answer.setSessionTransacted(false);
    if (endpoint.getExceptionListener() != null) {
        answer.setExceptionListener(endpoint.getExceptionListener());
    }
    if (endpoint.getErrorHandler() != null) {
        answer.setErrorHandler(endpoint.getErrorHandler());
    } else {
        answer.setErrorHandler(new DefaultSpringErrorHandler(endpoint.getCamelContext(), QueueReplyManager.class, endpoint.getErrorHandlerLoggingLevel(), endpoint.isErrorHandlerLogStackTrace()));
    }
    if (endpoint.getReceiveTimeout() >= 0) {
        answer.setReceiveTimeout(endpoint.getReceiveTimeout());
    }
    if (endpoint.getRecoveryInterval() >= 0) {
        answer.setRecoveryInterval(endpoint.getRecoveryInterval());
    }
    if (endpoint.getTaskExecutor() != null) {
        log.debug(""Using custom TaskExecutor: {} on listener container: {}"", endpoint.getTaskExecutor(), answer);
        answer.setTaskExecutor(endpoint.getTaskExecutor());
    }
    String name = ""QueueReplyManager["" + answer.getDestinationName() + ""]"";
    answer.setBeanName(name);
    if (answer.getConcurrentConsumers() > 1) {
        if (ReplyToType.Shared == type) {
            log.warn(""Using {}-{} concurrent consumer on {} with shared queue {} may not work properly with all message brokers."", answer.getConcurrentConsumers(), answer.getMaxConcurrentConsumers(), name, endpoint.getReplyTo());
        } else {
            log.info(""Using {}-{} concurrent consumers on {}"", answer.getConcurrentConsumers(), answer.getMaxConcurrentConsumers(), name);
        }
    }
    return answer;
}",java:S3776,39
"protected DefaultMessageListenerContainer createDefaultListenerContainer() throws Exception{
    DefaultMessageListenerContainer answer;
    ReplyToType type = endpoint.getConfiguration().getReplyToType();
    if (type == null) {
        type = ReplyToType.Shared;
    }
    if (ReplyToType.Shared == type) {
        String replyToSelectorName = endpoint.getReplyToDestinationSelectorName();
        if (replyToSelectorName != null) {
            replyToSelectorValue = ""ID:"" + new BigInteger(24 * 8, new Random()).toString(16);
            String fixedMessageSelector = replyToSelectorName + ""='"" + replyToSelectorValue + ""'"";
            answer = new SharedQueueMessageListenerContainer(endpoint, fixedMessageSelector);
            log.debug(""Using shared queue: {} with fixed message selector [{}] as reply listener: {}"", endpoint.getReplyTo(), fixedMessageSelector, answer);
        } else {
            dynamicMessageSelector = new MessageSelectorCreator(correlation);
            answer = new SharedQueueMessageListenerContainer(endpoint, dynamicMessageSelector);
            log.debug(""Using shared queue: {} with dynamic message selector as reply listener: {}"", endpoint.getReplyTo(), answer);
        }
        log.warn(""{} is using a shared reply queue, which is not as fast as alternatives."" + "" See more detail at the section 'Request-reply over JMS' in the JMS component documentation"", endpoint);
    } else if (ReplyToType.Exclusive == type) {
        answer = new ExclusiveQueueMessageListenerContainer(endpoint);
        log.debug(""Using exclusive queue: {} as reply listener: {}"", endpoint.getReplyTo(), answer);
    } else {
        throw new IllegalArgumentException(""ReplyToType "" + type + "" is not supported for reply queues"");
    }
    String replyToCacheLevelName = endpoint.getConfiguration().getReplyToCacheLevelName();
    if (replyToCacheLevelName != null) {
        answer.setCacheLevelName(replyToCacheLevelName);
        log.debug(""Setting the replyCacheLevel to be {}"", replyToCacheLevelName);
    }
    DestinationResolver resolver = endpoint.getDestinationResolver();
    if (resolver == null) {
        resolver = answer.getDestinationResolver();
    }
    answer.setDestinationResolver(new DestinationResolverDelegate(resolver));
    answer.setDestinationName(endpoint.getReplyTo());
    answer.setAutoStartup(true);
    answer.setIdleConsumerLimit(endpoint.getIdleConsumerLimit());
    answer.setIdleTaskExecutionLimit(endpoint.getIdleTaskExecutionLimit());
    if (endpoint.getMaxMessagesPerTask() >= 0) {
        answer.setMaxMessagesPerTask(endpoint.getMaxMessagesPerTask());
    }
    answer.setMessageListener(this);
    answer.setPubSubDomain(false);
    answer.setSubscriptionDurable(false);
    answer.setConcurrentConsumers(endpoint.getReplyToConcurrentConsumers());
    if (endpoint.getReplyToMaxConcurrentConsumers() > 0) {
        answer.setMaxConcurrentConsumers(endpoint.getReplyToMaxConcurrentConsumers());
    }
    answer.setConnectionFactory(endpoint.getConfiguration().getOrCreateConnectionFactory());
    setupClientId(endpoint, answer);
    answer.setSessionTransacted(false);
    if (endpoint.getExceptionListener() != null) {
        answer.setExceptionListener(endpoint.getExceptionListener());
    }
    if (endpoint.getErrorHandler() != null) {
        answer.setErrorHandler(endpoint.getErrorHandler());
    } else {
        answer.setErrorHandler(new DefaultSpringErrorHandler(endpoint.getCamelContext(), QueueReplyManager.class, endpoint.getErrorHandlerLoggingLevel(), endpoint.isErrorHandlerLogStackTrace()));
    }
    if (endpoint.getReceiveTimeout() >= 0) {
        answer.setReceiveTimeout(endpoint.getReceiveTimeout());
    }
    if (endpoint.getRecoveryInterval() >= 0) {
        answer.setRecoveryInterval(endpoint.getRecoveryInterval());
    }
    if (endpoint.getTaskExecutor() != null) {
        log.debug(""Using custom TaskExecutor: {} on listener container: {}"", endpoint.getTaskExecutor(), answer);
        answer.setTaskExecutor(endpoint.getTaskExecutor());
    }
    String name = ""QueueReplyManager["" + answer.getDestinationName() + ""]"";
    answer.setBeanName(name);
    if (answer.getConcurrentConsumers() > 1) {
        if (ReplyToType.Shared == type) {
            log.warn(""Using {}-{} concurrent consumer on {} with shared queue {} may not work properly with all message brokers."", answer.getConcurrentConsumers(), answer.getMaxConcurrentConsumers(), name, endpoint.getReplyTo());
        } else {
            log.info(""Using {}-{} concurrent consumers on {}"", answer.getConcurrentConsumers(), answer.getMaxConcurrentConsumers(), name);
        }
    }
    return answer;
}",java:S112,4
"public static List<CharArrayBuffer> parseBodyPartFields(final AS2SessionInputBuffer inbuffer, final String boundary, final LineParser parser, final List<CharArrayBuffer> fields) throws IOException{
    ObjectHelper.notNull(parser, ""parser"");
    ObjectHelper.notNull(fields, ""fields"");
    CharArrayBuffer current = null;
    CharArrayBuffer previous = null;
    while (true) {
        if (current == null) {
            current = new CharArrayBuffer(64);
        }
        final int l = inbuffer.readLine(current);
        if (l == -1 || current.length() < 1) {
            break;
        }
        if (boundary != null && isBoundaryDelimiter(current, null, boundary)) {
            break;
        }
        if ((current.charAt(0) == ' ' || current.charAt(0) == '\t') && previous != null) {
            int i = 0;
            while (i < current.length()) {
                final char ch = current.charAt(i);
                if (ch != ' ' && ch != '\t') {
                    break;
                }
                i++;
            }
            previous.append(' ');
            previous.append(current, i, current.length() - i);
            current.clear();
        } else {
            fields.add(current);
            previous = current;
            current = null;
        }
    }
    return fields;
}",java:S3776,39
"protected AbstractMessageListenerContainer createDefaultListenerContainer() throws Exception{
    DefaultMessageListenerContainer answer = new DefaultJmsMessageListenerContainer(endpoint, endpoint.isAllowReplyManagerQuickStop());
    answer.setDestinationName(""temporary"");
    answer.setDestinationResolver(destResolver);
    answer.setAutoStartup(true);
    if (endpoint.getMaxMessagesPerTask() >= 0) {
        answer.setMaxMessagesPerTask(endpoint.getMaxMessagesPerTask());
    }
    answer.setIdleConsumerLimit(endpoint.getIdleConsumerLimit());
    answer.setIdleTaskExecutionLimit(endpoint.getIdleTaskExecutionLimit());
    answer.setMessageListener(this);
    answer.setPubSubDomain(false);
    answer.setSubscriptionDurable(false);
    answer.setConcurrentConsumers(endpoint.getReplyToConcurrentConsumers());
    if (endpoint.getReplyToMaxConcurrentConsumers() > 0) {
        answer.setMaxConcurrentConsumers(endpoint.getReplyToMaxConcurrentConsumers());
    }
    answer.setConnectionFactory(endpoint.getConfiguration().getOrCreateConnectionFactory());
    if (endpoint.getReplyToCacheLevelName() != null) {
        if (""CACHE_NONE"".equals(endpoint.getReplyToCacheLevelName())) {
            throw new IllegalArgumentException(""ReplyToCacheLevelName cannot be CACHE_NONE when using temporary reply queues. The value must be either CACHE_CONSUMER, or CACHE_SESSION"");
        }
        answer.setCacheLevelName(endpoint.getReplyToCacheLevelName());
    } else {
        answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER);
    }
    setupClientId(endpoint, answer);
    answer.setSessionTransacted(false);
    answer.setExceptionListener(new TemporaryReplyQueueExceptionListener(destResolver, endpoint.getExceptionListener()));
    if (endpoint.getErrorHandler() != null) {
        answer.setErrorHandler(endpoint.getErrorHandler());
    } else {
        answer.setErrorHandler(new DefaultSpringErrorHandler(endpoint.getCamelContext(), TemporaryQueueReplyManager.class, endpoint.getErrorHandlerLoggingLevel(), endpoint.isErrorHandlerLogStackTrace()));
    }
    if (endpoint.getReceiveTimeout() >= 0) {
        answer.setReceiveTimeout(endpoint.getReceiveTimeout());
    }
    if (endpoint.getRecoveryInterval() >= 0) {
        answer.setRecoveryInterval(endpoint.getRecoveryInterval());
    }
    if (endpoint.getTaskExecutor() != null) {
        if (log.isDebugEnabled()) {
            log.debug(""Using custom TaskExecutor: {} on listener container: {}"", endpoint.getTaskExecutor(), answer);
        }
        answer.setTaskExecutor(endpoint.getTaskExecutor());
    }
    String name = ""TemporaryQueueReplyManager["" + endpoint.getDestinationName() + ""]"";
    answer.setBeanName(name);
    if (answer.getConcurrentConsumers() > 1) {
        log.info(""Using {}-{} concurrent consumers on {}"", answer.getConcurrentConsumers(), answer.getMaxConcurrentConsumers(), name);
    }
    return answer;
}",java:S112,4
"protected void addNotificationListener() throws Exception{
    JMXEndpoint ep = getEndpoint();
    NotificationFilter nf = ep.getNotificationFilter();
    if (nf == null && ep.getObservedAttribute() != null) {
        LOG.debug(""Observing attribute: {}"", ep.getObservedAttribute());
        boolean match = !ep.isNotifyDiffer();
        nf = new JMXConsumerNotificationFilter(ep.getObservedAttribute(), ep.getStringToCompare(), match);
    }
    ObjectName objectName = ep.getJMXObjectName();
    getServerConnection().addNotificationListener(objectName, this, nf, ep.getHandback());
}",java:S112,4
"protected void removeNotificationListeners() throws Exception{
    getServerConnection().removeNotificationListener(mJmxEndpoint.getJMXObjectName(), this);
    if (mConnectionNotificationListener != null) {
        mConnector.removeConnectionNotificationListener(mConnectionNotificationListener);
        mConnectionNotificationListener = null;
    }
}",java:S112,4
"private Number convertNumberToAttributeType(Number toConvert, ObjectName jmxObjectName, String observedAttribute) throws InstanceNotFoundException, ReflectionException, AttributeNotFoundException, MBeanException{
    Object attr = ManagementFactory.getPlatformMBeanServer().getAttribute(jmxObjectName, observedAttribute);
    if (attr instanceof Byte) {
        return toConvert != null ? toConvert.byteValue() : null;
    } else if (attr instanceof Integer) {
        return toConvert != null ? toConvert.intValue() : null;
    } else if (attr instanceof Short) {
        return toConvert != null ? toConvert.shortValue() : null;
    } else if (attr instanceof Long) {
        return toConvert != null ? toConvert.longValue() : null;
    } else if (attr instanceof Float) {
        return toConvert != null ? toConvert.floatValue() : null;
    } else {
        return toConvert;
    }
}",java:S3776,39
"public String format(Notification aNotification) throws NotificationFormatException{
    ObjectHelper.notNull(jaxbContext, ""jaxbContext"");
    NotificationEventType jaxb;
    boolean wrap = false;
    if (aNotification instanceof AttributeChangeNotification) {
        AttributeChangeNotification ac = (AttributeChangeNotification) aNotification;
        jaxb = mObjectFactory.createAttributeChangeNotification().withAttributeName(ac.getAttributeName()).withAttributeType(ac.getAttributeType()).withNewValue(ac.getNewValue() == null ? null : String.valueOf(ac.getNewValue())).withOldValue(ac.getOldValue() == null ? null : String.valueOf(ac.getOldValue()));
    } else if (aNotification instanceof JMXConnectionNotification) {
        jaxb = mObjectFactory.createJMXConnectionNotification().withConnectionId(((JMXConnectionNotification) aNotification).getConnectionId());
    } else if (aNotification instanceof MBeanServerNotification) {
        jaxb = mObjectFactory.createMBeanServerNotification().withMBeanName(String.valueOf(((MBeanServerNotification) aNotification).getMBeanName()));
    } else if (aNotification instanceof MonitorNotification) {
        MonitorNotification mn = (MonitorNotification) aNotification;
        jaxb = mObjectFactory.createMonitorNotification().withDerivedGauge(String.valueOf(mn.getDerivedGauge())).withObservedAttribute(mn.getObservedAttribute()).withObservedObject(String.valueOf(mn.getObservedObject())).withTrigger(String.valueOf(mn.getTrigger()));
    } else if (aNotification instanceof RelationNotification) {
        RelationNotification rn = (RelationNotification) aNotification;
        jaxb = mObjectFactory.createRelationNotification().withObjectName(String.valueOf(rn.getObjectName())).withRelationId(rn.getRelationId()).withRelationTypeName(rn.getRelationTypeName()).withRoleName(rn.getRoleName());
        if (rn.getNewRoleValue() != null) {
            ObjectNamesType ont = toObjectNamesType(rn.getNewRoleValue());
            ((org.apache.camel.component.jmx.jaxb.RelationNotification) jaxb).withNewRoleValue(ont);
        }
        if (rn.getOldRoleValue() != null) {
            ObjectNamesType ont = toObjectNamesType(rn.getOldRoleValue());
            ((org.apache.camel.component.jmx.jaxb.RelationNotification) jaxb).withOldRoleValue(ont);
        }
        if (rn.getMBeansToUnregister() != null) {
            ObjectNamesType ont = toObjectNamesType(rn.getMBeansToUnregister());
            ((org.apache.camel.component.jmx.jaxb.RelationNotification) jaxb).withMBeansToUnregister(ont);
        }
    } else if (aNotification instanceof TimerNotification) {
        jaxb = mObjectFactory.createTimerNotification().withNotificationId(((TimerNotification) aNotification).getNotificationID());
    } else {
        jaxb = mObjectFactory.createNotificationEventType();
        wrap = true;
    }
    jaxb.withMessage(aNotification.getMessage()).withSequence(aNotification.getSequenceNumber()).withSource(String.valueOf(aNotification.getSource())).withTimestamp(aNotification.getTimeStamp()).withType(aNotification.getType());
    if (aNotification.getUserData() != null) {
        jaxb.withUserData(String.valueOf(aNotification.getUserData()));
    }
    try {
        DatatypeFactory df = getDatatypeFactory();
        Date date = new Date(aNotification.getTimeStamp());
        GregorianCalendar gc = new GregorianCalendar();
        gc.setTime(date);
        jaxb.withDateTime(df.newXMLGregorianCalendar(gc));
        Object bean = wrap ? mObjectFactory.createNotificationEvent(jaxb) : jaxb;
        StringWriter sw = new StringWriter();
        Marshaller marshaller = jaxbContext.createMarshaller();
        marshaller.marshal(bean, sw);
        return sw.toString();
    } catch (DatatypeConfigurationException | JAXBException e) {
        throw new NotificationFormatException(e);
    }
}",java:S3776,39
"private synchronized JoltTransform getTransform() throws Exception{
    if (transform == null) {
        if (log.isDebugEnabled()) {
            String path = getResourceUri();
            log.debug(""Jolt content read from resource {} with resourceUri: {} for endpoint {}"", getResourceUri(), path, getEndpointUri());
        }
        if (this.transformDsl == JoltTransformType.Sortr) {
            this.transform = new Sortr();
        } else {
            Object spec = JsonUtils.jsonToObject(getResourceAsInputStream());
            switch(this.transformDsl) {
                case Shiftr:
                    this.transform = new Shiftr(spec);
                    break;
                case Defaultr:
                    this.transform = new Defaultr(spec);
                    break;
                case Removr:
                    this.transform = new Removr(spec);
                    break;
                case Chainr:
                default:
                    this.transform = Chainr.fromSpec(spec);
                    break;
            }
        }
    }
    return transform;
}",java:S112,4
"private Table getTable(Class<?> entityType){
    UpdatableRecord object = (UpdatableRecord) ObjectHelper.newInstance(entityType);
    return object.getTable();
}",java:S3740,38
"public String evalCode(CamelContext camelContext, String fqn, String script, boolean singleQuotes){
    String qn = fqn.substring(0, fqn.lastIndexOf('.'));
    String name = fqn.substring(fqn.lastIndexOf('.') + 1);
    script = ScriptHelper.resolveOptionalExternalScript(camelContext, script);
    script = script.trim();
    boolean biFunction = script.startsWith(""(e1, e2) ->"");
    script = staticHelper(script);
    script = alias(script);
    Set<String> scriptImports = new LinkedHashSet<>();
    Map<String, Class> scriptBeans = new HashMap<>();
    script = evalDependencyInjection(camelContext, scriptImports, scriptBeans, script);
    StringBuilder sb = new StringBuilder();
    sb.append(""package "").append(qn).append("";\n"");
    sb.append(""\n"");
    sb.append(""import java.util.*;\n"");
    sb.append(""import java.util.concurrent.*;\n"");
    sb.append(""import java.util.function.*;\n"");
    sb.append(""import java.util.stream.*;\n"");
    sb.append(""\n"");
    sb.append(""import org.apache.camel.*;\n"");
    sb.append(""import org.apache.camel.util.*;\n"");
    sb.append(""import static org.apache.camel.language.joor.JoorHelper.*;\n"");
    sb.append(""\n"");
    for (String i : imports) {
        sb.append(i);
        if (!i.endsWith("";"")) {
            sb.append("";"");
        }
        sb.append(""\n"");
    }
    for (String i : scriptImports) {
        sb.append(""import "");
        sb.append(i);
        sb.append("";\n"");
    }
    sb.append(""\n"");
    sb.append(""public class "").append(name).append("" implements org.apache.camel.language.joor.JoorMethod {\n"");
    sb.append(""\n"");
    for (Map.Entry<String, Class> entry : scriptBeans.entrySet()) {
        sb.append(""    private "").append(entry.getValue().getSimpleName()).append("" "").append(entry.getKey()).append("";\n"");
    }
    sb.append(""\n"");
    sb.append(""    public "").append(name).append(""(CamelContext context) throws Exception {\n"");
    for (Map.Entry<String, Class> entry : scriptBeans.entrySet()) {
        sb.append(""        "").append(entry.getKey()).append("" = "").append(""context.getRegistry().lookupByNameAndType(\"""").append(entry.getKey()).append(""\"", "").append(entry.getValue().getSimpleName()).append("".class);\n"");
    }
    sb.append(""    }\n"");
    sb.append(""\n"");
    sb.append(""    @Override\n"");
    sb.append(""    public Object evaluate(CamelContext context, Exchange exchange, Message message, Object body, Optional optionalBody) throws Exception {\n"");
    sb.append(""        "");
    if (!script.contains(""return "")) {
        sb.append(""return "");
    }
    if (biFunction) {
        if (!sb.toString().endsWith(""return "")) {
            sb.append(""return "");
        }
        sb.append(""(BiFunction<Exchange, Exchange, Object>) "");
    }
    if (singleQuotes) {
        String quoted = script.replace('\'', '""');
        sb.append(quoted);
    } else {
        sb.append(script);
    }
    if (!script.endsWith(""}"") && !script.endsWith("";"")) {
        sb.append("";"");
    }
    if (biFunction && !script.endsWith("";"")) {
        sb.append("";"");
    }
    sb.append(""\n"");
    sb.append(""    }\n"");
    sb.append(""}\n"");
    sb.append(""\n"");
    return sb.toString();
}",java:S3776,39
"private void loadConfiguration(){
    String loaded = ScriptHelper.resolveOptionalExternalScript(getCamelContext(), ""resource:"" + configResource);
    int counter1 = 0;
    int counter2 = 0;
    if (loaded != null) {
        String[] lines = loaded.split(""\n"");
        for (String line : lines) {
            line = line.trim();
            if (line.startsWith(""#"")) {
                continue;
            }
            if (line.startsWith(""import "")) {
                imports.add(line);
                counter1++;
                continue;
            }
            String key = StringHelper.before(line, ""="");
            String value = StringHelper.after(line, ""="");
            if (key != null) {
                key = key.trim();
            }
            if (value != null) {
                value = value.trim();
            }
            if (key != null && value != null) {
                this.aliases.put(key, value);
                counter2++;
            }
        }
    }
    if (counter1 > 0 || counter2 > 0) {
        LOG.info(""Loaded jOOR language imports: {} and aliases: {} from configuration: {}"", counter1, counter2, configResource);
    }
    if (compiler.getAliases() == null) {
        compiler.setAliases(aliases);
    } else {
        compiler.getAliases().putAll(aliases);
    }
    if (compiler.getImports() == null) {
        compiler.setImports(imports);
    } else {
        compiler.getImports().addAll(imports);
    }
    if (scriptingCompiler.getAliases() == null) {
        scriptingCompiler.setAliases(aliases);
    } else {
        scriptingCompiler.getAliases().putAll(aliases);
    }
    if (scriptingCompiler.getImports() == null) {
        scriptingCompiler.setImports(imports);
    } else {
        scriptingCompiler.getImports().addAll(imports);
    }
}",java:S3776,39
"private void initTransactionManager(CamelContext camelContext){
    if (transactionManager == null && camelContext != null) {
        Map<String, PlatformTransactionManager> map = camelContext.getRegistry().findByTypeWithName(PlatformTransactionManager.class);
        if (map != null) {
            if (map.size() == 1) {
                transactionManager = map.values().iterator().next();
                LOG.info(""Using TransactionManager found in registry with id [{}] {}"", map.keySet().iterator().next(), transactionManager);
            } else {
                LOG.debug(""Could not find a single TransactionManager in registry as there was {} instances."", map.size());
            }
        }
    } else {
        LOG.info(""Using TransactionManager configured on this component: {}"", transactionManager);
    }
    if (transactionManager == null && camelContext != null) {
        Map<String, TransactionTemplate> map = camelContext.getRegistry().findByTypeWithName(TransactionTemplate.class);
        if (map != null) {
            if (map.size() == 1) {
                transactionManager = map.values().iterator().next().getTransactionManager();
                LOG.info(""Using TransactionManager found in registry with id [{}] {}"", map.keySet().iterator().next(), transactionManager);
            } else {
                LOG.debug(""Could not find a single TransactionTemplate in registry as there was {} instances."", map.size());
            }
        }
    }
}",java:S3776,39
"@Deprecated
protected EntityManager createEntityManager(){
    if (sharedEntityManager) {
        return SharedEntityManagerCreator.createSharedEntityManager(getEntityManagerFactory());
    } else {
        return getEntityManagerFactory().createEntityManager();
    }
}",java:S6355,48
"protected void processEntity(Exchange exchange, EntityManager entityManager){
    final Object values = expression.evaluate(exchange, Object.class);
    if (values != null) {
        transactionStrategy.executeInTransaction(new Runnable() {

            @Override
            public void run() {
                if (getEndpoint().isJoinTransaction()) {
                    entityManager.joinTransaction();
                }
                if (values.getClass().isArray()) {
                    Object[] array = (Object[]) values;
                    Object[] managedArray = new Object[array.length];
                    Object managedEntity;
                    for (int i = 0; i < array.length; i++) {
                        Object element = array[i];
                        if (!getEndpoint().isRemove()) {
                            managedEntity = save(element);
                        } else {
                            managedEntity = remove(element);
                        }
                        managedArray[i] = managedEntity;
                    }
                    if (!getEndpoint().isUsePersist()) {
                        System.arraycopy(managedArray, 0, array, 0, array.length);
                        exchange.getIn().setBody(array);
                    }
                } else if (values instanceof Collection) {
                    Collection<?> collection = (Collection<?>) values;
                    Collection<Object> managedCollection = new ArrayList<>(collection.size());
                    Object managedEntity;
                    for (Object entity : collection) {
                        if (!getEndpoint().isRemove()) {
                            managedEntity = save(entity);
                        } else {
                            managedEntity = remove(entity);
                        }
                        managedCollection.add(managedEntity);
                    }
                    if (!getEndpoint().isUsePersist()) {
                        exchange.getIn().setBody(managedCollection);
                    }
                } else {
                    Object managedEntity;
                    if (!getEndpoint().isRemove()) {
                        managedEntity = save(values);
                    } else {
                        managedEntity = remove(values);
                    }
                    if (!getEndpoint().isUsePersist()) {
                        exchange.getIn().setBody(managedEntity);
                    }
                }
                if (getEndpoint().isFlushOnSend()) {
                    entityManager.flush();
                }
            }

            private Object save(final Object entity) {
                LOG.debug(""save: {}"", entity);
                if (getEndpoint().isUsePersist()) {
                    entityManager.persist(entity);
                    return entity;
                } else {
                    return entityManager.merge(entity);
                }
            }

            private Object remove(final Object entity) {
                LOG.debug(""remove: {}"", entity);
                Object managedEntity;
                if (entityManager.contains(entity)) {
                    managedEntity = entity;
                } else {
                    managedEntity = entityManager.merge(entity);
                }
                entityManager.remove(managedEntity);
                return managedEntity;
            }
        });
    }
}",java:S3776,39
"private JsonNode getPayload(Exchange exchange) throws Exception{
    JsonNode payload = null;
    if (headerName == null && propertyName == null) {
        payload = exchange.getMessage().getBody(JsonNode.class);
        if (payload == null) {
            throw new InvalidPayloadException(exchange, JsonNode.class);
        }
    } else {
        if (headerName != null) {
            payload = exchange.getMessage().getHeader(headerName, JsonNode.class);
        }
        if (payload == null && propertyName != null) {
            payload = exchange.getProperty(propertyName, JsonNode.class);
        }
        if (payload == null) {
            throw new NoSuchHeaderOrPropertyException(exchange, headerName, propertyName, JsonNode.class);
        }
    }
    return payload;
}",java:S112,4
"protected void initJsch(){
    JSch.setConfig(""StrictHostKeyChecking"", ""yes"");
    JSch.setLogger(new com.jcraft.jsch.Logger() {

        @Override
        public boolean isEnabled(int level) {
            return level == FATAL || level == ERROR ? ScpComponent.this.log.isErrorEnabled() : level == WARN ? ScpComponent.this.log.isWarnEnabled() : level == INFO ? ScpComponent.this.log.isInfoEnabled() : ScpComponent.this.log.isDebugEnabled();
        }

        @Override
        public void log(int level, String message) {
            if (level == FATAL || level == ERROR) {
                ScpComponent.this.log.error(""[JSCH] {}"", message);
            } else if (level == WARN) {
                ScpComponent.this.log.warn(""[JSCH] {}"", message);
            } else if (level == INFO) {
                if (isVerboseLogging()) {
                    ScpComponent.this.log.info(""[JSCH] {}"", message);
                } else {
                    ScpComponent.this.log.debug(""[JSCH] {}"", message);
                }
            } else {
                ScpComponent.this.log.debug(""[JSCH] {}"", message);
            }
        }
    });
}",java:S3776,39
"private Session createSession(ScpConfiguration config){
    ObjectHelper.notNull(config, ""ScpConfiguration"");
    try {
        final JSch jsch = new JSch();
        if (ObjectHelper.isNotEmpty(config.getCiphers())) {
            LOG.trace(""Using ciphers: {}"", config.getCiphers());
            Hashtable<String, String> ciphers = new Hashtable<>();
            ciphers.put(""cipher.s2c"", config.getCiphers());
            ciphers.put(""cipher.c2s"", config.getCiphers());
            JSch.setConfig(ciphers);
        }
        if (ObjectHelper.isNotEmpty(config.getPrivateKeyFile())) {
            LOG.trace(""Using private keyfile: {}"", config.getPrivateKeyFile());
            String pkfp = config.getPrivateKeyFilePassphrase();
            String name = config.getPrivateKeyFile();
            if (!name.startsWith(""classpath:"")) {
                name = ""file:"" + name;
            }
            try (InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(endpoint.getCamelContext(), name)) {
                byte[] data = endpoint.getCamelContext().getTypeConverter().mandatoryConvertTo(byte[].class, is);
                jsch.addIdentity(""camel-jsch"", data, null, pkfp != null ? pkfp.getBytes() : null);
            } catch (Exception e) {
                throw new GenericFileOperationFailedException(""Cannot load private keyfile: "" + config.getPrivateKeyFile(), e);
            }
        } else if (ObjectHelper.isNotEmpty(config.getPrivateKeyBytes())) {
            LOG.trace(""Using private key bytes: {}"", config.getPrivateKeyBytes());
            String pkfp = config.getPrivateKeyFilePassphrase();
            byte[] data = config.getPrivateKeyBytes();
            try {
                jsch.addIdentity(""camel-jsch"", data, null, pkfp != null ? pkfp.getBytes() : null);
            } catch (Exception e) {
                throw new GenericFileOperationFailedException(""Cannot load private key bytes: "" + Arrays.toString(config.getPrivateKeyBytes()), e);
            }
        }
        String knownHostsFile = config.getKnownHostsFile();
        if (knownHostsFile == null && config.isUseUserKnownHostsFile()) {
            if (userKnownHostFile == null) {
                userKnownHostFile = System.getProperty(""user.home"") + ""/.ssh/known_hosts"";
                LOG.info(""Known host file not configured, using user known host file: {}"", userKnownHostFile);
            }
            knownHostsFile = userKnownHostFile;
        }
        if (ObjectHelper.isNotEmpty(knownHostsFile)) {
            if (!knownHostsFile.startsWith(""classpath:"")) {
                knownHostsFile = ""file:"" + knownHostsFile;
            }
            try {
                InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(endpoint.getCamelContext(), knownHostsFile);
                jsch.setKnownHosts(is);
            } catch (Exception e) {
                throw new GenericFileOperationFailedException(""Cannot load known host file: "" + knownHostsFile, e);
            }
        } else {
            jsch.setKnownHosts((String) null);
        }
        session = jsch.getSession(config.getUsername(), config.getHost(), config.getPort());
        session.setTimeout(config.getTimeout());
        session.setUserInfo(new SessionUserInfo(config));
        if (ObjectHelper.isNotEmpty(config.getStrictHostKeyChecking())) {
            LOG.trace(""Using StrickHostKeyChecking: {}"", config.getStrictHostKeyChecking());
            session.setConfig(""StrictHostKeyChecking"", config.getStrictHostKeyChecking());
        }
        if (ObjectHelper.isNotEmpty(config.getPreferredAuthentications())) {
            LOG.trace(""Using preferredAuthentications: {}"", config.getPreferredAuthentications());
            session.setConfig(""PreferredAuthentications"", config.getPreferredAuthentications());
        }
        int timeout = config.getConnectTimeout();
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Connecting to {} with {} timeout..."", config.remoteServerInformation(), timeout > 0 ? (timeout + "" ms"") : ""no"");
        }
        if (timeout > 0) {
            session.connect(timeout);
        } else {
            session.connect();
        }
    } catch (JSchException e) {
        session = null;
        LOG.warn(""Could not create ssh session for {}"", config.remoteServerInformation(), e);
    }
    return session;
}",java:S3776,39
"private synchronized Expression getTransform(Message msg) throws Exception{
    final String jsltStringFromHeader = allowTemplateFromHeader ? msg.getHeader(JsltConstants.HEADER_JSLT_STRING, String.class) : null;
    final boolean useTemplateFromUri = jsltStringFromHeader == null;
    if (useTemplateFromUri && transform != null) {
        return transform;
    }
    final Collection<Function> functions = Objects.requireNonNullElse(((JsltComponent) getComponent()).getFunctions(), Collections.emptyList());
    final JsonFilter objectFilter = Objects.requireNonNullElse(((JsltComponent) getComponent()).getObjectFilter(), DEFAULT_JSON_FILTER);
    final String transformSource;
    final InputStream stream;
    if (useTemplateFromUri) {
        transformSource = getResourceUri();
        if (log.isDebugEnabled()) {
            log.debug(""Jslt content read from resource {} with resourceUri: {} for endpoint {}"", transformSource, transformSource, getEndpointUri());
        }
        stream = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext(), transformSource);
        if (stream == null) {
            throw new JsltException(""Cannot load resource '"" + transformSource + ""': not found"");
        }
    } else {
        stream = new ByteArrayInputStream(jsltStringFromHeader.getBytes(StandardCharsets.UTF_8));
        transformSource = ""<inline>"";
    }
    final Expression transform;
    try {
        transform = new Parser(new InputStreamReader(stream)).withFunctions(functions).withObjectFilter(objectFilter).withSource(transformSource).compile();
    } finally {
        IOHelper.close(stream);
    }
    if (useTemplateFromUri) {
        this.transform = transform;
    }
    return transform;
}",java:S112,4
"public static AS2MessageDispositionNotificationEntity parseDispositionNotification(List<CharArrayBuffer> dispositionNotificationFields) throws ParseException{
    String reportingUA = null;
    String mtaName = null;
    String finalRecipient = null;
    String originalMessageId = null;
    DispositionMode dispositionMode = null;
    AS2DispositionType dispositionType = null;
    AS2DispositionModifier dispositionModifier = null;
    List<String> failures = new ArrayList<>();
    List<String> errors = new ArrayList<>();
    List<String> warnings = new ArrayList<>();
    Map<String, String> extensionFields = new HashMap<>();
    ReceivedContentMic receivedContentMic = null;
    for (int i = 0; i < dispositionNotificationFields.size(); i++) {
        final CharArrayBuffer fieldLine = dispositionNotificationFields.get(i);
        final Field field = parseDispositionField(fieldLine);
        switch(field.getName().toLowerCase()) {
            case REPORTING_UA:
                {
                    if (field.getElements().length < 1) {
                        throw new ParseException(""Invalid '"" + MDNField.REPORTING_UA + ""' field: UA name is missing"");
                    }
                    reportingUA = field.getValue();
                    break;
                }
            case MDN_GATEWAY:
                {
                    Element[] elements = field.getElements();
                    if (elements.length < 2) {
                        throw new ParseException(""Invalid '"" + MDNField.MDN_GATEWAY + ""' field: MTA name is missing"");
                    }
                    mtaName = elements[1].getValue();
                    break;
                }
            case FINAL_RECIPIENT:
                {
                    Element[] elements = field.getElements();
                    if (elements.length < 2) {
                        throw new ParseException(""Invalid '"" + MDNField.FINAL_RECIPIENT + ""' field: recipient address is missing"");
                    }
                    finalRecipient = elements[1].getValue();
                    break;
                }
            case ORIGINAL_MESSAGE_ID:
                {
                    originalMessageId = field.getValue();
                    break;
                }
            case DISPOSITION:
                {
                    Element[] elements = field.getElements();
                    if (elements.length < 2) {
                        throw new ParseException(""Invalid '"" + MDNField.DISPOSITION + ""' field: "" + field.getValue());
                    }
                    dispositionMode = DispositionMode.parseDispositionMode(elements[0].getValue());
                    if (dispositionMode == null) {
                        throw new ParseException(""Invalid '"" + MDNField.DISPOSITION + ""' field: invalid disposition mode '"" + elements[0].getValue() + ""'"");
                    }
                    String dispositionTypeString = elements[1].getValue();
                    int slash = dispositionTypeString.indexOf(""/"");
                    if (slash == -1) {
                        dispositionType = AS2DispositionType.parseDispositionType(dispositionTypeString);
                    } else {
                        dispositionType = AS2DispositionType.parseDispositionType(dispositionTypeString.substring(0, slash));
                        dispositionModifier = AS2DispositionModifier.parseDispositionType(dispositionTypeString.substring(slash + 1));
                    }
                    break;
                }
            case FAILURE:
                failures.add(field.getValue());
                break;
            case ERROR:
                errors.add(field.getValue());
                break;
            case WARNING:
                warnings.add(field.getValue());
                break;
            case RECEIVED_CONTENT_MIC:
                {
                    Element[] elements = field.getElements();
                    if (elements.length < 1) {
                        throw new ParseException(""Invalid '"" + MDNField.RECEIVED_CONTENT_MIC + ""' field: MIC is missing"");
                    }
                    Element element = elements[0];
                    String[] parameters = element.getParameters();
                    if (parameters.length < 1) {
                        throw new ParseException(""Invalid '"" + MDNField.RECEIVED_CONTENT_MIC + ""' field: digest algorithm ID is missing"");
                    }
                    String digestAlgorithmId = parameters[0];
                    String encodedMessageDigest = element.getValue();
                    receivedContentMic = new ReceivedContentMic(digestAlgorithmId, encodedMessageDigest);
                    break;
                }
            default:
                extensionFields.put(field.getName(), field.getValue());
        }
    }
    return new AS2MessageDispositionNotificationEntity(reportingUA, mtaName, finalRecipient, originalMessageId, dispositionMode, dispositionType, dispositionModifier, failures.toArray(new String[0]), errors.toArray(new String[0]), warnings.toArray(new String[0]), extensionFields, receivedContentMic);
}",java:S3776,39
"@Deprecated
public JsonSchemaLoader getSchemaLoader(){
    return schemaLoader;
}",java:S6355,48
"@Deprecated
public void setSchemaLoader(JsonSchemaLoader schemaLoader){
    this.schemaLoader = schemaLoader;
}",java:S6355,48
"private Object doRead(String path, Exchange exchange) throws IOException, CamelExchangeException{
    final Object json = getPayload(exchange);
    if (json instanceof InputStream) {
        return readWithInputStream(path, exchange);
    } else if (json instanceof GenericFile) {
        LOG.trace(""JSonPath: {} is read as generic file: {}"", path, json);
        GenericFile<?> genericFile = (GenericFile<?>) json;
        if (genericFile.getCharset() != null) {
            InputStream inputStream = new FileInputStream((File) genericFile.getFile());
            return JsonPath.using(configuration).parse(inputStream, genericFile.getCharset()).read(path);
        }
    }
    if (json instanceof String) {
        LOG.trace(""JSonPath: {} is read as String: {}"", path, json);
        String str = (String) json;
        return JsonPath.using(configuration).parse(str).read(path);
    } else if (json instanceof Map) {
        LOG.trace(""JSonPath: {} is read as Map: {}"", path, json);
        Map map = (Map) json;
        return JsonPath.using(configuration).parse(map).read(path);
    } else if (json instanceof List) {
        LOG.trace(""JSonPath: {} is read as List: {}"", path, json);
        List list = (List) json;
        return JsonPath.using(configuration).parse(list).read(path);
    } else {
        Object answer = readWithInputStream(path, exchange);
        if (answer == null) {
            answer = readWithAdapter(path, exchange);
        }
        if (answer != null) {
            return answer;
        }
    }
    if (configuration.getOptions().contains(SUPPRESS_EXCEPTIONS)) {
        if (configuration.getOptions().contains(ALWAYS_RETURN_LIST)) {
            return Collections.emptyList();
        } else {
            return null;
        }
    }
    if (headerName != null) {
        throw new CamelExchangeException(""Cannot read message header "" + headerName + "" as supported JSON value"", exchange);
    } else {
        throw new CamelExchangeException(""Cannot read message body as supported JSON value"", exchange);
    }
}",java:S3776,39
"public void setConnectionPool(AS400ConnectionPool connectionPool){
    this.connectionPool = connectionPool;
}",java:S2886,33
"public int getCcsid(){
    return ccsid;
}",java:S4144,40
"@Deprecated
public Exchange receive(){
    return receive(-1);
}",java:S6355,48
"@Deprecated
public Exchange receiveNoWait(){
    return receive(0);
}",java:S6355,48
"private Exchange receive(DataQueue queue, long timeout) throws Exception{
    DataQueueEntry entry;
    if (timeout >= 0) {
        int seconds = (int) timeout / 1000;
        LOG.trace(""Reading from data queue: {} with {} seconds timeout"", queue.getName(), seconds);
        entry = queue.read(seconds);
    } else {
        LOG.trace(""Reading from data queue: {} with no timeout"", queue.getName());
        entry = queue.read(-1);
    }
    Exchange exchange = getEndpoint().createExchange();
    if (entry != null) {
        exchange.getIn().setHeader(Jt400Endpoint.SENDER_INFORMATION, entry.getSenderInformation());
        if (getEndpoint().getFormat() == Jt400Configuration.Format.binary) {
            exchange.getIn().setBody(entry.getData());
        } else {
            exchange.getIn().setBody(entry.getString());
        }
        return exchange;
    }
    return null;
}",java:S112,4
"private Exchange receive(KeyedDataQueue queue, long timeout) throws Exception{
    String key = getEndpoint().getSearchKey();
    String searchType = getEndpoint().getSearchType().name();
    KeyedDataQueueEntry entry;
    if (timeout >= 0) {
        int seconds = (int) timeout / 1000;
        LOG.trace(""Reading from data queue: {} with {} seconds timeout"", queue.getName(), seconds);
        entry = queue.read(key, seconds, searchType);
    } else {
        LOG.trace(""Reading from data queue: {} with no timeout"", queue.getName());
        entry = queue.read(key, -1, searchType);
    }
    Exchange exchange = createExchange(true);
    if (entry != null) {
        exchange.getIn().setHeader(Jt400Endpoint.SENDER_INFORMATION, entry.getSenderInformation());
        if (getEndpoint().getFormat() == Jt400Configuration.Format.binary) {
            exchange.getIn().setBody(entry.getData());
            exchange.getIn().setHeader(Jt400Endpoint.KEY, entry.getKey());
        } else {
            exchange.getIn().setBody(entry.getString());
            exchange.getIn().setHeader(Jt400Endpoint.KEY, entry.getKeyString());
        }
        return exchange;
    }
    return null;
}",java:S112,4
"private void process(DataQueue queue, Exchange exchange) throws Exception{
    if (endpoint.getFormat() == Jt400Configuration.Format.binary) {
        queue.write(exchange.getIn().getBody(byte[].class));
    } else {
        queue.write(exchange.getIn().getBody(String.class));
    }
}",java:S112,4
"private void process(KeyedDataQueue queue, Exchange exchange) throws Exception{
    if (endpoint.getFormat() == Jt400Configuration.Format.binary) {
        queue.write(exchange.getIn().getHeader(Jt400Endpoint.KEY, byte[].class), exchange.getIn().getBody(byte[].class));
    } else {
        queue.write(exchange.getIn().getHeader(Jt400Endpoint.KEY, String.class), exchange.getIn().getBody(String.class));
    }
}",java:S112,4
"private synchronized Exchange receive(MessageQueue queue, long timeout) throws Exception{
    QueuedMessage entry;
    int seconds = (timeout >= 0) ? (int) timeout / 1000 : -1;
    LOG.trace(""Reading from message queue: {} with {} seconds timeout"", queue.getPath(), -1 == seconds ? ""infinite"" : seconds);
    Jt400Configuration.MessageAction messageAction = getEndpoint().getMessageAction();
    entry = queue.receive(messageKey, seconds, messageAction.getJt400Value(), null == messageKey ? MessageQueue.ANY : MessageQueue.NEXT);
    if (null == entry) {
        return null;
    }
    if (Jt400Configuration.MessageAction.SAME == messageAction) {
        this.messageKey = entry.getKey();
    }
    Exchange exchange = createExchange(true);
    exchange.getIn().setHeader(Jt400Constants.SENDER_INFORMATION, entry.getFromJobNumber() + ""/"" + entry.getUser() + ""/"" + entry.getFromJobName());
    setHeaderIfValueNotNull(exchange.getIn(), Jt400Constants.MESSAGE_ID, entry.getID());
    setHeaderIfValueNotNull(exchange.getIn(), Jt400Constants.MESSAGE_FILE, entry.getFileName());
    setHeaderIfValueNotNull(exchange.getIn(), Jt400Constants.MESSAGE_TYPE, entry.getType());
    setHeaderIfValueNotNull(exchange.getIn(), Jt400Constants.MESSAGE_SEVERITY, entry.getSeverity());
    setHeaderIfValueNotNull(exchange.getIn(), Jt400Constants.MESSAGE, entry);
    if (AS400Message.INQUIRY == entry.getType()) {
        setHeaderIfValueNotNull(exchange.getIn(), Jt400Constants.MESSAGE_DFT_RPY, entry.getDefaultReply());
        if (getEndpoint().isSendingReply()) {
            setHeaderIfValueNotNull(exchange.getIn(), Jt400Constants.MESSAGE_REPLYTO_KEY, entry.getKey());
        }
    }
    exchange.getIn().setBody(entry.getText());
    return exchange;
}",java:S112,4
"private void process(MessageQueue queue, Exchange exchange) throws Exception{
    String msgText = exchange.getIn().getBody(String.class);
    byte[] messageKey = exchange.getIn().getHeader(Jt400Constants.MESSAGE_REPLYTO_KEY, byte[].class);
    if (ObjectHelper.isNotEmpty(messageKey) && ObjectHelper.isNotEmpty(msgText)) {
        queue.reply(messageKey, msgText);
    } else {
        queue.sendInformational(msgText);
    }
}",java:S112,4
"private ProgramParameter[] getParameterList(Exchange exchange, AS400 iSeries) throws InvalidPayloadException, PropertyVetoException{
    Object body = exchange.getIn().getMandatoryBody();
    Object[] params = (Object[]) body;
    ProgramParameter[] parameterList = new ProgramParameter[params.length];
    for (int i = 0; i < params.length; i++) {
        Object param = params[i];
        boolean input;
        boolean output;
        if (getISeriesEndpoint().isFieldIdxForOuput(i)) {
            output = true;
            input = param != null;
        } else {
            output = false;
            input = true;
        }
        byte[] inputData = null;
        int length = getISeriesEndpoint().getOutputFieldLength(i);
        if (input) {
            if (param != null) {
                AS400DataType typeConverter;
                if (param instanceof CharSequence) {
                    param = param.toString();
                    typeConverter = new AS400Text(length, iSeries);
                } else if (param instanceof char[]) {
                    param = new String((char[]) param);
                    typeConverter = new AS400Text(length, iSeries);
                } else if (param instanceof Integer) {
                    typeConverter = new AS400Bin4();
                } else if (param instanceof Long) {
                    typeConverter = new AS400Bin8();
                } else if (param instanceof byte[]) {
                    typeConverter = new AS400ByteArray(length);
                } else {
                    param = param.toString();
                    typeConverter = new AS400Text(length, iSeries);
                }
                inputData = typeConverter.toBytes(param);
            }
        }
        if (input && output) {
            LOG.trace(""Parameter {} is both input and output."", i);
            if (getISeriesEndpoint().getType() == Jt400Type.PGM) {
                parameterList[i] = new ProgramParameter(inputData, length);
            } else {
                parameterList[i] = new ProgramParameter(ProgramParameter.PASS_BY_REFERENCE, inputData, length);
            }
        } else if (input) {
            LOG.trace(""Parameter {} is input."", i);
            if (inputData != null) {
                parameterList[i] = new ProgramParameter(inputData);
            } else {
                parameterList[i] = new ProgramParameter();
                parameterList[i].setParameterType(ProgramParameter.PASS_BY_REFERENCE);
                parameterList[i].setNullParameter(true);
            }
        } else {
            LOG.trace(""Parameter {} is output."", i);
            parameterList[i] = new ProgramParameter(length);
        }
    }
    return parameterList;
}",java:S3776,39
"private String getOutputMessages(ProgramCall pgmCall) throws Exception{
    StringBuilder outputMsg = new StringBuilder();
    AS400Message[] messageList = pgmCall.getMessageList();
    for (int i = 0; i < messageList.length; ++i) {
        messageList[i].load();
        outputMsg.append(i).append("") "");
        outputMsg.append(messageList[i].getText());
        outputMsg.append("" - "");
        outputMsg.append(messageList[i].getHelp());
        outputMsg.append('\n');
    }
    return outputMsg.toString();
}",java:S112,4
"private AS400 connect() throws Exception{
    AS400 iSeries = getISeriesEndpoint().getSystem();
    if (!iSeries.isConnected(AS400.COMMAND)) {
        LOG.debug(""Connecting to {}"", getISeriesEndpoint());
        iSeries.connectService(AS400.COMMAND);
    }
    return iSeries;
}",java:S112,4
"private JtaTransactionPolicy resolveTransactionPolicy(JtaTransactionErrorHandlerDefinition definition){
    JtaTransactionPolicy answer = (JtaTransactionPolicy) definition.getTransactedPolicy();
    if (answer == null && definition.getTransactedPolicyRef() != null) {
        answer = mandatoryLookup(definition.getTransactedPolicyRef(), JtaTransactionPolicy.class);
    }
    if (answer == null) {
        LOG.debug(""No transaction policy configured on error handler. Will try find it in the registry."");
        Map<String, JtaTransactionPolicy> mapPolicy = findByTypeWithName(JtaTransactionPolicy.class);
        if (mapPolicy != null && mapPolicy.size() == 1) {
            JtaTransactionPolicy policy = mapPolicy.values().iterator().next();
            if (policy != null) {
                answer = policy;
            }
        }
        if (answer == null) {
            JtaTransactionPolicy policy = lookupByNameAndType(PROPAGATION_REQUIRED, JtaTransactionPolicy.class);
            if (policy != null) {
                answer = policy;
            }
        }
        if (answer != null) {
            LOG.debug(""Found TransactionPolicy in registry to use: {}"", answer);
        }
    }
    return answer;
}",java:S3776,39
"protected void doInTransactionTemplate(final Exchange exchange) throws Throwable{
    transactionPolicy.run(new JtaTransactionPolicy.Runnable() {

        @Override
        public void run() throws Throwable {
            Throwable rce;
            processByErrorHandler(exchange);
            if (exchange.getException() != null || exchange.isRollbackOnly()) {
                if (exchange.getException() != null) {
                    rce = exchange.getException();
                } else {
                    rce = new TransactionRolledbackException();
                }
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Throwing runtime exception to force transaction to rollback on {}"", transactionPolicy);
                }
                throw rce;
            }
        }
    });
}",java:S112,4
"private void logTransactionRollback(String redelivered, String ids, Throwable e, boolean rollbackOnly){
    if (rollbackLoggingLevel == LoggingLevel.OFF) {
        return;
    } else if (rollbackLoggingLevel == LoggingLevel.ERROR && LOG.isErrorEnabled()) {
        if (rollbackOnly) {
            LOG.error(""Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly"", transactionKey, redelivered, ids);
        } else {
            LOG.error(""Transaction rollback ({}) redelivered({}) for {} caught: {}"", transactionKey, redelivered, ids, e.getMessage());
        }
    } else if (rollbackLoggingLevel == LoggingLevel.WARN && LOG.isWarnEnabled()) {
        if (rollbackOnly) {
            LOG.warn(""Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly"", transactionKey, redelivered, ids);
        } else {
            LOG.warn(""Transaction rollback ({}) redelivered({}) for {} caught: {}"", transactionKey, redelivered, ids, e.getMessage());
        }
    } else if (rollbackLoggingLevel == LoggingLevel.INFO && LOG.isInfoEnabled()) {
        if (rollbackOnly) {
            LOG.info(""Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly"", transactionKey, redelivered, ids);
        } else {
            LOG.info(""Transaction rollback ({}) redelivered({}) for {} caught: {}"", transactionKey, redelivered, ids, e.getMessage());
        }
    } else if (rollbackLoggingLevel == LoggingLevel.DEBUG && LOG.isDebugEnabled()) {
        if (rollbackOnly) {
            LOG.debug(""Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly"", transactionKey, redelivered, ids);
        } else {
            LOG.debug(""Transaction rollback ({}) redelivered({}) for {} caught: {}"", transactionKey, redelivered, ids, e.getMessage());
        }
    } else if (rollbackLoggingLevel == LoggingLevel.TRACE && LOG.isTraceEnabled()) {
        if (rollbackOnly) {
            LOG.trace(""Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly"", transactionKey, redelivered, ids);
        } else {
            LOG.trace(""Transaction rollback ({}) redelivered({}) for {} caught: {}"", transactionKey, redelivered, ids, e.getMessage());
        }
    }
}",java:S3776,39
"protected void startPolling(){
    long partitionLastOffset = -1;
    try {
        lock.lock();
        long pollTimeoutMs = kafkaConsumer.getEndpoint().getConfiguration().getPollTimeoutMs();
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Polling {} from {} with timeout: {}"", threadId, getPrintableTopic(), pollTimeoutMs);
        }
        KafkaRecordProcessorFacade recordProcessorFacade = new KafkaRecordProcessorFacade(kafkaConsumer, threadId, commitManager, consumerListener);
        Duration pollDuration = Duration.ofMillis(pollTimeoutMs);
        ProcessingResult lastResult = null;
        while (isKafkaConsumerRunnableAndNotStopped() && isConnected() && pollExceptionStrategy.canContinue()) {
            ConsumerRecords<Object, Object> allRecords = consumer.poll(pollDuration);
            if (consumerListener != null) {
                if (!consumerListener.afterConsume(consumer)) {
                    continue;
                }
            }
            ProcessingResult result = recordProcessorFacade.processPolledRecords(allRecords, lastResult);
            updateTaskState();
            if (result.isBreakOnErrorHit() && !this.state.equals(State.PAUSED)) {
                LOG.debug(""We hit an error ... setting flags to force reconnect"");
                setReconnect(true);
                setConnected(false);
            } else {
                lastResult = result;
            }
        }
        if (!isConnected()) {
            LOG.debug(""Not reconnecting, check whether to auto-commit or not ..."");
            commitManager.commit();
        }
        safeUnsubscribe();
    } catch (InterruptException e) {
        kafkaConsumer.getExceptionHandler().handleException(""Interrupted while consuming "" + threadId + "" from kafka topic"", e);
        commitManager.commit();
        LOG.info(""Unsubscribing {} from {}"", threadId, getPrintableTopic());
        safeUnsubscribe();
        Thread.currentThread().interrupt();
    } catch (WakeupException e) {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""The kafka consumer was woken up while polling on thread {} for {}"", threadId, getPrintableTopic());
        }
    } catch (Exception e) {
        if (LOG.isDebugEnabled()) {
            LOG.warn(""Exception {} caught by thread {} while polling {} from kafka: {}"", e.getClass().getName(), threadId, getPrintableTopic(), e.getMessage(), e);
        } else {
            LOG.warn(""Exception {} caught by thread {} while polling {} from kafka: {}"", e.getClass().getName(), threadId, getPrintableTopic(), e.getMessage());
        }
        pollExceptionStrategy.handle(partitionLastOffset, e);
    } finally {
        if (!pollExceptionStrategy.canContinue()) {
            safeUnsubscribe();
            safeConsumerClose();
        }
        lock.unlock();
    }
}",java:S3776,39
"private void doSend(Object key, ProducerRecord<Object, Object> record, KafkaProducerCallBack cb){
    cb.increment();
    if (LOG.isDebugEnabled()) {
        LOG.debug(""Sending message to topic: {}, partition: {}, key: {}"", record.topic(), record.partition(), record.key());
    }
    if (key != null) {
        KafkaProducerMetadataCallBack metadataCallBack = new KafkaProducerMetadataCallBack(key, configuration.isRecordMetadata());
        DelegatingCallback delegatingCallback = new DelegatingCallback(cb, metadataCallBack);
        kafkaProducer.send(record, delegatingCallback);
    } else {
        kafkaProducer.send(record, cb);
    }
}",java:S6213,47
"@Deprecated
public StateRepository<String, String> getOffsetRepository(){
    return camelExchangePayload.offsetRepository;
}",java:S6355,48
"public Consumer<?, ?> getConsumer(){
    return consumer;
}",java:S1452,23
"public Consumer<?, ?> getConsumer(){
    return consumer;
}",java:S1452,23
"private void setupExchangeMessage(Message message, ConsumerRecord record){
    message.setHeader(KafkaConstants.PARTITION, record.partition());
    message.setHeader(KafkaConstants.TOPIC, record.topic());
    message.setHeader(KafkaConstants.OFFSET, record.offset());
    message.setHeader(KafkaConstants.HEADERS, record.headers());
    message.setHeader(KafkaConstants.TIMESTAMP, record.timestamp());
    message.setHeader(Exchange.MESSAGE_TIMESTAMP, record.timestamp());
    if (record.key() != null) {
        message.setHeader(KafkaConstants.KEY, record.key());
    }
    message.setBody(record.value());
}",java:S3740,38
"private void setupExchangeMessage(Message message, ConsumerRecord record){
    message.setHeader(KafkaConstants.PARTITION, record.partition());
    message.setHeader(KafkaConstants.TOPIC, record.topic());
    message.setHeader(KafkaConstants.OFFSET, record.offset());
    message.setHeader(KafkaConstants.HEADERS, record.headers());
    message.setHeader(KafkaConstants.TIMESTAMP, record.timestamp());
    message.setHeader(Exchange.MESSAGE_TIMESTAMP, record.timestamp());
    if (record.key() != null) {
        message.setHeader(KafkaConstants.KEY, record.key());
    }
    message.setBody(record.value());
}",java:S6213,47
"private void propagateHeaders(ConsumerRecord<Object, Object> record, Exchange exchange){
    HeaderFilterStrategy headerFilterStrategy = configuration.getHeaderFilterStrategy();
    KafkaHeaderDeserializer headerDeserializer = configuration.getHeaderDeserializer();
    StreamSupport.stream(record.headers().spliterator(), false).filter(header -> shouldBeFiltered(header, exchange, headerFilterStrategy)).forEach(header -> exchange.getIn().setHeader(header.key(), headerDeserializer.deserialize(header.key(), header.value())));
}",java:S6213,47
"private void logRecord(ConsumerRecord<Object, Object> record){
    if (LOG.isTraceEnabled()) {
        LOG.trace(""Partition = {}, offset = {}, key = {}, value = {}"", record.partition(), record.offset(), record.key(), record.value());
    }
}",java:S6213,47
"private KnativeConfiguration getKnativeConfiguration() throws Exception{
    final String envConfig = System.getenv(KnativeConstants.CONFIGURATION_ENV_VARIABLE);
    final KnativeConfiguration conf = configuration.copy();
    if (conf.getTransportOptions() == null) {
        conf.setTransportOptions(new HashMap<>());
    }
    if (conf.getFilters() == null) {
        conf.setFilters(new HashMap<>());
    }
    if (conf.getCeOverride() == null) {
        conf.setCeOverride(new HashMap<>());
    }
    if (conf.getEnvironment() == null) {
        KnativeEnvironment env;
        if (environmentPath != null) {
            env = KnativeEnvironment.mandatoryLoadFromResource(getCamelContext(), this.environmentPath);
        } else if (envConfig != null) {
            env = envConfig.startsWith(""file:"") || envConfig.startsWith(""classpath:"") ? KnativeEnvironment.mandatoryLoadFromResource(getCamelContext(), envConfig) : KnativeEnvironment.mandatoryLoadFromSerializedString(envConfig);
        } else {
            env = CamelContextHelper.findSingleByType(getCamelContext(), KnativeEnvironment.class);
        }
        if (env == null) {
            throw new IllegalStateException(""Cannot load Knative configuration from file or env variable"");
        }
        conf.setEnvironment(env);
    }
    return conf;
}",java:S112,4
"private void handleRequest(RoutingContext routingContext){
    final HttpServerRequest request = routingContext.request();
    final Exchange exchange = getEndpoint().createExchange();
    final Message message = toMessage(request, exchange);
    Buffer payload = routingContext.getBody();
    if (payload != null) {
        message.setBody(payload.getBytes());
    } else {
        message.setBody(null);
    }
    routingContext.vertx().executeBlocking(promise -> {
        try {
            createUoW(exchange);
        } catch (Exception e) {
            promise.fail(e);
            return;
        }
        getAsyncProcessor().process(exchange, c -> {
            if (!exchange.isFailed()) {
                promise.complete();
            } else {
                promise.fail(exchange.getException());
            }
        });
    }, false, result -> {
        try {
            Throwable failure = null;
            if (result.succeeded()) {
                try {
                    HttpServerResponse response = toHttpResponse(request, exchange.getMessage());
                    Buffer body = null;
                    if (request.response().getStatusCode() != 204 && configuration.isReply()) {
                        body = computeResponseBody(exchange.getMessage());
                        String contentType = MessageHelper.getContentType(exchange.getMessage());
                        if (contentType != null) {
                            response.putHeader(Exchange.CONTENT_TYPE, contentType);
                        }
                    }
                    if (body != null) {
                        request.response().end(body);
                    } else {
                        request.response().setStatusCode(204);
                        request.response().end();
                    }
                } catch (Exception e) {
                    failure = e;
                }
            } else if (result.failed()) {
                failure = result.cause();
            }
            if (failure != null) {
                getExceptionHandler().handleException(failure);
                routingContext.fail(failure);
            }
        } finally {
            doneUoW(exchange);
        }
    });
}",java:S3776,39
"private HttpServerResponse toHttpResponse(HttpServerRequest request, Message message){
    final HttpServerResponse response = request.response();
    final boolean failed = message.getExchange().isFailed();
    final int defaultCode = failed ? 500 : 200;
    final int code = message.getHeader(Exchange.HTTP_RESPONSE_CODE, defaultCode, int.class);
    final TypeConverter tc = message.getExchange().getContext().getTypeConverter();
    response.setStatusCode(code);
    if (configuration.isReply()) {
        for (Map.Entry<String, Object> entry : message.getHeaders().entrySet()) {
            final String key = entry.getKey();
            final Object value = entry.getValue();
            for (Object it : org.apache.camel.support.ObjectHelper.createIterable(value, null)) {
                String headerValue = tc.convertTo(String.class, it);
                if (headerValue == null) {
                    continue;
                }
                if (!headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {
                    response.putHeader(key, headerValue);
                }
            }
        }
        KnativeHttpSupport.remapCloudEventHeaders(configuration.getCloudEvent(), message);
        if (configuration.isRemoveCloudEventHeadersInReply()) {
            KnativeHttpSupport.removeCloudEventHeaders(configuration.getCloudEvent(), message);
        }
    }
    return response;
}",java:S3776,39
"public static Predicate<HttpServerRequest> createFilter(CloudEvent cloudEvent, KnativeResource resource){
    final Map<String, String> filters = new HashMap<>();
    for (Map.Entry<String, String> entry : resource.getFilters().entrySet()) {
        cloudEvent.attribute(entry.getKey()).map(CloudEvent.Attribute::http).ifPresentOrElse(k -> filters.put(k, entry.getValue()), () -> filters.put(entry.getKey(), entry.getValue()));
    }
    return (HttpServerRequest request) -> {
        if (filters.isEmpty()) {
            return true;
        }
        for (Map.Entry<String, String> entry : filters.entrySet()) {
            final List<String> values = request.headers().getAll(entry.getKey());
            if (values.isEmpty()) {
                return false;
            }
            String val = values.get(values.size() - 1);
            int idx = val.lastIndexOf(',');
            if (values.size() == 1 && idx != -1) {
                val = val.substring(idx + 1);
                val = val.trim();
            }
            boolean matches = Objects.equals(entry.getValue(), val) || val.matches(entry.getValue());
            if (!matches) {
                return false;
            }
        }
        return true;
    };
}",java:S3776,39
"public KubernetesConfiguration getKubernetesConfiguration(){
    return configuration;
}",java:S4144,40
"@Deprecated
public String getNamespaceName(){
    return getNamespace();
}",java:S6355,48
"@Deprecated
public void setNamespaceName(String namespace){
    setNamespace(namespace);
}",java:S6355,48
"@Deprecated
public String getConfigMapName(){
    return this.lockConfiguration.getConfigMapName();
}",java:S6355,48
"@Deprecated
public void setConfigMapName(String kubernetesResourceName){
    this.lockConfiguration.setConfigMapName(kubernetesResourceName);
}",java:S6355,48
"@Deprecated
public String getConfigMapName(){
    return kubernetesResourceName;
}",java:S6355,48
"@Deprecated
public void setConfigMapName(String kubernetesResourceName){
    this.kubernetesResourceName = kubernetesResourceName;
}",java:S6355,48
"public String getKubernetesResourceName(){
    return kubernetesResourceName;
}",java:S4144,40
"public void setKubernetesResourceName(String kubernetesResourceName){
    this.kubernetesResourceName = kubernetesResourceName;
}",java:S4144,40
"private CustomResourceDefinitionContext getCRDContext(KubernetesConfiguration config){
    if (ObjectHelper.isEmpty(config.getCrdName()) || ObjectHelper.isEmpty(config.getCrdGroup()) || ObjectHelper.isEmpty(config.getCrdScope()) || ObjectHelper.isEmpty(config.getCrdVersion()) || ObjectHelper.isEmpty(config.getCrdPlural())) {
        LOG.error(""one of more of the custom resource definition argument(s) are missing."");
        throw new IllegalArgumentException(""one of more of the custom resource definition argument(s) are missing."");
    }
    return new CustomResourceDefinitionContext.Builder().withName(config.getCrdName()).withGroup(config.getCrdGroup()).withScope(config.getCrdScope()).withVersion(config.getCrdVersion()).withPlural(config.getCrdPlural()).build();
}",java:S3398,35
"protected void doInitKubernetesClient(){
    if (clientEnabled == null) {
        clientEnabled = ""true"".equalsIgnoreCase(camelContext.getPropertiesComponent().resolveProperty(CLIENT_ENABLED).orElse(""true""));
    }
    if (mountPathConfigMaps == null) {
        mountPathConfigMaps = camelContext.getPropertiesComponent().resolveProperty(MOUNT_PATH_CONFIGMAPS).orElseGet(() -> System.getProperty(ENV_MOUNT_PATH_CONFIGMAPS, System.getenv(ENV_MOUNT_PATH_CONFIGMAPS)));
    }
    if (mountPathSecrets == null) {
        mountPathSecrets = camelContext.getPropertiesComponent().resolveProperty(MOUNT_PATH_SECRETS).orElseGet(() -> System.getProperty(ENV_MOUNT_PATH_SECRETS, System.getenv(ENV_MOUNT_PATH_SECRETS)));
    }
    if (clientEnabled && client == null) {
        client = CamelContextHelper.findSingleByType(camelContext, KubernetesClient.class);
    }
    if (clientEnabled && client == null) {
        PropertiesComponent pc = camelContext.getPropertiesComponent();
        OrderedLocationProperties properties = (OrderedLocationProperties) pc.loadProperties(k -> k.startsWith(""camel.kubernetes-config.client.""), k -> k.replace(""camel.kubernetes-config.client."", """"));
        if (!properties.isEmpty()) {
            ConfigBuilder config = new ConfigBuilder();
            PropertyConfigurer configurer = PluginHelper.getConfigurerResolver(camelContext).resolvePropertyConfigurer(ConfigBuilder.class.getName(), camelContext);
            OrderedLocationProperties copy = new OrderedLocationProperties();
            copy.putAll(properties);
            PropertyBindingSupport.build().withProperties(copy.asMap()).withFluentBuilder(true).withIgnoreCase(true).withReflection(false).withConfigurer(configurer).withTarget(config).withCamelContext(camelContext).withRemoveParameters(true).bind();
            if (!copy.isEmpty()) {
                for (var e : copy.entrySet()) {
                    properties.remove(e.getKey());
                }
            }
            client = new KubernetesClientBuilder().withConfig(config.build()).build();
            LOG.info(""Auto-configuration KubernetesClient summary"");
            for (var entry : properties.entrySet()) {
                String k = entry.getKey().toString();
                Object v = entry.getValue();
                String loc = LocationHelper.locationSummary(properties, k);
                if (SensitiveUtils.containsSensitive(k)) {
                    LOG.info(""    {} {}=xxxxxx"", loc, k);
                } else {
                    LOG.info(""    {} {}={}"", loc, k, v);
                }
            }
            if (!copy.isEmpty()) {
                for (var e : copy.entrySet()) {
                    LOG.warn(""Property not auto-configured: camel.kubernetes-config.client.{}={}"", e.getKey(), e.getValue());
                }
            }
        } else {
            client = new KubernetesClientBuilder().build();
            LOG.debug(""Created default KubernetesClient (auto-configured by itself)"");
        }
        camelContext.getRegistry().bind(""camelKubernetesClient"", client);
    }
    if (clientEnabled && client == null && getMountPath() == null) {
        throw new IllegalArgumentException(""Either a mount path or the Kubernetes Client must be configured"");
    }
    if (!clientEnabled && getMountPath() == null) {
        throw new IllegalArgumentException(""Mount path must be configured"");
    }
    if (client != null && LOGGED.compareAndSet(false, true)) {
        LOG.info(""KubernetesClient using masterUrl: {} with namespace: {}"", client.getMasterUrl(), client.getNamespace());
    }
}",java:S3776,39
"private boolean prepareNextPage(LdapContext ldapContext) throws Exception{
    Control[] responseControls = ldapContext.getResponseControls();
    byte[] cookie = null;
    if (responseControls != null) {
        for (Control responseControl : responseControls) {
            if (responseControl instanceof PagedResultsResponseControl) {
                PagedResultsResponseControl prrc = (PagedResultsResponseControl) responseControl;
                cookie = prrc.getCookie();
            }
        }
    }
    if (cookie == null) {
        return false;
    } else {
        ldapContext.setRequestControls(new Control[] { new PagedResultsControl(pageSize, cookie, Control.CRITICAL) });
        return true;
    }
}",java:S112,4
"private String processLdifEntry(LdapConnection conn, LdifEntry ldifEntry){
    try {
        if (ldifEntry.isChangeAdd() || ldifEntry.isLdifContent()) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""attempting add of {}"", ldifEntry);
            }
            conn.add(ldifEntry.getEntry());
        } else if (ldifEntry.isChangeModify()) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""attempting modify of {}"", ldifEntry);
            }
            conn.modify(ldifEntry.getDn(), ldifEntry.getModificationArray());
        } else if (ldifEntry.isChangeDelete()) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""attempting delete of {}"", ldifEntry);
            }
            conn.delete(ldifEntry.getDn());
        } else if (ldifEntry.isChangeModDn()) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""attempting DN move of {}"", ldifEntry);
            }
            conn.moveAndRename(ldifEntry.getDn(), new Dn(ldifEntry.getNewRdn(), ldifEntry.getNewSuperior()), ldifEntry.isDeleteOldRdn());
        } else if (ldifEntry.isChangeModRdn()) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""attempting RDN move of {}"", ldifEntry);
            }
            conn.rename(ldifEntry.getDn(), new Rdn(ldifEntry.getNewRdn()), ldifEntry.isDeleteOldRdn());
        }
        LOG.debug(""ldif success"");
        return ""success"";
    } catch (LdapException e) {
        LOG.debug(""failed to apply ldif"", e);
        return getRootCause(e);
    }
}",java:S3776,39
"private void verifyRequest(Exchange exchange){
    if (exchange.getIn().getHeader(Exchange.SAGA_LONG_RUNNING_ACTION) == null) {
        throw new IllegalArgumentException(""Missing "" + Exchange.SAGA_LONG_RUNNING_ACTION + "" header in received request"");
    }
    Set<String> usedURIs = new HashSet<>();
    String compensationURI = exchange.getIn().getHeader(URL_COMPENSATION_KEY, String.class);
    if (compensationURI != null) {
        usedURIs.add(compensationURI);
    }
    String completionURI = exchange.getIn().getHeader(URL_COMPLETION_KEY, String.class);
    if (completionURI != null) {
        usedURIs.add(completionURI);
    }
    if (usedURIs.isEmpty()) {
        try {
            Map<String, Object> queryParams = URISupport.parseQuery(exchange.getIn().getHeader(Exchange.HTTP_QUERY, String.class));
            if (!queryParams.isEmpty()) {
                if (queryParams.get(URL_COMPENSATION_KEY) != null) {
                    compensationURI = queryParams.get(URL_COMPENSATION_KEY).toString();
                    usedURIs.add(compensationURI);
                    exchange.getIn().setHeader(URL_COMPENSATION_KEY, compensationURI);
                }
                if (queryParams.get(URL_COMPLETION_KEY) != null) {
                    completionURI = queryParams.get(URL_COMPLETION_KEY).toString();
                    usedURIs.add(completionURI);
                    exchange.getIn().setHeader(URL_COMPLETION_KEY, completionURI);
                }
            }
        } catch (URISyntaxException ex) {
            throw new RuntimeCamelException(""URISyntaxException during "" + Exchange.HTTP_QUERY + "" header parsing"");
        }
    }
    for (String uri : usedURIs) {
        if (!sagaService.getRegisteredURIs().contains(uri)) {
            throw new IllegalArgumentException(""URI "" + uri + "" is not allowed"");
        }
    }
}",java:S3776,39
"public void parseURI(URI uri, Map<String, Object> parameters, LuceneComponent component) throws Exception{
    String protocol = uri.getScheme();
    if (!protocol.equalsIgnoreCase(""lucene"")) {
        throw new IllegalArgumentException(""Unrecognized Lucene protocol: "" + protocol + "" for uri: "" + uri);
    }
    this.uri = uri;
    this.authority = uri.getAuthority();
    if (!isValidAuthority()) {
        throw new URISyntaxException(uri.toASCIIString(), ""Incorrect URI syntax and/or Operation specified for the Lucene endpoint."" + "" Please specify the syntax as \""lucene:[Endpoint Name]:[Operation]?[Query]\"""");
    }
    setHost(retrieveTokenFromAuthority(""hostname""));
    String op = retrieveTokenFromAuthority(""operation"");
    if (op != null) {
        op = op.toLowerCase();
    }
    setOperation(LuceneOperation.valueOf(op));
    srcDir = component.resolveAndRemoveReferenceParameter(parameters, ""srcDir"", File.class, null);
    indexDir = component.resolveAndRemoveReferenceParameter(parameters, ""indexDir"", File.class, new File(""file:///./indexDirectory""));
    analyzer = component.resolveAndRemoveReferenceParameter(parameters, ""analyzer"", Analyzer.class, new StandardAnalyzer());
    setMaxHits(component.getAndRemoveParameter(parameters, ""maxHits"", Integer.class, 10));
}",java:S112,4
"public void index(Exchange exchange) throws Exception{
    LOG.debug(""Indexing {}"", exchange);
    openIndexWriter();
    Map<String, Object> headers = exchange.getIn().getHeaders();
    add(""exchangeId"", exchange.getExchangeId(), true);
    for (Entry<String, Object> entry : headers.entrySet()) {
        String field = entry.getKey();
        String value = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, entry.getValue());
        add(field, value, true);
    }
    add(""contents"", exchange.getIn().getMandatoryBody(String.class), true);
    closeIndexWriter();
}",java:S112,4
"protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map) throws MessagingException, IOException{
    for (int i = 0; i < mp.getCount(); i++) {
        Part part = mp.getBodyPart(i);
        LOG.trace(""Part #{}: {}"", i, part);
        if (part.isMimeType(""multipart/*"")) {
            LOG.trace(""Part #{}: is mimetype: multipart/*"", i);
            extractAttachmentsFromMultipart((Multipart) part.getContent(), map);
        } else {
            String disposition = part.getDisposition();
            String fileName = part.getFileName();
            if (fileName != null) {
                fileName = fileName.replaceAll(""[\n\r\t]"", ""_"");
            }
            if (isAttachment(disposition) && (fileName == null || fileName.isEmpty())) {
                if (generateMissingAttachmentNames != null && generateMissingAttachmentNames.equalsIgnoreCase(MAIL_GENERATE_MISSING_ATTACHMENT_NAMES_UUID)) {
                    fileName = UUID.randomUUID().toString();
                }
            }
            if (fileName != null && decodeFilename) {
                fileName = MimeUtility.decodeText(fileName);
            }
            if (fileName != null) {
                fileName = FileUtil.stripPath(fileName);
            }
            if (fileName != null) {
                fileName = fileName.trim();
            }
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Part #{}: Disposition: {}"", i, disposition);
                LOG.trace(""Part #{}: Description: {}"", i, part.getDescription());
                LOG.trace(""Part #{}: ContentType: {}"", i, part.getContentType());
                LOG.trace(""Part #{}: FileName: {}"", i, fileName);
                LOG.trace(""Part #{}: Size: {}"", i, part.getSize());
                LOG.trace(""Part #{}: LineCount: {}"", i, part.getLineCount());
            }
            if (validDisposition(disposition, fileName)) {
                LOG.debug(""Mail contains file attachment: {}"", fileName);
                if (handleDuplicateAttachmentNames != null) {
                    if (handleDuplicateAttachmentNames.equalsIgnoreCase(MailConstants.MAIL_HANDLE_DUPLICATE_ATTACHMENT_NAMES_UUID_PREFIX)) {
                        fileName = prefixDuplicateFilenames(map, fileName);
                    } else if (handleDuplicateAttachmentNames.equalsIgnoreCase(MailConstants.MAIL_HANDLE_DUPLICATE_ATTACHMENT_NAMES_UUID_SUFFIX)) {
                        fileName = suffixDuplicateFilenames(map, fileName);
                    }
                }
                if (!map.containsKey(fileName)) {
                    final DataHandler dataHandler = part.getDataHandler();
                    final DataSource dataSource = dataHandler.getDataSource();
                    final DataHandler replacement = new DataHandler(new DelegatingDataSource(fileName, dataSource));
                    DefaultAttachment camelAttachment = new DefaultAttachment(replacement);
                    @SuppressWarnings(""unchecked"")
                    Enumeration<Header> headers = part.getAllHeaders();
                    while (headers.hasMoreElements()) {
                        Header header = headers.nextElement();
                        camelAttachment.addHeader(header.getName(), header.getValue());
                    }
                    map.put(fileName, camelAttachment);
                } else {
                    handleDuplicateFileAttachment(mp, fileName);
                }
            }
        }
    }
}",java:S3776,39
"protected void appendHeadersFromCamelMessage(MimeMessage mimeMessage, MailConfiguration configuration, Exchange exchange) throws MessagingException, IOException{
    for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {
        String headerName = entry.getKey();
        Object headerValue = entry.getValue();
        if (headerValue != null) {
            if (headerFilterStrategy != null && !headerFilterStrategy.applyFilterToCamelHeaders(headerName, headerValue, exchange)) {
                if (headerName.equalsIgnoreCase(""subject"")) {
                    mimeMessage.setSubject(asString(exchange, headerValue), determineCharSet(configuration, exchange));
                    continue;
                }
                if (headerName.equalsIgnoreCase(""from"")) {
                    mimeMessage.setFrom(asEncodedInternetAddress(asString(exchange, headerValue), determineCharSet(configuration, exchange)));
                    continue;
                }
                if (headerName.equalsIgnoreCase(""sender"")) {
                    mimeMessage.setSender(asEncodedInternetAddress(asString(exchange, headerValue), determineCharSet(configuration, exchange)));
                    continue;
                }
                if (isRecipientHeader(headerName)) {
                    continue;
                }
                if (headerName.equalsIgnoreCase(configuration.getAlternativeBodyHeader())) {
                    continue;
                }
                if (isCollection(headerValue)) {
                    Iterator<?> iter = ObjectHelper.createIterator(headerValue);
                    while (iter.hasNext()) {
                        Object value = iter.next();
                        mimeMessage.addHeader(StringHelper.removeCRLF(headerName), asString(exchange, value));
                    }
                } else {
                    mimeMessage.setHeader(StringHelper.removeCRLF(headerName), asString(exchange, headerValue));
                }
            }
        }
    }
}",java:S3776,39
"protected void addAttachmentsToMultipart(MimeMultipart multipart, String partDisposition, AttachmentsContentTransferEncodingResolver encodingResolver, Exchange exchange) throws MessagingException{
    LOG.trace(""Adding attachments +++ start +++"");
    int i = 0;
    for (Map.Entry<String, Attachment> entry : exchange.getIn(AttachmentMessage.class).getAttachmentObjects().entrySet()) {
        String attachmentFilename = entry.getKey();
        Attachment attachment = entry.getValue();
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Attachment #{}: Disposition: {}"", i, partDisposition);
            LOG.trace(""Attachment #{}: DataHandler: {}"", i, attachment.getDataHandler());
            LOG.trace(""Attachment #{}: FileName: {}"", i, attachmentFilename);
        }
        if (attachment != null) {
            if (shouldAddAttachment()) {
                BodyPart messageBodyPart = new MimeBodyPart();
                messageBodyPart.setDataHandler(attachment.getDataHandler());
                for (String headerName : attachment.getHeaderNames()) {
                    List<String> values = attachment.getHeaderAsList(headerName);
                    for (String value : values) {
                        messageBodyPart.setHeader(headerName, value);
                    }
                }
                String pattern = ""cid"";
                if (attachmentFilename.regionMatches(true, 0, pattern, 0, pattern.length())) {
                    messageBodyPart.addHeader(""Content-ID"", ""<"" + attachmentFilename.substring(4) + "">"");
                    messageBodyPart.setFileName(attachmentFilename.substring(4));
                } else {
                    messageBodyPart.setFileName(attachmentFilename);
                }
                LOG.trace(""Attachment #{}: ContentType: {}"", i, messageBodyPart.getContentType());
                if (contentTypeResolver != null) {
                    String contentType = contentTypeResolver.resolveContentType(attachmentFilename);
                    LOG.trace(""Attachment #{}: Using content type resolver: {} resolved content type as: {}"", i, contentTypeResolver, contentType);
                    if (contentType != null) {
                        String value = contentType + ""; name="" + attachmentFilename;
                        messageBodyPart.setHeader(""Content-Type"", value);
                        LOG.trace(""Attachment #{}: ContentType: {}"", i, messageBodyPart.getContentType());
                    }
                }
                resolveContentTransferEncoding(encodingResolver, i, messageBodyPart);
                messageBodyPart.setDisposition(partDisposition);
                multipart.addBodyPart(messageBodyPart);
            } else {
                LOG.trace(""shouldAddAttachment: false"");
            }
        } else {
            LOG.warn(""Cannot add attachment: {} as DataHandler is null"", attachmentFilename);
        }
        i++;
    }
    LOG.trace(""Adding attachments +++ done +++"");
}",java:S3776,39
"protected Map<String, Object> extractHeadersFromMail(Message mailMessage, Exchange exchange) throws MessagingException, IOException{
    Map<String, Object> answer = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
    Enumeration<?> names = mailMessage.getAllHeaders();
    MailConfiguration mailConfiguration = ((MailEndpoint) exchange.getFromEndpoint()).getConfiguration();
    while (names.hasMoreElements()) {
        Header header = (Header) names.nextElement();
        String value = header.getValue();
        if (value != null && mailConfiguration.isMimeDecodeHeaders()) {
            value = MimeUtility.decodeText(MimeUtility.unfold(value));
        }
        if (headerFilterStrategy != null && !headerFilterStrategy.applyFilterToExternalHeaders(header.getName(), value, exchange)) {
            CollectionHelper.appendValue(answer, header.getName(), value);
        }
    }
    if (mapMailMessage) {
        Object content = mailMessage.getContent();
        if (content instanceof MimeMultipart) {
            MimeMultipart multipart = (MimeMultipart) content;
            int size = multipart.getCount();
            for (int i = 0; i < size; i++) {
                BodyPart part = multipart.getBodyPart(i);
                content = part.getContent();
                while (content instanceof MimeMultipart) {
                    if (multipart.getCount() < 1) {
                        break;
                    }
                    part = ((MimeMultipart) content).getBodyPart(0);
                    content = part.getContent();
                }
                String prefix = ""text"";
                if (part.getContentType().regionMatches(true, 0, prefix, 0, prefix.length())) {
                    answer.put(Exchange.CONTENT_TYPE, part.getContentType());
                    break;
                }
            }
        }
    }
    if (mailMessage.getSentDate() != null) {
        answer.put(Exchange.MESSAGE_TIMESTAMP, mailMessage.getSentDate().getTime());
    }
    return answer;
}",java:S3776,39
"protected JavaMailSender createJavaMailSender(CamelContext context){
    JavaMailSender answer = new DefaultJavaMailSender();
    if (javaMailProperties != null) {
        answer.setJavaMailProperties(javaMailProperties);
    } else {
        answer.setJavaMailProperties(createJavaMailProperties(context));
        if (additionalJavaMailProperties != null) {
            answer.getJavaMailProperties().putAll(additionalJavaMailProperties);
        }
    }
    if (host != null) {
        answer.setHost(host);
    }
    if (port >= 0) {
        answer.setPort(port);
    }
    if (username != null) {
        answer.setUsername(username);
    }
    if (password != null) {
        answer.setPassword(password);
    }
    if (authenticator != null) {
        answer.setAuthenticator(authenticator);
    }
    if (protocol != null) {
        answer.setProtocol(protocol);
    }
    if (session != null) {
        answer.setSession(session);
        String hostPropertyValue = session.getProperty(""mail.smtp.host"");
        if (hostPropertyValue != null && !hostPropertyValue.isEmpty()) {
            answer.setHost(hostPropertyValue);
        }
        String portPropertyValue = session.getProperty(""mail.smtp.port"");
        if (portPropertyValue != null && !portPropertyValue.isEmpty()) {
            answer.setPort(Integer.parseInt(portPropertyValue));
        }
    } else {
        ClassLoader tccl = Thread.currentThread().getContextClassLoader();
        try {
            if (applicationClassLoader != null) {
                Thread.currentThread().setContextClassLoader(applicationClassLoader);
            }
            Session sessionInstance = Session.getInstance(answer.getJavaMailProperties(), authenticator == null ? new DefaultAuthenticator(getUsername(), getPassword()) : authenticator);
            sessionInstance.setDebug(debugMode);
            answer.setSession(sessionInstance);
        } finally {
            Thread.currentThread().setContextClassLoader(tccl);
        }
    }
    return answer;
}",java:S3776,39
"private Queue<Exchange> retrieveMessages() throws MessagingException{
    Queue<Exchange> answer = new LinkedList<>();
    Message[] messages;
    final SortTerm[] sortTerm = getEndpoint().getSortTerm();
    final SearchTerm searchTerm = computeSearchTerm();
    if (sortTerm != null && serverCanSort) {
        final IMAPFolder imapFolder = (IMAPFolder) folder;
        if (searchTerm != null) {
            messages = imapFolder.getSortedMessages(sortTerm, searchTerm);
        } else {
            messages = imapFolder.getSortedMessages(sortTerm);
        }
    } else {
        if (searchTerm != null) {
            messages = folder.search(searchTerm, retrieveAllMessages());
        } else {
            messages = retrieveAllMessages();
        }
        if (sortTerm != null) {
            MailSorter.sortMessages(messages, sortTerm);
        }
    }
    int maxMessage = getMaxNumberOfMessages();
    boolean hasMessageLimit = hasMessageLimit(maxMessage);
    for (Message message : messages) {
        if (hasMessageLimit && answer.size() >= maxMessage) {
            break;
        }
        String key = getEndpoint().getMailUidGenerator().generateUuid(getEndpoint(), message);
        if (isValidMessage(key, message)) {
            if (getEndpoint().getConfiguration().isPeek()) {
                peekMessage(message);
            }
            Exchange exchange = createExchange(new KeyValueHolder<>(key, message));
            if (exchange != null) {
                answer.add(exchange);
            }
        }
    }
    if (LOG.isDebugEnabled()) {
        LOG.debug(""Fetching {} messages. Total {} messages."", answer.size(), messages.length);
    }
    return answer;
}",java:S3776,39
"protected Exchange createExchange(KeyValueHolder<String, Message> holder) throws MessagingException{
    try {
        String key = holder.getKey();
        Message message = holder.getValue();
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Mail is of type: {} - {}"", ObjectHelper.classCanonicalName(message), message);
        }
        if (!message.getFlags().contains(Flags.Flag.DELETED)) {
            Exchange exchange = createExchange(message);
            if (getEndpoint().getConfiguration().isMapMailMessage()) {
                LOG.trace(""Mapping from jakarta.mail.Message to Camel MailMessage"");
                exchange.getIn().getBody();
                exchange.getIn().getHeaders();
                try {
                    Map<String, Attachment> att = new HashMap<>();
                    getEndpoint().getBinding().extractAttachmentsFromMail(message, att);
                    if (!att.isEmpty()) {
                        exchange.getIn(AttachmentMessage.class).setAttachmentObjects(att);
                    }
                } catch (MessagingException | IOException e) {
                    releaseExchange(exchange, true);
                    throw new RuntimeCamelException(""Error accessing attachments due to: "" + e.getMessage(), e);
                }
            }
            exchange.setProperty(MAIL_MESSAGE_UID, key);
            return exchange;
        } else {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Skipping message as it was flagged as deleted: {}"", MailUtils.dumpMessage(message));
            }
        }
    } catch (Exception e) {
        if (skipFailedMessage) {
            LOG.debug(""Skipping failed message due {}"", e.getMessage(), e);
        } else if (handleFailedMessage) {
            handleException(e);
        } else {
            throw e;
        }
    }
    return null;
}",java:S3776,39
"protected void processCommit(Message mail, Exchange exchange){
    try {
        if (!folder.isOpen()) {
            folder.open(Folder.READ_WRITE);
        }
        String uid = (String) exchange.removeProperty(MAIL_MESSAGE_UID);
        if (getEndpoint().getConfiguration().getProtocol().startsWith(""pop3"")) {
            int count = folder.getMessageCount();
            Message found = null;
            LOG.trace(""Looking for POP3Message with UID {} from folder with {} mails"", uid, count);
            for (int i = 1; i <= count; ++i) {
                Message msg = folder.getMessage(i);
                if (uid.equals(getEndpoint().getMailUidGenerator().generateUuid(getEndpoint(), msg))) {
                    LOG.debug(""Found POP3Message with UID {} from folder with {} mails"", uid, count);
                    found = msg;
                    break;
                }
            }
            if (found == null) {
                boolean delete = getEndpoint().getConfiguration().isDelete();
                LOG.warn(""POP3message not found in folder. Message cannot be marked as {}"", delete ? ""DELETED"" : ""SEEN"");
            } else {
                mail = found;
            }
        }
        org.apache.camel.Message in = exchange.getIn();
        MailConfiguration config = getEndpoint().getConfiguration();
        String copyTo = in.getHeader(MailConstants.MAIL_COPY_TO, config.getCopyTo(), String.class);
        String moveTo = in.getHeader(MailConstants.MAIL_MOVE_TO, config.getMoveTo(), String.class);
        boolean delete = in.getHeader(MailConstants.MAIL_DELETE, config.isDelete(), boolean.class);
        copyOrMoveMessageIfRequired(config, mail, copyTo, false);
        if (delete) {
            LOG.trace(""Exchange processed, so flagging message as DELETED"");
            copyOrMoveMessageIfRequired(config, mail, moveTo, true);
            mail.setFlag(Flags.Flag.DELETED, true);
        } else {
            LOG.trace(""Exchange processed, so flagging message as SEEN"");
            mail.setFlag(Flags.Flag.SEEN, true);
            copyOrMoveMessageIfRequired(config, mail, moveTo, true);
        }
        if (getEndpoint().getIdempotentRepository() != null) {
            if (getEndpoint().isIdempotentRepositoryRemoveOnCommit()) {
                getEndpoint().getIdempotentRepository().remove(uid);
            } else {
                getEndpoint().getIdempotentRepository().confirm(uid);
            }
        }
    } catch (MessagingException e) {
        getExceptionHandler().handleException(""Error occurred during committing mail message: "" + mail, exchange, e);
    }
}",java:S3776,39
"private void copyOrMoveMessageIfRequired(MailConfiguration config, Message mail, String destinationFolder, boolean moveMessage) throws MessagingException{
    if (config.getProtocol().equals(MailUtils.PROTOCOL_IMAP) || config.getProtocol().equals(MailUtils.PROTOCOL_IMAPS)) {
        if (destinationFolder != null) {
            LOG.trace(""IMAP message needs to be {} to {}"", moveMessage ? ""moved"" : ""copied"", destinationFolder);
            Folder destFolder = store.getFolder(destinationFolder);
            if (!destFolder.exists()) {
                destFolder.create(Folder.HOLDS_MESSAGES);
            }
            folder.copyMessages(new Message[] { mail }, destFolder);
            if (moveMessage) {
                mail.setFlag(Flags.Flag.DELETED, true);
            }
            LOG.trace(""IMAP message {} {} to {}"", mail, moveMessage ? ""moved"" : ""copied"", destinationFolder);
        }
    }
}",java:S3776,39
"public static SearchTerm toSearchTerm(SimpleSearchTerm simple) throws ParseException{
    SearchTermBuilder builder = new SearchTermBuilder();
    if (simple.isUnseen()) {
        builder = builder.unseen();
    }
    if (simple.getSubjectOrBody() != null) {
        String text = simple.getSubjectOrBody();
        SearchTermBuilder builderTemp = new SearchTermBuilder();
        builderTemp = builderTemp.subject(text).body(SearchTermBuilder.Op.or, text);
        builder = builder.and(builderTemp.build());
    }
    if (simple.getSubject() != null) {
        builder = builder.subject(simple.getSubject());
    }
    if (simple.getBody() != null) {
        builder = builder.body(simple.getBody());
    }
    if (simple.getFrom() != null) {
        builder = builder.from(simple.getFrom());
    }
    if (simple.getTo() != null) {
        builder = builder.recipient(Message.RecipientType.TO, simple.getTo());
    }
    if (simple.getFromSentDate() != null) {
        String s = simple.getFromSentDate();
        if (s.startsWith(""now"")) {
            long offset = extractOffset(s);
            builder = builder.and(new NowSearchTerm(SearchTermBuilder.Comparison.GE.asNum(), true, offset));
        } else {
            SimpleDateFormat sdf = new SimpleDateFormat(NOW_DATE_FORMAT);
            Date date = sdf.parse(s);
            builder = builder.sent(SearchTermBuilder.Comparison.GE, date);
        }
    }
    if (simple.getToSentDate() != null) {
        String s = simple.getToSentDate();
        if (s.startsWith(""now"")) {
            long offset = extractOffset(s);
            builder = builder.and(new NowSearchTerm(SearchTermBuilder.Comparison.LE.asNum(), true, offset));
        } else {
            SimpleDateFormat sdf = new SimpleDateFormat(NOW_DATE_FORMAT);
            Date date = sdf.parse(s);
            builder = builder.sent(SearchTermBuilder.Comparison.LE, date);
        }
    }
    if (simple.getFromReceivedDate() != null) {
        String s = simple.getFromReceivedDate();
        if (s.startsWith(""now"")) {
            long offset = extractOffset(s);
            builder = builder.and(new NowSearchTerm(SearchTermBuilder.Comparison.GE.asNum(), false, offset));
        } else {
            SimpleDateFormat sdf = new SimpleDateFormat(NOW_DATE_FORMAT);
            Date date = sdf.parse(s);
            builder = builder.received(SearchTermBuilder.Comparison.GE, date);
        }
    }
    if (simple.getToReceivedDate() != null) {
        String s = simple.getToReceivedDate();
        if (s.startsWith(""now"")) {
            long offset = extractOffset(s);
            builder = builder.and(new NowSearchTerm(SearchTermBuilder.Comparison.LE.asNum(), false, offset));
        } else {
            SimpleDateFormat sdf = new SimpleDateFormat(NOW_DATE_FORMAT);
            Date date = sdf.parse(s);
            builder = builder.received(SearchTermBuilder.Comparison.LE, date);
        }
    }
    return builder.build();
}",java:S3776,39
"private byte[] readMimePart(InputStream mimePartStream) throws Exception{
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    IOHelper.copyAndCloseInput(mimePartStream, bos);
    return bos.toByteArray();
}",java:S112,4
"public CircuitBreaker<?> getCircuitBreaker(){
    return circuitBreaker;
}",java:S1452,23
"public CircuitBreaker<?> getCircuitBreaker(){
    return circuitBreaker;
}",java:S3740,38
"public void setCircuitBreaker(CircuitBreaker<?> circuitBreaker){
    this.circuitBreaker = circuitBreaker;
}",java:S3740,38
"protected void registerRepositoryChecks(HealthCheckRepository repository){
    if (repository.isEnabled()) {
        boolean isAllChecksLiveness = repository.stream().allMatch(HealthCheck::isLiveness);
        boolean isAllChecksReadiness = repository.stream().allMatch(HealthCheck::isReadiness);
        if (repository instanceof HealthCheckRegistryRepository || !isAllChecksLiveness && !isAllChecksReadiness) {
            repository.stream().filter(HealthCheck::isEnabled).forEach(this::registerMicroProfileHealthCheck);
        } else {
            String healthCheckName = repository.getId();
            if (repository.getClass().getName().startsWith(""org.apache.camel"") && !healthCheckName.startsWith(""camel-"")) {
                healthCheckName = ""camel-"" + healthCheckName;
            }
            CamelMicroProfileRepositoryHealthCheck repositoryHealthCheck = new CamelMicroProfileRepositoryHealthCheck(getCamelContext(), repository, healthCheckName);
            if (registerEagerly(repository)) {
                getReadinessRegistry().register(repository.getId(), repositoryHealthCheck);
            } else {
                if (isAllChecksLiveness) {
                    getLivenessRegistry().register(repository.getId(), repositoryHealthCheck);
                }
                if (isAllChecksReadiness) {
                    getReadinessRegistry().register(repository.getId(), repositoryHealthCheck);
                }
            }
        }
    }
}",java:S3776,39
"private Endpoint createEndpoint(String uri, MinaConfiguration config) throws Exception{
    ObjectHelper.notNull(getCamelContext(), ""camelContext"");
    String protocol = config.getProtocol();
    MinaEndpoint endpoint = null;
    if (protocol != null) {
        if (protocol.equals(""tcp"") || config.isDatagramProtocol() || protocol.equals(""vm"")) {
            endpoint = new MinaEndpoint(uri, this, config);
        }
    }
    if (endpoint == null) {
        throw new IllegalArgumentException(""Unrecognised MINA protocol: "" + protocol + "" for uri: "" + uri);
    }
    if (config.isSync()) {
        endpoint.setExchangePattern(ExchangePattern.InOut);
    } else {
        endpoint.setExchangePattern(ExchangePattern.InOnly);
    }
    return endpoint;
}",java:S112,4
"protected void setupSocketProtocol(MinaConfiguration configuration) throws Exception{
    LOG.debug(""createSocketEndpoint"");
    boolean minaLogger = configuration.isMinaLogger();
    List<IoFilter> filters = configuration.getFilters();
    address = new InetSocketAddress(configuration.getHost(), configuration.getPort());
    final int processorCount = Runtime.getRuntime().availableProcessors() + 1;
    acceptor = new NioSocketAcceptor(processorCount);
    configureCodecFactory(""MinaConsumer"", acceptor, configuration);
    ((NioSocketAcceptor) acceptor).setReuseAddress(true);
    setupNioSocketAcceptor(configuration, minaLogger, filters);
    if (configuration.getSslContextParameters() != null) {
        SslFilter filter = new SslFilter(configuration.getSslContextParameters().createSSLContext(getEndpoint().getCamelContext()));
        acceptor.getFilterChain().addFirst(""sslFilter"", filter);
    }
}",java:S112,4
"protected void setupClientSocketProtocol(MinaConfiguration configuration) throws Exception{
    boolean minaLogger = configuration.isMinaLogger();
    long timeout = configuration.getTimeout();
    List<IoFilter> filters = configuration.getFilters();
    address = new InetSocketAddress(configuration.getHost(), configuration.getPort());
    final int processorCount = Runtime.getRuntime().availableProcessors() + 1;
    connector = new NioSocketConnector(processorCount);
    workerPool = createThreadPool(configuration);
    connector.getFilterChain().addLast(""threadPool"", new ExecutorFilter(workerPool));
    if (minaLogger) {
        connector.getFilterChain().addLast(""logger"", new LoggingFilter());
    }
    appendIoFiltersToChain(filters, connector.getFilterChain());
    if (configuration.getSslContextParameters() != null) {
        SslFilter filter = new SslFilter(configuration.getSslContextParameters().createSSLContext(getEndpoint().getCamelContext()));
        connector.getFilterChain().addFirst(""sslFilter"", filter);
    }
    configureCodecFactory(""MinaConsumer"", connector, configuration);
    connector.setConnectTimeoutMillis(timeout);
}",java:S112,4
"private Exchange createExchange(IoSession session, Object payload){
    Exchange exchange;
    if (configuration.isTransferExchange()) {
        exchange = getEndpoint().createExchange();
    } else {
        exchange = createExchange(false);
    }
    exchange.getIn().setHeader(MinaConstants.MINA_IOSESSION, session);
    exchange.getIn().setHeader(MinaConstants.MINA_LOCAL_ADDRESS, session.getLocalAddress());
    exchange.getIn().setHeader(MinaConstants.MINA_REMOTE_ADDRESS, session.getRemoteAddress());
    MinaPayloadHelper.setIn(exchange, payload);
    return exchange;
}",java:S3398,35
"protected void doProcess(Exchange exchange) throws Exception{
    if (session == null && !lazySessionCreation) {
        throw new IllegalStateException(""Not started yet!"");
    }
    if (session == null || !session.isConnected()) {
        openConnection();
    }
    if (getEndpoint().getConfiguration().getCharsetName() != null) {
        exchange.setProperty(ExchangePropertyKey.CHARSET_NAME, IOHelper.normalizeCharset(getEndpoint().getConfiguration().getCharsetName()));
    }
    Object body = MinaPayloadHelper.getIn(getEndpoint(), exchange);
    if (body == null) {
        noReplyLogger.log(""No payload to send for exchange: "" + exchange);
        return;
    }
    if (getEndpoint().getConfiguration().isTextline()) {
        body = getEndpoint().getCamelContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body);
    }
    if (sync) {
        responseLatch = new CountDownLatch(1);
        handler.reset();
    }
    if (LOG.isDebugEnabled()) {
        Object out = body;
        if (body instanceof byte[]) {
            out = exchange.getContext().getTypeConverter().convertTo(String.class, body);
        }
        LOG.debug(""Writing body: {}"", out);
    }
    MinaHelper.writeBody(session, body, exchange, writeTimeout);
    if (sync) {
        LOG.debug(""Waiting for response using timeout {} millis."", timeout);
        boolean done = responseLatch.await(timeout, TimeUnit.MILLISECONDS);
        if (!done) {
            maybeDisconnectOnTimeout();
            throw new ExchangeTimedOutException(exchange, timeout);
        }
        if (handler.getCause() != null) {
            throw new CamelExchangeException(""Error occurred in ResponseHandler"", exchange, handler.getCause());
        } else if (!handler.isMessageReceived()) {
            maybeDisconnectOnTimeout();
            throw new ExchangeTimedOutException(exchange, timeout);
        } else {
            if (ExchangeHelper.isOutCapable(exchange)) {
                MinaPayloadHelper.setOut(exchange, handler.getMessage());
            } else {
                MinaPayloadHelper.setIn(exchange, handler.getMessage());
            }
        }
    }
}",java:S3776,39
"protected void doProcess(Exchange exchange) throws Exception{
    if (session == null && !lazySessionCreation) {
        throw new IllegalStateException(""Not started yet!"");
    }
    if (session == null || !session.isConnected()) {
        openConnection();
    }
    if (getEndpoint().getConfiguration().getCharsetName() != null) {
        exchange.setProperty(ExchangePropertyKey.CHARSET_NAME, IOHelper.normalizeCharset(getEndpoint().getConfiguration().getCharsetName()));
    }
    Object body = MinaPayloadHelper.getIn(getEndpoint(), exchange);
    if (body == null) {
        noReplyLogger.log(""No payload to send for exchange: "" + exchange);
        return;
    }
    if (getEndpoint().getConfiguration().isTextline()) {
        body = getEndpoint().getCamelContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body);
    }
    if (sync) {
        responseLatch = new CountDownLatch(1);
        handler.reset();
    }
    if (LOG.isDebugEnabled()) {
        Object out = body;
        if (body instanceof byte[]) {
            out = exchange.getContext().getTypeConverter().convertTo(String.class, body);
        }
        LOG.debug(""Writing body: {}"", out);
    }
    MinaHelper.writeBody(session, body, exchange, writeTimeout);
    if (sync) {
        LOG.debug(""Waiting for response using timeout {} millis."", timeout);
        boolean done = responseLatch.await(timeout, TimeUnit.MILLISECONDS);
        if (!done) {
            maybeDisconnectOnTimeout();
            throw new ExchangeTimedOutException(exchange, timeout);
        }
        if (handler.getCause() != null) {
            throw new CamelExchangeException(""Error occurred in ResponseHandler"", exchange, handler.getCause());
        } else if (!handler.isMessageReceived()) {
            maybeDisconnectOnTimeout();
            throw new ExchangeTimedOutException(exchange, timeout);
        } else {
            if (ExchangeHelper.isOutCapable(exchange)) {
                MinaPayloadHelper.setOut(exchange, handler.getMessage());
            } else {
                MinaPayloadHelper.setIn(exchange, handler.getMessage());
            }
        }
    }
}",java:S112,4
"protected void setupSocketProtocol() throws Exception{
    boolean minaLogger = configuration.isMinaLogger();
    long timeout = configuration.getTimeout();
    List<IoFilter> filters = configuration.getFilters();
    address = new InetSocketAddress(configuration.getHost(), configuration.getPort());
    final int processorCount = Runtime.getRuntime().availableProcessors() + 1;
    connector = new NioSocketConnector(processorCount);
    connectorConfig = connector.getSessionConfig();
    if (configuration.isOrderedThreadPoolExecutor()) {
        workerPool = new OrderedThreadPoolExecutor(configuration.getMaximumPoolSize());
    } else {
        workerPool = new UnorderedThreadPoolExecutor(configuration.getMaximumPoolSize());
    }
    connector.getFilterChain().addLast(""threadPool"", new ExecutorFilter(workerPool));
    if (minaLogger) {
        connector.getFilterChain().addLast(""logger"", new LoggingFilter());
    }
    appendIoFiltersToChain(filters, connector.getFilterChain());
    if (configuration.getSslContextParameters() != null) {
        SslFilter filter = new SslFilter(configuration.getSslContextParameters().createSSLContext(getEndpoint().getCamelContext()));
        connector.getFilterChain().addFirst(""sslFilter"", filter);
    }
    configureCodecFactory(""MinaProducer"", connector);
    connector.setConnectTimeoutMillis(timeout);
}",java:S112,4
"private boolean bucketExists(String bucketName) throws Exception{
    return getMinioClient().bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());
}",java:S112,4
"private void makeBucket(String bucketName) throws Exception{
    MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());
    if (isNotEmpty(getConfiguration().getRegion())) {
        makeBucketRequest.region(getConfiguration().getRegion());
    }
    getMinioClient().makeBucket(makeBucketRequest.build());
}",java:S112,4
"private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception{
    GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);
    MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryptionCustomerKey, getObjectRequest::ssec);
    MinioChecks.checkLengthAndSetConfig(getConfiguration()::getOffset, getObjectRequest::offset);
    MinioChecks.checkLengthAndSetConfig(getConfiguration()::getLength, getObjectRequest::length);
    MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getVersionId, getObjectRequest::versionId);
    MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getMatchETag, getObjectRequest::matchETag);
    MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getNotMatchETag, getObjectRequest::notMatchETag);
    MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getModifiedSince, getObjectRequest::modifiedSince);
    MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getUnModifiedSince, getObjectRequest::unmodifiedSince);
    return minioClient.getObject(getObjectRequest.build());
}",java:S112,4
"private boolean bucketExists(String bucketName) throws Exception{
    return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());
}",java:S112,4
"private void makeBucket(String bucketName) throws Exception{
    MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());
    if (isNotEmpty(getConfiguration().getRegion())) {
        makeBucketRequest.region(getConfiguration().getRegion());
    }
    minioClient.makeBucket(makeBucketRequest.build());
}",java:S112,4
"private void setBucketPolicy(String bucketName) throws Exception{
    LOG.trace(""Updating bucket {} with policy..."", bucketName);
    minioClient.setBucketPolicy(SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());
    LOG.trace(""Bucket policy updated"");
}",java:S112,4
" void getObjectStat(String objectName, Message message) throws Exception{
    String bucketName = getConfiguration().getBucketName();
    StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);
    MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryptionCustomerKey, statObjectRequest::ssec);
    MinioChecks.checkLengthAndSetConfig(getConfiguration()::getOffset, statObjectRequest::offset);
    MinioChecks.checkLengthAndSetConfig(getConfiguration()::getLength, statObjectRequest::length);
    MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getVersionId, statObjectRequest::versionId);
    MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getMatchETag, statObjectRequest::matchETag);
    MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getNotMatchETag, statObjectRequest::notMatchETag);
    MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getModifiedSince, statObjectRequest::modifiedSince);
    MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getUnModifiedSince, statObjectRequest::unmodifiedSince);
    StatObjectResponse stat = minioClient.statObject(statObjectRequest.build());
    message.setHeader(MinioConstants.OBJECT_NAME, stat.object());
    message.setHeader(MinioConstants.BUCKET_NAME, stat.bucket());
    message.setHeader(MinioConstants.E_TAG, stat.etag());
    message.setHeader(MinioConstants.LAST_MODIFIED, stat.headers().get(""last-modified""));
    message.setHeader(MinioConstants.VERSION_ID, stat.headers().get(""x-amz-version-id""));
    message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());
    message.setHeader(MinioConstants.CONTENT_LENGTH, stat.size());
    message.setHeader(MinioConstants.CONTENT_ENCODING, stat.headers().get(""content-encoding""));
    message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.headers().get(""content-disposition""));
    message.setHeader(MinioConstants.CACHE_CONTROL, stat.headers().get(""cache-control""));
    message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.headers().get(""x-amz-server-side-encryption""));
    message.setHeader(MinioConstants.EXPIRATION_TIME, stat.headers().get(""x-amz-expiration""));
    message.setHeader(MinioConstants.REPLICATION_STATUS, stat.headers().get(""x-amz-replication-status""));
    message.setHeader(MinioConstants.STORAGE_CLASS, stat.headers().get(""x-amz-storage-class""));
}",java:S112,4
"public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception{
    if (getConfiguration().isPojoRequest()) {
        PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);
        if (isNotEmpty(payload)) {
            ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());
            Message message = getMessageForResponse(exchange);
            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());
            if (isNotEmpty(putObjectResult.versionId())) {
                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());
            }
        }
    } else {
        final String bucketName = determineBucketName(exchange);
        final String objectName = determineObjectName(exchange);
        Map<String, String> objectMetadata = determineMetadata(exchange);
        Map<String, String> extraHeaders = determineExtraHeaders(exchange);
        long contentLength = Long.parseLong(objectMetadata.getOrDefault(Exchange.CONTENT_LENGTH, ""-1""));
        Object object = exchange.getIn().getMandatoryBody();
        InputStream inputStream = null;
        File filePayload = null;
        try {
            if (object instanceof WrappedFile) {
                object = ((WrappedFile<?>) object).getFile();
            }
            if (object instanceof File) {
                filePayload = (File) object;
                inputStream = new FileInputStream(filePayload);
                contentLength = filePayload.length();
            } else {
                inputStream = exchange.getMessage().getMandatoryBody(InputStream.class);
                if (contentLength <= 0) {
                    contentLength = determineLengthInputStream(inputStream);
                    if (contentLength == -1) {
                        LOG.debug(""The content length is not defined. It needs to be determined by reading the data into memory"");
                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
                        IOHelper.copyAndCloseInput(inputStream, baos);
                        byte[] arr = baos.toByteArray();
                        contentLength = arr.length;
                        inputStream = new ByteArrayInputStream(arr);
                    }
                }
            }
            if (contentLength > 0) {
                objectMetadata.put(Exchange.CONTENT_LENGTH, String.valueOf(contentLength));
            }
            doPutObject(exchange, bucketName, objectName, objectMetadata, extraHeaders, inputStream, contentLength);
        } finally {
            IOHelper.close(inputStream);
        }
        if (getConfiguration().isDeleteAfterWrite() && isNotEmpty(filePayload)) {
            FileUtil.deleteFile(filePayload);
        }
    }
}",java:S3776,39
"public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception{
    if (getConfiguration().isPojoRequest()) {
        PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);
        if (isNotEmpty(payload)) {
            ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());
            Message message = getMessageForResponse(exchange);
            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());
            if (isNotEmpty(putObjectResult.versionId())) {
                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());
            }
        }
    } else {
        final String bucketName = determineBucketName(exchange);
        final String objectName = determineObjectName(exchange);
        Map<String, String> objectMetadata = determineMetadata(exchange);
        Map<String, String> extraHeaders = determineExtraHeaders(exchange);
        long contentLength = Long.parseLong(objectMetadata.getOrDefault(Exchange.CONTENT_LENGTH, ""-1""));
        Object object = exchange.getIn().getMandatoryBody();
        InputStream inputStream = null;
        File filePayload = null;
        try {
            if (object instanceof WrappedFile) {
                object = ((WrappedFile<?>) object).getFile();
            }
            if (object instanceof File) {
                filePayload = (File) object;
                inputStream = new FileInputStream(filePayload);
                contentLength = filePayload.length();
            } else {
                inputStream = exchange.getMessage().getMandatoryBody(InputStream.class);
                if (contentLength <= 0) {
                    contentLength = determineLengthInputStream(inputStream);
                    if (contentLength == -1) {
                        LOG.debug(""The content length is not defined. It needs to be determined by reading the data into memory"");
                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
                        IOHelper.copyAndCloseInput(inputStream, baos);
                        byte[] arr = baos.toByteArray();
                        contentLength = arr.length;
                        inputStream = new ByteArrayInputStream(arr);
                    }
                }
            }
            if (contentLength > 0) {
                objectMetadata.put(Exchange.CONTENT_LENGTH, String.valueOf(contentLength));
            }
            doPutObject(exchange, bucketName, objectName, objectMetadata, extraHeaders, inputStream, contentLength);
        } finally {
            IOHelper.close(inputStream);
        }
        if (getConfiguration().isDeleteAfterWrite() && isNotEmpty(filePayload)) {
            FileUtil.deleteFile(filePayload);
        }
    }
}",java:S112,4
"private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception{
    if (getConfiguration().isPojoRequest()) {
        CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);
        if (isNotEmpty(payload)) {
            ObjectWriteResponse result = minioClient.copyObject(payload.build());
            Message message = getMessageForResponse(exchange);
            message.setBody(result);
        }
    } else {
        final String bucketName = determineBucketName(exchange);
        final String sourceKey = determineObjectName(exchange);
        final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);
        final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);
        if (isEmpty(destinationBucketName)) {
            throw new IllegalArgumentException(""Bucket Name Destination must be specified for copyObject Operation"");
        }
        if (isEmpty(destinationKey)) {
            throw new IllegalArgumentException(""Destination Key must be specified for copyObject Operation"");
        }
        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(bucketName).object(sourceKey);
        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder().bucket(destinationBucketName).object(destinationKey).source(copySourceBuilder.build());
        ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());
        Message message = getMessageForResponse(exchange);
        if (isNotEmpty(copyObjectResult.versionId())) {
            message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());
        }
    }
}",java:S112,4
"private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception{
    if (getConfiguration().isPojoRequest()) {
        RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);
        if (isNotEmpty(payload)) {
            minioClient.removeObject(payload.build());
            Message message = getMessageForResponse(exchange);
            message.setBody(true);
        }
    } else {
        final String bucketName = determineBucketName(exchange);
        final String sourceKey = determineObjectName(exchange);
        minioClient.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(sourceKey).build());
        Message message = getMessageForResponse(exchange);
        message.setBody(true);
    }
}",java:S112,4
"private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception{
    if (getConfiguration().isPojoRequest()) {
        RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);
        if (isNotEmpty(payload)) {
            minioClient.removeObjects(payload.build()).iterator().hasNext();
            Message message = getMessageForResponse(exchange);
            message.setBody(true);
        }
    } else {
        throw new IllegalArgumentException(""Cannot delete multiple objects without a POJO request"");
    }
}",java:S112,4
"private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception{
    List<Bucket> bucketsList = minioClient.listBuckets();
    Message message = getMessageForResponse(exchange);
    message.setBody(bucketsList.iterator());
}",java:S112,4
"private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception{
    final String bucketName = determineBucketName(exchange);
    if (getConfiguration().isPojoRequest()) {
        RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);
        if (isNotEmpty(payload)) {
            minioClient.removeBucket(payload.build());
            Message message = getMessageForResponse(exchange);
            message.setBody(""ok"");
        }
    } else {
        minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());
        Message message = getMessageForResponse(exchange);
        message.setBody(""ok"");
    }
}",java:S112,4
"private void getObject(MinioClient minioClient, Exchange exchange) throws Exception{
    if (getConfiguration().isPojoRequest()) {
        GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);
        if (isNotEmpty(payload)) {
            InputStream respond = minioClient.getObject(payload.build());
            Message message = getMessageForResponse(exchange);
            message.setBody(respond);
        }
    } else {
        final String bucketName = determineBucketName(exchange);
        final String sourceKey = determineObjectName(exchange);
        InputStream respond = minioClient.getObject(GetObjectArgs.builder().bucket(bucketName).object(sourceKey).build());
        Message message = getMessageForResponse(exchange);
        message.setBody(respond);
    }
}",java:S112,4
"private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception{
    if (getConfiguration().isPojoRequest()) {
        GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);
        if (isNotEmpty(payload)) {
            InputStream respond = minioClient.getObject(payload.build());
            Message message = getMessageForResponse(exchange);
            message.setBody(respond);
        }
    } else {
        final String bucketName = determineBucketName(exchange);
        final String sourceKey = determineObjectName(exchange);
        final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);
        final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);
        if (isEmpty(offset) || isEmpty(length)) {
            throw new IllegalArgumentException(""A Offset and length header must be configured to perform a partial get operation."");
        }
        InputStream respond = minioClient.getObject(GetObjectArgs.builder().bucket(bucketName).object(sourceKey).offset(Long.parseLong(offset)).length(Long.parseLong(length)).build());
        Message message = getMessageForResponse(exchange);
        message.setBody(respond);
    }
}",java:S112,4
"private void createPresignedUrl(MinioClient minioClient, Exchange exchange, Method method) throws Exception{
    int expiry = 60 * 60;
    Integer expirationInSeconds = exchange.getIn().getHeader(MinioConstants.PRESIGNED_URL_EXPIRATION_TIME, Integer.class);
    Message message = getMessageForResponse(exchange);
    if (expirationInSeconds != null) {
        expiry = expirationInSeconds;
    }
    if (getConfiguration().isPojoRequest()) {
        GetPresignedObjectUrlArgs.Builder payload = exchange.getIn().getMandatoryBody(GetPresignedObjectUrlArgs.Builder.class);
        if (isNotEmpty(payload)) {
            GetPresignedObjectUrlArgs args = payload.expiry(expiry).method(method).build();
            String response = minioClient.getPresignedObjectUrl(args);
            message.setBody(response);
        }
    } else {
        final String bucketName = determineBucketName(exchange);
        final String objectName = determineObjectName(exchange);
        GetPresignedObjectUrlArgs args = GetPresignedObjectUrlArgs.builder().bucket(bucketName).object(objectName).expiry(expiry).method(method).build();
        String response = minioClient.getPresignedObjectUrl(args);
        message.setBody(response);
    }
}",java:S112,4
"public void doConnectionClose(Socket socket, boolean reset, Logger log){
    String ignoringCallLogFormat = ""Ignoring {} Connection request because - {}: localAddress={} remoteAddress={}"";
    if (socket == null) {
        if (log != null) {
            log.debug(ignoringCallLogFormat, reset ? ""Reset"" : ""Close"", ""Socket is null"", ""null"", ""null"");
        }
    } else {
        SocketAddress localSocketAddress = socket.getLocalSocketAddress();
        SocketAddress remoteSocketAddress = socket.getRemoteSocketAddress();
        if (!socket.isConnected()) {
            if (log != null) {
                log.debug(ignoringCallLogFormat, reset ? ""Reset"" : ""Close"", ""Socket is not connected"", localSocketAddress, remoteSocketAddress);
            }
        } else if (socket.isClosed()) {
            if (log != null) {
                log.debug(ignoringCallLogFormat, reset ? ""Reset"" : ""Close"", ""Socket is already closed"", localSocketAddress, remoteSocketAddress);
            }
        } else {
            this.updateLastConnectionTerminatedTicks();
            final String ignoringExceptionStringFormat = ""Ignoring %s encountered calling %s on Socket: localAddress=%s remoteAddress=%s"";
            if (!socket.isInputShutdown()) {
                if (log != null) {
                    log.trace(""Shutting down input on Socket: localAddress={} remoteAddress={}"", localSocketAddress, remoteSocketAddress);
                }
                try {
                    socket.shutdownInput();
                } catch (Exception ioEx) {
                    if (log != null && log.isDebugEnabled()) {
                        String logMessage = String.format(ignoringExceptionStringFormat, ioEx.getClass().getSimpleName(), ""shutdownInput()"", localSocketAddress, remoteSocketAddress);
                        log.debug(logMessage, ioEx);
                    }
                }
            }
            if (!socket.isOutputShutdown()) {
                if (log != null) {
                    log.trace(""Shutting down output on Socket: localAddress={} remoteAddress={}"", localSocketAddress, remoteSocketAddress);
                }
                try {
                    socket.shutdownOutput();
                } catch (IOException ioEx) {
                    if (log != null && log.isDebugEnabled()) {
                        String logMessage = String.format(ignoringExceptionStringFormat, ioEx.getClass().getSimpleName(), ""shutdownOutput()"", localSocketAddress, remoteSocketAddress);
                        log.debug(logMessage, ioEx);
                    }
                }
            }
            if (reset) {
                final boolean on = true;
                final int linger = 0;
                if (log != null) {
                    log.trace(""Setting SO_LINGER to {} on Socket: localAddress={} remoteAddress={}"", linger, localSocketAddress, remoteSocketAddress);
                }
                try {
                    socket.setSoLinger(on, linger);
                } catch (IOException ioEx) {
                    if (log != null && log.isDebugEnabled()) {
                        String methodString = String.format(""setSoLinger(%b, %d)"", on, linger);
                        String logMessage = String.format(ignoringExceptionStringFormat, ioEx.getClass().getSimpleName(), methodString, localSocketAddress, remoteSocketAddress);
                        log.debug(logMessage, ioEx);
                    }
                }
            }
            try {
                if (log != null) {
                    log.trace(""Resetting Socket: localAddress={} remoteAddress={}"", localSocketAddress, remoteSocketAddress);
                }
                socket.close();
            } catch (IOException ioEx) {
                if (log != null && log.isDebugEnabled()) {
                    String warningMessage = String.format(ignoringExceptionStringFormat, ioEx.getClass().getSimpleName(), ""close()"", localSocketAddress, remoteSocketAddress);
                    log.debug(warningMessage, ioEx);
                }
            }
        }
    }
}",java:S3776,39
"private String processAcknowledgment(byte[] hl7MessageBytes, byte[] hl7AcknowledgementBytes) throws MllpException{
    String acknowledgementType = """";
    if (hl7AcknowledgementBytes != null && hl7AcknowledgementBytes.length > 3) {
        byte fieldDelim = hl7AcknowledgementBytes[3];
        int msaStartIndex = -1;
        for (int i = 0; i < hl7AcknowledgementBytes.length; ++i) {
            if (MllpProtocolConstants.SEGMENT_DELIMITER == hl7AcknowledgementBytes[i]) {
                final byte bM = 77;
                final byte bS = 83;
                final byte bC = 67;
                final byte bA = 65;
                final byte bE = 69;
                final byte bR = 82;
                if (hl7AcknowledgementBytes.length > i + 7) {
                    if (bM == hl7AcknowledgementBytes[i + 1] && bS == hl7AcknowledgementBytes[i + 2] && bA == hl7AcknowledgementBytes[i + 3] && fieldDelim == hl7AcknowledgementBytes[i + 4]) {
                        msaStartIndex = i + 1;
                        if (bA != hl7AcknowledgementBytes[i + 5] && bC != hl7AcknowledgementBytes[i + 5]) {
                            String errorMessage = String.format(""processAcknowledgment(hl7MessageBytes[%d], hl7AcknowledgementBytes[%d]) - unsupported acknowledgement type: '%s'"", hl7MessageBytes == null ? -1 : hl7MessageBytes.length, hl7AcknowledgementBytes.length, new String(hl7AcknowledgementBytes, i + 5, 2));
                            throw new MllpInvalidAcknowledgementException(errorMessage, hl7MessageBytes, hl7AcknowledgementBytes, logPhi);
                        } else {
                            switch(hl7AcknowledgementBytes[i + 6]) {
                                case bA:
                                    if (bA == hl7AcknowledgementBytes[i + 5]) {
                                        acknowledgementType = ""AA"";
                                    } else {
                                        acknowledgementType = ""CA"";
                                    }
                                    break;
                                case bE:
                                    if (bA == hl7AcknowledgementBytes[i + 5]) {
                                        throw new MllpApplicationErrorAcknowledgementException(hl7MessageBytes, hl7AcknowledgementBytes, logPhi);
                                    } else {
                                        throw new MllpCommitErrorAcknowledgementException(hl7MessageBytes, hl7AcknowledgementBytes, logPhi);
                                    }
                                case bR:
                                    if (bA == hl7AcknowledgementBytes[i + 5]) {
                                        throw new MllpApplicationRejectAcknowledgementException(hl7MessageBytes, hl7AcknowledgementBytes, logPhi);
                                    } else {
                                        throw new MllpCommitRejectAcknowledgementException(hl7MessageBytes, hl7AcknowledgementBytes, logPhi);
                                    }
                                default:
                                    String errorMessage = ""Unsupported acknowledgement type: "" + new String(hl7AcknowledgementBytes, i + 5, 2);
                                    throw new MllpInvalidAcknowledgementException(errorMessage, hl7MessageBytes, hl7AcknowledgementBytes, logPhi);
                            }
                        }
                        break;
                    }
                }
            }
        }
        if (-1 == msaStartIndex && getConfiguration().isValidatePayload()) {
            throw new MllpInvalidAcknowledgementException(""MSA Not found in acknowledgement"", hl7MessageBytes, hl7AcknowledgementBytes, logPhi);
        }
    }
    return acknowledgementType;
}",java:S3776,39
"public void processMessage(byte[] hl7MessageBytes, TcpSocketConsumerRunnable consumerRunnable){
    long now = System.currentTimeMillis();
    getEndpoint().updateLastConnectionActivityTicks(now);
    consumerRunnables.put(consumerRunnable, now);
    log.debug(""processMessage(hl7MessageBytes[{}], {}) - populating the exchange with received payload"", hl7MessageBytes == null ? -1 : hl7MessageBytes.length, consumerRunnable.getSocket());
    Exchange exchange = createExchange(false);
    exchange.setPattern(ExchangePattern.InOut);
    if (getConfiguration().hasCharsetName()) {
        exchange.setProperty(ExchangePropertyKey.CHARSET_NAME, getConfiguration().getCharsetName());
    }
    try {
        createUoW(exchange);
        if (exchange.hasProperties() || exchange.getProperty(MllpConstants.MLLP_AUTO_ACKNOWLEDGE) == null) {
            exchange.setProperty(MllpConstants.MLLP_AUTO_ACKNOWLEDGE, getConfiguration().isAutoAck());
        }
        Message message = exchange.getIn();
        if (consumerRunnable.hasLocalAddress()) {
            message.setHeader(MllpConstants.MLLP_LOCAL_ADDRESS, consumerRunnable.getLocalAddress());
        }
        if (consumerRunnable.hasRemoteAddress()) {
            message.setHeader(MllpConstants.MLLP_REMOTE_ADDRESS, consumerRunnable.getRemoteAddress());
        }
        if (getConfiguration().isValidatePayload()) {
            String exceptionMessage = hl7Util.generateInvalidPayloadExceptionMessage(hl7MessageBytes);
            if (exceptionMessage != null) {
                exchange.setException(new MllpInvalidMessageException(exceptionMessage, hl7MessageBytes, logPhi));
            }
        }
        populateHl7DataHeaders(exchange, message, hl7MessageBytes);
        if (getConfiguration().isStringPayload()) {
            if (hl7MessageBytes != null && hl7MessageBytes.length > 0) {
                message.setBody(new String(hl7MessageBytes, MllpCharsetHelper.getCharset(exchange, hl7MessageBytes, hl7Util, charset)));
            } else {
                message.setBody("""", String.class);
            }
        } else {
            message.setBody(hl7MessageBytes, byte[].class);
        }
        log.debug(""processMessage(hl7MessageBytes[{}], {}) - calling processor"", hl7MessageBytes == null ? -1 : hl7MessageBytes.length, consumerRunnable.getSocket());
        try {
            getProcessor().process(exchange);
            sendAcknowledgement(hl7MessageBytes, exchange, consumerRunnable);
        } catch (Exception unexpectedEx) {
            String resetMessage = ""processMessage(byte[], TcpSocketConsumerRunnable) - Unexpected exception processing exchange"";
            consumerRunnable.resetSocket(resetMessage);
            getExceptionHandler().handleException(resetMessage, exchange, unexpectedEx);
        }
    } catch (Exception uowEx) {
        getExceptionHandler().handleException(""processMessage(byte[], TcpSocketConsumerRunnable) - Unexpected exception creating Unit of Work"", exchange, uowEx);
    } finally {
        doneUoW(exchange);
        releaseExchange(exchange, false);
    }
}",java:S3776,39
" void populateHl7DataHeaders(Exchange exchange, Message message, byte[] hl7MessageBytes){
    if (getConfiguration().isHl7Headers() && exchange != null && exchange.getException() == null) {
        if (hl7MessageBytes == null || hl7MessageBytes.length < 8) {
            return;
        }
        final byte fieldSeparator = hl7MessageBytes[3];
        int endOfMSH = -1;
        List<Integer> fieldSeparatorIndexes = new ArrayList<>(10);
        for (int i = 0; i < hl7MessageBytes.length; ++i) {
            if (fieldSeparator == hl7MessageBytes[i]) {
                fieldSeparatorIndexes.add(i);
            } else if (MllpProtocolConstants.SEGMENT_DELIMITER == hl7MessageBytes[i]) {
                if (fieldSeparator != hl7MessageBytes[i - 1]) {
                    fieldSeparatorIndexes.add(i);
                }
                endOfMSH = i;
                break;
            }
        }
        if (-1 == endOfMSH) {
            log.warn(""Population of message headers failed - unable to find the end of the MSH segment"");
        } else {
            log.debug(""Populating the HL7 message headers"");
            Charset charset = MllpCharsetHelper.getCharset(exchange, this.charset);
            for (int i = 2; i < fieldSeparatorIndexes.size(); ++i) {
                int startingFieldSeparatorIndex = fieldSeparatorIndexes.get(i - 1);
                int endingFieldSeparatorIndex = fieldSeparatorIndexes.get(i);
                if (endingFieldSeparatorIndex - startingFieldSeparatorIndex > 1) {
                    String headerName;
                    switch(i) {
                        case 2:
                            headerName = MllpConstants.MLLP_SENDING_APPLICATION;
                            break;
                        case 3:
                            headerName = MllpConstants.MLLP_SENDING_FACILITY;
                            break;
                        case 4:
                            headerName = MllpConstants.MLLP_RECEIVING_APPLICATION;
                            break;
                        case 5:
                            headerName = MllpConstants.MLLP_RECEIVING_FACILITY;
                            break;
                        case 6:
                            headerName = MllpConstants.MLLP_TIMESTAMP;
                            break;
                        case 7:
                            headerName = MllpConstants.MLLP_SECURITY;
                            break;
                        case 8:
                            headerName = MllpConstants.MLLP_MESSAGE_TYPE;
                            break;
                        case 9:
                            headerName = MllpConstants.MLLP_MESSAGE_CONTROL;
                            break;
                        case 10:
                            headerName = MllpConstants.MLLP_PROCESSING_ID;
                            break;
                        case 11:
                            headerName = MllpConstants.MLLP_VERSION_ID;
                            break;
                        case 17:
                            headerName = MllpConstants.MLLP_CHARSET;
                            break;
                        default:
                            continue;
                    }
                    String headerValue = (i == 17 && getConfiguration().hasCharsetName()) ? getConfiguration().getCharsetName() : new String(hl7MessageBytes, startingFieldSeparatorIndex + 1, endingFieldSeparatorIndex - startingFieldSeparatorIndex - 1, charset);
                    message.setHeader(headerName, headerValue);
                    if (i == 8) {
                        String componentSeparator = new String(hl7MessageBytes, 4, 1, charset);
                        String[] components = headerValue.split(Pattern.quote(componentSeparator), 3);
                        message.setHeader(MllpConstants.MLLP_EVENT_TYPE, components[0]);
                        if (2 <= components.length) {
                            message.setHeader(MllpConstants.MLLP_TRIGGER_EVENT, components[1]);
                        }
                    }
                }
            }
        }
    } else {
        log.trace(""HL7 Message headers disabled"");
    }
}",java:S3776,39
" void sendAcknowledgement(byte[] originalHl7MessageBytes, Exchange exchange, TcpSocketConsumerRunnable consumerRunnable){
    log.trace(""sendAcknowledgement(originalHl7MessageBytes[{}], Exchange[{}], {}) - entering"", originalHl7MessageBytes == null ? -1 : originalHl7MessageBytes.length, exchange.getExchangeId(), consumerRunnable.getSocket());
    getEndpoint().checkBeforeSendProperties(exchange, consumerRunnable.getSocket(), log);
    byte[] acknowledgementMessageBytes = exchange.getProperty(MllpConstants.MLLP_ACKNOWLEDGEMENT, byte[].class);
    if (acknowledgementMessageBytes == null) {
        acknowledgementMessageBytes = exchange.getProperty(MllpConstants.MLLP_ACKNOWLEDGEMENT_STRING, byte[].class);
    }
    String acknowledgementMessageType = null;
    if (null == acknowledgementMessageBytes) {
        boolean autoAck = exchange.getProperty(MllpConstants.MLLP_AUTO_ACKNOWLEDGE, true, boolean.class);
        if (!autoAck) {
            if (getConfiguration().getExchangePattern() == ExchangePattern.InOut) {
                final Object acknowledgementBytesProperty = exchange.getProperty(MllpConstants.MLLP_ACKNOWLEDGEMENT);
                Object acknowledgementStringProperty = exchange.getProperty(MllpConstants.MLLP_ACKNOWLEDGEMENT_STRING);
                final String exceptionMessage = (acknowledgementBytesProperty == null && acknowledgementStringProperty == null) ? ""Automatic Acknowledgement is disabled and the "" + MllpConstants.MLLP_ACKNOWLEDGEMENT + "" and "" + MllpConstants.MLLP_ACKNOWLEDGEMENT_STRING + "" exchange properties are null"" : ""Automatic Acknowledgement is disabled and neither the "" + MllpConstants.MLLP_ACKNOWLEDGEMENT + ""(type = "" + getTypeOrNullString(acknowledgementBytesProperty) + "") nor the"" + MllpConstants.MLLP_ACKNOWLEDGEMENT_STRING + ""(type = "" + getTypeOrNullString(acknowledgementBytesProperty) + "") exchange properties can be converted to byte[]"";
                MllpInvalidAcknowledgementException invalidAckEx = new MllpInvalidAcknowledgementException(exceptionMessage, originalHl7MessageBytes, acknowledgementMessageBytes, logPhi);
                exchange.setProperty(MllpConstants.MLLP_ACKNOWLEDGEMENT_EXCEPTION, invalidAckEx);
                getExceptionHandler().handleException(invalidAckEx);
            }
        } else {
            String acknowledgmentTypeProperty = exchange.getProperty(MllpConstants.MLLP_ACKNOWLEDGEMENT_TYPE, String.class);
            String msa3 = exchange.getProperty(MllpConstants.MLLP_ACKNOWLEDGEMENT_MSA_TEXT, String.class);
            Exception exchangeEx = exchange.getException();
            try {
                if (null == acknowledgmentTypeProperty) {
                    if (null == exchangeEx) {
                        acknowledgementMessageType = ""AA"";
                    } else {
                        acknowledgementMessageType = ""AE"";
                        if (msa3 == null || msa3.isEmpty()) {
                            msa3 = exchangeEx.getClass().getName();
                        }
                    }
                } else {
                    switch(acknowledgmentTypeProperty) {
                        case ""AA"":
                            acknowledgementMessageType = ""AA"";
                            break;
                        case ""AE"":
                            acknowledgementMessageType = ""AE"";
                            if (exchangeEx != null && msa3 != null && msa3.isEmpty()) {
                                msa3 = exchangeEx.getClass().getName();
                            }
                            break;
                        case ""AR"":
                            acknowledgementMessageType = ""AR"";
                            if (exchangeEx != null && msa3 != null && msa3.isEmpty()) {
                                msa3 = exchangeEx.getClass().getName();
                            }
                            break;
                        default:
                            exchange.setException(new Hl7AcknowledgementGenerationException(hl7Util, ""Unsupported acknowledgment type: "" + acknowledgmentTypeProperty));
                            return;
                    }
                }
                hl7Util.generateAcknowledgementPayload(consumerRunnable.getMllpBuffer(), originalHl7MessageBytes, acknowledgementMessageType, msa3);
            } catch (MllpAcknowledgementGenerationException ackGenerationException) {
                exchange.setProperty(MllpConstants.MLLP_ACKNOWLEDGEMENT_EXCEPTION, ackGenerationException);
                getExceptionHandler().handleException(ackGenerationException);
            }
        }
    } else {
        consumerRunnable.getMllpBuffer().setEnvelopedMessage(acknowledgementMessageBytes);
        final byte bM = 77;
        final byte bS = 83;
        final byte bA = 65;
        final byte bE = 69;
        final byte bR = 82;
        final byte fieldSeparator = originalHl7MessageBytes[3];
        for (int i = 0; i < originalHl7MessageBytes.length; ++i) {
            if (MllpProtocolConstants.SEGMENT_DELIMITER == i) {
                if (i + 7 < originalHl7MessageBytes.length && bM == originalHl7MessageBytes[i + 1] && bS == originalHl7MessageBytes[i + 2] && bA == originalHl7MessageBytes[i + 3] && fieldSeparator == originalHl7MessageBytes[i + 4]) {
                    if (fieldSeparator != originalHl7MessageBytes[i + 7]) {
                        log.warn(""MSA-1 is longer than 2-bytes - ignoring trailing bytes"");
                    }
                    byte[] acknowledgmentTypeBytes = new byte[2];
                    acknowledgmentTypeBytes[0] = originalHl7MessageBytes[i + 5];
                    acknowledgmentTypeBytes[1] = originalHl7MessageBytes[i + 6];
                    try {
                        acknowledgementMessageType = new String(acknowledgmentTypeBytes, ExchangeHelper.getCharsetName(exchange));
                    } catch (IOException ioEx) {
                        throw new RuntimeCamelException(""Failed to convert acknowledgement message to string"", ioEx);
                    }
                    if (bA != acknowledgmentTypeBytes[0]) {
                        switch(acknowledgementMessageBytes[1]) {
                            case bA:
                            case bR:
                            case bE:
                                break;
                            default:
                                log.warn(""Invalid acknowledgement type [{}] found in message - should be AA, AE or AR"", acknowledgementMessageType);
                        }
                    }
                    String acknowledgementTypeProperty = exchange.getProperty(MllpConstants.MLLP_ACKNOWLEDGEMENT_TYPE, String.class);
                    if (null != acknowledgementTypeProperty && !acknowledgementTypeProperty.equals(acknowledgementMessageType)) {
                        log.warn(""Acknowledgement type found in message [{}] does not match {} exchange property "" + ""value [{}] - using value found in message"", acknowledgementMessageType, MllpConstants.MLLP_ACKNOWLEDGEMENT_TYPE, acknowledgementTypeProperty);
                    }
                }
            }
        }
    }
    Message message = exchange.getMessage();
    if (acknowledgementMessageType != null && !acknowledgementMessageType.isEmpty()) {
        message.setHeader(MllpConstants.MLLP_ACKNOWLEDGEMENT_TYPE, acknowledgementMessageType);
    }
    Charset charset = MllpCharsetHelper.getCharset(exchange, this.charset);
    if (consumerRunnable.getMllpBuffer().hasCompleteEnvelope()) {
        message.setHeader(MllpConstants.MLLP_ACKNOWLEDGEMENT, consumerRunnable.getMllpBuffer().toMllpPayload());
        message.setHeader(MllpConstants.MLLP_ACKNOWLEDGEMENT_STRING, consumerRunnable.getMllpBuffer().toHl7String(charset));
        if (log.isDebugEnabled()) {
            log.debug(""sendAcknowledgement(originalHl7MessageBytes[{}], Exchange[{}], {}) - Sending Acknowledgement: {}"", originalHl7MessageBytes == null ? -1 : originalHl7MessageBytes.length, exchange.getExchangeId(), consumerRunnable.getSocket(), consumerRunnable.getMllpBuffer().toPrintFriendlyHl7String());
        }
        try {
            consumerRunnable.getMllpBuffer().writeTo(consumerRunnable.getSocket());
        } catch (MllpSocketException acknowledgementDeliveryEx) {
            Exception exchangeEx = new MllpAcknowledgementDeliveryException(""Failure delivering acknowledgment"", originalHl7MessageBytes, acknowledgementMessageBytes, acknowledgementDeliveryEx, logPhi);
            exchange.setProperty(MllpConstants.MLLP_ACKNOWLEDGEMENT_EXCEPTION, acknowledgementDeliveryEx);
            exchange.setException(exchangeEx);
        } finally {
            consumerRunnable.getMllpBuffer().reset();
        }
    } else if (acknowledgementMessageBytes != null && acknowledgementMessageBytes.length > 0) {
        message.setHeader(MllpConstants.MLLP_ACKNOWLEDGEMENT, acknowledgementMessageBytes);
        String acknowledgementMessageString = new String(acknowledgementMessageBytes, charset);
        message.setHeader(MllpConstants.MLLP_ACKNOWLEDGEMENT_STRING, acknowledgementMessageString);
        if (log.isDebugEnabled()) {
            log.debug(""sendAcknowledgement(originalHl7MessageBytes[{}], Exchange[{}], {}) - Sending Acknowledgement: {}"", originalHl7MessageBytes == null ? -1 : originalHl7MessageBytes.length, exchange.getExchangeId(), consumerRunnable.getSocket(), hl7Util.convertToPrintFriendlyString(acknowledgementMessageBytes));
        }
        try {
            consumerRunnable.getMllpBuffer().setEnvelopedMessage(acknowledgementMessageBytes);
            consumerRunnable.getMllpBuffer().writeTo(consumerRunnable.getSocket());
        } catch (MllpSocketException acknowledgementDeliveryEx) {
            Exception exchangeEx = new MllpAcknowledgementDeliveryException(""Failure delivering acknowledgment"", originalHl7MessageBytes, acknowledgementMessageBytes, acknowledgementDeliveryEx, logPhi);
            exchange.setProperty(MllpConstants.MLLP_ACKNOWLEDGEMENT_EXCEPTION, acknowledgementDeliveryEx);
            exchange.setException(exchangeEx);
        }
    }
    getEndpoint().checkAfterSendProperties(exchange, consumerRunnable.getSocket(), log);
}",java:S3776,39
"public void appendBytesAsPrintFriendlyString(StringBuilder builder, byte[] phiBytes, int startPosition, int endPosition){
    if (builder == null) {
        throw new IllegalArgumentException(""StringBuilder cannot be null"");
    }
    if (null == phiBytes) {
        builder.append(NULL_REPLACEMENT_VALUE);
    } else if (phiBytes.length == 0) {
        builder.append(EMPTY_REPLACEMENT_VALUE);
    } else if (startPosition <= endPosition) {
        if (startPosition < 0) {
            startPosition = 0;
        }
        if (startPosition < phiBytes.length) {
            if (endPosition >= -1) {
                if (endPosition == -1 || endPosition >= phiBytes.length) {
                    endPosition = phiBytes.length;
                }
                int length = endPosition - startPosition;
                if (length > 0) {
                    int conversionLength = (logPhiMaxBytes > 0) ? Integer.min(length, logPhiMaxBytes) : length;
                    if (builder.capacity() - builder.length() < conversionLength + STRING_BUFFER_PAD_SIZE) {
                        builder.ensureCapacity(builder.length() + conversionLength + STRING_BUFFER_PAD_SIZE);
                    }
                    for (int i = 0; i < conversionLength; ++i) {
                        appendCharacterAsPrintFriendlyString(builder, (char) phiBytes[startPosition + i]);
                    }
                }
            }
        }
    }
}",java:S3776,39
"public synchronized void write(byte[] sourceBytes, int offset, int writeCount){
    if (sourceBytes != null && sourceBytes.length > 0) {
        if (offset < 0) {
            throw new IndexOutOfBoundsException(String.format(""write(byte[%d], offset[%d], writeCount[%d]) - offset is less than zero"", sourceBytes.length, offset, writeCount));
        }
        if (offset > sourceBytes.length) {
            throw new IndexOutOfBoundsException(String.format(""write(byte[%d], offset[%d], writeCount[%d]) - offset is greater than write count"", sourceBytes.length, offset, writeCount));
        }
        if (writeCount < 0) {
            throw new IndexOutOfBoundsException(String.format(""write(byte[%d], offset[%d], writeCount[%d]) - write count is less than zero"", sourceBytes.length, offset, writeCount));
        }
        if (writeCount > sourceBytes.length) {
            throw new IndexOutOfBoundsException(String.format(""write(byte[%d], offset[%d], writeCount[%d]) - write count is greater than length of the source byte[]"", sourceBytes.length, offset, writeCount));
        }
        if ((offset + writeCount) - sourceBytes.length > 0) {
            throw new IndexOutOfBoundsException(String.format(""write(byte[%d], offset[%d], writeCount[%d]) - offset plus write count <%d> is greater than length of the source byte[]"", sourceBytes.length, offset, writeCount, offset + writeCount));
        }
        ensureCapacity(writeCount);
        System.arraycopy(sourceBytes, offset, buffer, availableByteCount, writeCount);
        for (int i = offset; i < writeCount && (startOfBlockIndex < 0 || endOfBlockIndex < 0); ++i) {
            updateIndexes(sourceBytes[i], i);
        }
        availableByteCount += writeCount;
    }
}",java:S3776,39
"public synchronized void readFrom(Socket socket, int receiveTimeout, int readTimeout) throws MllpSocketException, SocketTimeoutException{
    if (socket != null && socket.isConnected() && !socket.isClosed()) {
        LOG.trace(""readFrom({}, {}, {}) - entering"", socket, receiveTimeout, readTimeout);
        ensureCapacity(minBufferSize);
        try {
            InputStream socketInputStream = socket.getInputStream();
            socket.setSoTimeout(receiveTimeout);
            readSocketInputStream(socketInputStream, socket);
            if (!hasCompleteEnvelope()) {
                socket.setSoTimeout(readTimeout);
                while (!hasCompleteEnvelope()) {
                    ensureCapacity(Math.max(minBufferSize, socketInputStream.available()));
                    readSocketInputStream(socketInputStream, socket);
                }
            }
        } catch (SocketTimeoutException timeoutEx) {
            throw timeoutEx;
        } catch (IOException ioEx) {
            final String exceptionMessage = String.format(""readFrom(%s, %d, %d) - IOException encountered"", socket, receiveTimeout, readTimeout);
            resetSocket(socket, exceptionMessage);
            throw new MllpSocketException(exceptionMessage, ioEx);
        } finally {
            if (size() > 0 && !hasCompleteEnvelope()) {
                if (!hasEndOfData() && hasEndOfBlock() && endOfBlockIndex < size() - 1) {
                    LOG.warn(""readFrom({}, {}, {}) - exiting with partial payload {}"", socket, receiveTimeout, readTimeout, hl7Util.convertToPrintFriendlyString(buffer, 0, size() - 1));
                }
            }
        }
    } else {
        LOG.warn(""readFrom({}, {}, {}) - no data read because Socket is invalid"", socket, receiveTimeout, readTimeout);
    }
    LOG.trace(""readFrom({}, {}, {}) - exiting"", socket, receiveTimeout, readTimeout);
}",java:S3776,39
"public synchronized void writeTo(Socket socket) throws MllpSocketException{
    if (socket != null && socket.isConnected() && !socket.isClosed()) {
        LOG.trace(""writeTo({}) - entering"", socket);
        if (!isEmpty()) {
            try {
                OutputStream socketOutputStream = socket.getOutputStream();
                if (hasStartOfBlock()) {
                    if (hasEndOfData()) {
                        socketOutputStream.write(buffer, startOfBlockIndex, endOfBlockIndex - startOfBlockIndex + 2);
                    } else if (hasEndOfBlock()) {
                        socketOutputStream.write(buffer, startOfBlockIndex, endOfBlockIndex - startOfBlockIndex + 1);
                        socketOutputStream.write(MllpProtocolConstants.END_OF_DATA);
                    } else {
                        socketOutputStream.write(buffer, startOfBlockIndex, availableByteCount - startOfBlockIndex);
                        socketOutputStream.write(MllpProtocolConstants.PAYLOAD_TERMINATOR);
                    }
                } else {
                    socketOutputStream.write(MllpProtocolConstants.START_OF_BLOCK);
                    socketOutputStream.write(buffer, 0, availableByteCount);
                    socketOutputStream.write(MllpProtocolConstants.PAYLOAD_TERMINATOR);
                }
                socketOutputStream.flush();
            } catch (IOException ioEx) {
                final String exceptionMessage = String.format(""writeTo(%s) - IOException encountered"", socket);
                resetSocket(socket, exceptionMessage);
                throw new MllpSocketException(exceptionMessage, ioEx);
            }
        } else {
            LOG.warn(""writeTo({}) - no data written because buffer is empty"", socket);
        }
    } else {
        LOG.warn(""writeTo({}) - no data written because Socket is invalid"", socket);
    }
    LOG.trace(""writeTo({}) - exiting"", socket);
}",java:S3776,39
" void doSocketClose(Socket socket, String logMessage, boolean reset){
    if (socket != null && socket.isConnected() && !socket.isClosed()) {
        if (logMessage != null && !logMessage.isEmpty()) {
            LOG.info(""{} - {} socket {}"", reset ? ""Resetting"" : ""Closing"", logMessage, socket);
        } else {
            LOG.debug(""{} socket {}"", reset ? ""Resetting"" : ""Closing"", socket);
        }
        endpoint.updateLastConnectionTerminatedTicks();
        if (!socket.isInputShutdown()) {
            try {
                socket.shutdownInput();
            } catch (IOException ignoredEx) {
                LOG.trace(""doSocketClose(socket[{}], logMessage[{}], reset[{}] - ignoring exception raised by Socket.shutdownInput()"", socket, logMessage, reset, ignoredEx);
            }
        }
        if (!socket.isOutputShutdown()) {
            try {
                socket.shutdownOutput();
            } catch (IOException ignoredEx) {
                LOG.trace(""doSocketClose(socket[{}], logMessage[{}], reset[{}] - ignoring exception raised by Socket.shutdownOutput()"", socket, logMessage, reset, ignoredEx);
            }
        }
        if (reset) {
            final boolean on = true;
            final int linger = 0;
            try {
                socket.setSoLinger(on, linger);
            } catch (IOException ignoredEx) {
                LOG.trace(""doSocketClose(socket[{}], logMessage[{}], reset[{}] - ignoring exception raised by Socket.setSoLinger({}, {})"", socket, logMessage, reset, on, linger, ignoredEx);
            }
        }
        try {
            socket.close();
        } catch (IOException ignoredEx) {
            LOG.trace(""doSocketClose(socket[{}], logMessage[{}], reset[{}] - ignoring exception raised by Socket.close()"", socket, logMessage, reset, ignoredEx);
        }
    }
}",java:S3776,39
"protected void doAssertIsSatisfied(long timeoutForEmptyEndpoints) throws InterruptedException{
    if (expectedCount == 0) {
        if (timeoutForEmptyEndpoints > 0) {
            LOG.debug(""Sleeping for: {} millis to check there really are no messages received"", timeoutForEmptyEndpoints);
            Thread.sleep(timeoutForEmptyEndpoints);
        }
        assertEquals(""Received message count"", expectedCount, getReceivedCounter());
    } else if (expectedCount > 0) {
        if (expectedCount != getReceivedCounter()) {
            waitForCompleteLatch();
        }
        if (failFastAssertionError == null) {
            assertEquals(""Received message count"", expectedCount, getReceivedCounter());
        }
    } else if (expectedMinimumCount > 0 && getReceivedCounter() < expectedMinimumCount) {
        waitForCompleteLatch();
    }
    if (failFastAssertionError != null) {
        throw failFastAssertionError;
    }
    if (expectedMinimumCount >= 0) {
        int receivedCounter = getReceivedCounter();
        assertTrue(""Received message count "" + receivedCounter + "", expected at least "" + expectedMinimumCount, expectedMinimumCount <= receivedCounter);
    }
    for (Runnable test : tests) {
        boolean skip = failFast && test instanceof AssertionTask;
        if (!skip) {
            test.run();
        }
    }
    for (Throwable failure : failures) {
        if (failure != null) {
            LOG.error(""Caught exception on {} due to: {}"", getEndpointUri(), failure.getMessage(), failure);
            fail(failure);
        }
    }
}",java:S3776,39
"public void expectedHeaderReceived(final String name, final Object value){
    if (expectedMinimumCount == -1 && expectedCount <= 0) {
        expectedMinimumMessageCount(1);
    }
    if (expectedHeaderValues == null) {
        HeadersMapFactory factory = getCamelContext().getCamelContextExtension().getHeadersMapFactory();
        if (factory != null) {
            expectedHeaderValues = factory.newMap();
        } else {
            expectedHeaderValues = new HashMap<>();
        }
        expects(new AssertionTask() {

            @Override
            public void assertOnIndex(int i) {
                final Exchange exchange = getReceivedExchange(i);
                for (Map.Entry<String, Object> entry : expectedHeaderValues.entrySet()) {
                    String key = entry.getKey();
                    Object expectedValue = entry.getValue();
                    if (expectedValue != null) {
                        assertTrue(""Exchange "" + i + "" has no headers"", exchange.getIn().hasHeaders());
                        boolean hasKey = exchange.getIn().getHeaders().containsKey(key);
                        assertTrue(""No header with name "" + key + "" found for message: "" + i, hasKey);
                    }
                    Object actualValue = exchange.getIn().getHeader(key);
                    actualValue = extractActualValue(exchange, actualValue, expectedValue);
                    assertEquals(""Header with name "" + key + "" for message: "" + i, expectedValue, actualValue);
                }
            }

            public void run() {
                for (int i = 0; i < getReceivedExchanges().size(); i++) {
                    assertOnIndex(i);
                }
            }
        });
    }
    expectedHeaderValues.put(name, value);
}",java:S3776,39
"protected synchronized void onExchange(Exchange exchange){
    try {
        if (log) {
            String line = getComponent().getExchangeFormatter().format(exchange);
            LOG.info(""mock:{} received #{} -> {}"", getName(), counter.get() + 1, line);
        }
        if (reporter != null) {
            reporter.process(exchange);
        }
        Exchange copy = exchange;
        if (copyOnExchange) {
            copy = ExchangeHelper.createCopy(exchange, true);
        }
        performAssertions(exchange, copy);
        if (failFast) {
            int index = getReceivedCounter() - 1;
            for (Runnable test : tests) {
                if (test instanceof AssertionTask) {
                    AssertionTask task = (AssertionTask) test;
                    try {
                        LOG.debug(""Running assertOnIndex({}) on task: {}"", index, task);
                        task.assertOnIndex(index);
                    } catch (AssertionError e) {
                        failFastAssertionError = e;
                        LOG.debug(""Assertion failed fast on {} received exchange due to {}"", index, e.getMessage());
                        while (latch != null && latch.getCount() > 0) {
                            latch.countDown();
                        }
                        break;
                    }
                }
            }
        }
    } catch (AssertionError | Exception e) {
        failures.add(e);
    } finally {
        if (latch != null) {
            latch.countDown();
        }
    }
}",java:S3776,39
"protected void performAssertions(Exchange exchange, Exchange copy) throws Exception{
    Message in = copy.getIn();
    Object actualBody = in.getBody();
    if (expectedHeaderValues != null) {
        if (actualHeaderValues == null) {
            HeadersMapFactory factory = getCamelContext().getCamelContextExtension().getHeadersMapFactory();
            if (factory != null) {
                actualHeaderValues = factory.newMap();
            } else {
                actualHeaderValues = new HashMap<>();
            }
        }
        if (in.hasHeaders()) {
            actualHeaderValues.putAll(in.getHeaders());
        }
    }
    if (expectedBodyValues != null) {
        int index = actualBodyValues.size();
        if (expectedBodyValues.size() > index) {
            Object expectedBody = expectedBodyValues.get(index);
            if (expectedBody != null) {
                Object body = in.getBody(expectedBody.getClass());
                if (body != null) {
                    actualBody = body;
                }
            }
            actualBodyValues.add(actualBody);
        }
    }
    if (LOG.isDebugEnabled()) {
        String msg = getEndpointUri() + "" >>>> "" + counter + "" : "" + copy + "" with body: "" + actualBody;
        if (copy.getIn().hasHeaders()) {
            msg += "" and headers:"" + copy.getIn().getHeaders();
        }
        LOG.debug(msg);
    }
    copy.setProperty(Exchange.RECEIVED_TIMESTAMP, new Date());
    addReceivedExchange(copy);
    final int receivedCounter = counter.incrementAndGet();
    Processor processor = processors.get(receivedCounter) != null ? processors.get(receivedCounter) : defaultProcessor;
    if (processor != null) {
        try {
            processor.process(exchange);
        } catch (Exception e) {
            exchange.setException(e);
        }
    }
}",java:S3776,39
"protected void addReceivedExchange(Exchange copy){
    if (retainFirst == 0 && retainLast == 0) {
    } else if (retainFirst < 0 && retainLast < 0) {
        receivedExchanges.add(copy);
    } else {
        if (retainFirst > 0 && counter.get() < retainFirst) {
            receivedExchanges.add(copy);
        } else if (retainLast > 0) {
            int index = receivedExchanges.size() - retainLast;
            if (index >= 0) {
                if (retainFirst <= 0 || retainFirst <= index) {
                    receivedExchanges.remove(index);
                }
            }
            receivedExchanges.add(copy);
        }
    }
}",java:S3776,39
"public T body(final Function<Object, Object> function){
    return delegate.expression(new ExpressionAdapter() {

        @Override
        public Object evaluate(Exchange exchange) {
            return function.apply(exchange.getIn().getBody());
        }
    });
}",java:S4276,41
"public T outBody(final Function<Object, Object> function){
    return delegate.expression(new ExpressionAdapter() {

        @Override
        public Object evaluate(Exchange exchange) {
            return function.apply(exchange.getOut().getBody());
        }
    });
}",java:S4276,41
"private boolean processCollection(Date fromDate, boolean usesTimestamp, boolean persistsTimestamp, boolean usesAttribute, final MongoCollection<Document> ptsCollection, final Document persistentTimestamp){
    if (!isStarted()) {
        return false;
    }
    try (MongoCursor<GridFSFile> cursor = getGridFSFileMongoCursor(fromDate, usesTimestamp, usesAttribute)) {
        boolean dateModified = false;
        while (cursor.hasNext() && isStarted()) {
            GridFSFile file = cursor.next();
            GridFSFile fOrig = file;
            if (usesAttribute) {
                FindOneAndUpdateOptions options = new FindOneAndUpdateOptions();
                options.returnDocument(ReturnDocument.AFTER);
                Bson filter = Filters.and(eq(""_id"", file.getId()), eq(endpoint.getFileAttributeName(), null));
                Bson update = Updates.set(endpoint.getFileAttributeName(), GRIDFS_FILE_ATTRIBUTE_PROCESSING);
                fOrig = endpoint.getFilesCollection().findOneAndUpdate(filter, update, options);
            }
            if (fOrig != null) {
                Exchange exchange = createExchange(true);
                GridFSDownloadStream downloadStream = endpoint.getGridFsBucket().openDownloadStream(file.getFilename());
                file = downloadStream.getGridFSFile();
                Document metadata = file.getMetadata();
                if (metadata != null) {
                    String contentType = metadata.get(GRIDFS_FILE_KEY_CONTENT_TYPE, String.class);
                    if (contentType != null) {
                        exchange.getIn().setHeader(GridFsConstants.FILE_CONTENT_TYPE, contentType);
                    }
                    exchange.getIn().setHeader(GridFsConstants.GRIDFS_METADATA, metadata.toJson());
                }
                exchange.getIn().setHeader(GridFsConstants.FILE_LENGTH, file.getLength());
                exchange.getIn().setHeader(GridFsConstants.FILE_LAST_MODIFIED, file.getUploadDate());
                exchange.getIn().setBody(downloadStream, InputStream.class);
                try {
                    getProcessor().process(exchange);
                    if (usesAttribute) {
                        Bson update = Updates.set(endpoint.getFileAttributeName(), GRIDFS_FILE_ATTRIBUTE_DONE);
                        endpoint.getFilesCollection().findOneAndUpdate(eq(""_id"", fOrig.getId()), update);
                    }
                    if (usesTimestamp && file.getUploadDate().compareTo(fromDate) > 0) {
                        fromDate = file.getUploadDate();
                        dateModified = true;
                    }
                } catch (Exception e) {
                }
            }
        }
        if (persistsTimestamp && dateModified) {
            Bson update = Updates.set(PERSISTENT_TIMESTAMP_KEY, fromDate);
            ptsCollection.findOneAndUpdate(eq(""_id"", persistentTimestamp.getObjectId(""_id"")), update);
        }
    }
    return false;
}",java:S3776,39
"public void initializeConnection() throws Exception{
    LOG.info(""Initialize GridFS endpoint: {}"", this);
    if (database == null) {
        throw new IllegalStateException(""Missing required endpoint configuration: database"");
    }
    db = mongoConnection.getDatabase(database);
    if (db == null) {
        throw new IllegalStateException(""Could not initialize GridFsComponent. Database "" + database + "" does not exist."");
    }
    if (bucket != null) {
        gridFSBucket = GridFSBuckets.create(db, bucket);
    } else {
        gridFSBucket = GridFSBuckets.create(db);
    }
    this.filesCollection = db.getCollection(gridFSBucket.getBucketName() + "".files"", GridFSFile.class);
}",java:S112,4
"protected void stop() throws Exception{
    if (log.isInfoEnabled()) {
        log.info(""Stopping MongoDB Tailable Cursor consumer, bound to collection: {}"", String.format(""db: %s, col: %s"", endpoint.getDatabase(), endpoint.getCollection()));
    }
    keepRunning = false;
    if (cursor != null) {
        cursor.close();
    }
    awaitStopped();
    if (log.isInfoEnabled()) {
        log.info(""Stopped MongoDB Tailable Cursor consumer, bound to collection: {}"", String.format(""db: %s, col: %s"", endpoint.getDatabase(), endpoint.getCollection()));
    }
}",java:S112,4
"public void initializeConnection() throws CamelMongoDbException{
    LOG.info(""Initialising MongoDb endpoint: {}"", this);
    if (database == null || collection == null && !(getDbStats.equals(operation) || command.equals(operation))) {
        throw new CamelMongoDbException(""Missing required endpoint configuration: database and/or collection"");
    }
    if (mongoConnection == null) {
        mongoConnection = resolveMongoConnection();
        if (mongoConnection == null) {
            throw new CamelMongoDbException(""Could not initialise MongoDbComponent. Could not resolve the mongo connection."");
        }
    }
    mongoDatabase = mongoConnection.getDatabase(database);
    if (mongoDatabase == null) {
        throw new CamelMongoDbException(""Could not initialise MongoDbComponent. Database "" + database + "" does not exist."");
    }
    if (collection != null) {
        if (!createCollection && !databaseContainsCollection(collection)) {
            throw new CamelMongoDbException(""Could not initialise MongoDbComponent. Collection "" + collection + "" does not exist on the database and createCollection is false."");
        }
        mongoCollection = mongoDatabase.getCollection(collection, Document.class);
        LOG.debug(""MongoDb component initialised and endpoint bound to MongoDB collection with the following parameters. "" + ""Cluster description: {}, Db: {}, Collection: {}"", mongoConnection.getClusterDescription(), mongoDatabase.getName(), collection);
        try {
            if (ObjectHelper.isNotEmpty(collectionIndex)) {
                ensureIndex(mongoCollection, createIndex());
            }
        } catch (Exception e) {
            throw new CamelMongoDbException(""Error creating index"", e);
        }
    }
}",java:S3776,39
"private Function<Exchange, Object> createDoFindAll(){
    return exchange -> {
        Iterable<Document> result;
        MongoCollection<Document> dbCol = calculateCollection(exchange);
        Bson query = exchange.getIn().getHeader(CRITERIA, Bson.class);
        if (query == null && exchange.getIn().getBody() != null) {
            query = exchange.getContext().getTypeConverter().tryConvertTo(Bson.class, exchange, exchange.getIn().getBody());
        }
        Bson fieldFilter = exchange.getIn().getHeader(FIELDS_PROJECTION, Bson.class);
        Integer batchSize = exchange.getIn().getHeader(BATCH_SIZE, Integer.class);
        Integer numToSkip = exchange.getIn().getHeader(NUM_TO_SKIP, Integer.class);
        Integer limit = exchange.getIn().getHeader(LIMIT, Integer.class);
        Document sortBy = exchange.getIn().getHeader(SORT_BY, Document.class);
        FindIterable<Document> ret;
        if (query == null && fieldFilter == null) {
            ret = dbCol.find();
        } else if (fieldFilter == null) {
            ret = dbCol.find(query);
        } else if (query != null) {
            ret = dbCol.find(query).projection(fieldFilter);
        } else {
            ret = dbCol.find().projection(fieldFilter);
        }
        if (sortBy != null) {
            ret.sort(sortBy);
        }
        if (batchSize != null) {
            ret.batchSize(batchSize);
        }
        if (numToSkip != null) {
            ret.skip(numToSkip);
        }
        if (limit != null) {
            ret.limit(limit);
        }
        ret.allowDiskUse(exchange.getIn().getHeader(MongoDbConstants.ALLOW_DISK_USE, Boolean.class));
        if (!MongoDbOutputType.MongoIterable.equals(endpoint.getOutputType())) {
            try {
                result = new ArrayList<>();
                ret.iterator().forEachRemaining(((List<Document>) result)::add);
                exchange.getMessage().setHeader(RESULT_PAGE_SIZE, ((List<Document>) result).size());
            } finally {
                ret.iterator().close();
            }
        } else {
            result = ret;
        }
        return result;
    };
}",java:S3776,39
"@Deprecated
public Message getResponse(){
    return exchange.getOut();
}",java:S6355,48
"private BeanProcessor createBeanProcessor(SqlSession session) throws Exception{
    Class<?> clazz = session.getConfiguration().getTypeAliasRegistry().resolveAlias(endpoint.getBeanName());
    if (clazz == null) {
        clazz = getEndpoint().getCamelContext().getClassResolver().resolveMandatoryClass(endpoint.getBeanName());
    }
    LOG.debug(""Resolved MyBatis Bean: {} as class: {}"", endpoint.getBeanName(), clazz);
    Object mapper = session.getMapper(clazz);
    if (mapper == null) {
        throw new IllegalArgumentException(""No Mapper with typeAlias or class name: "" + endpoint.getBeanName() + "" in MyBatis configuration."");
    }
    LOG.debug(""Resolved MyBatis Bean mapper: {}"", mapper);
    BeanProcessor answer = new BeanProcessor(mapper, getEndpoint().getCamelContext());
    answer.setMethod(endpoint.getMethodName());
    return answer;
}",java:S112,4
"private void doProcessResult(Exchange exchange, Object result, SqlSession session){
    final String outputHeader = getEndpoint().getOutputHeader();
    Message answer = exchange.getIn();
    if (ExchangeHelper.isOutCapable(exchange)) {
        answer = exchange.getOut();
        answer.getHeaders().putAll(exchange.getIn().getHeaders());
        if (outputHeader != null) {
            answer.setBody(exchange.getIn().getBody());
        }
    }
    if (endpoint.getStatementType() == StatementType.SelectList || endpoint.getStatementType() == StatementType.SelectOne) {
        MappedStatement ms = session.getConfiguration().getMappedStatement(statement);
        if (ms != null && ms.getStatementType() == org.apache.ibatis.mapping.StatementType.CALLABLE) {
            if (result == null) {
                LOG.trace(""Setting result as existing body as MyBatis statement type is Callable, and there was no result."");
                answer.setBody(exchange.getIn().getBody());
            } else {
                if (outputHeader != null) {
                    LOG.trace(""Setting result as header [{}]: {}"", outputHeader, result);
                    answer.setHeader(outputHeader, result);
                } else {
                    LOG.trace(""Setting result as body: {}"", result);
                    answer.setBody(result);
                    answer.setHeader(MyBatisConstants.MYBATIS_RESULT, result);
                }
            }
        } else {
            if (outputHeader != null) {
                LOG.trace(""Setting result as header [{}]: {}"", outputHeader, result);
                answer.setHeader(outputHeader, result);
            } else {
                LOG.trace(""Setting result as body: {}"", result);
                answer.setBody(result);
                answer.setHeader(MyBatisConstants.MYBATIS_RESULT, result);
            }
        }
    } else {
        final String headerName = (outputHeader != null) ? outputHeader : MyBatisConstants.MYBATIS_RESULT;
        answer.setHeader(headerName, result);
    }
    answer.setHeader(MyBatisConstants.MYBATIS_STATEMENT_NAME, statement);
}",java:S3776,39
"private SSLContext createSSLContext(NettyProducer producer) throws Exception{
    NettyConfiguration configuration = producer.getConfiguration();
    if (!configuration.isSsl()) {
        return null;
    }
    SSLContext answer;
    if (configuration.getSslContextParameters() != null) {
        answer = configuration.getSslContextParameters().createSSLContext(producer.getContext());
        if (answer.getSupportedSSLParameters().getServerNames() != null && !answer.getSupportedSSLParameters().getServerNames().isEmpty()) {
            sniServerNames = answer.getSupportedSSLParameters().getServerNames();
        }
    } else {
        if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {
            LOG.debug(""keystorefile is null"");
        }
        if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {
            LOG.debug(""truststorefile is null"");
        }
        if (configuration.getPassphrase() == null) {
            LOG.debug(""passphrase is null"");
        }
        char[] pw = configuration.getPassphrase() != null ? configuration.getPassphrase().toCharArray() : null;
        SSLEngineFactory sslEngineFactory;
        if (configuration.getKeyStoreFile() != null || configuration.getTrustStoreFile() != null) {
            sslEngineFactory = new SSLEngineFactory();
            answer = sslEngineFactory.createSSLContext(producer.getContext(), configuration.getKeyStoreFormat(), configuration.getSecurityProvider(), ""file:"" + configuration.getKeyStoreFile().getPath(), ""file:"" + configuration.getTrustStoreFile().getPath(), pw);
        } else if (configuration.getKeyStoreResource() != null || configuration.getTrustStoreResource() != null) {
            sslEngineFactory = new SSLEngineFactory();
            answer = sslEngineFactory.createSSLContext(producer.getContext(), configuration.getKeyStoreFormat(), configuration.getSecurityProvider(), configuration.getKeyStoreResource(), configuration.getTrustStoreResource(), pw);
        } else {
            answer = SSLContext.getDefault();
        }
    }
    return answer;
}",java:S3776,39
"private SslHandler configureClientSSLOnDemand() throws Exception{
    if (!producer.getConfiguration().isSsl()) {
        return null;
    }
    if (producer.getConfiguration().getSslHandler() != null) {
        return producer.getConfiguration().getSslHandler();
    } else if (sslContext != null) {
        URI uri = new URI(producer.getEndpoint().getEndpointUri());
        SSLEngine engine = sslContext.createSSLEngine(uri.getHost(), uri.getPort());
        engine.setUseClientMode(true);
        SSLParameters sslParameters = engine.getSSLParameters();
        sslParameters.setServerNames(sniServerNames != null ? sniServerNames : Arrays.asList(new SNIHostName(uri.getHost())));
        engine.setSSLParameters(sslParameters);
        if (producer.getConfiguration().getSslContextParameters() == null) {
            engine.setEnabledProtocols(producer.getConfiguration().getEnabledProtocols().split("",""));
        }
        return new SslHandler(engine);
    }
    return null;
}",java:S112,4
"public String getUsername(){
    return username;
}",java:S4144,40
"private SSLContext createSSLContext(CamelContext camelContext, NettyServerBootstrapConfiguration configuration) throws Exception{
    if (!configuration.isSsl()) {
        return null;
    }
    SSLContext answer;
    if (configuration.getSslContextParameters() != null) {
        answer = configuration.getSslContextParameters().createSSLContext(camelContext);
    } else {
        if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {
            LOG.debug(""keystorefile is null"");
        }
        if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {
            LOG.debug(""truststorefile is null"");
        }
        if (configuration.getPassphrase() == null) {
            LOG.debug(""passphrase is null"");
        }
        char[] pw = configuration.getPassphrase() != null ? configuration.getPassphrase().toCharArray() : null;
        SSLEngineFactory sslEngineFactory;
        if (configuration.getKeyStoreFile() != null || configuration.getTrustStoreFile() != null) {
            sslEngineFactory = new SSLEngineFactory();
            answer = sslEngineFactory.createSSLContext(camelContext, configuration.getKeyStoreFormat(), configuration.getSecurityProvider(), ""file:"" + configuration.getKeyStoreFile().getPath(), ""file:"" + configuration.getTrustStoreFile().getPath(), pw);
        } else {
            sslEngineFactory = new SSLEngineFactory();
            answer = sslEngineFactory.createSSLContext(camelContext, configuration.getKeyStoreFormat(), configuration.getSecurityProvider(), configuration.getKeyStoreResource(), configuration.getTrustStoreResource(), pw);
        }
    }
    return answer;
}",java:S3776,39
"private SSLContext createSSLContext() throws Exception{
    if (!configuration.isSsl()) {
        return null;
    }
    SSLContext answer;
    if (configuration.getSslContextParameters() != null) {
        answer = configuration.getSslContextParameters().createSSLContext(null);
    } else {
        if (configuration.getKeyStoreFile() == null && configuration.getKeyStoreResource() == null) {
            LOG.debug(""keystorefile is null"");
        }
        if (configuration.getTrustStoreFile() == null && configuration.getTrustStoreResource() == null) {
            LOG.debug(""truststorefile is null"");
        }
        if (configuration.getPassphrase() == null) {
            LOG.debug(""passphrase is null"");
        }
        char[] pw = configuration.getPassphrase() != null ? configuration.getPassphrase().toCharArray() : null;
        SSLEngineFactory sslEngineFactory;
        if (configuration.getKeyStoreFile() != null || configuration.getTrustStoreFile() != null) {
            sslEngineFactory = new SSLEngineFactory();
            answer = sslEngineFactory.createSSLContext(camelContext, configuration.getKeyStoreFormat(), configuration.getSecurityProvider(), ""file:"" + configuration.getKeyStoreFile().getPath(), ""file:"" + configuration.getTrustStoreFile().getPath(), pw);
        } else {
            sslEngineFactory = new SSLEngineFactory();
            answer = sslEngineFactory.createSSLContext(camelContext, configuration.getKeyStoreFormat(), configuration.getSecurityProvider(), configuration.getKeyStoreResource(), configuration.getTrustStoreResource(), pw);
        }
    }
    return answer;
}",java:S3776,39
"private SslHandler configureServerSSLOnDemand(){
    if (!configuration.isSsl()) {
        return null;
    }
    if (configuration.getSslHandler() != null) {
        return configuration.getSslHandler();
    } else if (sslContext != null) {
        SSLEngine engine = sslContext.createSSLEngine();
        engine.setUseClientMode(false);
        engine.setNeedClientAuth(configuration.isNeedClientAuth());
        if (configuration.getSslContextParameters() == null) {
            engine.setEnabledProtocols(configuration.getEnabledProtocols().split("",""));
        }
        return new SslHandler(engine);
    }
    return null;
}",java:S2177,28
"public void setConfiguration(NettyHttpConfiguration configuration){
    super.setConfiguration(configuration);
}",java:S1185,15
" Consumer doCreateConsumer(CamelContext camelContext, Processor processor, String verb, String basePath, String uriTemplate, RestConfiguration configuration, Map<String, Object> parameters, boolean api) throws Exception{
    String path = basePath;
    if (uriTemplate != null) {
        if (uriTemplate.startsWith(""/"")) {
            path = path + uriTemplate;
        } else {
            path = path + ""/"" + uriTemplate;
        }
    }
    path = FileUtil.stripLeadingSeparator(path);
    String scheme = ""http"";
    String host = """";
    int port = 0;
    RestConfiguration config = configuration;
    if (config == null) {
        config = CamelContextHelper.getRestConfiguration(getCamelContext(), ""netty-http"");
    }
    if (config.getScheme() != null) {
        scheme = config.getScheme();
    }
    if (config.getHost() != null) {
        host = config.getHost();
    }
    int num = config.getPort();
    if (num > 0) {
        port = num;
    }
    String contextPath = config.getContextPath();
    if (ObjectHelper.isNotEmpty(contextPath)) {
        contextPath = FileUtil.stripTrailingSeparator(contextPath);
        contextPath = FileUtil.stripLeadingSeparator(contextPath);
        if (ObjectHelper.isNotEmpty(contextPath)) {
            path = contextPath + ""/"" + path;
        }
    }
    if (ObjectHelper.isEmpty(host)) {
        host = RestComponentHelper.resolveRestHostName(host, config);
    }
    Map<String, Object> map = RestComponentHelper.initRestEndpointProperties(""netty-http"", config);
    boolean cors = config.isEnableCORS();
    if (api) {
        map.put(""matchOnUriPrefix"", ""true"");
    }
    RestComponentHelper.addHttpRestrictParam(map, verb, cors);
    String url = RestComponentHelper.createRestConsumerUrl(""netty-http"", scheme, host, port, path, map);
    NettyHttpEndpoint endpoint = (NettyHttpEndpoint) camelContext.getEndpoint(url, parameters);
    Consumer consumer = endpoint.createConsumer(processor);
    if (config.getConsumerProperties() != null && !config.getConsumerProperties().isEmpty()) {
        setProperties(camelContext, consumer, config.getConsumerProperties());
    }
    return consumer;
}",java:S107,1
"public static Exception populateNettyHttpOperationFailedException(Exchange exchange, String url, FullHttpResponse response, int responseCode, boolean transferException){
    String statusText = response.status().reasonPhrase();
    if (responseCode >= 300 && responseCode < 400) {
        String redirectLocation = response.headers().get(""location"");
        if (redirectLocation != null) {
            return new NettyHttpOperationFailedException(url, responseCode, statusText, redirectLocation, response);
        } else {
            return new NettyHttpOperationFailedException(url, responseCode, statusText, null, response);
        }
    }
    if (transferException) {
        String contentType = response.headers().get(NettyHttpConstants.CONTENT_TYPE);
        if (NettyHttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT.equals(contentType)) {
            InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, response);
            if (is != null) {
                try {
                    Object body = deserializeJavaObjectFromStream(is);
                    if (body instanceof Exception) {
                        return (Exception) body;
                    }
                } catch (Exception e) {
                    return e;
                } finally {
                    IOHelper.close(is);
                }
            }
        }
    }
    return new NettyHttpOperationFailedException(url, responseCode, statusText, null, response);
}",java:S3776,39
"@Deprecated
public HttpContent getHttpContent(){
    return content;
}",java:S6355,48
"protected Channel openChannel(final ChannelFuture channelFuture) throws Exception{
    if (LOG.isTraceEnabled()) {
        LOG.trace(""Waiting for operation to complete {} for {} millis"", channelFuture, configuration.getConnectTimeout());
    }
    channelFuture.awaitUninterruptibly();
    if (!channelFuture.isDone() || !channelFuture.isSuccess()) {
        if (configuration.isReconnect()) {
            scheduleReconnect(channelFuture);
            return null;
        } else {
            ConnectException cause = new ConnectException(""Cannot connect to "" + configuration.getAddress());
            if (channelFuture.cause() != null) {
                cause.initCause(channelFuture.cause());
            }
            throw cause;
        }
    }
    Channel answer = channelFuture.channel();
    if (LOG.isDebugEnabled()) {
        LOG.debug(""Creating connector to address: {}"", configuration.getAddress());
    }
    if (configuration.isReconnect()) {
        answer.closeFuture().addListener(new ChannelFutureListener() {

            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                scheduleReconnect(channelFuture);
            }
        });
    }
    return answer;
}",java:S112,4
"@Override
public Producer createProducer() throws Exception{
    throw new UnsupportedOperationException(""FeedProducer is not implemented"");
}",java:S1123,5
"@Override
public Producer createProducer() throws Exception{
    throw new UnsupportedOperationException(""FeedProducer is not implemented"");
}",java:S1133,8
"public void parseURI(URI uri, Map<String, Object> parameters, NettyComponent component, String... supportedProtocols) throws Exception{
    protocol = uri.getScheme();
    boolean found = false;
    for (String supportedProtocol : supportedProtocols) {
        if (protocol != null && protocol.equalsIgnoreCase(supportedProtocol)) {
            found = true;
            break;
        }
    }
    if (!found) {
        throw new IllegalArgumentException(""Unrecognized Netty protocol: "" + protocol + "" for uri: "" + uri);
    }
    setHost(uri.getHost());
    if (uri.getPort() != -1) {
        setPort(uri.getPort());
    }
    ssl = component.getAndRemoveOrResolveReferenceParameter(parameters, ""ssl"", boolean.class, ssl);
    sslHandler = component.getAndRemoveOrResolveReferenceParameter(parameters, ""sslHandler"", SslHandler.class, sslHandler);
    passphrase = component.getAndRemoveOrResolveReferenceParameter(parameters, ""passphrase"", String.class, passphrase);
    keyStoreFormat = component.getAndRemoveOrResolveReferenceParameter(parameters, ""keyStoreFormat"", String.class, keyStoreFormat == null ? ""JKS"" : keyStoreFormat);
    securityProvider = component.getAndRemoveOrResolveReferenceParameter(parameters, ""securityProvider"", String.class, securityProvider == null ? ""SunX509"" : securityProvider);
    keyStoreResource = uriRef(component, parameters, ""keyStoreResource"", keyStoreResource);
    trustStoreResource = uriRef(component, parameters, ""trustStoreResource"", trustStoreResource);
    clientInitializerFactory = component.getAndRemoveOrResolveReferenceParameter(parameters, ""clientInitializerFactory"", ClientInitializerFactory.class, clientInitializerFactory);
    serverInitializerFactory = component.getAndRemoveOrResolveReferenceParameter(parameters, ""serverInitializerFactory"", ServerInitializerFactory.class, serverInitializerFactory);
    List<ChannelHandler> referencedEncoders = component.resolveAndRemoveReferenceListParameter(parameters, ""encoders"", ChannelHandler.class, null);
    addToHandlersList(encodersList, referencedEncoders, ChannelHandler.class);
    List<ChannelHandler> referencedDecoders = component.resolveAndRemoveReferenceListParameter(parameters, ""decoders"", ChannelHandler.class, null);
    addToHandlersList(decodersList, referencedDecoders, ChannelHandler.class);
    List<ChannelHandler> configEncoders = EndpointHelper.resolveReferenceListParameter(component.getCamelContext(), encoders, ChannelHandler.class);
    addToHandlersList(encodersList, configEncoders, ChannelHandler.class);
    List<ChannelHandler> configDecoders = EndpointHelper.resolveReferenceListParameter(component.getCamelContext(), decoders, ChannelHandler.class);
    addToHandlersList(decodersList, configDecoders, ChannelHandler.class);
    PropertyConfigurer configurer = PluginHelper.getConfigurerResolver(component.getCamelContext()).resolvePropertyConfigurer(this.getClass().getName(), component.getCamelContext());
    PropertyBindingSupport.build().withCamelContext(component.getCamelContext()).withTarget(this).withReflection(false).withIgnoreCase(true).withConfigurer(configurer).withProperties(parameters).bind();
    options = PropertiesHelper.extractProperties(parameters, ""option."");
    if (options.isEmpty()) {
        options = null;
    }
    if (encodersList.isEmpty() && decodersList.isEmpty()) {
        if (isAllowDefaultCodec()) {
            if (""udp"".equalsIgnoreCase(protocol)) {
                encodersList.add(ChannelHandlerFactories.newDatagramPacketEncoder());
            }
            if (isTextline()) {
                Charset charset = getEncoding() != null ? Charset.forName(getEncoding()) : CharsetUtil.UTF_8;
                encodersList.add(ChannelHandlerFactories.newStringEncoder(charset, protocol));
                ByteBuf[] delimiters = delimiter == TextLineDelimiter.LINE ? Delimiters.lineDelimiter() : Delimiters.nulDelimiter();
                decodersList.add(ChannelHandlerFactories.newDelimiterBasedFrameDecoder(decoderMaxLineLength, delimiters, protocol));
                decodersList.add(ChannelHandlerFactories.newStringDecoder(charset, protocol));
                LOG.debug(""Using textline encoders and decoders with charset: {}, delimiter: {} and decoderMaxLineLength: {}"", charset, delimiter, decoderMaxLineLength);
            } else if (""udp"".equalsIgnoreCase(protocol) && isUdpByteArrayCodec()) {
                encodersList.add(ChannelHandlerFactories.newByteArrayEncoder(protocol));
                decodersList.add(ChannelHandlerFactories.newByteArrayDecoder(protocol));
            } else {
                Charset charset = getEncoding() != null ? Charset.forName(getEncoding()) : CharsetUtil.UTF_8;
                encodersList.add(ChannelHandlerFactories.newStringEncoder(charset, protocol));
                decodersList.add(ChannelHandlerFactories.newStringDecoder(charset, protocol));
            }
            if (""udp"".equalsIgnoreCase(protocol)) {
                decodersList.add(ChannelHandlerFactories.newDatagramPacketDecoder());
            }
        } else {
            LOG.debug(""No encoders and decoders will be used"");
        }
    } else {
        LOG.debug(""Using configured encoders and/or decoders"");
    }
}",java:S3776,39
"public void setDecoders(List<ChannelHandler> decoders){
    this.decodersList = decoders;
}",java:S4144,40
"public void setEncoders(List<ChannelHandler> encoders){
    this.encodersList = encoders;
}",java:S4144,40
"@Deprecated
public void setClientPipelineFactory(ClientInitializerFactory clientPipelineFactory){
    this.clientInitializerFactory = clientPipelineFactory;
}",java:S6355,48
"@Deprecated
public ClientInitializerFactory getClientPipelineFactory(){
    return clientInitializerFactory;
}",java:S6355,48
"public ClientInitializerFactory getClientInitializerFactory(){
    return clientInitializerFactory;
}",java:S4144,40
"public void processWithConnectedChannel(final Exchange exchange, final BodyReleaseCallback callback, final ChannelFuture channelFuture, final Object body){
    final Channel channel = channelFuture.channel();
    if (getConfiguration().isReuseChannel() && exchange.getProperty(NettyConstants.NETTY_CHANNEL) == null) {
        channel.attr(CORRELATION_MANAGER_ATTR).set(correlationManager);
        exchange.setProperty(NettyConstants.NETTY_CHANNEL, channel);
        exchange.getExchangeExtension().addOnCompletion(new SynchronizationAdapter() {

            @Override
            public void onComplete(Exchange exchange) {
                Boolean close;
                if (ExchangeHelper.isOutCapable(exchange)) {
                    close = exchange.getOut().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);
                } else {
                    close = exchange.getIn().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);
                }
                boolean disconnect = getConfiguration().isDisconnect();
                if (close != null) {
                    disconnect = close;
                }
                if (disconnect) {
                    LOG.trace(""Closing channel {} as routing the Exchange is done"", channel);
                    NettyHelper.close(channel);
                }
                releaseChannel(channelFuture);
            }
        });
    }
    final NettyCamelStateCorrelationManager channelCorrelationManager = Optional.ofNullable(channel.attr(CORRELATION_MANAGER_ATTR).get()).orElse(correlationManager);
    if (exchange.getIn().getHeader(NettyConstants.NETTY_REQUEST_TIMEOUT) != null) {
        long timeoutInMs = exchange.getIn().getHeader(NettyConstants.NETTY_REQUEST_TIMEOUT, Long.class);
        ChannelHandler oldHandler = channel.pipeline().get(""timeout"");
        ReadTimeoutHandler newHandler = new ReadTimeoutHandler(timeoutInMs, TimeUnit.MILLISECONDS);
        if (oldHandler == null) {
            channel.pipeline().addBefore(""handler"", ""timeout"", newHandler);
        } else {
            channel.pipeline().replace(oldHandler, ""timeout"", newHandler);
        }
    }
    final AsyncCallback producerCallback;
    if (configuration.isReuseChannel()) {
        producerCallback = callback.getOriginalCallback();
    } else {
        producerCallback = new NettyProducerCallback(channelFuture, callback.getOriginalCallback());
    }
    final NettyCamelState state = new NettyCamelState(producerCallback, exchange);
    channelCorrelationManager.putState(channel, state);
    InetSocketAddress remoteAddress = null;
    if (!isTcp()) {
        remoteAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());
    }
    NettyHelper.writeBodyAsync(LOG, channel, remoteAddress, body, new ChannelFutureListener() {

        public void operationComplete(ChannelFuture channelFuture) throws Exception {
            LOG.trace(""Operation complete {}"", channelFuture);
            if (!channelFuture.isSuccess()) {
                Throwable cause = null;
                try {
                    channelFuture.get(0, TimeUnit.MILLISECONDS);
                } catch (Exception e) {
                    cause = e.getCause();
                }
                if (cause != null) {
                    exchange.setException(cause);
                }
                state.onExceptionCaughtOnce(false);
                return;
            }
            if (!configuration.isSync()) {
                try {
                    Boolean close;
                    if (ExchangeHelper.isOutCapable(exchange)) {
                        close = exchange.getOut().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);
                    } else {
                        close = exchange.getIn().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);
                    }
                    boolean disconnect = getConfiguration().isDisconnect();
                    if (close != null) {
                        disconnect = close;
                    }
                    if (!configuration.isReuseChannel() && disconnect) {
                        if (LOG.isTraceEnabled()) {
                            LOG.trace(""Closing channel when complete at address: {}"", getEndpoint().getConfiguration().getAddress());
                        }
                        NettyHelper.close(channel);
                    }
                } finally {
                    producerCallback.done(false);
                }
            }
        }
    });
}",java:S3776,39
"protected Object getRequestBody(Exchange exchange) throws Exception{
    Object body = NettyPayloadHelper.getIn(getEndpoint(), exchange);
    if (body == null) {
        return null;
    }
    if (getConfiguration().isTextline()) {
        body = NettyHelper.getTextlineBody(body, exchange, getConfiguration().getDelimiter(), getConfiguration().isAutoAppendDelimiter());
    }
    return body;
}",java:S112,4
"protected ChannelFuture openConnection() throws Exception{
    ChannelFuture answer;
    if (isTcp()) {
        Bootstrap clientBootstrap = new Bootstrap();
        if (configuration.getUnixDomainSocketPath() != null) {
            clientBootstrap.channel(EpollDomainSocketChannel.class);
        } else {
            if (configuration.isNativeTransport()) {
                clientBootstrap.channel(EpollSocketChannel.class);
            } else {
                clientBootstrap.channel(NioSocketChannel.class);
            }
        }
        clientBootstrap.group(getWorkerGroup());
        clientBootstrap.option(ChannelOption.SO_KEEPALIVE, configuration.isKeepAlive());
        clientBootstrap.option(ChannelOption.TCP_NODELAY, configuration.isTcpNoDelay());
        clientBootstrap.option(ChannelOption.SO_REUSEADDR, configuration.isReuseAddress());
        clientBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, configuration.getConnectTimeout());
        clientBootstrap.handler(pipelineFactory);
        SocketAddress socketAddress;
        if (configuration.getUnixDomainSocketPath() != null) {
            Path udsPath = Path.of(configuration.getUnixDomainSocketPath()).toAbsolutePath();
            LOG.debug(""Creating new TCP client bootstrap connecting to {} with options {}"", udsPath, clientBootstrap);
            socketAddress = new DomainSocketAddress(udsPath.toFile());
        } else {
            LOG.debug(""Creating new TCP client bootstrap connecting to {}:{} with options: {}"", configuration.getHost(), configuration.getPort(), clientBootstrap);
            socketAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());
        }
        answer = clientBootstrap.connect(socketAddress);
        LOG.debug(""TCP client bootstrap created"");
        return answer;
    } else {
        Bootstrap connectionlessClientBootstrap = new Bootstrap();
        if (configuration.isNativeTransport()) {
            connectionlessClientBootstrap.channel(EpollDatagramChannel.class);
        } else {
            connectionlessClientBootstrap.channel(NioDatagramChannel.class);
        }
        connectionlessClientBootstrap.group(getWorkerGroup());
        connectionlessClientBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, configuration.getConnectTimeout());
        connectionlessClientBootstrap.option(ChannelOption.SO_BROADCAST, configuration.isBroadcast());
        connectionlessClientBootstrap.option(ChannelOption.SO_SNDBUF, configuration.getSendBufferSize());
        connectionlessClientBootstrap.option(ChannelOption.SO_RCVBUF, configuration.getReceiveBufferSize());
        connectionlessClientBootstrap.handler(pipelineFactory);
        if (!configuration.isUdpConnectionlessSending()) {
            answer = connectionlessClientBootstrap.connect(new InetSocketAddress(configuration.getHost(), configuration.getPort()));
        } else {
            answer = connectionlessClientBootstrap.bind(new InetSocketAddress(0)).sync();
            Channel channel = answer.channel();
            allChannels.add(channel);
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Created new UDP client bootstrap connecting to {}:{} with options: {}"", configuration.getHost(), configuration.getPort(), connectionlessClientBootstrap);
        }
        return answer;
    }
}",java:S3776,39
"protected ChannelFuture openConnection() throws Exception{
    ChannelFuture answer;
    if (isTcp()) {
        Bootstrap clientBootstrap = new Bootstrap();
        if (configuration.getUnixDomainSocketPath() != null) {
            clientBootstrap.channel(EpollDomainSocketChannel.class);
        } else {
            if (configuration.isNativeTransport()) {
                clientBootstrap.channel(EpollSocketChannel.class);
            } else {
                clientBootstrap.channel(NioSocketChannel.class);
            }
        }
        clientBootstrap.group(getWorkerGroup());
        clientBootstrap.option(ChannelOption.SO_KEEPALIVE, configuration.isKeepAlive());
        clientBootstrap.option(ChannelOption.TCP_NODELAY, configuration.isTcpNoDelay());
        clientBootstrap.option(ChannelOption.SO_REUSEADDR, configuration.isReuseAddress());
        clientBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, configuration.getConnectTimeout());
        clientBootstrap.handler(pipelineFactory);
        SocketAddress socketAddress;
        if (configuration.getUnixDomainSocketPath() != null) {
            Path udsPath = Path.of(configuration.getUnixDomainSocketPath()).toAbsolutePath();
            LOG.debug(""Creating new TCP client bootstrap connecting to {} with options {}"", udsPath, clientBootstrap);
            socketAddress = new DomainSocketAddress(udsPath.toFile());
        } else {
            LOG.debug(""Creating new TCP client bootstrap connecting to {}:{} with options: {}"", configuration.getHost(), configuration.getPort(), clientBootstrap);
            socketAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());
        }
        answer = clientBootstrap.connect(socketAddress);
        LOG.debug(""TCP client bootstrap created"");
        return answer;
    } else {
        Bootstrap connectionlessClientBootstrap = new Bootstrap();
        if (configuration.isNativeTransport()) {
            connectionlessClientBootstrap.channel(EpollDatagramChannel.class);
        } else {
            connectionlessClientBootstrap.channel(NioDatagramChannel.class);
        }
        connectionlessClientBootstrap.group(getWorkerGroup());
        connectionlessClientBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, configuration.getConnectTimeout());
        connectionlessClientBootstrap.option(ChannelOption.SO_BROADCAST, configuration.isBroadcast());
        connectionlessClientBootstrap.option(ChannelOption.SO_SNDBUF, configuration.getSendBufferSize());
        connectionlessClientBootstrap.option(ChannelOption.SO_RCVBUF, configuration.getReceiveBufferSize());
        connectionlessClientBootstrap.handler(pipelineFactory);
        if (!configuration.isUdpConnectionlessSending()) {
            answer = connectionlessClientBootstrap.connect(new InetSocketAddress(configuration.getHost(), configuration.getPort()));
        } else {
            answer = connectionlessClientBootstrap.bind(new InetSocketAddress(0)).sync();
            Channel channel = answer.channel();
            allChannels.add(channel);
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Created new UDP client bootstrap connecting to {}:{} with options: {}"", configuration.getHost(), configuration.getPort(), connectionlessClientBootstrap);
        }
        return answer;
    }
}",java:S112,4
"protected void notifyChannelOpen(ChannelFuture channelFuture) throws Exception{
    if (LOG.isTraceEnabled()) {
        LOG.trace(""Channel open finished with {}"", channelFuture);
    }
    if (channelFuture.isSuccess()) {
        Channel answer = channelFuture.channel();
        allChannels.add(answer);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Creating connector to address: {}"", configuration.getAddress());
        }
    }
}",java:S112,4
"protected void notifyChannelOpen(ChannelFuture channelFuture) throws Exception{
    if (LOG.isTraceEnabled()) {
        LOG.trace(""Channel open finished with {}"", channelFuture);
    }
    if (channelFuture.isSuccess()) {
        Channel answer = channelFuture.channel();
        allChannels.add(answer);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Creating connector to address: {}"", configuration.getAddress());
        }
    }
}",java:S1130,7
"@Deprecated
public File getKeyStoreFile(){
    return keyStoreFile;
}",java:S6355,48
"@Deprecated
public void setKeyStoreFile(File keyStoreFile){
    this.keyStoreFile = keyStoreFile;
}",java:S6355,48
"@Deprecated
public File getTrustStoreFile(){
    return trustStoreFile;
}",java:S6355,48
"@Deprecated
public void setTrustStoreFile(File trustStoreFile){
    this.trustStoreFile = trustStoreFile;
}",java:S6355,48
"@Deprecated
public ServerInitializerFactory getServerPipelineFactory(){
    return serverInitializerFactory;
}",java:S6355,48
"@Deprecated
public void setServerPipelineFactory(ServerInitializerFactory serverPipelineFactory){
    this.serverInitializerFactory = serverPipelineFactory;
}",java:S6355,48
"public boolean compatible(NettyServerBootstrapConfiguration other){
    boolean isCompatible = true;
    if (!protocol.equals(other.protocol)) {
        isCompatible = false;
    } else if (!host.equals(other.host)) {
        isCompatible = false;
    } else if (port != other.port) {
        isCompatible = false;
    } else if (broadcast != other.broadcast) {
        isCompatible = false;
    } else if (sendBufferSize != other.sendBufferSize) {
        return false;
    } else if (receiveBufferSize != other.receiveBufferSize) {
        isCompatible = false;
    } else if (receiveBufferSizePredictor != other.receiveBufferSizePredictor) {
        isCompatible = false;
    } else if (workerCount != other.workerCount) {
        isCompatible = false;
    } else if (bossCount != other.bossCount) {
        isCompatible = false;
    } else if (keepAlive != other.keepAlive) {
        isCompatible = false;
    } else if (tcpNoDelay != other.tcpNoDelay) {
        isCompatible = false;
    } else if (reuseAddress != other.reuseAddress) {
        isCompatible = false;
    } else if (connectTimeout != other.connectTimeout) {
        isCompatible = false;
    } else if (backlog != other.backlog) {
        isCompatible = false;
    } else if (serverInitializerFactory != other.serverInitializerFactory) {
        isCompatible = false;
    } else if (nettyServerBootstrapFactory != other.nettyServerBootstrapFactory) {
        isCompatible = false;
    } else if (options == null && other.options != null) {
        isCompatible = false;
    } else if (options != null && other.options == null) {
        isCompatible = false;
    } else if (options != null && other.options != null && options.size() != other.options.size()) {
        isCompatible = false;
    } else if (options != null && other.options != null && !options.keySet().containsAll(other.options.keySet())) {
        isCompatible = false;
    } else if (options != null && other.options != null && !options.values().containsAll(other.options.values())) {
        isCompatible = false;
    } else if (ssl != other.ssl) {
        isCompatible = false;
    } else if (sslHandler != other.sslHandler) {
        isCompatible = false;
    } else if (sslContextParameters != other.sslContextParameters) {
        isCompatible = false;
    } else if (needClientAuth != other.needClientAuth) {
        isCompatible = false;
    } else if (keyStoreFile != other.keyStoreFile) {
        isCompatible = false;
    } else if (trustStoreFile != other.trustStoreFile) {
        isCompatible = false;
    } else if (keyStoreResource != null && !keyStoreResource.equals(other.keyStoreResource)) {
        isCompatible = false;
    } else if (trustStoreResource != null && !trustStoreResource.equals(other.trustStoreResource)) {
        isCompatible = false;
    } else if (keyStoreFormat != null && !keyStoreFormat.equals(other.keyStoreFormat)) {
        isCompatible = false;
    } else if (securityProvider != null && !securityProvider.equals(other.securityProvider)) {
        isCompatible = false;
    } else if (passphrase != null && !passphrase.equals(other.passphrase)) {
        isCompatible = false;
    } else if (bossGroup != other.bossGroup) {
        isCompatible = false;
    } else if (workerGroup != other.workerGroup) {
        isCompatible = false;
    } else if (networkInterface != null && !networkInterface.equals(other.networkInterface)) {
        isCompatible = false;
    } else if (reconnect != other.reconnect) {
        isCompatible = false;
    } else if (reconnectInterval != other.reconnectInterval) {
        isCompatible = false;
    } else if (unixDomainSocketPath != other.unixDomainSocketPath) {
        isCompatible = false;
    }
    return isCompatible;
}",java:S3776,39
"protected void startServerBootstrap() throws Exception{
    EventLoopGroup bg = configuration.getBossGroup();
    EventLoopGroup wg = configuration.getWorkerGroup();
    if (bg == null) {
        bossGroup = new NettyServerBossPoolBuilder().withNativeTransport(configuration.isNativeTransport()).withBossCount(configuration.getBossCount()).withName(""NettyServerTCPBoss"").build();
        bg = bossGroup;
    }
    if (wg == null) {
        workerGroup = new NettyWorkerPoolBuilder().withNativeTransport(configuration.isNativeTransport()).withWorkerCount(configuration.getWorkerCount()).withName(""NettyServerTCPWorker"").build();
        wg = workerGroup;
    }
    serverBootstrap = new ServerBootstrap();
    if (configuration.getUnixDomainSocketPath() != null) {
        serverBootstrap.group(bg, wg).channel(EpollServerDomainSocketChannel.class);
    } else {
        if (configuration.isNativeTransport()) {
            serverBootstrap.group(bg, wg).channel(EpollServerSocketChannel.class);
        } else {
            serverBootstrap.group(bg, wg).channel(NioServerSocketChannel.class);
        }
    }
    serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, configuration.isKeepAlive());
    serverBootstrap.childOption(ChannelOption.TCP_NODELAY, configuration.isTcpNoDelay());
    serverBootstrap.option(ChannelOption.SO_REUSEADDR, configuration.isReuseAddress());
    serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, configuration.isReuseAddress());
    serverBootstrap.childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, configuration.getConnectTimeout());
    if (configuration.getBacklog() > 0) {
        serverBootstrap.option(ChannelOption.SO_BACKLOG, configuration.getBacklog());
    }
    Map<String, Object> options = configuration.getOptions();
    if (options != null) {
        for (Map.Entry<String, Object> entry : options.entrySet()) {
            String value = entry.getValue().toString();
            ChannelOption<Object> option = ChannelOption.valueOf(entry.getKey());
            if (EndpointHelper.isReferenceParameter(value)) {
                String name = value.substring(1);
                Object o = CamelContextHelper.mandatoryLookup(camelContext, name);
                serverBootstrap.option(option, o);
            } else {
                serverBootstrap.option(option, value);
            }
        }
    }
    serverBootstrap.childHandler(pipelineFactory);
    LOG.debug(""Created ServerBootstrap {}"", serverBootstrap);
    SocketAddress socketAddress;
    if (configuration.getUnixDomainSocketPath() != null) {
        Path udsPath = Path.of(configuration.getUnixDomainSocketPath()).toAbsolutePath();
        LOG.info(""ServerBootstrap binding to {}"", udsPath);
        socketAddress = new DomainSocketAddress(udsPath.toFile());
    } else {
        LOG.info(""ServerBootstrap binding to {}:{}"", configuration.getHost(), configuration.getPort());
        socketAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());
    }
    ChannelFuture channelFuture = serverBootstrap.bind(socketAddress).sync();
    channel = channelFuture.channel();
    allChannels.add(channel);
}",java:S3776,39
"protected void startServerBootstrap() throws Exception{
    EventLoopGroup bg = configuration.getBossGroup();
    EventLoopGroup wg = configuration.getWorkerGroup();
    if (bg == null) {
        bossGroup = new NettyServerBossPoolBuilder().withNativeTransport(configuration.isNativeTransport()).withBossCount(configuration.getBossCount()).withName(""NettyServerTCPBoss"").build();
        bg = bossGroup;
    }
    if (wg == null) {
        workerGroup = new NettyWorkerPoolBuilder().withNativeTransport(configuration.isNativeTransport()).withWorkerCount(configuration.getWorkerCount()).withName(""NettyServerTCPWorker"").build();
        wg = workerGroup;
    }
    serverBootstrap = new ServerBootstrap();
    if (configuration.getUnixDomainSocketPath() != null) {
        serverBootstrap.group(bg, wg).channel(EpollServerDomainSocketChannel.class);
    } else {
        if (configuration.isNativeTransport()) {
            serverBootstrap.group(bg, wg).channel(EpollServerSocketChannel.class);
        } else {
            serverBootstrap.group(bg, wg).channel(NioServerSocketChannel.class);
        }
    }
    serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, configuration.isKeepAlive());
    serverBootstrap.childOption(ChannelOption.TCP_NODELAY, configuration.isTcpNoDelay());
    serverBootstrap.option(ChannelOption.SO_REUSEADDR, configuration.isReuseAddress());
    serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, configuration.isReuseAddress());
    serverBootstrap.childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, configuration.getConnectTimeout());
    if (configuration.getBacklog() > 0) {
        serverBootstrap.option(ChannelOption.SO_BACKLOG, configuration.getBacklog());
    }
    Map<String, Object> options = configuration.getOptions();
    if (options != null) {
        for (Map.Entry<String, Object> entry : options.entrySet()) {
            String value = entry.getValue().toString();
            ChannelOption<Object> option = ChannelOption.valueOf(entry.getKey());
            if (EndpointHelper.isReferenceParameter(value)) {
                String name = value.substring(1);
                Object o = CamelContextHelper.mandatoryLookup(camelContext, name);
                serverBootstrap.option(option, o);
            } else {
                serverBootstrap.option(option, value);
            }
        }
    }
    serverBootstrap.childHandler(pipelineFactory);
    LOG.debug(""Created ServerBootstrap {}"", serverBootstrap);
    SocketAddress socketAddress;
    if (configuration.getUnixDomainSocketPath() != null) {
        Path udsPath = Path.of(configuration.getUnixDomainSocketPath()).toAbsolutePath();
        LOG.info(""ServerBootstrap binding to {}"", udsPath);
        socketAddress = new DomainSocketAddress(udsPath.toFile());
    } else {
        LOG.info(""ServerBootstrap binding to {}:{}"", configuration.getHost(), configuration.getPort());
        socketAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());
    }
    ChannelFuture channelFuture = serverBootstrap.bind(socketAddress).sync();
    channel = channelFuture.channel();
    allChannels.add(channel);
}",java:S112,4
"protected void startServerBootstrap() throws Exception{
    EventLoopGroup wg = configuration.getWorkerGroup();
    if (wg == null) {
        workerGroup = new NettyWorkerPoolBuilder().withNativeTransport(configuration.isNativeTransport()).withWorkerCount(configuration.getWorkerCount()).withName(""NettyServerTCPWorker"").build();
        wg = workerGroup;
    }
    Bootstrap bootstrap = new Bootstrap();
    if (configuration.isNativeTransport()) {
        bootstrap.group(wg).channel(EpollDatagramChannel.class);
    } else {
        bootstrap.group(wg).channel(NioDatagramChannel.class);
    }
    bootstrap.option(ChannelOption.SO_REUSEADDR, configuration.isReuseAddress());
    bootstrap.option(ChannelOption.SO_SNDBUF, configuration.getSendBufferSize());
    bootstrap.option(ChannelOption.SO_RCVBUF, configuration.getReceiveBufferSize());
    bootstrap.option(ChannelOption.SO_BROADCAST, configuration.isBroadcast());
    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, configuration.getConnectTimeout());
    if (configuration.getReceiveBufferSizePredictor() > 0) {
        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, new FixedRecvByteBufAllocator(configuration.getReceiveBufferSizePredictor()));
    }
    if (configuration.getBacklog() > 0) {
        bootstrap.option(ChannelOption.SO_BACKLOG, configuration.getBacklog());
    }
    Map<String, Object> options = configuration.getOptions();
    if (options != null) {
        for (Map.Entry<String, Object> entry : options.entrySet()) {
            String value = entry.getValue().toString();
            ChannelOption<Object> option = ChannelOption.valueOf(entry.getKey());
            if (EndpointHelper.isReferenceParameter(value)) {
                String name = value.substring(1);
                Object o = CamelContextHelper.mandatoryLookup(camelContext, name);
                bootstrap.option(option, o);
            } else {
                bootstrap.option(option, value);
            }
        }
    }
    LOG.debug(""Created Bootstrap {}"", bootstrap);
    bootstrap.handler(pipelineFactory);
    InetSocketAddress hostAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());
    SubnetUtils multicastSubnet = new SubnetUtils(MULTICAST_SUBNET);
    if (multicastSubnet.getInfo().isInRange(configuration.getHost())) {
        ChannelFuture channelFuture = bootstrap.bind(configuration.getPort()).sync();
        channel = channelFuture.channel();
        DatagramChannel datagramChannel = (DatagramChannel) channel;
        String networkInterface = configuration.getNetworkInterface() == null ? LOOPBACK_INTERFACE : configuration.getNetworkInterface();
        multicastNetworkInterface = NetworkInterface.getByName(networkInterface);
        ObjectHelper.notNull(multicastNetworkInterface, ""No network interface found for '"" + networkInterface + ""'."");
        LOG.info(""ConnectionlessBootstrap joining {}:{} using network interface: {}"", configuration.getHost(), configuration.getPort(), multicastNetworkInterface.getName());
        datagramChannel.joinGroup(hostAddress, multicastNetworkInterface).syncUninterruptibly();
        allChannels.add(datagramChannel);
    } else {
        LOG.info(""ConnectionlessBootstrap binding to {}:{}"", configuration.getHost(), configuration.getPort());
        ChannelFuture channelFuture = bootstrap.bind(hostAddress).sync();
        channel = channelFuture.channel();
        allChannels.add(channel);
    }
}",java:S3776,39
"protected void startServerBootstrap() throws Exception{
    EventLoopGroup wg = configuration.getWorkerGroup();
    if (wg == null) {
        workerGroup = new NettyWorkerPoolBuilder().withNativeTransport(configuration.isNativeTransport()).withWorkerCount(configuration.getWorkerCount()).withName(""NettyServerTCPWorker"").build();
        wg = workerGroup;
    }
    Bootstrap bootstrap = new Bootstrap();
    if (configuration.isNativeTransport()) {
        bootstrap.group(wg).channel(EpollDatagramChannel.class);
    } else {
        bootstrap.group(wg).channel(NioDatagramChannel.class);
    }
    bootstrap.option(ChannelOption.SO_REUSEADDR, configuration.isReuseAddress());
    bootstrap.option(ChannelOption.SO_SNDBUF, configuration.getSendBufferSize());
    bootstrap.option(ChannelOption.SO_RCVBUF, configuration.getReceiveBufferSize());
    bootstrap.option(ChannelOption.SO_BROADCAST, configuration.isBroadcast());
    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, configuration.getConnectTimeout());
    if (configuration.getReceiveBufferSizePredictor() > 0) {
        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, new FixedRecvByteBufAllocator(configuration.getReceiveBufferSizePredictor()));
    }
    if (configuration.getBacklog() > 0) {
        bootstrap.option(ChannelOption.SO_BACKLOG, configuration.getBacklog());
    }
    Map<String, Object> options = configuration.getOptions();
    if (options != null) {
        for (Map.Entry<String, Object> entry : options.entrySet()) {
            String value = entry.getValue().toString();
            ChannelOption<Object> option = ChannelOption.valueOf(entry.getKey());
            if (EndpointHelper.isReferenceParameter(value)) {
                String name = value.substring(1);
                Object o = CamelContextHelper.mandatoryLookup(camelContext, name);
                bootstrap.option(option, o);
            } else {
                bootstrap.option(option, value);
            }
        }
    }
    LOG.debug(""Created Bootstrap {}"", bootstrap);
    bootstrap.handler(pipelineFactory);
    InetSocketAddress hostAddress = new InetSocketAddress(configuration.getHost(), configuration.getPort());
    SubnetUtils multicastSubnet = new SubnetUtils(MULTICAST_SUBNET);
    if (multicastSubnet.getInfo().isInRange(configuration.getHost())) {
        ChannelFuture channelFuture = bootstrap.bind(configuration.getPort()).sync();
        channel = channelFuture.channel();
        DatagramChannel datagramChannel = (DatagramChannel) channel;
        String networkInterface = configuration.getNetworkInterface() == null ? LOOPBACK_INTERFACE : configuration.getNetworkInterface();
        multicastNetworkInterface = NetworkInterface.getByName(networkInterface);
        ObjectHelper.notNull(multicastNetworkInterface, ""No network interface found for '"" + networkInterface + ""'."");
        LOG.info(""ConnectionlessBootstrap joining {}:{} using network interface: {}"", configuration.getHost(), configuration.getPort(), multicastNetworkInterface.getName());
        datagramChannel.joinGroup(hostAddress, multicastNetworkInterface).syncUninterruptibly();
        allChannels.add(datagramChannel);
    } else {
        LOG.info(""ConnectionlessBootstrap binding to {}:{}"", configuration.getHost(), configuration.getPort());
        ChannelFuture channelFuture = bootstrap.bind(hostAddress).sync();
        channel = channelFuture.channel();
        allChannels.add(channel);
    }
}",java:S112,4
"protected Message getResponseMessage(Exchange exchange, ChannelHandlerContext ctx, Object message) throws Exception{
    Object body = message;
    if (LOG.isDebugEnabled()) {
        LOG.debug(""Channel: {} received body: {}"", ctx.channel(), body);
    }
    if (producer.getConfiguration().isTextline()) {
        body = producer.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, message);
    }
    if (ExchangeHelper.isOutCapable(exchange)) {
        NettyPayloadHelper.setOut(exchange, body);
        return exchange.getOut();
    } else {
        NettyPayloadHelper.setIn(exchange, body);
        return exchange.getIn();
    }
}",java:S112,4
"protected Exchange createExchange(ChannelHandlerContext ctx, Object message) throws Exception{
    Exchange exchange = consumer.createExchange(false);
    consumer.getEndpoint().updateMessageHeader(exchange.getIn(), ctx);
    NettyPayloadHelper.setIn(exchange, message);
    return exchange;
}",java:S112,4
"protected Exchange createExchange(ChannelHandlerContext ctx, Object message) throws Exception{
    Exchange exchange = consumer.createExchange(false);
    consumer.getEndpoint().updateMessageHeader(exchange.getIn(), ctx);
    NettyPayloadHelper.setIn(exchange, message);
    return exchange;
}",java:S1130,7
"protected Object getResponseBody(Exchange exchange) throws Exception{
    boolean exception = exchange.getException() != null && !consumer.getEndpoint().getConfiguration().isTransferExchange();
    if (exception) {
        return exchange.getException();
    }
    if (exchange.hasOut()) {
        return NettyPayloadHelper.getOut(consumer.getEndpoint(), exchange);
    } else {
        return NettyPayloadHelper.getIn(consumer.getEndpoint(), exchange);
    }
}",java:S112,4
"@Deprecated
public int getAddressCount(){
    long countLong = getAddressCountLong();
    if (countLong > Integer.MAX_VALUE) {
        throw new RuntimeException(""Count is larger than an integer: "" + countLong);
    }
    return (int) countLong;
}",java:S6355,48
"private int[] toArray(int val){
    int[] ret = new int[4];
    for (int j = 3; j >= 0; --j) {
        ret[j] |= (val >>> 8 * (3 - j)) & 0xff;
    }
    return ret;
}",java:S3398,35
"private String format(int[] octets){
    StringBuilder str = new StringBuilder();
    for (int i = 0; i < octets.length; ++i) {
        str.append(octets[i]);
        if (i != octets.length - 1) {
            str.append(""."");
        }
    }
    return str.toString();
}",java:S3398,35
"protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception{
    NitriteEndpoint endpoint = new NitriteEndpoint(uri, this);
    setProperties(endpoint, parameters);
    if (endpoint.getCollection() != null && endpoint.getRepositoryClass() != null) {
        throw new IllegalArgumentException(""Options collection and repositoryClass cannot be used together"");
    }
    if (endpoint.getCollection() == null && endpoint.getRepositoryClass() == null) {
        throw new IllegalArgumentException(""Either collection or repositoryClass option is required"");
    }
    String normalizedPath = FileUtil.compactPath(remaining);
    endpoint.setDatabase(normalizedPath);
    Nitrite nitriteDatabase = databaseCache.computeIfAbsent(normalizedPath, path -> {
        NitriteBuilder builder = Nitrite.builder().compressed().filePath(path);
        if (endpoint.getUsername() == null && endpoint.getPassword() == null) {
            return builder.openOrCreate();
        } else {
            return builder.openOrCreate(endpoint.getUsername(), endpoint.getPassword());
        }
    });
    endpoint.setNitriteDatabase(nitriteDatabase);
    PersistentCollection nitriteCollection = collectionCache.computeIfAbsent(new CollectionCacheKey(endpoint), key -> {
        if (key.collection != null) {
            return key.database.getCollection(key.collection);
        } else {
            if (key.repositoryName != null) {
                return key.database.getRepository(key.repositoryName, key.repositoryClass);
            } else if (key.repositoryClass != null) {
                return key.database.getRepository(key.repositoryClass);
            } else {
                throw new IllegalArgumentException(""Required one of option: collection or repositoryClass"");
            }
        }
    });
    endpoint.setNitriteCollection(nitriteCollection);
    return endpoint;
}",java:S3776,39
"public void setNitriteCollection(PersistentCollection collection){
    this.nitriteCollection = collection;
}",java:S3740,38
"public PersistentCollection getNitriteCollection(){
    return nitriteCollection;
}",java:S3740,38
"protected Object getPayload(Exchange exchange, NitriteEndpoint endpoint) throws Exception{
    Class<?> targetClass = endpoint.getRepositoryClass() != null ? endpoint.getRepositoryClass() : Document.class;
    Object payload = expression.evaluate(exchange, Object.class);
    return endpoint.getCamelContext().getTypeConverter().mandatoryConvertTo(targetClass, exchange, payload);
}",java:S112,4
"private boolean harvest() throws Exception{
    boolean hasNext = false;
    if (!this.empty) {
        String responseXML = httpClient.doRequest(this.baseURI, this.verb, this.set, this.from, this.until, this.metadata, this.resumptionToken, this.identifier);
        OAIPMHResponse oaipmhResponse = new OAIPMHResponse(responseXML);
        this.oaipmhResponseHandler.process(oaipmhResponse);
        Optional<String> resumptionToken = oaipmhResponse.getResumptionToken();
        if (resumptionToken.isPresent() && !resumptionToken.get().isEmpty()) {
            this.resumptionToken = resumptionToken.get();
            hasNext = true;
        } else {
            this.resumptionToken = null;
            this.empty = true;
        }
    }
    return hasNext;
}",java:S112,4
"public String doRequest(URI baseURI, String verb, String set, String from, String until, String metadataPrefix, String token, String identifier) throws IOException, URISyntaxException{
    try (CloseableHttpClient httpclient = getCloseableHttpClient()) {
        URIBuilder builder = new URIBuilder();
        builder.setScheme(baseURI.getScheme()).setHost(baseURI.getHost()).setPort(baseURI.getPort()).setPath(baseURI.getPath()).addParameter(""verb"", verb).addParameters(URLEncodedUtils.parse(baseURI, Charset.defaultCharset()));
        if (identifier != null) {
            builder.addParameter(""identifier"", identifier);
        }
        if (token != null) {
            builder.addParameter(""resumptionToken"", token);
        } else {
            if (metadataPrefix != null) {
                builder.addParameter(""metadataPrefix"", metadataPrefix);
            }
            if (set != null) {
                builder.addParameter(""set"", set);
            }
            if (from != null) {
                builder.addParameter(""from"", from);
            }
            if (until != null) {
                builder.addParameter(""until"", until);
            }
        }
        HttpGet httpget = new HttpGet(builder.build());
        LOG.info(""Executing request: {} "", httpget);
        HttpClientResponseHandler<String> responseHandler = new HttpClientResponseHandler<String>() {

            @Override
            public String handleResponse(final ClassicHttpResponse response) throws HttpException, IOException {
                int status = response.getCode();
                if (status >= 200 && status < 300) {
                    HttpEntity entity = response.getEntity();
                    if (entity == null) {
                        throw new IOException(""No response received"");
                    }
                    return EntityUtils.toString(entity, StandardCharsets.UTF_8);
                } else {
                    throw new ClientProtocolException(""Unexpected response status: "" + status);
                }
            }
        };
        String responseBody = httpclient.execute(httpget, responseHandler);
        LOG.debug(""Response received: {}"", responseBody);
        return responseBody;
    }
}",java:S3776,39
"public String doRequest(URI baseURI, String verb, String set, String from, String until, String metadataPrefix, String token, String identifier) throws IOException, URISyntaxException{
    try (CloseableHttpClient httpclient = getCloseableHttpClient()) {
        URIBuilder builder = new URIBuilder();
        builder.setScheme(baseURI.getScheme()).setHost(baseURI.getHost()).setPort(baseURI.getPort()).setPath(baseURI.getPath()).addParameter(""verb"", verb).addParameters(URLEncodedUtils.parse(baseURI, Charset.defaultCharset()));
        if (identifier != null) {
            builder.addParameter(""identifier"", identifier);
        }
        if (token != null) {
            builder.addParameter(""resumptionToken"", token);
        } else {
            if (metadataPrefix != null) {
                builder.addParameter(""metadataPrefix"", metadataPrefix);
            }
            if (set != null) {
                builder.addParameter(""set"", set);
            }
            if (from != null) {
                builder.addParameter(""from"", from);
            }
            if (until != null) {
                builder.addParameter(""until"", until);
            }
        }
        HttpGet httpget = new HttpGet(builder.build());
        LOG.info(""Executing request: {} "", httpget);
        HttpClientResponseHandler<String> responseHandler = new HttpClientResponseHandler<String>() {

            @Override
            public String handleResponse(final ClassicHttpResponse response) throws HttpException, IOException {
                int status = response.getCode();
                if (status >= 200 && status < 300) {
                    HttpEntity entity = response.getEntity();
                    if (entity == null) {
                        throw new IOException(""No response received"");
                    }
                    return EntityUtils.toString(entity, StandardCharsets.UTF_8);
                } else {
                    throw new ClientProtocolException(""Unexpected response status: "" + status);
                }
            }
        };
        String responseBody = httpclient.execute(httpget, responseHandler);
        LOG.debug(""Response received: {}"", responseBody);
        return responseBody;
    }
}",java:S107,1
"@Deprecated
public Message getResponse(){
    return exchange.getOut();
}",java:S6355,48
"public void parseURI(URI uri) throws Exception{
    transport = AvroTransport.valueOf(uri.getScheme());
    setHost(uri.getHost());
    setPort(uri.getPort());
    if (uri.getPath() != null && StringUtils.indexOf(uri.getPath(), AVRO_MESSAGE_NAME_SEPARATOR) != -1) {
        String path = StringUtils.substringAfter(uri.getPath(), AVRO_MESSAGE_NAME_SEPARATOR);
        if (!path.contains(AVRO_MESSAGE_NAME_SEPARATOR)) {
            setMessageName(path);
        } else {
            throw new IllegalArgumentException(""Unrecognized Avro message name: "" + path + "" for uri: "" + uri);
        }
    }
    setUriAuthority(uri.getAuthority());
}",java:S112,4
"private void writeContent(final Edm edm, final HttpEntityEnclosingRequestBase httpEntityRequest, final UriInfoWithType uriInfo, final Map<String, String> endpointHttpHeaders, final Object content, final Olingo2ResponseHandler<T> responseHandler, EntityProviderWriteProperties entityProviderWriteProperties){
    try {
        final ODataResponse response = writeContent(edm, uriInfo, content, entityProviderWriteProperties);
        for (String header : response.getHeaderNames()) {
            httpEntityRequest.setHeader(header, response.getHeader(header));
        }
        if (response.getEntity() instanceof InputStream) {
            httpEntityRequest.setEntity(new InputStreamEntity((InputStream) response.getEntity()));
        }
        final Header requestContentTypeHeader = httpEntityRequest.getFirstHeader(HttpHeaders.CONTENT_TYPE);
        final ContentType requestContentType = requestContentTypeHeader != null ? ContentType.parse(requestContentTypeHeader.getValue()) : contentType;
        execute(httpEntityRequest, requestContentType, endpointHttpHeaders, new AbstractFutureCallback<T>(responseHandler) {

            @SuppressWarnings(""unchecked"")
            @Override
            public void onCompleted(HttpResponse result) throws IOException, EntityProviderException, BatchException, ODataApplicationException {
                HttpStatusCodes statusCode = HttpStatusCodes.fromStatusCode(result.getStatusLine().getStatusCode());
                final boolean noEntity = result.getEntity() == null || result.getEntity().getContentLength() == 0;
                if (statusCode == HttpStatusCodes.NO_CONTENT || noEntity) {
                    responseHandler.onResponse((T) HttpStatusCodes.fromStatusCode(result.getStatusLine().getStatusCode()), headersToMap(result.getAllHeaders()));
                } else {
                    switch(uriInfo.getUriType()) {
                        case URI9:
                            String type = result.containsHeader(HttpHeaders.CONTENT_TYPE) ? result.getFirstHeader(HttpHeaders.CONTENT_TYPE).getValue() : null;
                            final List<BatchSingleResponse> singleResponses = EntityProvider.parseBatchResponse(result.getEntity().getContent(), type);
                            final List<Olingo2BatchResponse> responses = new ArrayList<>();
                            Map<String, String> contentIdLocationMap = new HashMap<>();
                            final List<Olingo2BatchRequest> batchRequests = (List<Olingo2BatchRequest>) content;
                            final Iterator<Olingo2BatchRequest> iterator = batchRequests.iterator();
                            for (BatchSingleResponse response : singleResponses) {
                                final Olingo2BatchRequest request = iterator.next();
                                if (request instanceof Olingo2BatchChangeRequest && ((Olingo2BatchChangeRequest) request).getContentId() != null) {
                                    contentIdLocationMap.put(""$"" + ((Olingo2BatchChangeRequest) request).getContentId(), response.getHeader(HttpHeaders.LOCATION));
                                }
                                try {
                                    responses.add(parseResponse(edm, contentIdLocationMap, request, response));
                                } catch (Exception e) {
                                    responses.add(new Olingo2BatchResponse(Integer.parseInt(response.getStatusCode()), response.getStatusInfo(), response.getContentId(), response.getHeaders(), new ODataApplicationException(""Error parsing response for "" + request + "": "" + e.getMessage(), Locale.ENGLISH, e)));
                                }
                            }
                            responseHandler.onResponse((T) responses, headersToMap(result.getAllHeaders()));
                            break;
                        case URI4:
                        case URI5:
                            final List<EdmProperty> simplePropertyPath = uriInfo.getPropertyPath();
                            final EdmProperty simpleProperty = simplePropertyPath.get(simplePropertyPath.size() - 1);
                            if (uriInfo.isValue()) {
                                responseHandler.onResponse((T) EntityProvider.readPropertyValue(simpleProperty, result.getEntity().getContent()), headersToMap(result.getAllHeaders()));
                            } else {
                                responseHandler.onResponse((T) EntityProvider.readProperty(getContentType(), simpleProperty, result.getEntity().getContent(), getEntityProviderReadProperties()), headersToMap(result.getAllHeaders()));
                            }
                            break;
                        case URI3:
                            final List<EdmProperty> complexPropertyPath = uriInfo.getPropertyPath();
                            final EdmProperty complexProperty = complexPropertyPath.get(complexPropertyPath.size() - 1);
                            responseHandler.onResponse((T) EntityProvider.readProperty(getContentType(), complexProperty, result.getEntity().getContent(), getEntityProviderReadProperties()), headersToMap(result.getAllHeaders()));
                            break;
                        case URI7A:
                            final EdmEntitySet targetLinkEntitySet = uriInfo.getTargetEntitySet();
                            responseHandler.onResponse((T) EntityProvider.readLink(getContentType(), targetLinkEntitySet, result.getEntity().getContent()), headersToMap(result.getAllHeaders()));
                            break;
                        case URI7B:
                            final EdmEntitySet targetLinksEntitySet = uriInfo.getTargetEntitySet();
                            responseHandler.onResponse((T) EntityProvider.readLinks(getContentType(), targetLinksEntitySet, result.getEntity().getContent()), headersToMap(result.getAllHeaders()));
                            break;
                        case URI1:
                        case URI2:
                        case URI6A:
                        case URI6B:
                            responseHandler.onResponse((T) EntityProvider.readEntry(response.getContentHeader(), uriInfo.getTargetEntitySet(), result.getEntity().getContent(), getEntityProviderReadProperties()), headersToMap(result.getAllHeaders()));
                            break;
                        default:
                            throw new ODataApplicationException(""Unsupported resource type "" + uriInfo.getTargetType(), Locale.ENGLISH);
                    }
                }
            }
        });
    } catch (Exception e) {
        responseHandler.onException(e);
    } catch (Error e) {
        responseHandler.onException(new ODataApplicationException(""Runtime Error Occurred"", Locale.ENGLISH, e));
    }
}",java:S3776,39
"private void validateConfiguration(AvroConfiguration config) throws Exception{
    if (config.getProtocol() == null && config.getProtocolClassName() != null) {
        Class<?> protocolClass = getCamelContext().getClassResolver().resolveClass(config.getProtocolClassName());
        if (protocolClass != null) {
            try {
                Field f = protocolClass.getField(""PROTOCOL"");
                if (f != null) {
                    Protocol protocol = (Protocol) f.get(null);
                    config.setProtocol(protocol);
                }
            } catch (NoSuchFieldException e) {
                ReflectData reflectData = ReflectData.get();
                config.setProtocol(reflectData.getProtocol(protocolClass));
                config.setReflectionProtocol(true);
            }
        }
    }
    if (config.getProtocol() == null) {
        throw new IllegalArgumentException(""Avro configuration does not contain protocol"");
    }
    if (config.getMessageName() != null && !config.getProtocol().getMessages().containsKey(config.getMessageName())) {
        throw new IllegalArgumentException(""Message "" + config.getMessageName() + "" is not defined in protocol"");
    }
    if (config.isSingleParameter()) {
        Map<String, Protocol.Message> messageMap = config.getProtocol().getMessages();
        Iterable<Protocol.Message> messagesToCheck = config.getMessageName() == null ? messageMap.values() : Collections.singleton(messageMap.get(config.getMessageName()));
        for (Protocol.Message message : messagesToCheck) {
            if (message.getRequest().getFields().size() != 1) {
                throw new IllegalArgumentException(""Single parameter option can't be used with message "" + message.getName() + "" because it has "" + message.getRequest().getFields().size() + "" parameters defined"");
            }
        }
    }
}",java:S3776,39
"private static UriInfoWithType parseUri(Edm edm, String resourcePath, Map<String, String> queryParams){
    UriInfoWithType result;
    try {
        final List<PathSegment> pathSegments = new ArrayList<>();
        final String[] segments = new URI(resourcePath).getPath().split(SEPARATOR);
        if (queryParams == null) {
            queryParams = Collections.emptyMap();
        }
        for (String segment : segments) {
            if (segment.indexOf(';') == -1) {
                pathSegments.add(new ODataPathSegmentImpl(segment, null));
            } else {
                final String[] splitSegment = segment.split("";"");
                segment = splitSegment[0];
                Map<String, List<String>> matrixParams = new HashMap<>();
                for (int i = 1; i < splitSegment.length; i++) {
                    final String[] param = splitSegment[i].split(""="");
                    List<String> values = matrixParams.get(param[0]);
                    if (values == null) {
                        values = new ArrayList<>();
                        matrixParams.put(param[0], values);
                    }
                    if (param[1].indexOf(',') == -1) {
                        values.add(param[1]);
                    } else {
                        values.addAll(Arrays.asList(param[1].split("","")));
                    }
                }
                pathSegments.add(new ODataPathSegmentImpl(segment, matrixParams));
            }
        }
        result = new UriInfoWithType(UriParser.parse(edm, pathSegments, queryParams), resourcePath);
    } catch (URISyntaxException | ODataException e) {
        throw new IllegalArgumentException(""resourcePath: "" + e.getMessage(), e);
    }
    return result;
}",java:S3776,39
"public void execute(final HttpUriRequest httpUriRequest, final ContentType contentType, final Map<String, String> endpointHttpHeaders, final FutureCallback<HttpResponse> callback){
    if (!ContentType.APPLICATION_FORM_URLENCODED.getMimeType().equals(contentType.getMimeType()) && !contentType.getMimeType().startsWith(MULTIPART_MIME_TYPE)) {
        httpUriRequest.addHeader(HttpHeaders.ACCEPT, contentType.withCharset("""").toString().toLowerCase());
        final Charset charset = contentType.getCharset();
        if (null != charset) {
            httpUriRequest.addHeader(HttpHeaders.ACCEPT_CHARSET, charset.name().toLowerCase());
        }
    }
    if (httpUriRequest instanceof HttpEntityEnclosingRequestBase && httpUriRequest.getFirstHeader(HttpHeaders.CONTENT_TYPE) == null) {
        httpUriRequest.addHeader(HttpHeaders.CONTENT_TYPE, contentType.toString());
    }
    if (httpHeaders != null && !httpHeaders.isEmpty()) {
        for (Map.Entry<String, String> entry : httpHeaders.entrySet()) {
            httpUriRequest.setHeader(entry.getKey(), entry.getValue());
        }
    }
    if (endpointHttpHeaders != null && !endpointHttpHeaders.isEmpty()) {
        for (Map.Entry<String, String> entry : endpointHttpHeaders.entrySet()) {
            httpUriRequest.setHeader(entry.getKey(), entry.getValue());
        }
    }
    if (!httpUriRequest.containsHeader(ODataHttpHeaders.DATASERVICEVERSION)) {
        httpUriRequest.addHeader(ODataHttpHeaders.DATASERVICEVERSION, ODataServiceVersion.V20);
    }
    if (!httpUriRequest.containsHeader(MAX_DATA_SERVICE_VERSION)) {
        httpUriRequest.addHeader(MAX_DATA_SERVICE_VERSION, ODataServiceVersion.V30);
    }
    if (client instanceof CloseableHttpAsyncClient) {
        ((CloseableHttpAsyncClient) client).execute(httpUriRequest, callback);
    } else {
        try {
            CloseableHttpResponse result = ((CloseableHttpClient) client).execute(httpUriRequest);
            callback.completed(result);
        } catch (IOException e) {
            callback.failed(e);
        }
    }
}",java:S3776,39
"private void validateConfiguration(AvroConfiguration config) throws Exception{
    if (config.getProtocol() == null && config.getProtocolClassName() != null) {
        Class<?> protocolClass = getCamelContext().getClassResolver().resolveClass(config.getProtocolClassName());
        if (protocolClass != null) {
            try {
                Field f = protocolClass.getField(""PROTOCOL"");
                if (f != null) {
                    Protocol protocol = (Protocol) f.get(null);
                    config.setProtocol(protocol);
                }
            } catch (NoSuchFieldException e) {
                ReflectData reflectData = ReflectData.get();
                config.setProtocol(reflectData.getProtocol(protocolClass));
                config.setReflectionProtocol(true);
            }
        }
    }
    if (config.getProtocol() == null) {
        throw new IllegalArgumentException(""Avro configuration does not contain protocol"");
    }
    if (config.getMessageName() != null && !config.getProtocol().getMessages().containsKey(config.getMessageName())) {
        throw new IllegalArgumentException(""Message "" + config.getMessageName() + "" is not defined in protocol"");
    }
    if (config.isSingleParameter()) {
        Map<String, Protocol.Message> messageMap = config.getProtocol().getMessages();
        Iterable<Protocol.Message> messagesToCheck = config.getMessageName() == null ? messageMap.values() : Collections.singleton(messageMap.get(config.getMessageName()));
        for (Protocol.Message message : messagesToCheck) {
            if (message.getRequest().getFields().size() != 1) {
                throw new IllegalArgumentException(""Single parameter option can't be used with message "" + message.getName() + "" because it has "" + message.getRequest().getFields().size() + "" parameters defined"");
            }
        }
    }
}",java:S112,4
"public Edm getEdm(Map<String, String> endpointHttpHeaders) throws RuntimeCamelException{
    Edm localEdm = edm;
    if (localEdm == null) {
        synchronized (this) {
            localEdm = edm;
            if (localEdm == null) {
                final CountDownLatch latch = new CountDownLatch(1);
                final Exception[] error = new Exception[1];
                olingo2App.read(null, ""$metadata"", null, endpointHttpHeaders, new Olingo2ResponseHandler<Edm>() {

                    @Override
                    public void onResponse(Edm response, Map<String, String> responseHeaders) {
                        edm = response;
                        latch.countDown();
                    }

                    @Override
                    public void onException(Exception ex) {
                        error[0] = ex;
                        latch.countDown();
                    }

                    @Override
                    public void onCanceled() {
                        error[0] = new RuntimeCamelException(""OData HTTP request cancelled!"");
                        latch.countDown();
                    }
                });
                try {
                    latch.await();
                    final Exception ex = error[0];
                    if (ex != null) {
                        if (ex instanceof RuntimeCamelException) {
                            throw (RuntimeCamelException) ex;
                        } else {
                            final String message = ex.getMessage() != null ? ex.getMessage() : ex.getClass().getName();
                            throw new RuntimeCamelException(""Error reading EDM: "" + message, ex);
                        }
                    }
                } catch (InterruptedException e) {
                    throw new RuntimeCamelException(e.getMessage(), e);
                }
                localEdm = edm;
            }
        }
    }
    return localEdm;
}",java:S3776,39
"private void writeContent(final Edm edm, HttpEntityEnclosingRequestBase httpEntityRequest, final UriInfo uriInfo, final Object content, final Map<String, String> endpointHttpHeaders, final Olingo4ResponseHandler<T> responseHandler){
    try {
        httpEntityRequest.setEntity(writeContent(edm, uriInfo, content));
        final Header requestContentTypeHeader = httpEntityRequest.getEntity().getContentType();
        final ContentType requestContentType = requestContentTypeHeader != null ? ContentType.parse(requestContentTypeHeader.getValue()) : contentType;
        execute(httpEntityRequest, requestContentType, endpointHttpHeaders, new AbstractFutureCallback<T>(responseHandler) {

            @SuppressWarnings(""unchecked"")
            @Override
            public void onCompleted(HttpResponse result) throws IOException, ODataException {
                HttpStatusCode statusCode = HttpStatusCode.fromStatusCode(result.getStatusLine().getStatusCode());
                final boolean noEntity = result.getEntity() == null || result.getEntity().getContentLength() == 0;
                if (statusCode == HttpStatusCode.NO_CONTENT || noEntity) {
                    responseHandler.onResponse((T) HttpStatusCode.fromStatusCode(result.getStatusLine().getStatusCode()), headersToMap(result.getAllHeaders()));
                } else {
                    if (uriInfo.getKind() == UriInfoKind.resource) {
                        List<UriResource> listResource = uriInfo.getUriResourceParts();
                        UriResourceKind lastResourceKind = listResource.get(listResource.size() - 1).getKind();
                        switch(lastResourceKind) {
                            case action:
                            case entitySet:
                                ClientEntity entity = odataReader.readEntity(result.getEntity().getContent(), ContentType.parse(result.getEntity().getContentType().getValue()));
                                responseHandler.onResponse((T) entity, headersToMap(result.getAllHeaders()));
                                break;
                            default:
                                break;
                        }
                    } else if (uriInfo.getKind() == UriInfoKind.batch) {
                        List<Olingo4BatchResponse> batchResponse = parseBatchResponse(edm, result, (List<Olingo4BatchRequest>) content);
                        responseHandler.onResponse((T) batchResponse, headersToMap(result.getAllHeaders()));
                    } else {
                        throw new ODataException(""Unsupported resource type: "" + uriInfo.getKind().name());
                    }
                }
            }
        });
    } catch (Exception e) {
        responseHandler.onException(e);
    } catch (Error e) {
        responseHandler.onException(new ODataException(""Runtime Error Occurred"", e));
    }
}",java:S3776,39
"private InputStream serializeBatchRequest(final Edm edm, final List<Olingo4BatchRequest> batchParts, String boundary) throws ODataException{
    final ByteArrayOutputStream batchRequestHeaderOutputStream = new ByteArrayOutputStream();
    try {
        batchRequestHeaderOutputStream.write(boundary.getBytes(StandardCharsets.UTF_8));
        batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);
        for (Olingo4BatchRequest batchPart : batchParts) {
            writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_HTTP.toContentTypeString());
            writeHttpHeader(batchRequestHeaderOutputStream, ODataBatchConstants.ITEM_TRANSFER_ENCODING_LINE, null);
            if (batchPart instanceof Olingo4BatchQueryRequest) {
                final Olingo4BatchQueryRequest batchQueryPart = (Olingo4BatchQueryRequest) batchPart;
                final String batchQueryUri = createUri(StringUtils.isBlank(batchQueryPart.getResourceUri()) ? serviceUri : batchQueryPart.getResourceUri(), batchQueryPart.getResourcePath(), concatQueryParams(batchQueryPart.getQueryParams()));
                final UriInfo uriInfo = parseUri(edm, batchQueryPart.getResourcePath(), concatQueryParams(batchQueryPart.getQueryParams()), serviceUri);
                batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);
                batchRequestHeaderOutputStream.write((HttpGet.METHOD_NAME + "" "" + batchQueryUri + "" "" + HttpVersion.HTTP_1_1).getBytes(StandardCharsets.UTF_8));
                batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);
                final ContentType acceptType = getResourceContentType(uriInfo);
                final String acceptCharset = acceptType.getParameter(ContentType.PARAMETER_CHARSET);
                writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.ACCEPT, contentType.getType().toLowerCase() + ""/"" + contentType.getSubtype().toLowerCase());
                if (null != acceptCharset) {
                    writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.ACCEPT_CHARSET, acceptCharset.toLowerCase());
                }
                batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);
                batchRequestHeaderOutputStream.write(boundary.getBytes(StandardCharsets.UTF_8));
                batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);
            } else if (batchPart instanceof Olingo4BatchChangeRequest) {
                final Olingo4BatchChangeRequest batchChangePart = (Olingo4BatchChangeRequest) batchPart;
                final String batchChangeUri = createUri(StringUtils.isBlank(batchChangePart.getResourceUri()) ? serviceUri : batchChangePart.getResourceUri(), batchChangePart.getResourcePath(), null);
                final UriInfo uriInfo = parseUri(edm, batchChangePart.getResourcePath(), null, serviceUri);
                if (batchChangePart.getOperation() != Operation.DELETE) {
                    writeHttpHeader(batchRequestHeaderOutputStream, CONTENT_ID_HEADER, batchChangePart.getContentId());
                }
                batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);
                batchRequestHeaderOutputStream.write((batchChangePart.getOperation().getHttpMethod() + "" "" + batchChangeUri + "" "" + HttpVersion.HTTP_1_1).getBytes(StandardCharsets.UTF_8));
                batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);
                writeHttpHeader(batchRequestHeaderOutputStream, HttpHeader.ODATA_VERSION, ODataServiceVersion.V40.toString());
                final ContentType acceptType = getResourceContentType(uriInfo);
                final String acceptCharset = acceptType.getParameter(ContentType.PARAMETER_CHARSET);
                writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.ACCEPT, contentType.getType().toLowerCase() + ""/"" + contentType.getSubtype().toLowerCase());
                if (null != acceptCharset) {
                    writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.ACCEPT_CHARSET, acceptCharset.toLowerCase());
                }
                writeHttpHeader(batchRequestHeaderOutputStream, HttpHeaders.CONTENT_TYPE, acceptType.toContentTypeString());
                if (batchChangePart.getOperation() != Operation.DELETE) {
                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);
                    AbstractHttpEntity httpEnity = writeContent(edm, uriInfo, batchChangePart.getBody());
                    batchRequestHeaderOutputStream.write(IOUtils.toByteArray(httpEnity.getContent()));
                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);
                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);
                } else {
                    batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);
                }
                batchRequestHeaderOutputStream.write(boundary.getBytes(StandardCharsets.UTF_8));
                batchRequestHeaderOutputStream.write(ODataStreamer.CRLF);
            } else {
                throw new ODataException(""Unsupported batch part request object type: "" + batchPart);
            }
        }
    } catch (Exception e) {
        throw new ODataException(""Error during batch request serialization"", e);
    }
    return new ByteArrayInputStream(batchRequestHeaderOutputStream.toByteArray());
}",java:S3776,39
"private List<Olingo4BatchResponse> parseBatchResponse(final Edm edm, HttpResponse response, List<Olingo4BatchRequest> batchRequest) throws ODataException{
    List<Olingo4BatchResponse> batchResponse = new <Olingo4BatchResponse> ArrayList();
    try {
        final Header[] contentHeaders = response.getHeaders(HttpHeader.CONTENT_TYPE);
        final ODataBatchLineIterator batchLineIterator = new ODataBatchLineIteratorImpl(IOUtils.lineIterator(response.getEntity().getContent(), StandardCharsets.UTF_8));
        final String batchBoundary = ODataBatchUtilities.getBoundaryFromHeader(getHeadersCollection(contentHeaders));
        final ODataBatchController batchController = new ODataBatchController(batchLineIterator, batchBoundary);
        batchController.getBatchLineIterator().next();
        int batchRequestIndex = 0;
        while (batchController.getBatchLineIterator().hasNext()) {
            OutputStream os = new ByteArrayOutputStream();
            ODataBatchUtilities.readBatchPart(batchController, os, false);
            Object content = null;
            final Olingo4BatchRequest batchPartRequest = batchRequest.get(batchRequestIndex);
            final HttpResponse batchPartHttpResponse = constructBatchPartHttpResponse(new ByteArrayInputStream(((ByteArrayOutputStream) os).toByteArray()));
            final StatusLine batchPartStatusLine = batchPartHttpResponse.getStatusLine();
            final int batchPartLineStatusCode = batchPartStatusLine.getStatusCode();
            Map<String, String> batchPartHeaders = getHeadersValueMap(batchPartHttpResponse.getAllHeaders());
            if (batchPartRequest instanceof Olingo4BatchQueryRequest) {
                Olingo4BatchQueryRequest batchPartQueryRequest = (Olingo4BatchQueryRequest) batchPartRequest;
                final UriInfo uriInfo = parseUri(edm, batchPartQueryRequest.getResourcePath(), null, serviceUri);
                if (HttpStatusCode.BAD_REQUEST.getStatusCode() <= batchPartLineStatusCode && batchPartLineStatusCode <= AbstractFutureCallback.NETWORK_CONNECT_TIMEOUT_ERROR) {
                    final ContentType responseContentType = getContentTypeHeader(batchPartHttpResponse);
                    content = odataReader.readError(batchPartHttpResponse.getEntity().getContent(), responseContentType);
                } else if (batchPartLineStatusCode == HttpStatusCode.NO_CONTENT.getStatusCode()) {
                } else {
                    content = readContent(uriInfo, batchPartHttpResponse.getEntity().getContent());
                }
                Olingo4BatchResponse batchPartResponse = new Olingo4BatchResponse(batchPartStatusLine.getStatusCode(), batchPartStatusLine.getReasonPhrase(), null, batchPartHeaders, content);
                batchResponse.add(batchPartResponse);
            } else if (batchPartRequest instanceof Olingo4BatchChangeRequest) {
                Olingo4BatchChangeRequest batchPartChangeRequest = (Olingo4BatchChangeRequest) batchPartRequest;
                if (batchPartLineStatusCode != HttpStatusCode.NO_CONTENT.getStatusCode()) {
                    if (HttpStatusCode.BAD_REQUEST.getStatusCode() <= batchPartLineStatusCode && batchPartLineStatusCode <= AbstractFutureCallback.NETWORK_CONNECT_TIMEOUT_ERROR) {
                        final ContentType responseContentType = ContentType.parse(batchPartHttpResponse.getFirstHeader(HttpHeaders.CONTENT_TYPE).getValue());
                        content = odataReader.readError(response.getEntity().getContent(), responseContentType);
                    } else {
                        final UriInfo uriInfo = parseUri(edm, batchPartChangeRequest.getResourcePath() + (batchPartChangeRequest.getOperation() == Operation.CREATE ? CLIENT_ENTITY_FAKE_MARKER : """"), null, serviceUri);
                        content = readContent(uriInfo, batchPartHttpResponse.getEntity().getContent());
                    }
                }
                Olingo4BatchResponse batchPartResponse = new Olingo4BatchResponse(batchPartStatusLine.getStatusCode(), batchPartStatusLine.getReasonPhrase(), batchPartChangeRequest.getContentId(), batchPartHeaders, content);
                batchResponse.add(batchPartResponse);
            } else {
                throw new ODataException(""Unsupported batch part request object type: "" + batchPartRequest);
            }
            batchRequestIndex++;
        }
    } catch (IOException | HttpException e) {
        throw new ODataException(e);
    }
    return batchResponse;
}",java:S3776,39
"public void execute(HttpUriRequest httpUriRequest, ContentType contentType, final Map<String, String> endpointHttpHeaders, FutureCallback<HttpResponse> callback){
    if (!ContentType.APPLICATION_FORM_URLENCODED.equals(contentType) && !contentType.toContentTypeString().startsWith(MULTIPART_MIME_TYPE)) {
        httpUriRequest.addHeader(HttpHeaders.ACCEPT, contentType.getType().toLowerCase() + ""/"" + contentType.getSubtype().toLowerCase());
        final String acceptCharset = contentType.getParameter(ContentType.PARAMETER_CHARSET);
        if (null != acceptCharset) {
            httpUriRequest.addHeader(HttpHeaders.ACCEPT_CHARSET, acceptCharset.toLowerCase());
        }
    }
    if (httpUriRequest instanceof HttpEntityEnclosingRequestBase && httpUriRequest.getFirstHeader(HttpHeaders.CONTENT_TYPE) == null) {
        httpUriRequest.addHeader(HttpHeaders.CONTENT_TYPE, contentType.toString());
    }
    if (ObjectHelper.isNotEmpty(httpHeaders)) {
        for (Map.Entry<String, String> entry : httpHeaders.entrySet()) {
            httpUriRequest.setHeader(entry.getKey(), entry.getValue());
        }
    }
    if (ObjectHelper.isNotEmpty(endpointHttpHeaders)) {
        for (Map.Entry<String, String> entry : endpointHttpHeaders.entrySet()) {
            httpUriRequest.setHeader(entry.getKey(), entry.getValue());
        }
    }
    if (!httpUriRequest.containsHeader(HttpHeaders.ACCEPT_CHARSET)) {
        httpUriRequest.addHeader(HttpHeaders.ACCEPT_CHARSET, Constants.UTF8.toLowerCase());
    }
    if (!httpUriRequest.containsHeader(HttpHeader.ODATA_VERSION)) {
        httpUriRequest.addHeader(HttpHeader.ODATA_VERSION, ODataServiceVersion.V40.toString());
    }
    if (!httpUriRequest.containsHeader(HttpHeader.ODATA_MAX_VERSION)) {
        httpUriRequest.addHeader(HttpHeader.ODATA_MAX_VERSION, ODataServiceVersion.V40.toString());
    }
    if (client instanceof CloseableHttpAsyncClient) {
        ((CloseableHttpAsyncClient) client).execute(httpUriRequest, callback);
    } else {
        try {
            CloseableHttpResponse result = ((CloseableHttpClient) client).execute(httpUriRequest);
            callback.completed(result);
        } catch (IOException e) {
            callback.failed(e);
        }
    }
}",java:S3776,39
"public Edm getEdm(Map<String, String> endpointHttpHeaders) throws RuntimeCamelException{
    Edm localEdm = edm;
    if (localEdm == null) {
        synchronized (this) {
            localEdm = edm;
            if (localEdm == null) {
                final CountDownLatch latch = new CountDownLatch(1);
                final Exception[] error = new Exception[1];
                olingo4App.read(null, Constants.METADATA, null, endpointHttpHeaders, new Olingo4ResponseHandler<Edm>() {

                    @Override
                    public void onResponse(Edm response, Map<String, String> responseHeaders) {
                        edm = response;
                        latch.countDown();
                    }

                    @Override
                    public void onException(Exception ex) {
                        error[0] = ex;
                        latch.countDown();
                    }

                    @Override
                    public void onCanceled() {
                        error[0] = new RuntimeCamelException(""OData HTTP request cancelled!"");
                        latch.countDown();
                    }
                });
                try {
                    latch.await();
                    final Exception ex = error[0];
                    if (ex != null) {
                        if (ex instanceof RuntimeCamelException) {
                            throw (RuntimeCamelException) ex;
                        } else {
                            final String message = ex.getMessage() != null ? ex.getMessage() : ex.getClass().getName();
                            throw new RuntimeCamelException(""Error reading EDM: "" + message, ex);
                        }
                    }
                } catch (InterruptedException e) {
                    throw new RuntimeCamelException(e.getMessage(), e);
                }
                localEdm = edm;
            }
        }
    }
    return localEdm;
}",java:S3776,39
"private SecuritySchemeDefinition convertSecurityScheme(SecurityScheme securityScheme){
    SecuritySchemeDefinition swaggerScheme = null;
    switch(securityScheme.getType()) {
        case HTTP:
            if (""basic"".equals(securityScheme.getName())) {
                swaggerScheme = new BasicAuthDefinition();
            } else {
                throw new IllegalStateException(""OpenAPI 2.0 does not support bearer token security schemes."");
            }
            break;
        case APIKEY:
            if (securityScheme.getIn() == SecurityScheme.In.COOKIE) {
                throw new IllegalStateException(""Invalid 'in' value for API Key security scheme"");
            } else {
                swaggerScheme = new ApiKeyAuthDefinition(securityScheme.getName(), In.forValue(securityScheme.getIn().name()));
            }
            break;
        case OAUTH2:
            OAuth2Definition oauth2 = new OAuth2Definition();
            OAuthFlows flows = securityScheme.getFlows();
            Scopes scopes = null;
            if (flows.getImplicit() != null) {
                oauth2.implicit(flows.getImplicit().getAuthorizationUrl());
                scopes = flows.getImplicit().getScopes();
            } else if (flows.getPassword() != null) {
                oauth2.password(flows.getPassword().getTokenUrl());
                scopes = flows.getPassword().getScopes();
            } else if (flows.getClientCredentials() != null) {
                oauth2.application(flows.getClientCredentials().getTokenUrl());
                scopes = flows.getClientCredentials().getScopes();
            } else if (flows.getAuthorizationCode() != null) {
                oauth2.accessCode(flows.getAuthorizationCode().getAuthorizationUrl(), flows.getAuthorizationCode().getTokenUrl());
                scopes = flows.getAuthorizationCode().getScopes();
            } else {
            }
            if (scopes != null) {
                for (Map.Entry<String, String> entry : scopes.entrySet()) {
                    oauth2.addScope(entry.getKey(), entry.getValue());
                }
            }
            swaggerScheme = oauth2;
            break;
        default:
            throw new IllegalStateException(""Security scheme "" + securityScheme.getType().toString() + ""is not supported in OpenAPI 2"");
    }
    if (swaggerScheme != null && securityScheme.getDescription() != null) {
        swaggerScheme.setDescription(securityScheme.getDescription());
    }
    return swaggerScheme;
}",java:S3776,39
"private void setServerInfo(Swagger openApi2, List<Server> servers){
    for (Server server : servers) {
        String serverUrl = server.getUrl();
        if (serverUrl != null && !serverUrl.isEmpty()) {
            try {
                URL url = new URL(serverUrl);
                openApi2.setHost(url.getHost() + "":"" + url.getPort());
                openApi2.setBasePath(url.getPath());
                Scheme scheme = Scheme.forValue(url.getProtocol());
                if (scheme != null) {
                    openApi2.addScheme(scheme);
                }
            } catch (MalformedURLException e) {
                log.warn(""Malformed URL in configuration: {}"", serverUrl);
                int basePathIndex = serverUrl.lastIndexOf('/');
                if (basePathIndex > 0) {
                    openApi2.setBasePath(serverUrl.substring(basePathIndex));
                } else {
                    basePathIndex = serverUrl.length() - 1;
                }
                int protIndex = serverUrl.indexOf(""://"");
                if (protIndex > 0) {
                    String protocol = serverUrl.substring(0, protIndex);
                    Scheme scheme = Scheme.forValue(protocol);
                    if (scheme != null) {
                        openApi2.addScheme(scheme);
                    }
                    openApi2.setHost(serverUrl.substring(protIndex + 3, basePathIndex));
                } else {
                    openApi2.setHost(serverUrl.substring(0, basePathIndex));
                }
            }
        }
    }
}",java:S3776,39
"private Response convertResponse(ApiResponse apiResponse){
    Response response = new Response().description(apiResponse.getDescription());
    Map<String, Object> examples = new java.util.HashMap<>();
    if (apiResponse.getContent() != null) {
        for (MediaType contentType : apiResponse.getContent().values()) {
            if (contentType.getSchema() != null) {
                response.setResponseSchema(convertSchema(contentType.getSchema()));
                if (contentType.getExamples() != null) {
                    for (Map.Entry<String, Example> ex : contentType.getExamples().entrySet()) {
                        examples.put(ex.getKey(), ex.getValue().getValue());
                    }
                }
                break;
            }
        }
    }
    if (!examples.isEmpty()) {
        response.setExamples(examples);
    }
    if (apiResponse.getHeaders() != null) {
        for (Map.Entry<String, Header> hdr : apiResponse.getHeaders().entrySet()) {
            Property headerProp = convertHeaderToProperty(hdr.getValue());
            if (headerProp != null) {
                response.addHeader(hdr.getKey(), headerProp);
            }
        }
    }
    return response;
}",java:S3776,39
"private Model convertSchema(Schema schema){
    Model model = null;
    if (schema instanceof FileSchema) {
        return new ModelImpl().type(""file"");
    }
    if (schema.get$ref() != null) {
        return new RefModel(convertRef(schema.get$ref()));
    } else if (schema.getItems() != null) {
        model = new ArrayModel().items(convertSchemaToProperty(schema.getItems()));
    } else {
        model = new ModelImpl().type(schema.getType()).format(schema.getFormat());
    }
    if (schema.getProperties() != null) {
        model.setProperties(convertPropertiesMap(schema.getProperties()));
    }
    if (schema.getRequired() != null && model instanceof ModelImpl) {
        for (Object req : schema.getRequired()) {
            ((ModelImpl) model).addRequired(req.toString());
        }
    }
    if (schema.getDescription() != null && !schema.getDescription().isEmpty()) {
        model.setDescription(schema.getDescription());
    }
    if (schema.getExtensions() != null) {
        ((ModelImpl) model).setVendorExtensions(schema.getExtensions());
    }
    return model;
}",java:S3740,38
"private Map<String, Property> convertPropertiesMap(Map properties){
    Map<String, Property> swaggerProps = new java.util.HashMap<>(properties.size());
    for (Map.Entry<String, Schema> propEntry : ((Map<String, Schema>) properties).entrySet()) {
        swaggerProps.put(propEntry.getKey(), convertSchemaToProperty(propEntry.getValue()));
    }
    return swaggerProps;
}",java:S3740,38
"private Property convertSchemaToProperty(Schema schema){
    if (schema.get$ref() != null) {
        return new RefProperty(convertRef(schema.get$ref()));
    }
    if (schema instanceof IntegerSchema) {
        IntegerProperty prop = new IntegerProperty();
        prop.setFormat(schema.getFormat());
        return prop;
    } else if (schema instanceof NumberSchema) {
        if (""float"".equals(schema.getFormat())) {
            return new io.swagger.models.properties.FloatProperty();
        } else if (""double"".equals(schema.getFormat())) {
            return new io.swagger.models.properties.DoubleProperty();
        } else if (""int64"".equals(schema.getFormat())) {
            return new io.swagger.models.properties.LongProperty();
        } else {
            return new io.swagger.models.properties.BaseIntegerProperty(schema.getFormat());
        }
    } else if (schema instanceof ByteArraySchema) {
        return new io.swagger.models.properties.ByteArrayProperty();
    } else if (schema instanceof BinarySchema) {
        return new io.swagger.models.properties.BinaryProperty();
    } else if (schema instanceof DateSchema) {
        return new io.swagger.models.properties.DateProperty();
    } else if (schema instanceof DateTimeSchema) {
        return new io.swagger.models.properties.DateTimeProperty();
    } else if (schema instanceof PasswordSchema) {
        return new io.swagger.models.properties.PasswordProperty();
    } else if (schema instanceof FileSchema) {
        return new io.swagger.models.properties.FileProperty();
    } else if (schema instanceof StringSchema) {
        StringProperty prop = new StringProperty(schema.getFormat());
        if (schema.getEnum() != null) {
            prop.setEnum(schema.getEnum());
        }
        return prop;
    } else if (schema instanceof ArraySchema) {
        return new io.swagger.models.properties.ArrayProperty(convertSchemaToProperty(schema.getItems()));
    } else if (schema instanceof MapSchema) {
        if (schema.getAdditionalProperties() != null && schema.getAdditionalProperties() instanceof Schema) {
            return new io.swagger.models.properties.MapProperty(convertSchemaToProperty((Schema) schema.getAdditionalProperties()));
        }
        if (schema.getAdditionalItems() != null) {
            return new io.swagger.models.properties.MapProperty(convertSchemaToProperty(schema.getAdditionalItems()));
        } else {
            return new io.swagger.models.properties.MapProperty();
        }
    } else {
        return PropertyBuilder.build(schema.getType(), schema.getFormat(), null);
    }
}",java:S3776,39
"private Property convertSchemaToProperty(Schema schema){
    if (schema.get$ref() != null) {
        return new RefProperty(convertRef(schema.get$ref()));
    }
    if (schema instanceof IntegerSchema) {
        IntegerProperty prop = new IntegerProperty();
        prop.setFormat(schema.getFormat());
        return prop;
    } else if (schema instanceof NumberSchema) {
        if (""float"".equals(schema.getFormat())) {
            return new io.swagger.models.properties.FloatProperty();
        } else if (""double"".equals(schema.getFormat())) {
            return new io.swagger.models.properties.DoubleProperty();
        } else if (""int64"".equals(schema.getFormat())) {
            return new io.swagger.models.properties.LongProperty();
        } else {
            return new io.swagger.models.properties.BaseIntegerProperty(schema.getFormat());
        }
    } else if (schema instanceof ByteArraySchema) {
        return new io.swagger.models.properties.ByteArrayProperty();
    } else if (schema instanceof BinarySchema) {
        return new io.swagger.models.properties.BinaryProperty();
    } else if (schema instanceof DateSchema) {
        return new io.swagger.models.properties.DateProperty();
    } else if (schema instanceof DateTimeSchema) {
        return new io.swagger.models.properties.DateTimeProperty();
    } else if (schema instanceof PasswordSchema) {
        return new io.swagger.models.properties.PasswordProperty();
    } else if (schema instanceof FileSchema) {
        return new io.swagger.models.properties.FileProperty();
    } else if (schema instanceof StringSchema) {
        StringProperty prop = new StringProperty(schema.getFormat());
        if (schema.getEnum() != null) {
            prop.setEnum(schema.getEnum());
        }
        return prop;
    } else if (schema instanceof ArraySchema) {
        return new io.swagger.models.properties.ArrayProperty(convertSchemaToProperty(schema.getItems()));
    } else if (schema instanceof MapSchema) {
        if (schema.getAdditionalProperties() != null && schema.getAdditionalProperties() instanceof Schema) {
            return new io.swagger.models.properties.MapProperty(convertSchemaToProperty((Schema) schema.getAdditionalProperties()));
        }
        if (schema.getAdditionalItems() != null) {
            return new io.swagger.models.properties.MapProperty(convertSchemaToProperty(schema.getAdditionalItems()));
        } else {
            return new io.swagger.models.properties.MapProperty();
        }
    } else {
        return PropertyBuilder.build(schema.getType(), schema.getFormat(), null);
    }
}",java:S3740,38
"public static void clearVendorExtensions(OpenAPI openApi){
    if (openApi.getExtensions() != null) {
        openApi.getExtensions().clear();
    }
    if (openApi.getComponents() != null && openApi.getComponents().getSchemas() != null) {
        for (Schema<?> schemaDefinition : openApi.getComponents().getSchemas().values()) {
            schemaDefinition.getExtensions().clear();
        }
    }
    if (openApi.getPaths() != null) {
        for (PathItem path : openApi.getPaths().values()) {
            if (path.getExtensions() != null) {
                path.getExtensions().clear();
            }
            for (Operation op : path.readOperationsMap().values()) {
                if (op.getExtensions() != null) {
                    op.getExtensions().clear();
                }
            }
        }
    }
}",java:S3776,39
" OpenAPI loadOpenApiModel(String apiDoc) throws Exception{
    final OpenAPIParser openApiParser = new OpenAPIParser();
    final SwaggerParseResult openApi = openApiParser.readLocation(apiDoc, null, null);
    if (openApi != null && openApi.getOpenAPI() != null) {
        return openApi.getOpenAPI();
    }
    throw new IllegalArgumentException(""The given OpenApi specification could not be loaded from `"" + apiDoc + ""`."");
}",java:S112,4
"private Producer createHttpProducer(CamelContext camelContext, OpenAPI openApi, Operation operation, String host, String verb, String path, String queryParameters, String consumes, String produces, String componentName, Map<String, Object> parameters) throws Exception{
    LOG.debug(""Using OpenApi operation: {} with {} {}"", operation, verb, path);
    RestProducerFactory factory = (RestProducerFactory) parameters.remove(""restProducerFactory"");
    if (factory != null) {
        LOG.debug(""Using RestProducerFactory: {}"", factory);
        if (produces == null) {
            StringJoiner producesBuilder = new StringJoiner("","");
            List<String> list = new ArrayList<>();
            if (operation.getResponses() != null) {
                for (ApiResponse response : operation.getResponses().values()) {
                    if (response.getContent() != null) {
                        for (String mediaType : response.getContent().keySet()) {
                            producesBuilder.add(mediaType);
                        }
                    }
                }
            }
            produces = producesBuilder.length() == 0 ? null : producesBuilder.toString();
        }
        if (consumes == null) {
            StringJoiner consumesBuilder = new StringJoiner("","");
            if (operation.getRequestBody() != null && operation.getRequestBody().getContent() != null) {
                for (String mediaType : operation.getRequestBody().getContent().keySet()) {
                    consumesBuilder.add(mediaType);
                }
            }
            consumes = consumesBuilder.length() == 0 ? null : consumesBuilder.toString();
        }
        String basePath;
        String uriTemplate;
        if (host == null) {
            host = RestOpenApiSupport.getHostFromOasDocument(openApi);
            basePath = RestOpenApiSupport.getBasePathFromOasDocument(openApi);
            uriTemplate = path;
        } else {
            basePath = path;
            uriTemplate = null;
        }
        RestConfiguration config = CamelContextHelper.getRestConfiguration(camelContext, null, componentName);
        return factory.createProducer(camelContext, host, verb, basePath, uriTemplate, queryParameters, consumes, produces, config, parameters);
    } else {
        throw new IllegalStateException(""Cannot find RestProducerFactory in Registry or as a Component to use"");
    }
}",java:S3776,39
"private Producer createHttpProducer(CamelContext camelContext, OpenAPI openApi, Operation operation, String host, String verb, String path, String queryParameters, String consumes, String produces, String componentName, Map<String, Object> parameters) throws Exception{
    LOG.debug(""Using OpenApi operation: {} with {} {}"", operation, verb, path);
    RestProducerFactory factory = (RestProducerFactory) parameters.remove(""restProducerFactory"");
    if (factory != null) {
        LOG.debug(""Using RestProducerFactory: {}"", factory);
        if (produces == null) {
            StringJoiner producesBuilder = new StringJoiner("","");
            List<String> list = new ArrayList<>();
            if (operation.getResponses() != null) {
                for (ApiResponse response : operation.getResponses().values()) {
                    if (response.getContent() != null) {
                        for (String mediaType : response.getContent().keySet()) {
                            producesBuilder.add(mediaType);
                        }
                    }
                }
            }
            produces = producesBuilder.length() == 0 ? null : producesBuilder.toString();
        }
        if (consumes == null) {
            StringJoiner consumesBuilder = new StringJoiner("","");
            if (operation.getRequestBody() != null && operation.getRequestBody().getContent() != null) {
                for (String mediaType : operation.getRequestBody().getContent().keySet()) {
                    consumesBuilder.add(mediaType);
                }
            }
            consumes = consumesBuilder.length() == 0 ? null : consumesBuilder.toString();
        }
        String basePath;
        String uriTemplate;
        if (host == null) {
            host = RestOpenApiSupport.getHostFromOasDocument(openApi);
            basePath = RestOpenApiSupport.getBasePathFromOasDocument(openApi);
            uriTemplate = path;
        } else {
            basePath = path;
            uriTemplate = null;
        }
        RestConfiguration config = CamelContextHelper.getRestConfiguration(camelContext, null, componentName);
        return factory.createProducer(camelContext, host, verb, basePath, uriTemplate, queryParameters, consumes, produces, config, parameters);
    } else {
        throw new IllegalStateException(""Cannot find RestProducerFactory in Registry or as a Component to use"");
    }
}",java:S107,1
"public List<? extends Schema<?>> readClass(OpenAPI oasDocument, Class<?> clazz){
    if (clazz.equals(java.io.File.class)) {
        return null;
    } else {
        return readClassOpenApi3(clazz);
    }
}",java:S1452,23
"public List<? extends Schema<?>> readClass(OpenAPI oasDocument, Class<?> clazz){
    if (clazz.equals(java.io.File.class)) {
        return null;
    } else {
        return readClassOpenApi3(clazz);
    }
}",java:S1452,23
"public List<? extends Schema<?>> readClass(OpenAPI oasDocument, Class<?> clazz){
    if (clazz.equals(java.io.File.class)) {
        return null;
    } else {
        return readClassOpenApi3(clazz);
    }
}",java:S1172,13
"private void parse(CamelContext camelContext, OpenAPI openApi, RestDefinition rest, String camelContextId, ClassResolver classResolver, BeanConfig config) throws ClassNotFoundException{
    List<VerbDefinition> filter = new ArrayList<>();
    for (VerbDefinition verb : rest.getVerbs()) {
        Boolean disabled = CamelContextHelper.parseBoolean(camelContext, verb.getDisabled());
        if (disabled == null || !disabled) {
            filter.add(verb);
        }
    }
    List<VerbDefinition> verbs = new ArrayList<>(filter);
    verbs.sort(new VerbOrdering(camelContext));
    String[] pathAsTags = null != rest.getTag() ? getValue(camelContext, rest.getTag()).split("","") : null != rest.getPath() ? new String[] { getValue(camelContext, rest.getPath()) } : new String[0];
    parseOas30(openApi, rest, pathAsTags);
    Set<String> types = new LinkedHashSet<>();
    for (VerbDefinition verb : verbs) {
        String apiDocs;
        if (verb.getApiDocs() != null) {
            apiDocs = verb.getApiDocs();
        } else {
            apiDocs = rest.getApiDocs();
        }
        if (apiDocs != null && !Boolean.parseBoolean(apiDocs)) {
            continue;
        }
        String type = verb.getType();
        if (org.apache.camel.util.ObjectHelper.isNotEmpty(type)) {
            if (type.endsWith(""[]"")) {
                type = type.substring(0, type.length() - 2);
            }
            types.add(type);
        }
        type = verb.getOutType();
        if (org.apache.camel.util.ObjectHelper.isNotEmpty(type)) {
            if (type.endsWith(""[]"")) {
                type = type.substring(0, type.length() - 2);
            }
            types.add(type);
        }
        if (verb.getResponseMsgs() != null) {
            for (ResponseMessageDefinition def : verb.getResponseMsgs()) {
                type = def.getResponseModel();
                if (org.apache.camel.util.ObjectHelper.isNotEmpty(type)) {
                    if (type.endsWith(""[]"")) {
                        type = type.substring(0, type.length() - 2);
                    }
                    types.add(type);
                }
            }
        }
    }
    for (String type : types) {
        Class<?> clazz = classResolver.resolveMandatoryClass(type);
        appendModels(clazz, openApi);
    }
    doParseVerbs(camelContext, openApi, rest, camelContextId, verbs, pathAsTags, config);
    List<SecurityDefinition> securityRequirements = rest.getSecurityRequirements();
    securityRequirements.forEach(requirement -> {
        SecurityRequirement oasRequirement = new SecurityRequirement();
        List<String> scopes;
        if (requirement.getScopes() == null || requirement.getScopes().trim().isEmpty()) {
            scopes = Collections.emptyList();
        } else {
            scopes = Arrays.asList(requirement.getScopes().trim().split(""\\s*,\\s*""));
        }
        oasRequirement.addList(requirement.getKey(), scopes);
        openApi.addSecurityItem(oasRequirement);
    });
}",java:S3776,39
"private void parseOas30(OpenAPI openApi, RestDefinition rest, String[] pathAsTags){
    String summary = rest.getDescriptionText();
    for (String tag : pathAsTags) {
        openApi.addTagsItem(new Tag().name(tag).description(summary));
    }
    RestSecuritiesDefinition sd = rest.getSecurityDefinitions();
    if (sd != null && !sd.getSecurityDefinitions().isEmpty() && openApi.getComponents() == null) {
        openApi.setComponents(new Components());
    }
    if (sd != null) {
        for (RestSecurityDefinition def : sd.getSecurityDefinitions()) {
            if (def instanceof BasicAuthDefinition) {
                SecurityScheme auth = new SecurityScheme().type(SecurityScheme.Type.HTTP).name(""basic"").description(def.getDescription());
                openApi.getComponents().addSecuritySchemes(def.getKey(), auth);
            } else if (def instanceof BearerTokenDefinition) {
                SecurityScheme auth = new SecurityScheme().type(SecurityScheme.Type.HTTP).name(""bearer"").description(def.getDescription()).bearerFormat(((BearerTokenDefinition) def).getFormat());
                openApi.getComponents().addSecuritySchemes(def.getKey(), auth);
            } else if (def instanceof ApiKeyDefinition) {
                ApiKeyDefinition rs = (ApiKeyDefinition) def;
                SecurityScheme auth = new SecurityScheme().type(SecurityScheme.Type.APIKEY).name(rs.getName()).description(def.getDescription());
                if (rs.getInHeader() != null && Boolean.parseBoolean(rs.getInHeader())) {
                    auth.setIn(SecurityScheme.In.HEADER);
                } else if (rs.getInQuery() != null && Boolean.parseBoolean(rs.getInQuery())) {
                    auth.setIn(SecurityScheme.In.QUERY);
                } else if (rs.getInCookie() != null && Boolean.parseBoolean(rs.getInCookie())) {
                    auth.setIn(SecurityScheme.In.COOKIE);
                } else {
                    throw new IllegalStateException(""No API Key location specified."");
                }
                openApi.getComponents().addSecuritySchemes(def.getKey(), auth);
            } else if (def instanceof OAuth2Definition) {
                OAuth2Definition rs = (OAuth2Definition) def;
                SecurityScheme auth = new SecurityScheme().type(SecurityScheme.Type.OAUTH2).description(def.getDescription());
                String flow = rs.getFlow();
                if (flow == null) {
                    flow = inferOauthFlow(rs);
                }
                OAuthFlows oauthFlows = new OAuthFlows();
                auth.setFlows(oauthFlows);
                OAuthFlow oauthFlow = new OAuthFlow();
                switch(flow) {
                    case ""authorizationCode"":
                    case ""accessCode"":
                        oauthFlows.setAuthorizationCode(oauthFlow);
                        break;
                    case ""implicit"":
                        oauthFlows.setImplicit(oauthFlow);
                        break;
                    case ""clientCredentials"":
                    case ""application"":
                        oauthFlows.setClientCredentials(oauthFlow);
                        break;
                    case ""password"":
                        oauthFlows.setPassword(oauthFlow);
                        break;
                    default:
                        throw new IllegalStateException(""Invalid OAuth flow '"" + flow + ""' specified"");
                }
                oauthFlow.setAuthorizationUrl(rs.getAuthorizationUrl());
                oauthFlow.setTokenUrl(rs.getTokenUrl());
                oauthFlow.setRefreshUrl(rs.getRefreshUrl());
                if (!rs.getScopes().isEmpty()) {
                    oauthFlow.setScopes(new Scopes());
                    for (RestPropertyDefinition scope : rs.getScopes()) {
                        oauthFlow.getScopes().addString(scope.getKey(), scope.getValue());
                    }
                }
                openApi.getComponents().addSecuritySchemes(def.getKey(), auth);
            } else if (def instanceof MutualTLSDefinition) {
                SecurityScheme auth = new SecurityScheme().type(SecurityScheme.Type.MUTUALTLS).description(def.getDescription());
                openApi.getComponents().addSecuritySchemes(def.getKey(), auth);
            } else if (def instanceof OpenIdConnectDefinition) {
                SecurityScheme auth = new SecurityScheme().type(SecurityScheme.Type.OPENIDCONNECT).description(def.getDescription());
                auth.setOpenIdConnectUrl(((OpenIdConnectDefinition) def).getUrl());
                openApi.getComponents().addSecuritySchemes(def.getKey(), auth);
            }
        }
    }
}",java:S3776,39
"private void doParseVerbs(CamelContext camelContext, OpenAPI openApi, RestDefinition rest, String camelContextId, List<VerbDefinition> verbs, String[] pathAsTags, BeanConfig config){
    String basePath = buildBasePath(camelContext, rest);
    for (VerbDefinition verb : verbs) {
        String apiDocs;
        if (verb.getApiDocs() != null) {
            apiDocs = getValue(camelContext, verb.getApiDocs());
        } else {
            apiDocs = getValue(camelContext, rest.getApiDocs());
        }
        if (apiDocs != null && !Boolean.parseBoolean(apiDocs)) {
            continue;
        }
        String method = verb.asVerb().toLowerCase(Locale.US);
        String opPath = OpenApiHelper.buildUrl(basePath, getValue(camelContext, verb.getPath()));
        if (openApi.getPaths() == null) {
            openApi.paths(new Paths());
        }
        PathItem path = openApi.getPaths().get(opPath);
        if (path == null) {
            path = new PathItem();
        }
        Operation op = new Operation();
        for (String tag : pathAsTags) {
            op.addTagsItem(tag);
        }
        final String operationId;
        if (verb.getId() != null) {
            operationId = getValue(camelContext, verb.getId());
        } else if (rest.getId() != null) {
            operationId = getValue(camelContext, rest.getId());
        } else {
            verb.idOrCreate(camelContext.getCamelContextExtension().getContextPlugin(NodeIdFactory.class));
            operationId = verb.getId();
        }
        op.setOperationId(operationId);
        op.addExtension(""x-camelContextId"", camelContextId);
        path.operation(PathItem.HttpMethod.valueOf(method.toUpperCase()), op);
        String consumes = getValue(camelContext, verb.getConsumes() != null ? verb.getConsumes() : rest.getConsumes());
        if (consumes == null) {
            consumes = config.defaultConsumes;
        }
        String produces = getValue(camelContext, verb.getProduces() != null ? verb.getProduces() : rest.getProduces());
        if (produces == null) {
            produces = config.defaultProduces;
        }
        doParseVerb(camelContext, openApi, verb, op, consumes, produces);
        doParseResponseMessages(camelContext, openApi, verb, op, produces);
        openApi.getPaths().addPathItem(opPath, path);
    }
}",java:S3776,39
"private void doParseVerb(CamelContext camelContext, OpenAPI openApi, VerbDefinition verb, Operation op, String consumes, String produces){
    if (verb.getDescriptionText() != null) {
        op.setSummary(getValue(camelContext, verb.getDescriptionText()));
    }
    if (""true"".equals(verb.getDeprecated())) {
        op.setDeprecated(Boolean.TRUE);
    }
    for (SecurityDefinition sd : verb.getSecurity()) {
        List<String> scopes = new ArrayList<>();
        if (sd.getScopes() != null) {
            for (String scope : ObjectHelper.createIterable(getValue(camelContext, sd.getScopes()))) {
                scopes.add(scope);
            }
        }
        SecurityRequirement securityRequirement = new SecurityRequirement();
        securityRequirement.addList(getValue(camelContext, sd.getKey()), scopes);
        op.addSecurityItem(securityRequirement);
    }
    for (ParamDefinition param : verb.getParams()) {
        Parameter parameter = new Parameter().in(param.getType().name());
        if (parameter != null) {
            parameter.setName(getValue(camelContext, param.getName()));
            if (org.apache.camel.util.ObjectHelper.isNotEmpty(param.getDescription())) {
                parameter.setDescription(getValue(camelContext, param.getDescription()));
            }
            parameter.setRequired(param.getRequired());
            if (!""body"".equals(parameter.getIn())) {
                Schema schema = new Schema<>();
                final boolean isArray = getValue(camelContext, param.getDataType()).equalsIgnoreCase(""array"");
                final List<String> allowableValues = getValue(camelContext, param.getAllowableValuesAsStringList());
                final boolean hasAllowableValues = allowableValues != null && !allowableValues.isEmpty();
                if (param.getDataType() != null) {
                    parameter.setSchema(schema);
                    schema.setType(getValue(camelContext, param.getDataType()));
                    if (param.getDataFormat() != null) {
                        schema.setFormat(getValue(camelContext, param.getDataFormat()));
                    }
                    if (isArray) {
                        String arrayType = getValue(camelContext, param.getArrayType());
                        if (arrayType != null) {
                            if (arrayType.equalsIgnoreCase(""string"")) {
                                defineSchemas(parameter, allowableValues, String.class);
                            }
                            if (arrayType.equalsIgnoreCase(""int"") || arrayType.equalsIgnoreCase(""integer"")) {
                                defineSchemas(parameter, allowableValues, Integer.class);
                            }
                            if (arrayType.equalsIgnoreCase(""long"")) {
                                defineSchemas(parameter, allowableValues, Long.class);
                            }
                            if (arrayType.equalsIgnoreCase(""float"")) {
                                defineSchemas(parameter, allowableValues, Float.class);
                            }
                            if (arrayType.equalsIgnoreCase(""double"")) {
                                defineSchemas(parameter, allowableValues, Double.class);
                            }
                            if (arrayType.equalsIgnoreCase(""boolean"")) {
                                defineSchemas(parameter, allowableValues, Boolean.class);
                            }
                            if (arrayType.equalsIgnoreCase(""byte"")) {
                                defineSchemas(parameter, allowableValues, ByteArraySchema.class);
                            }
                            if (arrayType.equalsIgnoreCase(""binary"")) {
                                defineSchemas(parameter, allowableValues, BinarySchema.class);
                            }
                            if (arrayType.equalsIgnoreCase(""date"")) {
                                defineSchemas(parameter, allowableValues, DateSchema.class);
                            }
                            if (arrayType.equalsIgnoreCase(""date-time"")) {
                                defineSchemas(parameter, allowableValues, DateTimeSchema.class);
                            }
                            if (arrayType.equalsIgnoreCase(""password"")) {
                                defineSchemas(parameter, allowableValues, PasswordSchema.class);
                            }
                        }
                    }
                }
                if (param.getCollectionFormat() != null) {
                    parameter.setStyle(convertToOpenApiStyle(getValue(camelContext, param.getCollectionFormat().name())));
                }
                if (hasAllowableValues && !isArray) {
                    schema.setEnum(allowableValues);
                }
                if (org.apache.camel.util.ObjectHelper.isNotEmpty(param.getDefaultValue())) {
                    schema.setDefault(getValue(camelContext, param.getDefaultValue()));
                }
                if (param.getExamples() != null && !param.getExamples().isEmpty()) {
                    for (RestPropertyDefinition example : param.getExamples()) {
                        if (example.getKey().isEmpty()) {
                            if (parameter.getExample() != null) {
                                LOG.warn(""The parameter already has an example with no key!"");
                            }
                            parameter.setExample(example.getValue());
                        } else {
                            parameter.addExample(example.getKey(), new Example().value(example.getValue()));
                        }
                    }
                }
                op.addParametersItem(parameter);
            }
            if (parameter.getIn().equals(""body"")) {
                RequestBody reqBody = new RequestBody().content(new Content());
                reqBody.setRequired(param.getRequired());
                reqBody.setDescription(getValue(camelContext, param.getDescription()));
                op.setRequestBody(reqBody);
                String type = getValue(camelContext, param.getDataType() != null ? param.getDataType() : verb.getType());
                Schema<?> bodySchema = null;
                if (type != null) {
                    if (type.endsWith(""[]"")) {
                        type = type.substring(0, type.length() - 2);
                        bodySchema = modelTypeAsProperty(type, openApi);
                    } else {
                        String ref = modelTypeAsRef(type, openApi);
                        if (ref != null) {
                            bodySchema = new Schema().$ref(OAS30_SCHEMA_DEFINITION_PREFIX + ref);
                        } else {
                            bodySchema = modelTypeAsProperty(type, openApi);
                        }
                    }
                }
                if (consumes != null) {
                    String[] parts = consumes.split("","");
                    for (String part : parts) {
                        MediaType mediaType = new MediaType().schema(bodySchema);
                        if (param.getExamples() != null) {
                            for (RestPropertyDefinition example : param.getExamples()) {
                                if (part.equals(example.getKey())) {
                                    mediaType.setExample(example.getValue());
                                }
                            }
                        }
                        reqBody.getContent().addMediaType(part, mediaType);
                    }
                }
            }
        }
    }
    if (op.getParameters() != null && op.getParameters().isEmpty()) {
        op.setParameters(null);
    }
    if (verb.getOutType() != null) {
        if (op.getResponses() == null) {
            op.setResponses(new ApiResponses());
        }
        String[] parts;
        if (produces != null) {
            parts = produces.split("","");
            for (String produce : parts) {
                ApiResponse response = new ApiResponse().description(""Output type"");
                Content responseContent = new Content();
                MediaType contentType = new MediaType();
                responseContent.addMediaType(produce, contentType);
                Schema<?> model = modelTypeAsProperty(getValue(camelContext, verb.getOutType()), openApi);
                contentType.setSchema(model);
                response.setContent(responseContent);
                op.getResponses().addApiResponse(""200"", response);
            }
        }
    }
}",java:S3776,39
"private static void defineSchemas(final Parameter serializableParameter, final List<String> allowableValues, final Class<?> type){
    Schema parameterSchema = serializableParameter.getSchema();
    if (allowableValues != null && !allowableValues.isEmpty()) {
        if (String.class.equals(type)) {
            parameterSchema.setEnum(allowableValues);
        } else {
            convertAndSetItemsEnum(parameterSchema, allowableValues, type);
        }
    } else if (Objects.equals(parameterSchema.getType(), ""array"")) {
        Schema<?> itemsSchema;
        if (Integer.class.equals(type)) {
            itemsSchema = new IntegerSchema();
        } else if (Long.class.equals(type)) {
            itemsSchema = new IntegerSchema().format(""int64"");
        } else if (Float.class.equals(type)) {
            itemsSchema = new NumberSchema().format(""float"");
        } else if (Double.class.equals(type)) {
            itemsSchema = new NumberSchema().format(""double"");
        } else if (ByteArraySchema.class.equals(type)) {
            itemsSchema = new ByteArraySchema();
        } else if (BinarySchema.class.equals(type)) {
            itemsSchema = new BinarySchema();
        } else if (Date.class.equals(type)) {
            itemsSchema = new DateSchema();
        } else if (DateTimeSchema.class.equals(type)) {
            itemsSchema = new DateTimeSchema();
        } else if (PasswordSchema.class.equals(type)) {
            itemsSchema = new PasswordSchema();
        } else {
            itemsSchema = new StringSchema();
        }
        parameterSchema.setItems(itemsSchema);
    }
}",java:S3776,39
"private void doParseResponse(CamelContext camelContext, OpenAPI openApi, Operation op, String produces, ResponseMessageDefinition msg){
    ApiResponse response = null;
    String code = getValue(camelContext, msg.getCode());
    response = op.getResponses().get(code);
    if (response == null) {
        response = new ApiResponse();
        op.getResponses().addApiResponse(code, response);
    }
    if (org.apache.camel.util.ObjectHelper.isNotEmpty(msg.getResponseModel())) {
        String[] parts;
        if (produces != null) {
            Content respContent = new Content();
            parts = produces.split("","");
            for (String produce : parts) {
                Schema model = modelTypeAsProperty(getValue(camelContext, msg.getResponseModel()), openApi);
                respContent.addMediaType(produce, new MediaType().schema(model));
            }
            response.setContent(respContent);
        }
    }
    if (org.apache.camel.util.ObjectHelper.isNotEmpty(msg.getMessage())) {
        response.setDescription(getValue(camelContext, msg.getMessage()));
    }
    if (msg.getHeaders() != null) {
        for (ResponseHeaderDefinition header : msg.getHeaders()) {
            String name = getValue(camelContext, header.getName());
            String type = getValue(camelContext, header.getDataType());
            String format = getValue(camelContext, header.getDataFormat());
            if (""string"".equals(type) || ""long"".equals(type) || ""float"".equals(type) || ""double"".equals(type) || ""boolean"".equals(type)) {
                setResponseHeader(camelContext, response, header, name, format, type);
            } else if (""int"".equals(type) || ""integer"".equals(type)) {
                setResponseHeader(camelContext, response, header, name, format, ""integer"");
            } else if (""array"".equals(type)) {
                Header ap = new Header();
                response.addHeaderObject(name, ap);
                if (org.apache.camel.util.ObjectHelper.isNotEmpty(header.getDescription())) {
                    ap.setDescription(getValue(camelContext, header.getDescription()));
                }
                if (header.getArrayType() != null) {
                    String arrayType = getValue(camelContext, header.getArrayType());
                    if (arrayType.equalsIgnoreCase(""string"") || arrayType.equalsIgnoreCase(""long"") || arrayType.equalsIgnoreCase(""float"") || arrayType.equalsIgnoreCase(""double"") || arrayType.equalsIgnoreCase(""boolean"")) {
                        setHeaderSchemaOas30(ap, arrayType);
                    } else if (arrayType.equalsIgnoreCase(""int"") || arrayType.equalsIgnoreCase(""integer"")) {
                        setHeaderSchemaOas30(ap, ""integer"");
                    }
                }
                if (header.getExample() != null) {
                    ap.addExample("""", new Example().value(getValue(camelContext, header.getExample())));
                }
            }
        }
    }
    if (msg.getExamples() != null) {
        if (response.getContent() != null) {
            for (MediaType mediaType : response.getContent().values()) {
                for (RestPropertyDefinition prop : msg.getExamples()) {
                    mediaType.addExamples(getValue(camelContext, prop.getKey()), new Example().value(getValue(camelContext, prop.getValue())));
                }
            }
        }
    }
}",java:S3776,39
"private Object getClassNameExtension(Schema model){
    Object className = null;
    if (model.getExtensions() != null) {
        Object value = model.getExtensions().get(""x-className"");
        if (value instanceof Map) {
            className = ((Map) value).get(""format"");
        }
    }
    return className;
}",java:S3740,38
"private Schema<?> modelTypeAsProperty(String typeName, OpenAPI openApi){
    Schema<?> prop = null;
    boolean array = typeName.endsWith(""[]"");
    if (array) {
        typeName = typeName.substring(0, typeName.length() - 2);
    }
    String ref = modelTypeAsRef(typeName, openApi);
    if (ref == null) {
        if (array && (""byte"".equals(typeName) || ""java.lang.Byte"".equals(typeName))) {
            prop = new Schema<byte[]>().type(""number"").format(""byte"");
            array = false;
        } else if (""string"".equalsIgnoreCase(typeName) || ""java.lang.String"".equals(typeName)) {
            prop = new StringSchema();
        } else if (""int"".equals(typeName) || ""java.lang.Integer"".equals(typeName)) {
            prop = new IntegerSchema();
        } else if (""long"".equals(typeName) || ""java.lang.Long"".equals(typeName)) {
            prop = new IntegerSchema().format(""int64"");
        } else if (""float"".equals(typeName) || ""java.lang.Float"".equals(typeName)) {
            prop = new NumberSchema().format(""float"");
        } else if (""double"".equals(typeName) || ""java.lang.Double"".equals(typeName)) {
            prop = new NumberSchema().format(""double"");
        } else if (""boolean"".equals(typeName) || ""java.lang.Boolean"".equals(typeName)) {
            prop = new NumberSchema().format(""boolean"");
        } else if (""file"".equals(typeName) || ""java.io.File"".equals(typeName)) {
            prop = new FileSchema();
        } else {
            prop = new StringSchema();
        }
    }
    if (array) {
        Schema<?> items = new Schema<>();
        if (ref != null) {
            items.set$ref(OAS30_SCHEMA_DEFINITION_PREFIX + ref);
        }
        prop = new ArraySchema().items(items);
    } else if (prop == null) {
        prop = new Schema<>().$ref(OAS30_SCHEMA_DEFINITION_PREFIX + ref);
    }
    return prop;
}",java:S3776,39
"private Schema<?> modelTypeAsProperty(String typeName, OpenAPI openApi){
    Schema<?> prop = null;
    boolean array = typeName.endsWith(""[]"");
    if (array) {
        typeName = typeName.substring(0, typeName.length() - 2);
    }
    String ref = modelTypeAsRef(typeName, openApi);
    if (ref == null) {
        if (array && (""byte"".equals(typeName) || ""java.lang.Byte"".equals(typeName))) {
            prop = new Schema<byte[]>().type(""number"").format(""byte"");
            array = false;
        } else if (""string"".equalsIgnoreCase(typeName) || ""java.lang.String"".equals(typeName)) {
            prop = new StringSchema();
        } else if (""int"".equals(typeName) || ""java.lang.Integer"".equals(typeName)) {
            prop = new IntegerSchema();
        } else if (""long"".equals(typeName) || ""java.lang.Long"".equals(typeName)) {
            prop = new IntegerSchema().format(""int64"");
        } else if (""float"".equals(typeName) || ""java.lang.Float"".equals(typeName)) {
            prop = new NumberSchema().format(""float"");
        } else if (""double"".equals(typeName) || ""java.lang.Double"".equals(typeName)) {
            prop = new NumberSchema().format(""double"");
        } else if (""boolean"".equals(typeName) || ""java.lang.Boolean"".equals(typeName)) {
            prop = new NumberSchema().format(""boolean"");
        } else if (""file"".equals(typeName) || ""java.io.File"".equals(typeName)) {
            prop = new FileSchema();
        } else {
            prop = new StringSchema();
        }
    }
    if (array) {
        Schema<?> items = new Schema<>();
        if (ref != null) {
            items.set$ref(OAS30_SCHEMA_DEFINITION_PREFIX + ref);
        }
        prop = new ArraySchema().items(items);
    } else if (prop == null) {
        prop = new Schema<>().$ref(OAS30_SCHEMA_DEFINITION_PREFIX + ref);
    }
    return prop;
}",java:S3740,38
"private void appendModels(Class<?> clazz, OpenAPI openApi){
    RestModelConverters converters = new RestModelConverters();
    List<? extends Schema<?>> models = converters.readClass(openApi, clazz);
    if (models == null) {
        return;
    }
    if (openApi.getComponents() == null) {
        openApi.setComponents(new Components());
    }
    for (Schema<?> newSchema : models) {
        boolean addSchema = true;
        if (openApi.getComponents().getSchemas() != null) {
            Schema<?> existing = openApi.getComponents().getSchemas().get(newSchema.getName());
            if (existing != null) {
                Object oldClassName = getClassNameExtension(existing);
                Object newClassName = getClassNameExtension(newSchema);
                if (oldClassName != null) {
                    addSchema = false;
                    LOG.info(""Duplicate schema found for with name {}; classname1={}, classname2={}"", newSchema.getName(), oldClassName, newClassName != null ? newClassName : ""none"");
                }
            }
        }
        if (addSchema) {
            openApi.getComponents().addSchemas(newSchema.getName(), newSchema);
        }
    }
}",java:S3776,39
"private void setInfo(BeanConfig openApiConfig, String version, String title, String description, String termsOfService, String licenseName, String licenseUrl, String contactName, String contactUrl, String contactEmail){
    Info info = new Info().version(version).title(title).description(description).termsOfService(termsOfService);
    if (licenseName != null || licenseUrl != null) {
        License license = new License().name(licenseName).url(licenseUrl);
        info.setLicense(license);
    }
    if (contactName != null || contactUrl != null || contactEmail != null) {
        Contact contact = new Contact().name(contactName).url(contactUrl).email(contactEmail);
        info.setContact(contact);
    }
    openApiConfig.setInfo(info);
}",java:S107,1
"public void renderResourceListing(CamelContext camelContext, RestApiResponseAdapter response, BeanConfig openApiConfig, boolean json, Map<String, Object> headers, ClassResolver classResolver, RestConfiguration configuration) throws Exception{
    LOG.trace(""renderResourceListing"");
    ObjectMapper mapper = new ObjectMapper();
    mapper.enable(SerializationFeature.INDENT_OUTPUT);
    mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
    if (cors) {
        setupCorsHeaders(response, configuration.getCorsHeaders());
    }
    List<RestDefinition> rests = getRestDefinitions(camelContext);
    if (rests != null) {
        final Map<String, Object> apiProperties = configuration.getApiProperties() != null ? configuration.getApiProperties() : new HashMap<>();
        if (json) {
            response.setHeader(Exchange.CONTENT_TYPE, (String) apiProperties.getOrDefault(""api.specification.contentType.json"", ""application/json""));
            OpenAPI openApi = reader.read(camelContext, rests, openApiConfig, camelContext.getName(), classResolver);
            if (configuration.isUseXForwardHeaders()) {
                setupXForwardedHeaders(openApi, headers);
            }
            if (!configuration.isApiVendorExtension()) {
                clearVendorExtensions(openApi);
            }
            byte[] bytes = null;
            if (!openApiConfig.isOpenApi3()) {
                OpenAPI3to2 converter = new OpenAPI3to2();
                converter.convertOpenAPI3to2(openApi);
                bytes = converter.getSwaggerAsJson();
            } else {
                String result = io.swagger.v3.core.util.Json31.pretty(openApi);
                bytes = result.getBytes(StandardCharsets.UTF_8);
            }
            int len = bytes.length;
            response.setHeader(Exchange.CONTENT_LENGTH, Integer.toString(len));
            response.writeBytes(bytes);
        } else {
            response.setHeader(Exchange.CONTENT_TYPE, (String) apiProperties.getOrDefault(""api.specification.contentType.yaml"", ""text/yaml""));
            OpenAPI openApi = reader.read(camelContext, rests, openApiConfig, camelContext.getName(), classResolver);
            if (configuration.isUseXForwardHeaders()) {
                setupXForwardedHeaders(openApi, headers);
            }
            if (!configuration.isApiVendorExtension()) {
                clearVendorExtensions(openApi);
            }
            byte[] bytes = null;
            if (!openApiConfig.isOpenApi3()) {
                OpenAPI3to2 converter = new OpenAPI3to2();
                converter.convertOpenAPI3to2(openApi);
                bytes = converter.getSwaggerAsYaml();
            } else {
                String result = io.swagger.v3.core.util.Yaml.pretty(openApi);
                bytes = result.getBytes();
            }
            int len = bytes.length;
            response.setHeader(Exchange.CONTENT_LENGTH, Integer.toString(len));
            response.writeBytes(bytes);
        }
    } else {
        response.noContent();
    }
}",java:S3776,39
"protected OSClient createClient(){
    if (V2.equals(getApiVersion())) {
        return createV2Client();
    }
    return createV3Client();
}",java:S3740,38
"protected Payload createPayload(Message msg){
    Payload payload = msg.getBody(Payload.class);
    if (ObjectHelper.isNotEmpty(payload)) {
        return payload;
    }
    Object messageBody = msg.getBody();
    if (messageBody instanceof URL) {
        payload = Payloads.create((URL) messageBody);
    }
    if (messageBody instanceof File) {
        payload = Payloads.create((File) messageBody);
    }
    if (messageBody instanceof InputStream) {
        payload = Payloads.create((InputStream) messageBody);
    }
    if (payload == null) {
        throw new IllegalArgumentException(""You have to set payload. It can be InputStream, File or URL class"");
    }
    return payload;
}",java:S3740,38
"public SolverManager getSolverManager(){
    return solverManager;
}",java:S3740,38
"public void setSolverManager(SolverManager solverManager){
    this.solverManager = solverManager;
}",java:S3740,38
"public final PGConnection initJdbc() throws Exception{
    PGConnection conn;
    if (this.getDatasource() != null) {
        conn = PgEventHelper.toPGConnection(this.getDatasource().getConnection());
    } else {
        ClassResolver classResolver = getCamelContext().getClassResolver();
        classResolver.resolveMandatoryClass(PGDriver.class.getName(), PgEventComponent.class.getClassLoader());
        conn = (PGConnection) DriverManager.getConnection(""jdbc:pgsql://"" + this.getHost() + "":"" + this.getPort() + ""/"" + this.getDatabase(), this.getUser(), this.getPass());
    }
    return conn;
}",java:S112,4
"protected void setupStartupSummary() throws Exception{
    camelContext.addStartupListener(new StartupListener() {

        private volatile Set<HttpEndpointModel> last;

        @Override
        public void onCamelContextStarted(CamelContext context, boolean alreadyStarted) throws Exception {
            camelContext.getManagementStrategy().addEventNotifier(new SimpleEventNotifierSupport() {

                @Override
                public boolean isEnabled(CamelEvent event) {
                    return event instanceof CamelEvent.CamelContextStartedEvent || event instanceof CamelEvent.RouteReloadedEvent;
                }

                @Override
                public void notify(CamelEvent event) throws Exception {
                    if (event instanceof CamelEvent.RouteReloadedEvent) {
                        CamelEvent.RouteReloadedEvent re = (CamelEvent.RouteReloadedEvent) event;
                        if (re.getIndex() < re.getTotal()) {
                            return;
                        }
                    }
                    Set<HttpEndpointModel> endpoints = platformHttpComponent.getHttpEndpoints();
                    if (endpoints.isEmpty()) {
                        return;
                    }
                    if (last == null || last.size() != endpoints.size() || !last.containsAll(endpoints)) {
                        LOG.info(""HTTP endpoints summary"");
                        for (HttpEndpointModel u : endpoints) {
                            String line = ""http://0.0.0.0:"" + (server != null ? server.getPort() : getPort()) + u.getUri();
                            if (u.getVerbs() != null) {
                                line += "" ("" + u.getVerbs() + "")"";
                            }
                            LOG.info(""    {}"", line);
                        }
                    }
                    last = new HashSet<>(endpoints);
                }
            });
        }
    });
}",java:S3776,39
"protected void setupStartupSummary() throws Exception{
    camelContext.addStartupListener(new StartupListener() {

        private volatile Set<HttpEndpointModel> last;

        @Override
        public void onCamelContextStarted(CamelContext context, boolean alreadyStarted) throws Exception {
            camelContext.getManagementStrategy().addEventNotifier(new SimpleEventNotifierSupport() {

                @Override
                public boolean isEnabled(CamelEvent event) {
                    return event instanceof CamelEvent.CamelContextStartedEvent || event instanceof CamelEvent.RouteReloadedEvent;
                }

                @Override
                public void notify(CamelEvent event) throws Exception {
                    if (event instanceof CamelEvent.RouteReloadedEvent) {
                        CamelEvent.RouteReloadedEvent re = (CamelEvent.RouteReloadedEvent) event;
                        if (re.getIndex() < re.getTotal()) {
                            return;
                        }
                    }
                    Set<HttpEndpointModel> endpoints = platformHttpComponent.getHttpEndpoints();
                    if (endpoints.isEmpty()) {
                        return;
                    }
                    if (last == null || last.size() != endpoints.size() || !last.containsAll(endpoints)) {
                        LOG.info(""HTTP endpoints summary"");
                        for (HttpEndpointModel u : endpoints) {
                            String line = ""http://0.0.0.0:"" + (server != null ? server.getPort() : getPort()) + u.getUri();
                            if (u.getVerbs() != null) {
                                line += "" ("" + u.getVerbs() + "")"";
                            }
                            LOG.info(""    {}"", line);
                        }
                    }
                    last = new HashSet<>(endpoints);
                }
            });
        }
    });
}",java:S112,4
"protected void setupDevConsole(){
    Route dev = router.route(""/q/dev"");
    dev.method(HttpMethod.GET);
    dev.produces(""text/plain"");
    dev.produces(""application/json"");
    Route devSub = router.route(""/q/dev/*"");
    devSub.method(HttpMethod.GET);
    devSub.produces(""text/plain"");
    devSub.produces(""application/json"");
    Handler<RoutingContext> handler = new Handler<RoutingContext>() {

        @Override
        public void handle(RoutingContext ctx) {
            String acp = ctx.request().getHeader(""Accept"");
            int pos1 = acp != null ? acp.indexOf(""html"") : Integer.MAX_VALUE;
            if (pos1 == -1) {
                pos1 = Integer.MAX_VALUE;
            }
            int pos2 = acp != null ? acp.indexOf(""json"") : Integer.MAX_VALUE;
            if (pos2 == -1) {
                pos2 = Integer.MAX_VALUE;
            }
            final boolean html = pos1 < pos2;
            final boolean json = pos2 < pos1;
            final DevConsole.MediaType mediaType = json ? DevConsole.MediaType.JSON : DevConsole.MediaType.TEXT;
            ctx.response().putHeader(""content-type"", ""text/plain"");
            if (!camelContext.isDevConsole()) {
                ctx.end(""Developer Console is not enabled on CamelContext. Set camel.context.dev-console=true in application.properties"");
            }
            DevConsoleRegistry dcr = camelContext.getCamelContextExtension().getContextPlugin(DevConsoleRegistry.class);
            if (dcr == null || !dcr.isEnabled()) {
                ctx.end(""Developer Console is not enabled"");
                return;
            }
            String path = StringHelper.after(ctx.request().path(), ""/q/dev/"");
            String s = path;
            if (s != null && s.contains(""/"")) {
                s = StringHelper.before(s, ""/"");
            }
            String id = s;
            if (id == null || id.isEmpty() || id.equals(""index"")) {
                StringBuilder sb = new StringBuilder();
                JsonObject root = new JsonObject();
                dcr.stream().forEach(c -> {
                    if (json) {
                        JsonObject jo = new JsonObject();
                        jo.put(""id"", c.getId());
                        jo.put(""displayName"", c.getDisplayName());
                        jo.put(""description"", c.getDescription());
                        root.put(c.getId(), jo);
                    } else {
                        String link = c.getId();
                        String eol = ""\n"";
                        if (html) {
                            link = ""<a href=\""dev/"" + link + ""\"">"" + c.getId() + ""</a>"";
                            eol = ""<br/>\n"";
                        }
                        sb.append(link).append("": "").append(c.getDescription()).append(eol);
                        if (""top"".equals(c.getId())) {
                            link = link.replace(""top"", ""top/*"");
                            sb.append(link).append("": "").append(""Display the top processors"").append(eol);
                        }
                    }
                });
                if (sb.length() > 0) {
                    String out = sb.toString();
                    if (html) {
                        ctx.response().putHeader(""content-type"", ""text/html"");
                    }
                    ctx.end(out);
                } else if (!root.isEmpty()) {
                    ctx.response().putHeader(""content-type"", ""application/json"");
                    String out = root.toJson();
                    ctx.end(out);
                } else {
                    ctx.end();
                }
            } else {
                Map<String, Object> params = new HashMap<>();
                ctx.queryParams().forEach(params::put);
                params.put(Exchange.HTTP_PATH, path);
                StringBuilder sb = new StringBuilder();
                JsonObject root = new JsonObject();
                dcr.stream().sorted((o1, o2) -> {
                    int p1 = id.indexOf(o1.getId());
                    int p2 = id.indexOf(o2.getId());
                    return Integer.compare(p1, p2);
                }).forEach(c -> {
                    boolean include = ""all"".equals(id) || c.getId().equalsIgnoreCase(id);
                    if (include && c.supportMediaType(mediaType)) {
                        Object out = c.call(mediaType, params);
                        if (out != null && mediaType == DevConsole.MediaType.TEXT) {
                            sb.append(c.getDisplayName()).append("":"");
                            sb.append(""\n\n"");
                            sb.append(out);
                            sb.append(""\n\n"");
                        } else if (out != null && mediaType == DevConsole.MediaType.JSON) {
                            root.put(c.getId(), out);
                        }
                    }
                });
                if (sb.length() > 0) {
                    String out = sb.toString();
                    ctx.end(out);
                } else if (!root.isEmpty()) {
                    ctx.response().putHeader(""content-type"", ""application/json"");
                    String out = root.toJson();
                    ctx.end(out);
                } else {
                    ctx.end(""Developer Console not found: "" + id);
                }
            }
        }
    };
    dev.handler(new BlockingHandlerDecorator(handler, true));
    devSub.handler(new BlockingHandlerDecorator(handler, true));
    platformHttpComponent.addHttpEndpoint(""/q/dev"", null, null);
}",java:S3776,39
"protected void setupUploadConsole(final String dir){
    final Route upload = router.route(""/q/upload/:filename"").method(HttpMethod.PUT).handler(BodyHandler.create(true));
    final Route uploadDelete = router.route(""/q/upload/:filename"");
    uploadDelete.method(HttpMethod.DELETE);
    Handler<RoutingContext> handler = new Handler<RoutingContext>() {

        @Override
        public void handle(RoutingContext ctx) {
            String name = ctx.pathParam(""filename"");
            if (name == null) {
                ctx.response().setStatusCode(400);
                ctx.end();
                return;
            }
            int status = 200;
            boolean delete = HttpMethod.DELETE == ctx.request().method();
            if (delete) {
                if (name.contains(""*"")) {
                    if (name.equals(""*"")) {
                        name = ""**"";
                    }
                    AntPathMatcher match = AntPathMatcher.INSTANCE;
                    File[] files = new File(dir).listFiles();
                    if (files != null) {
                        for (File f : files) {
                            if (f.getName().startsWith(""."") || f.isHidden()) {
                                continue;
                            }
                            if (match.match(name, f.getName())) {
                                LOG.info(""Deleting file: {}/{}"", dir, name);
                                FileUtil.deleteFile(f);
                            }
                        }
                    }
                } else {
                    File f = new File(dir, name);
                    if (f.exists() && f.isFile()) {
                        LOG.info(""Deleting file: {}/{}"", dir, name);
                        FileUtil.deleteFile(f);
                    }
                }
            } else {
                File f = new File(dir, name);
                boolean exists = f.isFile() && f.exists();
                LOG.info(""{} file: {}/{}"", exists ? ""Updating"" : ""Creating"", dir, name);
                File tmp = new File(dir, name + "".tmp"");
                FileOutputStream fos = null;
                try {
                    fos = new FileOutputStream(tmp, false);
                    RequestBody rb = ctx.body();
                    IOHelper.writeText(rb.asString(), fos);
                    FileUtil.renameFileUsingCopy(tmp, f);
                    FileUtil.deleteFile(tmp);
                } catch (Exception e) {
                    LOG.warn(""Error saving file: {}/{} due to: {}"", dir, name, e.getMessage(), e);
                    status = 500;
                } finally {
                    IOHelper.close(fos);
                    FileUtil.deleteFile(tmp);
                }
            }
            ctx.response().setStatusCode(status);
            ctx.end();
        }
    };
    upload.handler(new BlockingHandlerDecorator(handler, true));
    uploadDelete.handler(new BlockingHandlerDecorator(handler, true));
    platformHttpComponent.addHttpEndpoint(""/q/upload"", ""PUT,DELETE"", null);
}",java:S3776,39
"protected Message toCamelMessage(RoutingContext ctx, Exchange exchange){
    final Message result = exchange.getIn();
    final HeaderFilterStrategy headerFilterStrategy = getEndpoint().getHeaderFilterStrategy();
    populateCamelHeaders(ctx, result.getHeaders(), exchange, headerFilterStrategy);
    final String mimeType = ctx.parsedHeaders().contentType().value();
    final boolean isMultipartFormData = ""multipart/form-data"".equals(mimeType);
    if (""application/x-www-form-urlencoded"".equals(mimeType) || isMultipartFormData) {
        final MultiMap formData = ctx.request().formAttributes();
        final Map<String, Object> body = new HashMap<>();
        for (String key : formData.names()) {
            for (String value : formData.getAll(key)) {
                if (headerFilterStrategy != null && !headerFilterStrategy.applyFilterToExternalHeaders(key, value, exchange)) {
                    appendHeader(result.getHeaders(), key, value);
                    appendHeader(body, key, value);
                }
            }
        }
        if (!body.isEmpty()) {
            result.setBody(body);
        }
        if (isMultipartFormData) {
            populateAttachments(ctx.fileUploads(), result);
        }
    } else {
        final RequestBody requestBody = ctx.body();
        final Buffer body = requestBody.buffer();
        if (body != null) {
            result.setBody(body);
        } else {
            result.setBody(null);
        }
    }
    return result;
}",java:S3776,39
" static Handler<RoutingContext> createCorsHandler(VertxPlatformHttpServerConfiguration configuration){
    final VertxPlatformHttpServerConfiguration.Cors corsConfig = configuration.getCors();
    return (RoutingContext event) -> {
        final HttpServerRequest request = event.request();
        final HttpServerResponse response = event.response();
        final String origin = request.getHeader(HttpHeaders.ORIGIN);
        if (origin == null) {
            event.next();
        } else {
            final String requestedMethods = request.getHeader(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD);
            if (requestedMethods != null) {
                processHeaders(response, HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, requestedMethods, corsConfig.getMethods());
            }
            final String requestedHeaders = request.getHeader(HttpHeaders.ACCESS_CONTROL_REQUEST_HEADERS);
            if (requestedHeaders != null) {
                processHeaders(response, HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, requestedHeaders, corsConfig.getHeaders());
            }
            final boolean allowsOrigin = ObjectHelper.isEmpty(corsConfig.getOrigins()) || corsConfig.getOrigins().contains(origin);
            if (allowsOrigin) {
                response.headers().set(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, origin);
            }
            response.headers().set(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, ""true"");
            if (ObjectHelper.isNotEmpty(corsConfig.getExposedHeaders())) {
                response.headers().set(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, String.join("","", corsConfig.getExposedHeaders()));
            }
            if (request.method().equals(HttpMethod.OPTIONS)) {
                if ((requestedHeaders != null || requestedMethods != null) && corsConfig.getAccessControlMaxAge() != null) {
                    response.putHeader(HttpHeaders.ACCESS_CONTROL_MAX_AGE, String.valueOf(corsConfig.getAccessControlMaxAge().getSeconds()));
                }
                response.end();
            } else {
                event.next();
            }
        }
    };
}",java:S3776,39
" static Object toHttpResponse(HttpServerResponse response, Message message, HeaderFilterStrategy headerFilterStrategy, boolean muteExceptions){
    final Exchange exchange = message.getExchange();
    final TypeConverter tc = exchange.getContext().getTypeConverter();
    final int code = determineResponseCode(exchange, message.getBody());
    response.setStatusCode(code);
    if (headerFilterStrategy != null) {
        for (Map.Entry<String, Object> entry : message.getHeaders().entrySet()) {
            final String key = entry.getKey();
            final Object value = entry.getValue();
            final Iterator<?> it = ObjectHelper.createIterator(value, null, true);
            String firstValue = null;
            List<String> values = null;
            while (it.hasNext()) {
                final String headerValue = tc.convertTo(String.class, it.next());
                if (headerValue != null && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, exchange)) {
                    if (firstValue == null) {
                        firstValue = headerValue;
                    } else {
                        if (values == null) {
                            values = new ArrayList<>();
                            values.add(firstValue);
                        }
                        values.add(headerValue);
                    }
                }
            }
            if (values != null) {
                response.putHeader(key, values);
            } else if (firstValue != null) {
                response.putHeader(key, firstValue);
            }
        }
    }
    Object body = message.getBody();
    final Exception exception = exchange.getException();
    if (exception != null) {
        if (muteExceptions) {
            body = """";
            message.setHeader(Exchange.CONTENT_TYPE, ""text/plain; charset=utf-8"");
        } else {
            final StringWriter sw = new StringWriter();
            final PrintWriter pw = new PrintWriter(sw);
            exception.printStackTrace(pw);
            body = ByteBuffer.wrap(sw.toString().getBytes(StandardCharsets.UTF_8));
            message.setHeader(Exchange.CONTENT_TYPE, ""text/plain; charset=utf-8"");
        }
        ExchangeHelper.setFailureHandled(exchange);
    }
    final Integer length = determineContentLength(body);
    if (length != null) {
        response.putHeader(""Content-Length"", String.valueOf(length));
    } else {
        response.setChunked(true);
    }
    final String contentType = MessageHelper.getContentType(message);
    if (contentType != null) {
        response.putHeader(""Content-Type"", contentType);
    }
    return body;
}",java:S3776,39
" static void populateCamelHeaders(RoutingContext ctx, Map<String, Object> headersMap, Exchange exchange, HeaderFilterStrategy headerFilterStrategy){
    final HttpServerRequest request = ctx.request();
    headersMap.put(Exchange.HTTP_PATH, request.path());
    if (headerFilterStrategy != null) {
        final MultiMap requestHeaders = request.headers();
        final String authz = requestHeaders.get(""authorization"");
        if (authz != null && authz.trim().startsWith(""Basic"")) {
            if (!headerFilterStrategy.applyFilterToExternalHeaders(Exchange.AUTHENTICATION, ""Basic"", exchange)) {
                appendHeader(headersMap, Exchange.AUTHENTICATION, ""Basic"");
            }
        }
        for (String name : requestHeaders.names()) {
            for (String value : requestHeaders.getAll(name)) {
                if (!headerFilterStrategy.applyFilterToExternalHeaders(name.toString(), value, exchange)) {
                    appendHeader(headersMap, name.toString(), value);
                }
            }
        }
        final MultiMap pathParameters = ctx.queryParams();
        if (!pathParameters.isEmpty()) {
            for (String name : pathParameters.names()) {
                for (String value : pathParameters.getAll(name)) {
                    if (!headerFilterStrategy.applyFilterToExternalHeaders(name, value, exchange)) {
                        appendHeader(headersMap, name, value);
                    }
                }
            }
        }
    }
    for (Map.Entry<String, String> en : ctx.pathParams().entrySet()) {
        appendHeader(headersMap, en.getKey(), en.getValue());
    }
    headersMap.put(Exchange.HTTP_METHOD, request.method().toString());
    headersMap.put(Exchange.HTTP_URL, request.absoluteURI());
    headersMap.put(Exchange.HTTP_URI, request.uri());
    headersMap.put(Exchange.HTTP_QUERY, request.query());
    headersMap.put(Exchange.HTTP_RAW_QUERY, request.query());
}",java:S3776,39
"private Consumer doCreateConsumer(CamelContext camelContext, Processor processor, String verb, String basePath, String uriTemplate, String consumes, String produces, RestConfiguration configuration, Map<String, Object> parameters, boolean api) throws Exception{
    String path = basePath;
    if (uriTemplate != null) {
        if (uriTemplate.startsWith(""/"")) {
            path = path + uriTemplate;
        } else {
            path = path + ""/"" + uriTemplate;
        }
    }
    path = FileUtil.stripLeadingSeparator(path);
    RestConfiguration config = configuration;
    if (config == null) {
        config = CamelContextHelper.getRestConfiguration(getCamelContext(), PlatformHttpConstants.PLATFORM_HTTP_COMPONENT_NAME);
    }
    String contextPath = config.getContextPath();
    if (ObjectHelper.isNotEmpty(contextPath)) {
        contextPath = FileUtil.stripTrailingSeparator(contextPath);
        contextPath = FileUtil.stripLeadingSeparator(contextPath);
        if (ObjectHelper.isNotEmpty(contextPath)) {
            path = contextPath + ""/"" + path;
        }
    }
    Map<String, Object> map = RestComponentHelper.initRestEndpointProperties(PlatformHttpConstants.PLATFORM_HTTP_COMPONENT_NAME, config);
    boolean cors = config.isEnableCORS();
    if (api) {
        map.put(""matchOnUriPrefix"", ""true"");
    }
    RestComponentHelper.addHttpRestrictParam(map, verb, cors);
    String url = RestComponentHelper.createRestConsumerUrl(""platform-http"", path, map);
    PlatformHttpEndpoint endpoint = (PlatformHttpEndpoint) camelContext.getEndpoint(url, parameters);
    endpoint.setConsumes(consumes);
    endpoint.setProduces(produces);
    Consumer consumer = endpoint.createConsumer(processor);
    if (config.getConsumerProperties() != null && !config.getConsumerProperties().isEmpty()) {
        setProperties(camelContext, consumer, config.getConsumerProperties());
    }
    return consumer;
}",java:S107,1
"public MediaSizeName selectMediaSizeNameISO(String size){
    if (size.equalsIgnoreCase(""iso_a0"")) {
        mediaSizeName = MediaSizeName.ISO_A0;
    } else if (size.equalsIgnoreCase(""iso_a1"")) {
        mediaSizeName = MediaSizeName.ISO_A1;
    } else if (size.equalsIgnoreCase(""iso_a2"")) {
        mediaSizeName = MediaSizeName.ISO_A2;
    } else if (size.equalsIgnoreCase(""iso_a3"")) {
        mediaSizeName = MediaSizeName.ISO_A3;
    } else if (size.equalsIgnoreCase(""iso_a4"")) {
        mediaSizeName = MediaSizeName.ISO_A4;
    } else if (size.equalsIgnoreCase(""iso_a5"")) {
        mediaSizeName = MediaSizeName.ISO_A5;
    } else if (size.equalsIgnoreCase(""iso_a6"")) {
        mediaSizeName = MediaSizeName.ISO_A6;
    } else if (size.equalsIgnoreCase(""iso_a7"")) {
        mediaSizeName = MediaSizeName.ISO_A7;
    } else if (size.equalsIgnoreCase(""iso_a8"")) {
        mediaSizeName = MediaSizeName.ISO_A8;
    } else if (size.equalsIgnoreCase(""iso_a9"")) {
        mediaSizeName = MediaSizeName.ISO_A9;
    } else if (size.equalsIgnoreCase(""iso_a10"")) {
        mediaSizeName = MediaSizeName.ISO_A10;
    } else if (size.equalsIgnoreCase(""iso_b0"")) {
        mediaSizeName = MediaSizeName.ISO_B0;
    } else if (size.equalsIgnoreCase(""iso_b1"")) {
        mediaSizeName = MediaSizeName.ISO_B1;
    } else if (size.equalsIgnoreCase(""iso_b2"")) {
        mediaSizeName = MediaSizeName.ISO_B2;
    } else if (size.equalsIgnoreCase(""iso_b3"")) {
        mediaSizeName = MediaSizeName.ISO_B3;
    } else if (size.equalsIgnoreCase(""iso_b4"")) {
        mediaSizeName = MediaSizeName.ISO_B4;
    } else if (size.equalsIgnoreCase(""iso_b5"")) {
        mediaSizeName = MediaSizeName.ISO_B5;
    } else if (size.equalsIgnoreCase(""iso_b6"")) {
        mediaSizeName = MediaSizeName.ISO_B6;
    } else if (size.equalsIgnoreCase(""iso_b7"")) {
        mediaSizeName = MediaSizeName.ISO_B7;
    } else if (size.equalsIgnoreCase(""iso_b8"")) {
        mediaSizeName = MediaSizeName.ISO_B8;
    } else if (size.equalsIgnoreCase(""iso_b9"")) {
        mediaSizeName = MediaSizeName.ISO_B9;
    } else if (size.equalsIgnoreCase(""iso_b10"")) {
        mediaSizeName = MediaSizeName.ISO_B10;
    } else if (size.equalsIgnoreCase(""iso_c0"")) {
        mediaSizeName = MediaSizeName.ISO_C0;
    } else if (size.equalsIgnoreCase(""iso_c1"")) {
        mediaSizeName = MediaSizeName.ISO_C1;
    } else if (size.equalsIgnoreCase(""iso_c2"")) {
        mediaSizeName = MediaSizeName.ISO_C2;
    } else if (size.equalsIgnoreCase(""iso_c3"")) {
        mediaSizeName = MediaSizeName.ISO_C3;
    } else if (size.equalsIgnoreCase(""iso_c4"")) {
        mediaSizeName = MediaSizeName.ISO_C4;
    } else if (size.equalsIgnoreCase(""iso_c5"")) {
        mediaSizeName = MediaSizeName.ISO_C5;
    } else if (size.equalsIgnoreCase(""iso_c6"")) {
        mediaSizeName = MediaSizeName.ISO_C6;
    }
    return mediaSizeName;
}",java:S3776,39
"public MediaSizeName selectMediaSizeNameNA(String size){
    if (size.equalsIgnoreCase(""na_letter"")) {
        mediaSizeName = MediaSizeName.NA_LETTER;
    } else if (size.equalsIgnoreCase(""na_legal"")) {
        mediaSizeName = MediaSizeName.NA_LEGAL;
    } else if (size.equalsIgnoreCase(""executive"")) {
        mediaSizeName = MediaSizeName.EXECUTIVE;
    } else if (size.equalsIgnoreCase(""ledger"")) {
        mediaSizeName = MediaSizeName.LEDGER;
    } else if (size.equalsIgnoreCase(""tabloid"")) {
        mediaSizeName = MediaSizeName.TABLOID;
    } else if (size.equalsIgnoreCase(""invoice"")) {
        mediaSizeName = MediaSizeName.INVOICE;
    } else if (size.equalsIgnoreCase(""folio"")) {
        mediaSizeName = MediaSizeName.FOLIO;
    } else if (size.equalsIgnoreCase(""quarto"")) {
        mediaSizeName = MediaSizeName.QUARTO;
    } else if (size.equalsIgnoreCase(""japanese_postcard"")) {
        mediaSizeName = MediaSizeName.JAPANESE_POSTCARD;
    } else if (size.equalsIgnoreCase(""oufuko_postcard"")) {
        mediaSizeName = MediaSizeName.JAPANESE_DOUBLE_POSTCARD;
    } else if (size.equalsIgnoreCase(""a"")) {
        mediaSizeName = MediaSizeName.A;
    } else if (size.equalsIgnoreCase(""b"")) {
        mediaSizeName = MediaSizeName.B;
    } else if (size.equalsIgnoreCase(""c"")) {
        mediaSizeName = MediaSizeName.C;
    } else if (size.equalsIgnoreCase(""d"")) {
        mediaSizeName = MediaSizeName.D;
    } else if (size.equalsIgnoreCase(""e"")) {
        mediaSizeName = MediaSizeName.E;
    } else if (size.equalsIgnoreCase(""iso_designated_long"")) {
        mediaSizeName = MediaSizeName.ISO_DESIGNATED_LONG;
    } else if (size.equalsIgnoreCase(""italian_envelope"")) {
        mediaSizeName = MediaSizeName.ITALY_ENVELOPE;
    } else if (size.equalsIgnoreCase(""monarch_envelope"")) {
        mediaSizeName = MediaSizeName.MONARCH_ENVELOPE;
    } else if (size.equalsIgnoreCase(""personal_envelope"")) {
        mediaSizeName = MediaSizeName.PERSONAL_ENVELOPE;
    } else if (size.equalsIgnoreCase(""na_number_9_envelope"")) {
        mediaSizeName = MediaSizeName.NA_NUMBER_9_ENVELOPE;
    } else if (size.equalsIgnoreCase(""na_number_10_envelope"")) {
        mediaSizeName = MediaSizeName.NA_NUMBER_10_ENVELOPE;
    } else if (size.equalsIgnoreCase(""na_number_11_envelope"")) {
        mediaSizeName = MediaSizeName.NA_NUMBER_11_ENVELOPE;
    } else if (size.equalsIgnoreCase(""na_number_12_envelope"")) {
        mediaSizeName = MediaSizeName.NA_NUMBER_12_ENVELOPE;
    } else if (size.equalsIgnoreCase(""na_number_14_envelope"")) {
        mediaSizeName = MediaSizeName.NA_NUMBER_14_ENVELOPE;
    } else if (size.equalsIgnoreCase(""na_6x9_envelope"")) {
        mediaSizeName = MediaSizeName.NA_6X9_ENVELOPE;
    } else if (size.equalsIgnoreCase(""na_7x9_envelope"")) {
        mediaSizeName = MediaSizeName.NA_7X9_ENVELOPE;
    } else if (size.equalsIgnoreCase(""na_9x11_envelope"")) {
        mediaSizeName = MediaSizeName.NA_9X11_ENVELOPE;
    } else if (size.equalsIgnoreCase(""na_9x12_envelope"")) {
        mediaSizeName = MediaSizeName.NA_9X12_ENVELOPE;
    } else if (size.equalsIgnoreCase(""na_10x13_envelope"")) {
        mediaSizeName = MediaSizeName.NA_10X13_ENVELOPE;
    } else if (size.equalsIgnoreCase(""na_10x14_envelope"")) {
        mediaSizeName = MediaSizeName.NA_10X14_ENVELOPE;
    } else if (size.equalsIgnoreCase(""na_10x15_envelope"")) {
        mediaSizeName = MediaSizeName.NA_10X15_ENVELOPE;
    } else if (size.equalsIgnoreCase(""na_5x7"")) {
        mediaSizeName = MediaSizeName.NA_5X7;
    } else if (size.equalsIgnoreCase(""na_8x10"")) {
        mediaSizeName = MediaSizeName.NA_8X10;
    } else {
        mediaSizeName = MediaSizeName.NA_LETTER;
    }
    return mediaSizeName;
}",java:S3776,39
"public MediaSizeName selectMediaSizeNameOther(String size){
    if (size.equalsIgnoreCase(""executive"")) {
        mediaSizeName = MediaSizeName.EXECUTIVE;
    } else if (size.equalsIgnoreCase(""ledger"")) {
        mediaSizeName = MediaSizeName.LEDGER;
    } else if (size.equalsIgnoreCase(""tabloid"")) {
        mediaSizeName = MediaSizeName.TABLOID;
    } else if (size.equalsIgnoreCase(""invoice"")) {
        mediaSizeName = MediaSizeName.INVOICE;
    } else if (size.equalsIgnoreCase(""folio"")) {
        mediaSizeName = MediaSizeName.FOLIO;
    } else if (size.equalsIgnoreCase(""quarto"")) {
        mediaSizeName = MediaSizeName.QUARTO;
    } else if (size.equalsIgnoreCase(""japanese_postcard"")) {
        mediaSizeName = MediaSizeName.JAPANESE_POSTCARD;
    } else if (size.equalsIgnoreCase(""oufuko_postcard"")) {
        mediaSizeName = MediaSizeName.JAPANESE_DOUBLE_POSTCARD;
    } else if (size.equalsIgnoreCase(""a"")) {
        mediaSizeName = MediaSizeName.A;
    } else if (size.equalsIgnoreCase(""b"")) {
        mediaSizeName = MediaSizeName.B;
    } else if (size.equalsIgnoreCase(""c"")) {
        mediaSizeName = MediaSizeName.C;
    } else if (size.equalsIgnoreCase(""d"")) {
        mediaSizeName = MediaSizeName.D;
    } else if (size.equalsIgnoreCase(""e"")) {
        mediaSizeName = MediaSizeName.E;
    } else if (size.equalsIgnoreCase(""iso_designated_long"")) {
        mediaSizeName = MediaSizeName.ISO_DESIGNATED_LONG;
    } else if (size.equalsIgnoreCase(""italian_envelope"")) {
        mediaSizeName = MediaSizeName.ITALY_ENVELOPE;
    } else if (size.equalsIgnoreCase(""monarch_envelope"")) {
        mediaSizeName = MediaSizeName.MONARCH_ENVELOPE;
    } else if (size.equalsIgnoreCase(""personal_envelope"")) {
        mediaSizeName = MediaSizeName.PERSONAL_ENVELOPE;
    }
    return mediaSizeName;
}",java:S3776,39
"public void parseURI(URI uri) throws Exception{
    String protocol = uri.getScheme();
    if (!protocol.equalsIgnoreCase(""lpr"")) {
        throw new IllegalArgumentException(""Unrecognized Print protocol: "" + protocol + "" for uri: "" + uri);
    }
    setUri(uri);
    setHostname(uri.getHost());
    setPort(uri.getPort());
    String path = uri.getPath();
    path = StringHelper.removeStartingCharacters(path, '/');
    path = StringHelper.removeStartingCharacters(path, '\\');
    setPrintername(path);
    Map<String, Object> printSettings = URISupport.parseParameters(uri);
    setFlavor((String) printSettings.get(""flavor""));
    setMimeType((String) printSettings.get(""mimeType""));
    setDocFlavor(assignDocFlavor(flavor, mimeType));
    setPrinterPrefix((String) printSettings.get(""printerPrefix""));
    if (printSettings.containsKey(""copies"")) {
        setCopies(Integer.valueOf((String) printSettings.get(""copies"")));
    }
    setMediaSize((String) printSettings.get(""mediaSize""));
    setSides((String) printSettings.get(""sides""));
    setOrientation((String) printSettings.get(""orientation""));
    setMediaSizeName(assignMediaSize(mediaSize));
    setInternalSides(assignSides(sides));
    setInternalOrientation(assignOrientation(orientation));
    if (printSettings.containsKey(""sendToPrinter"")) {
        if (!(Boolean.parseBoolean((String) printSettings.get(""sendToPrinter"")))) {
            setSendToPrinter(false);
        }
    }
    if (printSettings.containsKey(""mediaTray"")) {
        setMediaTray((String) printSettings.get(""mediaTray""));
    }
}",java:S112,4
"private DocFlavor assignDocFlavor(String flavor, String mimeType){
    if (mimeType == null) {
        mimeType = ""AUTOSENSE"";
    }
    if (flavor == null) {
        flavor = ""DocFlavor.BYTE_ARRAY"";
    }
    DocFlavor d = DocFlavor.BYTE_ARRAY.AUTOSENSE;
    DocFlavorAssigner docFlavorAssigner = new DocFlavorAssigner();
    if (mimeType.equalsIgnoreCase(""AUTOSENSE"")) {
        d = docFlavorAssigner.forMimeTypeAUTOSENSE(flavor);
    } else if (mimeType.equalsIgnoreCase(""GIF"")) {
        d = docFlavorAssigner.forMimeTypeGIF(flavor);
    } else if (mimeType.equalsIgnoreCase(""JPEG"")) {
        d = docFlavorAssigner.forMimeTypeJPEG(flavor);
    } else if (mimeType.equalsIgnoreCase(""PDF"")) {
        d = docFlavorAssigner.forMimeTypePDF(flavor);
    } else if (mimeType.equalsIgnoreCase(""PCL"")) {
        d = docFlavorAssigner.forMimeTypePCL(flavor);
    } else if (mimeType.equalsIgnoreCase(""POSTSCRIPT"")) {
        d = docFlavorAssigner.forMimeTypePOSTSCRIPT(flavor);
    } else if (mimeType.equalsIgnoreCase(""TEXT_HTML_HOST"")) {
        d = docFlavorAssigner.forMimeTypeHOST(flavor, mimeType);
    } else if (mimeType.equalsIgnoreCase(""TEXT_HTML_US_ASCII"")) {
        d = docFlavorAssigner.forMimeTypeUSASCII(flavor, mimeType);
    } else if (mimeType.equalsIgnoreCase(""TEXT_HTML_UTF_16"")) {
        d = docFlavorAssigner.forMimeTypeUTF16(flavor, mimeType);
    } else if (mimeType.equalsIgnoreCase(""TEXT_HTML_UTF_16LE"")) {
        d = docFlavorAssigner.forMimeTypeUTF16LE(flavor, mimeType);
    } else if (mimeType.equalsIgnoreCase(""TEXT_HTML_UTF_16BE"")) {
        d = docFlavorAssigner.forMimeTypeUTF16BE(flavor, mimeType);
    } else if (mimeType.equalsIgnoreCase(""TEXT_HTML_UTF_8"")) {
        d = docFlavorAssigner.forMimeTypeUTF8(flavor, mimeType);
    } else if (mimeType.equalsIgnoreCase(""TEXT_PLAIN_HOST"")) {
        d = docFlavorAssigner.forMimeTypeHOST(flavor, mimeType);
    } else if (mimeType.equalsIgnoreCase(""TEXT_PLAIN_US_ASCII"")) {
        d = docFlavorAssigner.forMimeTypeUSASCII(flavor, mimeType);
    } else if (mimeType.equalsIgnoreCase(""TEXT_PLAIN_UTF_16"")) {
        d = docFlavorAssigner.forMimeTypeUTF16(flavor, mimeType);
    } else if (mimeType.equalsIgnoreCase(""TEXT_PLAIN_UTF_16LE"")) {
        d = docFlavorAssigner.forMimeTypeUTF16LE(flavor, mimeType);
    } else if (mimeType.equalsIgnoreCase(""TEXT_PLAIN_UTF_16BE"")) {
        d = docFlavorAssigner.forMimeTypeUTF16BE(flavor, mimeType);
    } else if (mimeType.equalsIgnoreCase(""TEXT_PLAIN_UTF_8"")) {
        d = docFlavorAssigner.forMimeTypeUTF8(flavor, mimeType);
    } else if (mimeType.equalsIgnoreCase(""TEXT_HTML"")) {
        d = docFlavorAssigner.forMimeTypeBasic(flavor, mimeType);
    } else if (mimeType.equalsIgnoreCase(""TEXT_PLAIN"")) {
        d = docFlavorAssigner.forMimeTypeBasic(flavor, mimeType);
    } else if (mimeType.equalsIgnoreCase(""PAGEABLE"")) {
        d = docFlavorAssigner.forMimeTypePAGEABLE();
    } else if (mimeType.equalsIgnoreCase(""PRINTABLE"")) {
        d = docFlavorAssigner.forMimeTypePRINTABLE();
    } else if (mimeType.equalsIgnoreCase(""RENDERABLE_IMAGE"")) {
        d = docFlavorAssigner.forMimeTypeRENDERABLEIMAGE();
    }
    return d;
}",java:S3776,39
"public Consumer getConsumer(){
    return consumer;
}",java:S3740,38
"@Deprecated
public void setMaxPendingMessagesAcrossPartitions(int maxPendingMessagesAcrossPartitions){
    this.maxPendingMessagesAcrossPartitions = maxPendingMessagesAcrossPartitions;
}",java:S6355,48
"@Deprecated
public int getMaxPendingMessagesAcrossPartitions(){
    return maxPendingMessagesAcrossPartitions;
}",java:S6355,48
"protected static ConsumerBuilder<byte[]> getBuilder(final String name, final PulsarEndpoint pulsarEndpoint, final PulsarConsumer pulsarConsumer){
    final PulsarConfiguration endpointConfiguration = pulsarEndpoint.getPulsarConfiguration();
    ConsumerBuilder<byte[]> builder = pulsarEndpoint.getPulsarClient().newConsumer();
    if (endpointConfiguration.getKeySharedPolicy() != null) {
        if (""AUTO_SPLIT"".equalsIgnoreCase(endpointConfiguration.getKeySharedPolicy())) {
            builder.keySharedPolicy(KeySharedPolicy.autoSplitHashRange());
        } else if (""STICKY"".equalsIgnoreCase(endpointConfiguration.getKeySharedPolicy())) {
            builder.keySharedPolicy(KeySharedPolicy.stickyHashRange());
        } else {
            throw new IllegalArgumentException(""Unsupported KeySharedPolicy: "" + endpointConfiguration.getKeySharedPolicy());
        }
    }
    if (endpointConfiguration.isTopicsPattern()) {
        builder.topicsPattern(pulsarEndpoint.getUri());
        if (endpointConfiguration.getSubscriptionTopicsMode() != null) {
            builder.subscriptionTopicsMode(endpointConfiguration.getSubscriptionTopicsMode());
        }
    } else {
        builder.topic(pulsarEndpoint.getUri());
    }
    builder.subscriptionName(endpointConfiguration.getSubscriptionName()).receiverQueueSize(endpointConfiguration.getConsumerQueueSize()).consumerName(name).ackTimeout(endpointConfiguration.getAckTimeoutMillis(), TimeUnit.MILLISECONDS).subscriptionInitialPosition(endpointConfiguration.getSubscriptionInitialPosition().toPulsarSubscriptionInitialPosition()).acknowledgmentGroupTime(endpointConfiguration.getAckGroupTimeMillis(), TimeUnit.MILLISECONDS).negativeAckRedeliveryDelay(endpointConfiguration.getNegativeAckRedeliveryDelayMicros(), TimeUnit.MICROSECONDS).readCompacted(endpointConfiguration.isReadCompacted());
    if (endpointConfiguration.isMessageListener()) {
        builder.messageListener(new PulsarMessageListener(pulsarEndpoint, pulsarConsumer));
    }
    if (endpointConfiguration.isEnableRetry()) {
        builder.enableRetry(true);
        DeadLetterPolicyBuilder policy = DeadLetterPolicy.builder().maxRedeliverCount(endpointConfiguration.getMaxRedeliverCount());
        if (endpointConfiguration.getRetryLetterTopic() != null) {
            policy.retryLetterTopic(endpointConfiguration.getRetryLetterTopic());
        }
        builder.deadLetterPolicy(policy.build());
    } else if (endpointConfiguration.getMaxRedeliverCount() != null) {
        DeadLetterPolicyBuilder policy = DeadLetterPolicy.builder().maxRedeliverCount(endpointConfiguration.getMaxRedeliverCount());
        if (endpointConfiguration.getDeadLetterTopic() != null) {
            policy.deadLetterTopic(endpointConfiguration.getDeadLetterTopic());
        }
        builder.deadLetterPolicy(policy.build());
    }
    if (ObjectHelper.isNotEmpty(endpointConfiguration.getAckTimeoutRedeliveryBackoff())) {
        builder.ackTimeoutRedeliveryBackoff(endpointConfiguration.getAckTimeoutRedeliveryBackoff());
    }
    if (ObjectHelper.isNotEmpty(endpointConfiguration.getNegativeAckRedeliveryBackoff())) {
        builder.negativeAckRedeliveryBackoff(endpointConfiguration.getNegativeAckRedeliveryBackoff());
    }
    return builder;
}",java:S3776,39
"protected QuartzEndpoint lookupQuartzEndpoint(CamelContext camelContext, JobExecutionContext quartzContext) throws JobExecutionException{
    TriggerKey triggerKey = quartzContext.getTrigger().getKey();
    JobDetail jobDetail = quartzContext.getJobDetail();
    JobKey jobKey = jobDetail.getKey();
    if (LOG.isDebugEnabled()) {
        LOG.debug(""Looking up existing QuartzEndpoint with triggerKey={}"", triggerKey);
    }
    for (Route route : camelContext.getRoutes()) {
        Endpoint endpoint = route.getEndpoint();
        if (endpoint instanceof DelegateEndpoint) {
            endpoint = ((DelegateEndpoint) endpoint).getEndpoint();
        }
        if (endpoint instanceof QuartzEndpoint) {
            QuartzEndpoint quartzEndpoint = (QuartzEndpoint) endpoint;
            TriggerKey checkTriggerKey = quartzEndpoint.getTriggerKey();
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Checking route endpoint={} with checkTriggerKey={}"", quartzEndpoint, checkTriggerKey);
            }
            if (triggerKey.equals(checkTriggerKey) || jobDetail.requestsRecovery() && jobKey.getGroup().equals(checkTriggerKey.getGroup()) && jobKey.getName().equals(checkTriggerKey.getName())) {
                return quartzEndpoint;
            }
        }
    }
    String endpointUri = quartzContext.getMergedJobDataMap().getString(QuartzConstants.QUARTZ_ENDPOINT_URI);
    QuartzEndpoint result;
    if (camelContext.hasEndpoint(endpointUri) != null) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Getting Endpoint from camelContext."");
        }
        result = camelContext.getEndpoint(endpointUri, QuartzEndpoint.class);
    } else if ((result = searchForEndpointMatch(camelContext, endpointUri)) != null) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Found match for endpoint URI = {} by searching endpoint list."", endpointUri);
        }
    } else {
        LOG.warn(""Cannot find existing QuartzEndpoint with uri: {}. Creating new endpoint instance."", endpointUri);
        result = camelContext.getEndpoint(endpointUri, QuartzEndpoint.class);
    }
    if (result == null) {
        throw new JobExecutionException(""No QuartzEndpoint could be found with endpointUri: "" + endpointUri);
    }
    return result;
}",java:S3776,39
"public Map getProperties(){
    return properties;
}",java:S3740,38
"public void setProperties(Map properties){
    this.properties = properties;
}",java:S3740,38
"private SchedulerFactory createSchedulerFactory() throws SchedulerException{
    SchedulerFactory answer;
    Properties prop = loadProperties();
    if (prop != null) {
        prop.put(""org.quartz.scheduler.skipUpdateCheck"", ""true"");
        prop.put(""org.terracotta.quartz.skipUpdateCheck"", ""true"");
        if (isPrefixInstanceName()) {
            String instName = createInstanceName(prop);
            prop.setProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME, instName);
        }
        if (isInterruptJobsOnShutdown()) {
            prop.setProperty(StdSchedulerFactory.PROP_SCHED_INTERRUPT_JOBS_ON_SHUTDOWN, ""true"");
        }
        if (enableJmx && !prop.containsKey(""org.quartz.scheduler.jmx.export"")) {
            prop.put(""org.quartz.scheduler.jmx.export"", ""true"");
            LOG.info(""Setting org.quartz.scheduler.jmx.export=true to ensure QuartzScheduler(s) will be enlisted in JMX"");
        }
        answer = new StdSchedulerFactory(prop);
    } else {
        InputStream is = StdSchedulerFactory.class.getClassLoader().getResourceAsStream(""org/quartz/quartz.properties"");
        if (is == null) {
            throw new SchedulerException(""Quartz properties file not found in classpath: org/quartz/quartz.properties"");
        }
        prop = new Properties();
        try {
            prop.load(is);
        } catch (IOException e) {
            throw new SchedulerException(""Error loading Quartz properties file from classpath: org/quartz/quartz.properties"", e);
        } finally {
            IOHelper.close(is);
        }
        if (isPrefixInstanceName()) {
            String instName = createInstanceName(prop);
            prop.setProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME, instName);
        }
        prop.put(""org.quartz.scheduler.skipUpdateCheck"", ""true"");
        prop.put(""org.terracotta.quartz.skipUpdateCheck"", ""true"");
        if (isInterruptJobsOnShutdown()) {
            prop.setProperty(StdSchedulerFactory.PROP_SCHED_INTERRUPT_JOBS_ON_SHUTDOWN, ""true"");
        }
        if (enableJmx && !prop.containsKey(""org.quartz.scheduler.jmx.export"")) {
            prop.put(""org.quartz.scheduler.jmx.export"", ""true"");
            LOG.info(""Setting org.quartz.scheduler.jmx.export=true to ensure QuartzScheduler(s) will be enlisted in JMX"");
        }
        answer = new StdSchedulerFactory(prop);
    }
    if (LOG.isDebugEnabled()) {
        String name = prop.getProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME);
        LOG.debug(""Creating SchedulerFactory: {} with properties: {}"", name, prop);
    }
    return answer;
}",java:S3776,39
"private TriggerKey createTriggerKey(String uri, String remaining, QuartzEndpoint endpoint) throws Exception{
    URI u = new URI(uri);
    String path = StringHelper.after(u.getPath(), ""/"");
    String host = u.getHost();
    if (host == null) {
        host = StringHelper.before(remaining, ""/"");
        if (host == null) {
            host = remaining;
        }
    }
    String name;
    String group;
    if (ObjectHelper.isNotEmpty(path) && ObjectHelper.isNotEmpty(host)) {
        group = host;
        name = path;
    } else {
        String camelContextName = QuartzHelper.getQuartzContextName(getCamelContext());
        group = camelContextName == null ? ""Camel"" : ""Camel_"" + camelContextName;
        name = host;
    }
    if (prefixJobNameWithEndpointId) {
        name = endpoint.getId() + ""_"" + name;
    }
    return new TriggerKey(name, group);
}",java:S112,4
"private void addJobInScheduler() throws Exception{
    Scheduler scheduler = getComponent().getScheduler();
    JobDetail jobDetail;
    Trigger oldTrigger = scheduler.getTrigger(triggerKey);
    boolean triggerExisted = oldTrigger != null;
    if (triggerExisted && !isRecoverableJob()) {
        ensureNoDupTriggerKey();
    }
    jobDetail = createJobDetail();
    Trigger trigger = createTrigger(jobDetail);
    QuartzHelper.updateJobDataMap(getCamelContext(), jobDetail, getEndpointUri(), isUsingFixedCamelContextName());
    boolean scheduled = true;
    if (triggerExisted) {
        if (hasTriggerChanged(oldTrigger, trigger)) {
            scheduler.rescheduleJob(triggerKey, trigger);
        }
    } else {
        try {
            Calendar cal = null;
            if (trigger.getCalendarName() != null) {
                cal = scheduler.getCalendar(trigger.getCalendarName());
            }
            OperableTrigger ot = (OperableTrigger) trigger;
            Date ft = ot.computeFirstFireTime(cal);
            if (ft == null && ignoreExpiredNextFireTime) {
                scheduled = false;
                LOG.warn(""Job {} (cron={}, triggerType={}, jobClass={}) not scheduled, because it will never fire in the future"", trigger.getKey(), cron, trigger.getClass().getSimpleName(), jobDetail.getJobClass().getSimpleName());
            } else {
                scheduler.scheduleJob(jobDetail, trigger);
            }
        } catch (ObjectAlreadyExistsException ex) {
            if (!(getComponent().isClustered())) {
                throw ex;
            } else {
                trigger = scheduler.getTrigger(triggerKey);
                if (trigger == null) {
                    throw new SchedulerException(""Trigger could not be found in quartz scheduler."");
                }
            }
        }
    }
    if (scheduled) {
        if (LOG.isInfoEnabled()) {
            Object nextFireTime = trigger.getNextFireTime();
            if (nextFireTime != null) {
                nextFireTime = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSSZ"").format(nextFireTime);
            }
            LOG.info(""Job {} (cron={}, triggerType={}, jobClass={}) is scheduled. Next fire date is {}"", trigger.getKey(), cron, trigger.getClass().getSimpleName(), jobDetail.getJobClass().getSimpleName(), nextFireTime);
        }
    }
    AtomicInteger number = (AtomicInteger) scheduler.getContext().get(QuartzConstants.QUARTZ_CAMEL_JOBS_COUNT);
    if (number != null) {
        number.incrementAndGet();
    }
    jobAdded.set(true);
}",java:S3776,39
"private Trigger createTrigger(JobDetail jobDetail) throws Exception{
    final Map<String, Object> copy = new HashMap<>(triggerParameters);
    final TriggerBuilder<Trigger> triggerBuilder = TriggerBuilder.newTrigger().withIdentity(triggerKey);
    if (getComponent().getScheduler().isStarted() || triggerStartDelay < 0) {
        triggerBuilder.startAt(new Date(System.currentTimeMillis() + triggerStartDelay));
    }
    if (cron != null) {
        LOG.debug(""Creating CronTrigger: {}"", cron);
        final String timeZone = (String) copy.get(""timeZone"");
        if (timeZone != null) {
            if (ObjectHelper.isNotEmpty(customCalendar)) {
                triggerBuilder.withSchedule(cronSchedule(cron).withMisfireHandlingInstructionFireAndProceed().inTimeZone(TimeZone.getTimeZone(timeZone))).modifiedByCalendar(QuartzConstants.QUARTZ_CAMEL_CUSTOM_CALENDAR);
            } else {
                triggerBuilder.withSchedule(cronSchedule(cron).withMisfireHandlingInstructionFireAndProceed().inTimeZone(TimeZone.getTimeZone(timeZone)));
            }
            jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_CRON_TIMEZONE, timeZone);
        } else {
            if (ObjectHelper.isNotEmpty(customCalendar)) {
                triggerBuilder.withSchedule(cronSchedule(cron).withMisfireHandlingInstructionFireAndProceed()).modifiedByCalendar(QuartzConstants.QUARTZ_CAMEL_CUSTOM_CALENDAR);
            } else {
                triggerBuilder.withSchedule(cronSchedule(cron).withMisfireHandlingInstructionFireAndProceed());
            }
        }
        jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_TYPE, ""cron"");
        jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_CRON_EXPRESSION, cron);
    } else {
        LOG.debug(""Creating SimpleTrigger."");
        int repeat = SimpleTrigger.REPEAT_INDEFINITELY;
        String repeatString = (String) copy.get(""repeatCount"");
        if (repeatString != null) {
            repeat = EndpointHelper.resolveParameter(getCamelContext(), repeatString, Integer.class);
            copy.put(""repeatCount"", repeat);
        }
        long interval = 1000;
        String intervalString = (String) copy.get(""repeatInterval"");
        if (intervalString != null) {
            interval = EndpointHelper.resolveParameter(getCamelContext(), intervalString, Long.class);
            copy.put(""repeatInterval"", interval);
        }
        if (ObjectHelper.isNotEmpty(customCalendar)) {
            triggerBuilder.withSchedule(simpleSchedule().withMisfireHandlingInstructionFireNow().withRepeatCount(repeat).withIntervalInMilliseconds(interval)).modifiedByCalendar(QuartzConstants.QUARTZ_CAMEL_CUSTOM_CALENDAR);
        } else {
            triggerBuilder.withSchedule(simpleSchedule().withMisfireHandlingInstructionFireNow().withRepeatCount(repeat).withIntervalInMilliseconds(interval));
        }
        jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_TYPE, ""simple"");
        jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_SIMPLE_REPEAT_COUNTER, String.valueOf(repeat));
        jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_SIMPLE_REPEAT_INTERVAL, String.valueOf(interval));
    }
    final Trigger result = triggerBuilder.build();
    if (!copy.isEmpty()) {
        LOG.debug(""Setting user extra triggerParameters {}"", copy);
        setProperties(result, copy);
    }
    LOG.debug(""Created trigger={}"", result);
    return result;
}",java:S3776,39
"private Trigger createTrigger(JobDetail jobDetail) throws Exception{
    final Map<String, Object> copy = new HashMap<>(triggerParameters);
    final TriggerBuilder<Trigger> triggerBuilder = TriggerBuilder.newTrigger().withIdentity(triggerKey);
    if (getComponent().getScheduler().isStarted() || triggerStartDelay < 0) {
        triggerBuilder.startAt(new Date(System.currentTimeMillis() + triggerStartDelay));
    }
    if (cron != null) {
        LOG.debug(""Creating CronTrigger: {}"", cron);
        final String timeZone = (String) copy.get(""timeZone"");
        if (timeZone != null) {
            if (ObjectHelper.isNotEmpty(customCalendar)) {
                triggerBuilder.withSchedule(cronSchedule(cron).withMisfireHandlingInstructionFireAndProceed().inTimeZone(TimeZone.getTimeZone(timeZone))).modifiedByCalendar(QuartzConstants.QUARTZ_CAMEL_CUSTOM_CALENDAR);
            } else {
                triggerBuilder.withSchedule(cronSchedule(cron).withMisfireHandlingInstructionFireAndProceed().inTimeZone(TimeZone.getTimeZone(timeZone)));
            }
            jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_CRON_TIMEZONE, timeZone);
        } else {
            if (ObjectHelper.isNotEmpty(customCalendar)) {
                triggerBuilder.withSchedule(cronSchedule(cron).withMisfireHandlingInstructionFireAndProceed()).modifiedByCalendar(QuartzConstants.QUARTZ_CAMEL_CUSTOM_CALENDAR);
            } else {
                triggerBuilder.withSchedule(cronSchedule(cron).withMisfireHandlingInstructionFireAndProceed());
            }
        }
        jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_TYPE, ""cron"");
        jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_CRON_EXPRESSION, cron);
    } else {
        LOG.debug(""Creating SimpleTrigger."");
        int repeat = SimpleTrigger.REPEAT_INDEFINITELY;
        String repeatString = (String) copy.get(""repeatCount"");
        if (repeatString != null) {
            repeat = EndpointHelper.resolveParameter(getCamelContext(), repeatString, Integer.class);
            copy.put(""repeatCount"", repeat);
        }
        long interval = 1000;
        String intervalString = (String) copy.get(""repeatInterval"");
        if (intervalString != null) {
            interval = EndpointHelper.resolveParameter(getCamelContext(), intervalString, Long.class);
            copy.put(""repeatInterval"", interval);
        }
        if (ObjectHelper.isNotEmpty(customCalendar)) {
            triggerBuilder.withSchedule(simpleSchedule().withMisfireHandlingInstructionFireNow().withRepeatCount(repeat).withIntervalInMilliseconds(interval)).modifiedByCalendar(QuartzConstants.QUARTZ_CAMEL_CUSTOM_CALENDAR);
        } else {
            triggerBuilder.withSchedule(simpleSchedule().withMisfireHandlingInstructionFireNow().withRepeatCount(repeat).withIntervalInMilliseconds(interval));
        }
        jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_TYPE, ""simple"");
        jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_SIMPLE_REPEAT_COUNTER, String.valueOf(repeat));
        jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_SIMPLE_REPEAT_INTERVAL, String.valueOf(interval));
    }
    final Trigger result = triggerBuilder.build();
    if (!copy.isEmpty()) {
        LOG.debug(""Setting user extra triggerParameters {}"", copy);
        setProperties(result, copy);
    }
    LOG.debug(""Created trigger={}"", result);
    return result;
}",java:S112,4
"public void pauseTrigger() throws Exception{
    Scheduler scheduler = getComponent().getScheduler();
    boolean isClustered = scheduler.getMetaData().isJobStoreClustered();
    if (jobPaused.get() || isClustered) {
        return;
    }
    jobPaused.set(true);
    if (!scheduler.isShutdown()) {
        LOG.info(""Pausing trigger {}"", triggerKey);
        scheduler.pauseTrigger(triggerKey);
    }
}",java:S112,4
"public void resumeTrigger() throws Exception{
    if (!jobPaused.get()) {
        return;
    }
    jobPaused.set(false);
    Scheduler scheduler = getComponent().getScheduler();
    if (scheduler != null) {
        LOG.info(""Resuming trigger {}"", triggerKey);
        scheduler.resumeTrigger(triggerKey);
    }
}",java:S112,4
"public void onConsumerStop(QuartzConsumer quartzConsumer) throws Exception{
    if (jobAdded.get()) {
        pauseTrigger();
    }
    this.processor = null;
}",java:S1172,13
"public void onJobExecute(Action action, Route route) throws Exception{
    LOG.debug(""Scheduled Event notification received. Performing action: {} on route: {}"", action, route.getId());
    ServiceStatus routeStatus = route.getCamelContext().getRouteController().getRouteStatus(route.getId());
    if (action == Action.START) {
        if (routeStatus == ServiceStatus.Stopped) {
            startRoute(route);
        } else if (ServiceHelper.isSuspended(route.getConsumer())) {
            resumeOrStartConsumer(route.getConsumer());
        }
    } else if (action == Action.STOP) {
        if (routeStatus == ServiceStatus.Started || routeStatus == ServiceStatus.Suspended) {
            stopRoute(route, getRouteStopGracePeriod(), getTimeUnit());
        } else {
            LOG.warn(""Route is not in a started/suspended state and cannot be stopped. The current route state is {}"", routeStatus);
        }
    } else if (action == Action.SUSPEND) {
        if (routeStatus == ServiceStatus.Started) {
            suspendOrStopConsumer(route.getConsumer());
        } else {
            LOG.warn(""Route is not in a started state and cannot be suspended. The current route state is {}"", routeStatus);
        }
    } else if (action == Action.RESUME) {
        if (routeStatus == ServiceStatus.Started) {
            if (ServiceHelper.isSuspended(route.getConsumer())) {
                resumeOrStartConsumer(route.getConsumer());
            } else {
                LOG.warn(""The Consumer {} is not suspended and cannot be resumed."", route.getConsumer());
            }
        } else {
            LOG.warn(""Route is not in a started state and cannot be resumed. The current route state is {}"", routeStatus);
        }
    }
}",java:S3776,39
"public void ensureInitialized() throws Exception{
    if (!engine.isInitialized()) {
        synchronized (engine) {
            if (!engine.isInitialized()) {
                engine.initializeEngine();
                ServiceHelper.startService(engine);
            }
        }
    }
}",java:S112,4
" void initializeEngine() throws ConfigError, FieldConvertError, JMException{
    LOG.debug(""Initializing QuickFIX/J Engine: {}"", uri);
    if (messageFactory == null) {
        messageFactory = new DefaultMessageFactory();
    }
    if (sessionLogFactory == null) {
        sessionLogFactory = inferLogFactory(settings);
    }
    if (messageStoreFactory == null) {
        messageStoreFactory = inferMessageStoreFactory(settings);
    }
    if (!settings.isSetting(Session.SETTING_START_TIME)) {
        settings.setString(Session.SETTING_START_TIME, DEFAULT_START_TIME);
    }
    if (!settings.isSetting(Session.SETTING_END_TIME)) {
        settings.setString(Session.SETTING_END_TIME, DEFAULT_END_TIME);
    }
    if (!settings.isSetting(Session.SETTING_HEARTBTINT)) {
        settings.setLong(Session.SETTING_HEARTBTINT, DEFAULT_HEARTBTINT);
    }
    ThreadModel threadModel = ThreadModel.ThreadPerConnector;
    if (settings.isSetting(SETTING_THREAD_MODEL)) {
        threadModel = ThreadModel.valueOf(settings.getString(SETTING_THREAD_MODEL));
    }
    if (settings.isSetting(SETTING_USE_JMX) && settings.getBool(SETTING_USE_JMX)) {
        LOG.info(""Enabling JMX for QuickFIX/J"");
        jmxExporter = new JmxExporter();
    } else {
        jmxExporter = null;
    }
    ClassLoader ccl = Thread.currentThread().getContextClassLoader();
    try {
        Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
        if (isConnectorRole(settings, SessionFactory.ACCEPTOR_CONNECTION_TYPE)) {
            acceptor = createAcceptor(new Dispatcher(), settings, messageStoreFactory, sessionLogFactory, messageFactory, threadModel);
        } else {
            acceptor = null;
        }
        if (isConnectorRole(settings, SessionFactory.INITIATOR_CONNECTION_TYPE)) {
            initiator = createInitiator(new Dispatcher(), settings, messageStoreFactory, sessionLogFactory, messageFactory, threadModel);
        } else {
            initiator = null;
        }
        if (acceptor == null && initiator == null) {
            throw new ConfigError(""No connector role"");
        }
    } finally {
        Thread.currentThread().setContextClassLoader(ccl);
    }
    LOG.debug(""Initialized QuickFIX/J Engine: {}"", uri);
    initialized.set(true);
}",java:S3776,39
"protected static SessionSettings loadSettings(CamelContext camelContext, String settingsResourceName) throws Exception{
    InputStream inputStream = ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext, settingsResourceName);
    return new SessionSettings(inputStream);
}",java:S112,4
" void schedule(Runnable runnable, boolean first, boolean main, boolean sync){
    if (LOG.isTraceEnabled()) {
        LOG.trace(""Schedule [first={}, main={}, sync={}]: {}"", first, main, sync, runnable);
    }
    if (main) {
        if (!queue.isEmpty()) {
            if (back == null) {
                back = new ArrayDeque<>();
            }
            back.push(queue);
            queue = new ArrayDeque<>();
        }
    }
    if (first) {
        queue.addFirst(runnable);
        if (stats) {
            executor.pendingTasks.increment();
        }
    } else {
        queue.addLast(runnable);
        if (stats) {
            executor.pendingTasks.increment();
        }
    }
    if (!running || sync) {
        running = true;
        if (stats) {
            executor.runningWorkers.increment();
        }
        try {
            for (; ; ) {
                final Runnable polled = queue.pollFirst();
                if (polled == null) {
                    if (back != null && !back.isEmpty()) {
                        queue = back.pollFirst();
                        continue;
                    } else {
                        break;
                    }
                }
                try {
                    if (stats) {
                        executor.pendingTasks.decrement();
                    }
                    if (LOG.isTraceEnabled()) {
                        LOG.trace(""Worker #{} running: {}"", number, polled);
                    }
                    polled.run();
                } catch (Exception e) {
                    LOG.warn(""Error executing reactive work due to {}. This exception is ignored."", e.getMessage(), e);
                }
            }
        } finally {
            running = false;
            if (stats) {
                executor.runningWorkers.decrement();
            }
        }
    } else {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Queuing reactive work: {}"", runnable);
        }
    }
}",java:S3776,39
"private void flushCycle(){
    boolean notRunning = flushing.compareAndSet(false, true);
    if (notRunning) {
        workerPool.execute(() -> {
            try {
                List<MonoSubscription> completed = new LinkedList<>();
                for (MonoSubscription sub : this.subscriptions) {
                    sub.flush();
                    if (sub.isTerminated()) {
                        completed.add(sub);
                    }
                }
                this.subscriptions.removeAll(completed);
            } finally {
                flushing.set(false);
            }
            boolean runAgain = false;
            for (MonoSubscription sub : this.subscriptions) {
                if (sub.isReady()) {
                    runAgain = true;
                    break;
                }
            }
            if (runAgain) {
                flushCycle();
            }
        });
    }
}",java:S3776,39
"public String getPersistentRepositoryName(){
    return persistenceMapName;
}",java:S4144,40
"private Exchange processTask(Exchange exchange){
    Exchange copy = null;
    UnitOfWork uow = null;
    Throwable cause;
    try {
        LOG.debug(""Running processor: {} with exchange: {}"", processor, exchange);
        copy = processorExchangeFactory.createCorrelatedCopy(exchange, false);
        if (copy.getUnitOfWork() != null) {
            uow = copy.getUnitOfWork();
        } else {
            uow = PluginHelper.getUnitOfWorkFactory(copy.getContext()).createUnitOfWork(copy);
            copy.getExchangeExtension().setUnitOfWork(uow);
            Route route = ExchangeHelper.getRoute(exchange);
            if (route != null) {
                uow.pushRoute(route);
            }
        }
        processor.process(copy);
        if (copy.getException() != null) {
            exchange.setException(copy.getException());
        } else {
            ExchangeHelper.copyResults(exchange, copy);
            exchange.setProperty(ExchangePropertyKey.CIRCUIT_BREAKER_RESPONSE_SUCCESSFUL_EXECUTION, true);
            exchange.setProperty(ExchangePropertyKey.CIRCUIT_BREAKER_RESPONSE_FROM_FALLBACK, false);
        }
    } catch (Exception e) {
        exchange.setException(e);
    } finally {
        UnitOfWorkHelper.doneUow(uow, copy);
        cause = exchange.getException();
    }
    processorExchangeFactory.release(exchange);
    if (cause != null) {
        throw RuntimeExchangeException.wrapRuntimeException(cause);
    }
    return exchange;
}",java:S3398,35
"public static String getBasePathFromOpenApi(final OpenAPI openApi){
    String basePath = null;
    if (openApi.getServers() != null) {
        for (Server server : openApi.getServers()) {
            if (server.getUrl() != null) {
                try {
                    URI serverUrl = new URI(parseVariables(server.getUrl(), server));
                    basePath = serverUrl.getPath();
                    if (basePath.indexOf(""//"") == 0) {
                        basePath = basePath.substring(1);
                    }
                    if (""/"".equals(basePath)) {
                        basePath = """";
                    }
                } catch (URISyntaxException e) {
                    basePath = server.getUrl();
                }
            }
        }
    }
    return basePath;
}",java:S3776,39
" Map<String, Object> determineEndpointParameters(final OpenAPI openapi, final Operation operation){
    final Map<String, Object> parameters = new HashMap<>();
    final String componentName = determineComponentName();
    if (componentName != null) {
        parameters.put(""producerComponentName"", componentName);
    }
    final String host = determineHost(openapi, operation);
    if (host != null) {
        parameters.put(""host"", host);
    }
    final RestOpenApiComponent component = component();
    List<String> specificationLevelConsumers = new ArrayList<>();
    Set<String> operationLevelConsumers = new java.util.HashSet<>();
    if (operation.getResponses() != null) {
        for (ApiResponse response : operation.getResponses().values()) {
            if (response.getContent() != null) {
                operationLevelConsumers.addAll(response.getContent().keySet());
            }
        }
    }
    final String determinedConsumes = determineOption(specificationLevelConsumers, operationLevelConsumers, component.getConsumes(), consumes);
    if (isNotEmpty(determinedConsumes)) {
        parameters.put(""consumes"", determinedConsumes);
    }
    List<String> specificationLevelProducers = new ArrayList<>();
    Set<String> operationLevelProducers = new java.util.HashSet<>();
    if (operation.getRequestBody() != null && operation.getRequestBody().getContent() != null) {
        operationLevelProducers.addAll(operation.getRequestBody().getContent().keySet());
    }
    final String determinedProducers = determineOption(specificationLevelProducers, operationLevelProducers, component.getProduces(), produces);
    if (isNotEmpty(determinedProducers)) {
        parameters.put(""produces"", determinedProducers);
    }
    final String queryParameters = determineQueryParameters(openapi, operation).map(this::queryParameter).collect(Collectors.joining(""&""));
    if (isNotEmpty(queryParameters)) {
        parameters.put(""queryParameters"", queryParameters);
    }
    final Map<String, Object> componentParameters = new HashMap<>();
    if (component.isUseGlobalSslContextParameters()) {
        componentParameters.put(""useGlobalSslContextParameters"", component.isUseGlobalSslContextParameters());
    }
    if (component.getSslContextParameters() != null) {
        componentParameters.put(""sslContextParameters"", component.getSslContextParameters());
    }
    final Map<Object, Object> nestedParameters = new HashMap<>();
    if (!componentParameters.isEmpty()) {
        nestedParameters.put(""component"", componentParameters);
    }
    if (this.parameters != null) {
        if (operation.getParameters() != null) {
            for (Map.Entry<String, Object> entry : this.parameters.entrySet()) {
                for (Parameter param : operation.getParameters()) {
                    boolean clash = ""path"".equals(param.getIn()) && entry.getKey().equals(param.getName());
                    if (!clash) {
                        nestedParameters.put(entry.getKey(), entry.getValue());
                    }
                }
            }
        } else {
            nestedParameters.putAll(this.parameters);
        }
    }
    if (!nestedParameters.isEmpty()) {
        parameters.put(""parameters"", nestedParameters);
    }
    return parameters;
}",java:S3776,39
" String determineHost(final OpenAPI openApi, Operation operation){
    if (isNotEmpty(host)) {
        return host;
    }
    final String componentHost = component().getHost();
    if (isNotEmpty(componentHost)) {
        return componentHost;
    }
    URI absoluteURI = null;
    URI relativeURI = null;
    Set<URI> operationURIs = getURIs(operation.getServers());
    Optional<URI> opURI = operationURIs.stream().filter(uri -> uri.isAbsolute()).findFirst();
    if (opURI.isEmpty()) {
        Set<URI> apiURIs = getURIs(openApi.getServers());
        for (URI uri : apiURIs) {
            if (uri.isAbsolute()) {
                absoluteURI = uri;
            } else {
                relativeURI = uri;
            }
        }
        for (URI uri : operationURIs) {
            if (absoluteURI != null) {
                absoluteURI = absoluteURI.resolve(uri);
            } else if (relativeURI != null && !relativeURI.equals(uri)) {
                relativeURI = relativeURI.resolve(uri);
            } else {
                relativeURI = uri;
            }
        }
    } else {
        absoluteURI = opURI.get();
    }
    if (absoluteURI != null) {
        return absoluteURI.toString();
    }
    final CamelContext camelContext = getCamelContext();
    final RestConfiguration globalRestConfiguration = CamelContextHelper.getRestConfiguration(camelContext, null, determineComponentName());
    final String globalConfigurationHost = hostFrom(globalRestConfiguration);
    if (globalConfigurationHost != null) {
        return globalConfigurationHost;
    }
    final String specificationScheme = specificationUri.getScheme();
    String prefix = ""http"";
    if (specificationUri.isAbsolute() && specificationScheme.regionMatches(true, 0, prefix, 0, prefix.length())) {
        try {
            return new URI(specificationUri.getScheme(), specificationUri.getUserInfo(), specificationUri.getHost(), specificationUri.getPort(), null, null, null).toString();
        } catch (final URISyntaxException e) {
            throw new IllegalStateException(""Unable to create a new URI from: "" + specificationUri, e);
        }
    }
    throw new IllegalStateException(""Unable to determine destination host for requests. The OpenApi specification"" + "" does not specify `scheme` and `host` parameters, the specification URI is not absolute with `http` or"" + "" `https` scheme, and no RestConfigurations configured with `scheme`, `host` and `port` were found for `"" + (determineComponentName() != null ? determineComponentName() : ""default"" + ""` component"") + "" and there is no global RestConfiguration with those properties"");
}",java:S3776,39
"private boolean isExcluded(String routeId){
    if (!excludePatterns.isEmpty()) {
        for (String pattern : excludePatterns) {
            if (pattern.equals(routeId)) {
                LOG.debug(""Ignoring route with ID {}"", routeId);
                return true;
            }
        }
    }
    return false;
}",java:S3398,35
"protected void verifyUnderlyingComponent(Scope scope, ResultBuilder builder, Map<String, Object> map){
    String componentName = (String) map.get(""producerComponentName"");
    if (ObjectHelper.isNotEmpty(componentName)) {
        final Map<String, Object> parameters = new HashMap<>(map);
        try {
            final Component component = getTransportComponent(componentName);
            final Optional<ComponentVerifierExtension> extension = component.getExtension(ComponentVerifierExtension.class);
            if (extension.isPresent()) {
                final ComponentVerifierExtension verifier = extension.get();
                final RuntimeCamelCatalog catalog = PluginHelper.getRuntimeCamelCatalog(getCamelContext());
                final String json = catalog.componentJSonSchema(""rest"");
                final ComponentModel model = JsonMapper.generateComponentModel(json);
                model.getEndpointPathOptions().stream().filter(o -> o.getKind().equals(""path"")).forEach(o -> parameters.remove(o.getName()));
                final Map<String, Object> restParameters = new HashMap<>(parameters);
                Stream.concat(model.getComponentOptions().stream(), model.getOptions().stream()).forEach(o -> {
                    String name = o.getName();
                    Object val = restParameters.remove(name);
                    if (val != null) {
                        restParameters.put(""rest."" + name, parameters.get(name));
                    }
                });
                if (scope == Scope.CONNECTIVITY) {
                    model.getEndpointPathOptions().forEach(o -> {
                        String name = o.getName();
                        Object val = map.get(name);
                        if (val != null) {
                            restParameters.put(""rest."" + name, val);
                        }
                    });
                }
                Result result = verifier.verify(scope, restParameters);
                for (VerificationError error : result.getErrors()) {
                    builder.error(ResultErrorBuilder.fromError(error).detail(""component"", componentName).build());
                }
            } else {
                builder.error(ResultErrorBuilder.withUnsupportedComponent(componentName).build());
            }
        } catch (Exception e) {
            builder.error(ResultErrorBuilder.withException(e).build());
        }
    } else {
        builder.error(ResultErrorBuilder.withMissingOption(""componentName"").build());
    }
}",java:S3776,39
"protected void prepareExchange(Exchange exchange) throws Exception{
    boolean hasPath = false;
    String resolvedUriTemplate = getEndpoint().getUriTemplate() != null ? getEndpoint().getUriTemplate() : getEndpoint().getPath();
    Message inMessage = exchange.getIn();
    if (prepareUriTemplate) {
        if (resolvedUriTemplate.contains(""{"")) {
            String[] arr = resolvedUriTemplate.split(""\\/"");
            StringJoiner uriTemplateBuilder = new StringJoiner(""/"");
            for (String a : arr) {
                String resolvedUriParam = resolveHeaderPlaceholders(a, inMessage);
                if (!a.equals(resolvedUriParam) && !resolvedUriParam.contains(""{"") && !resolvedUriParam.contains(""}"")) {
                    hasPath = true;
                    uriTemplateBuilder.add(resolvedUriParam);
                } else {
                    uriTemplateBuilder.add(a);
                }
            }
            resolvedUriTemplate = uriTemplateBuilder.toString();
        }
    }
    String query = createQueryParameters(getEndpoint().getQueryParameters(), inMessage);
    if (query != null) {
        inMessage.setHeader(RestConstants.REST_HTTP_QUERY, query);
    }
    if (hasPath) {
        String host = getEndpoint().getHost();
        String basePath = getEndpoint().getUriTemplate() != null ? getEndpoint().getPath() : null;
        basePath = FileUtil.stripLeadingSeparator(basePath);
        resolvedUriTemplate = FileUtil.stripLeadingSeparator(resolvedUriTemplate);
        String overrideUri = host;
        if (!ObjectHelper.isEmpty(basePath)) {
            overrideUri += ""/"" + basePath;
        }
        if (!ObjectHelper.isEmpty(resolvedUriTemplate)) {
            overrideUri += ""/"" + resolvedUriTemplate;
        }
        inMessage.setHeader(RestConstants.REST_HTTP_URI, overrideUri);
        inMessage.removeHeader(Exchange.HTTP_PATH);
    }
    String method = getEndpoint().getMethod();
    if (method != null) {
        String upper = method.toUpperCase(Locale.US);
        inMessage.setHeader(RestConstants.HTTP_METHOD, upper);
    }
    final String produces = getEndpoint().getProduces();
    if (isEmpty(inMessage.getHeader(RestConstants.CONTENT_TYPE)) && isNotEmpty(produces)) {
        inMessage.setHeader(RestConstants.CONTENT_TYPE, produces);
    }
    final String consumes = getEndpoint().getConsumes();
    if (isEmpty(inMessage.getHeader(RestConstants.ACCEPT)) && isNotEmpty(consumes)) {
        inMessage.setHeader(RestConstants.ACCEPT, consumes);
    }
}",java:S3776,39
"protected void prepareExchange(Exchange exchange) throws Exception{
    boolean hasPath = false;
    String resolvedUriTemplate = getEndpoint().getUriTemplate() != null ? getEndpoint().getUriTemplate() : getEndpoint().getPath();
    Message inMessage = exchange.getIn();
    if (prepareUriTemplate) {
        if (resolvedUriTemplate.contains(""{"")) {
            String[] arr = resolvedUriTemplate.split(""\\/"");
            StringJoiner uriTemplateBuilder = new StringJoiner(""/"");
            for (String a : arr) {
                String resolvedUriParam = resolveHeaderPlaceholders(a, inMessage);
                if (!a.equals(resolvedUriParam) && !resolvedUriParam.contains(""{"") && !resolvedUriParam.contains(""}"")) {
                    hasPath = true;
                    uriTemplateBuilder.add(resolvedUriParam);
                } else {
                    uriTemplateBuilder.add(a);
                }
            }
            resolvedUriTemplate = uriTemplateBuilder.toString();
        }
    }
    String query = createQueryParameters(getEndpoint().getQueryParameters(), inMessage);
    if (query != null) {
        inMessage.setHeader(RestConstants.REST_HTTP_QUERY, query);
    }
    if (hasPath) {
        String host = getEndpoint().getHost();
        String basePath = getEndpoint().getUriTemplate() != null ? getEndpoint().getPath() : null;
        basePath = FileUtil.stripLeadingSeparator(basePath);
        resolvedUriTemplate = FileUtil.stripLeadingSeparator(resolvedUriTemplate);
        String overrideUri = host;
        if (!ObjectHelper.isEmpty(basePath)) {
            overrideUri += ""/"" + basePath;
        }
        if (!ObjectHelper.isEmpty(resolvedUriTemplate)) {
            overrideUri += ""/"" + resolvedUriTemplate;
        }
        inMessage.setHeader(RestConstants.REST_HTTP_URI, overrideUri);
        inMessage.removeHeader(Exchange.HTTP_PATH);
    }
    String method = getEndpoint().getMethod();
    if (method != null) {
        String upper = method.toUpperCase(Locale.US);
        inMessage.setHeader(RestConstants.HTTP_METHOD, upper);
    }
    final String produces = getEndpoint().getProduces();
    if (isEmpty(inMessage.getHeader(RestConstants.CONTENT_TYPE)) && isNotEmpty(produces)) {
        inMessage.setHeader(RestConstants.CONTENT_TYPE, produces);
    }
    final String consumes = getEndpoint().getConsumes();
    if (isEmpty(inMessage.getHeader(RestConstants.ACCEPT)) && isNotEmpty(consumes)) {
        inMessage.setHeader(RestConstants.ACCEPT, consumes);
    }
}",java:S112,4
"protected AsyncProcessor createBindingProcessor() throws Exception{
    String mode = configuration.getBindingMode().name();
    if (bindingMode != null) {
        mode = bindingMode.name();
    }
    boolean skip = configuration.isSkipBindingOnErrorCode();
    if (skipBindingOnErrorCode != null) {
        skip = skipBindingOnErrorCode;
    }
    if (""off"".equals(mode)) {
        return null;
    }
    String name = configuration.getJsonDataFormat();
    if (name != null) {
        Object instance = camelContext.getRegistry().lookupByName(name);
        if (instance != null) {
            throw new IllegalArgumentException(""JsonDataFormat name: "" + name + "" must not be an existing bean instance from the registry"");
        }
    } else {
        name = ""jackson"";
    }
    DataFormat json = camelContext.createDataFormat(name);
    DataFormat outJson = camelContext.createDataFormat(name);
    if (mode.contains(""json"") && json == null) {
        throw new IllegalArgumentException(""JSON DataFormat "" + name + "" not found."");
    }
    if (json != null) {
        PropertyConfigurer configurer = PluginHelper.getConfigurerResolver(camelContext).resolvePropertyConfigurer(name + ""-dataformat-configurer"", camelContext);
        if (configurer == null) {
            throw new IllegalStateException(""Cannot find configurer for dataformat: "" + name);
        }
        PropertyBindingSupport.Builder builder = PropertyBindingSupport.build().withCamelContext(camelContext).withConfigurer(configurer).withTarget(json);
        if (type != null) {
            String typeName = type.endsWith(""[]"") ? type.substring(0, type.length() - 2) : type;
            builder.withProperty(""unmarshalType"", typeName);
            builder.withProperty(""useList"", type.endsWith(""[]""));
        }
        setAdditionalConfiguration(configuration, ""json.in."", builder);
        builder.bind();
        builder = PropertyBindingSupport.build().withCamelContext(camelContext).withConfigurer(configurer).withTarget(outJson);
        if (outType != null) {
            String typeName = outType.endsWith(""[]"") ? outType.substring(0, outType.length() - 2) : outType;
            builder.withProperty(""unmarshalType"", typeName);
            builder.withProperty(""useList"", outType.endsWith(""[]""));
        }
        setAdditionalConfiguration(configuration, ""json.out."", builder);
        builder.bind();
    }
    name = configuration.getXmlDataFormat();
    if (name != null) {
        Object instance = camelContext.getRegistry().lookupByName(name);
        if (instance != null) {
            throw new IllegalArgumentException(""XmlDataFormat name: "" + name + "" must not be an existing bean instance from the registry"");
        }
    } else {
        name = ""jaxb"";
    }
    DataFormat jaxb = camelContext.createDataFormat(name);
    DataFormat outJaxb = camelContext.createDataFormat(name);
    if (mode.contains(""xml"") && jaxb == null) {
        throw new IllegalArgumentException(""XML DataFormat "" + name + "" not found."");
    }
    if (jaxb != null) {
        PluginHelper.getRestBindingJaxbDataFormatFactory(camelContext).setupJaxb(camelContext, configuration, type, null, outType, null, jaxb, outJaxb);
    }
    return new RestProducerBindingProcessor(producer, camelContext, json, jaxb, outJson, outJaxb, mode, skip, outType);
}",java:S3776,39
" static String createQueryParameters(String query, Message inMessage) throws URISyntaxException, UnsupportedEncodingException{
    if (query != null) {
        final Map<String, Object> givenParams = URISupport.parseQuery(query);
        final Map<String, Object> params = new LinkedHashMap<>(givenParams.size());
        for (Map.Entry<String, Object> entry : givenParams.entrySet()) {
            Object v = entry.getValue();
            if (v != null) {
                String a = v.toString();
                a = URLDecoder.decode(a, ""UTF-8"");
                if (a.startsWith(""{"") && a.endsWith(""}"")) {
                    String key = a.substring(1, a.length() - 1);
                    boolean optional = false;
                    if (key.endsWith(""?"")) {
                        key = key.substring(0, key.length() - 1);
                        optional = true;
                    }
                    Object value = inMessage.getHeader(key);
                    if (value != null) {
                        params.put(entry.getKey(), value);
                    } else if (!optional) {
                        params.put(entry.getKey(), entry.getValue());
                    }
                } else {
                    params.put(entry.getKey(), entry.getValue());
                }
            }
        }
        query = URISupport.createQueryString(params);
        while (query.endsWith(""&"")) {
            query = query.substring(0, query.length() - 1);
        }
    }
    return query;
}",java:S3776,39
"private void doDone(){
    if (exchange.getException() != null) {
        return;
    }
    if (skipBindingOnErrorCode) {
        Integer code = exchange.getMessage().getHeader(RestConstants.HTTP_RESPONSE_CODE, Integer.class);
        if (code != null && code >= 300) {
            return;
        }
    }
    boolean isXml = false;
    boolean isJson = false;
    String contentType = ExchangeHelper.getContentType(exchange);
    if (contentType != null) {
        isXml = contentType.toLowerCase(Locale.ENGLISH).contains(""xml"");
        isJson = contentType.toLowerCase(Locale.ENGLISH).contains(""json"");
    }
    if (bindingMode != null) {
        isXml &= bindingMode.equals(""off"") || bindingMode.equals(""auto"") || bindingMode.contains(""xml"");
        isJson &= bindingMode.equals(""off"") || bindingMode.equals(""auto"") || bindingMode.contains(""json"");
        if (!isJson && !isXml) {
            isXml = bindingMode.equals(""auto"") || bindingMode.contains(""xml"");
            isJson = bindingMode.equals(""auto"") || bindingMode.contains(""json"");
        }
    }
    if (isXml && isJson) {
        isXml = wasXml;
        isJson = !wasXml;
    }
    ExchangeHelper.prepareOutToIn(exchange);
    ensureHeaderContentType(isXml, isJson, exchange);
    if (bindingMode == null || ""off"".equals(bindingMode)) {
        return;
    }
    if (jsonUnmarshal == null && xmlUnmarshal == null) {
        return;
    }
    if (exchange.hasOut() && exchange.getOut().getBody() == null || !exchange.hasOut() && exchange.getIn().getBody() == null) {
        return;
    }
    contentType = exchange.getIn().getHeader(RestConstants.CONTENT_TYPE, String.class);
    contentType = contentType.toLowerCase(Locale.US);
    try {
        if (isJson && jsonUnmarshal != null) {
            if (contentType.contains(""json"")) {
                jsonUnmarshal.process(exchange);
            }
        } else if (isXml && xmlUnmarshal != null) {
            if (contentType.contains(""xml"")) {
                xmlUnmarshal.process(exchange);
            }
        } else {
            if (bindingMode.equals(""auto"")) {
            } else {
                if (bindingMode.contains(""xml"")) {
                    exchange.setException(new CamelExchangeException(""Cannot bind from xml as message body is not xml compatible"", exchange));
                } else {
                    exchange.setException(new CamelExchangeException(""Cannot bind from json as message body is not json compatible"", exchange));
                }
            }
        }
    } catch (Exception e) {
        exchange.setException(e);
    }
}",java:S3776,39
"public static SyndFeed createFeed(String feedUri, ClassLoader classLoader) throws Exception{
    ClassLoader tccl = Thread.currentThread().getContextClassLoader();
    try {
        Thread.currentThread().setContextClassLoader(classLoader);
        return createSyndFeed(feedUri);
    } finally {
        Thread.currentThread().setContextClassLoader(tccl);
    }
}",java:S112,4
"private SalesforceHttpClient createHttpClient() throws Exception{
    final SalesforceHttpClient httpClient;
    CamelContext camelContext = new DefaultCamelContext();
    try {
        final SslContextFactory.Client sslContextFactory = new SslContextFactory.Client();
        sslContextFactory.setSslContext(sslContextParameters.createSSLContext(camelContext));
        SecurityUtils.adaptToIBMCipherNames(sslContextFactory);
        httpClient = new SalesforceHttpClient(sslContextFactory);
    } catch (GeneralSecurityException | IOException e) {
        throw new RuntimeException(""Error creating default SSL context: "" + e.getMessage(), e);
    }
    httpClient.setConnectTimeout(DEFAULT_TIMEOUT);
    httpClient.setTimeout(DEFAULT_TIMEOUT);
    httpClient.setFollowRedirects(true);
    if (httpClientProperties != null && !httpClientProperties.isEmpty()) {
        try {
            PropertyBindingSupport.bindProperties(camelContext, httpClient, new HashMap<>(httpClientProperties));
        } catch (final Exception e) {
            throw new RuntimeException(""Error setting HTTP client properties: "" + e.getMessage(), e);
        }
    }
    responseTimeout = httpClient.getTimeout() + 1000L;
    if (httpProxyHost != null && httpProxyPort != null) {
        final Origin.Address proxyAddress = new Origin.Address(httpProxyHost, httpProxyPort);
        ProxyConfiguration.Proxy proxy;
        if (isHttpProxySocks4) {
            proxy = new Socks4Proxy(proxyAddress, isHttpProxySecure);
        } else {
            proxy = new HttpProxy(proxyAddress, isHttpProxySecure);
        }
        if (httpProxyIncludedAddresses != null && !httpProxyIncludedAddresses.isEmpty()) {
            proxy.getIncludedAddresses().addAll(httpProxyIncludedAddresses);
        }
        if (httpProxyExcludedAddresses != null && !httpProxyExcludedAddresses.isEmpty()) {
            proxy.getExcludedAddresses().addAll(httpProxyExcludedAddresses);
        }
        httpClient.getProxyConfiguration().addProxy(proxy);
    }
    if (httpProxyUsername != null && httpProxyPassword != null) {
        StringHelper.notEmpty(httpProxyAuthUri, ""httpProxyAuthUri"");
        StringHelper.notEmpty(httpProxyRealm, ""httpProxyRealm"");
        final Authentication authentication;
        if (httpProxyUseDigestAuth) {
            authentication = new DigestAuthentication(URI.create(httpProxyAuthUri), httpProxyRealm, httpProxyUsername, httpProxyPassword);
        } else {
            authentication = new BasicAuthentication(URI.create(httpProxyAuthUri), httpProxyRealm, httpProxyUsername, httpProxyPassword);
        }
        httpClient.getAuthenticationStore().addAuthentication(authentication);
    }
    final SalesforceSession session = new SalesforceSession(new DefaultCamelContext(), httpClient, httpClient.getTimeout(), new SalesforceLoginConfig(loginUrl, clientId, clientSecret, userName, password, false));
    httpClient.setSession(session);
    try {
        httpClient.start();
    } catch (final Exception e) {
        throw new RuntimeException(""Error creating HTTP client: "" + e.getMessage(), e);
    }
    return httpClient;
}",java:S3776,39
"public String getFieldType(final SObjectDescription description, final SObjectField field){
    if (isPicklist(field)) {
        if (Boolean.TRUE.equals(useStringsForPicklists)) {
            if (picklistsEnumToSObject.containsKey(description.getName()) && picklistsEnumToSObject.get(description.getName()).contains(field.getName())) {
                return enumTypeName(description.getName(), field.getName());
            }
            return String.class.getName();
        } else if (picklistsStringToSObject.containsKey(description.getName()) && picklistsStringToSObject.get(description.getName()).contains(field.getName())) {
            return String.class.getName();
        }
        return enumTypeName(description.getName(), field.getName());
    } else if (isMultiSelectPicklist(field)) {
        if (Boolean.TRUE.equals(useStringsForPicklists)) {
            if (picklistsEnumToSObject.containsKey(description.getName()) && picklistsEnumToSObject.get(description.getName()).contains(field.getName())) {
                return enumTypeName(description.getName(), field.getName()) + ""[]"";
            }
            return String.class.getName() + ""[]"";
        } else if (picklistsStringToSObject.containsKey(description.getName()) && picklistsStringToSObject.get(description.getName()).contains(field.getName())) {
            return String.class.getName() + ""[]"";
        }
        return enumTypeName(description.getName(), field.getName()) + ""[]"";
    } else {
        final String soapType = field.getSoapType();
        final String lookupType = soapType.substring(soapType.indexOf(':') + 1);
        final String type = types.get(lookupType);
        if (type == null) {
            getLog().warn(String.format(""Unsupported field type `%s` in field `%s` of object `%s`"", soapType, field.getName(), description.getName()));
            getLog().debug(""Currently known types:\n "" + types.entrySet().stream().map(e -> e.getKey() + ""="" + e.getValue()).collect(Collectors.joining(""\n"")));
        }
        return type;
    }
}",java:S3776,39
"private static void filterObjectNames(final Set<String> objectNames, final String[] includes, final String includePattern, final String[] excludes, final String excludePattern, final Logger log) throws Exception{
    log.info(""Looking for matching Object names..."");
    final Set<String> includedNames = new HashSet<>();
    if (includes != null && includes.length > 0) {
        for (String name : includes) {
            name = name.trim();
            if (name.isEmpty()) {
                throw new RuntimeException(""Invalid empty name in includes"");
            }
            includedNames.add(name);
        }
    }
    final Set<String> excludedNames = new HashSet<>();
    if (excludes != null && excludes.length > 0) {
        for (String name : excludes) {
            name = name.trim();
            if (name.isEmpty()) {
                throw new RuntimeException(""Invalid empty name in excludes"");
            }
            excludedNames.add(name);
        }
    }
    Pattern incPattern;
    if (includePattern != null && !includePattern.trim().isEmpty()) {
        incPattern = Pattern.compile(includePattern.trim());
    } else if (includedNames.isEmpty()) {
        incPattern = Defaults.MATCH_EVERYTHING_PATTERN;
    } else {
        incPattern = Defaults.MATCH_NOTHING_PATTERN;
    }
    Pattern excPattern;
    if (excludePattern != null && !excludePattern.trim().isEmpty()) {
        excPattern = Pattern.compile(excludePattern.trim());
    } else {
        excPattern = Defaults.MATCH_NOTHING_PATTERN;
    }
    final Set<String> acceptedNames = new HashSet<>();
    for (final String name : objectNames) {
        if ((includedNames.contains(name) || incPattern.matcher(name).matches()) && !excludedNames.contains(name) && !excPattern.matcher(name).matches()) {
            acceptedNames.add(name);
        }
    }
    objectNames.clear();
    objectNames.addAll(acceptedNames);
    log.info(String.format(""Found %s matching Objects"", objectNames.size()));
}",java:S3776,39
"public void processEvent(Object record, String replayId) throws IOException{
    final Exchange exchange = createExchange(true);
    final Message in = exchange.getIn();
    in.setBody(record);
    in.setHeader(HEADER_SALESFORCE_PUBSUB_REPLAY_ID, replayId);
    AsyncCallback cb = defaultConsumerCallback(exchange, true);
    getAsyncProcessor().process(exchange, cb);
}",java:S6213,47
"public void processEvent(Object record, String replayId) throws IOException{
    final Exchange exchange = createExchange(true);
    final Message in = exchange.getIn();
    in.setBody(record);
    in.setHeader(HEADER_SALESFORCE_PUBSUB_REPLAY_ID, replayId);
    AsyncCallback cb = defaultConsumerCallback(exchange, true);
    getAsyncProcessor().process(exchange, cb);
}",java:S1130,7
"public SubscriptionHelper getSubscriptionHelper() throws Exception{
    if (subscriptionHelper == null) {
        subscriptionHelper = new SubscriptionHelper(this);
    }
    return subscriptionHelper;
}",java:S112,4
"public SubscriptionHelper getSubscriptionHelper() throws Exception{
    if (subscriptionHelper == null) {
        subscriptionHelper = new SubscriptionHelper(this);
    }
    return subscriptionHelper;
}",java:S1130,7
" RestClient createRestClient(final Map<String, Object> properties) throws Exception{
    final SalesforceEndpointConfig modifiedConfig = Optional.ofNullable(config).map(SalesforceEndpointConfig::copy).orElseGet(() -> new SalesforceEndpointConfig());
    final CamelContext camelContext = getCamelContext();
    PropertyBindingSupport.bindProperties(camelContext, modifiedConfig, properties);
    return createRestClientFor(modifiedConfig);
}",java:S112,4
"public RawClient createRawClientFor(SalesforceEndpoint endpoint) throws SalesforceException{
    return new DefaultRawClient(httpClient, """", session, loginConfig);
}",java:S1172,13
" static SalesforceHttpClient setupHttpClient(final SalesforceHttpClient httpClient, final CamelContext camelContext, final Map<String, Object> httpClientProperties) throws Exception{
    if (httpClientProperties == null || httpClientProperties.isEmpty()) {
        return httpClient;
    }
    final TypeConverter typeConverter = camelContext.getTypeConverter();
    PropertyBindingSupport.bindProperties(camelContext, httpClient, new HashMap<>(httpClientProperties));
    final Long httpConnectionTimeout = typeConverter.convertTo(Long.class, httpClientProperties.get(HTTP_CONNECTION_TIMEOUT));
    final Long httpIdleTimeout = typeConverter.convertTo(Long.class, httpClientProperties.get(HTTP_IDLE_TIMEOUT));
    final Long httpRequestTimeout = typeConverter.convertTo(Long.class, httpClientProperties.get(HTTP_REQUEST_TIMEOUT));
    final Integer maxContentLength = typeConverter.convertTo(Integer.class, httpClientProperties.get(HTTP_MAX_CONTENT_LENGTH));
    Integer requestBufferSize = typeConverter.convertTo(Integer.class, httpClientProperties.get(HTTP_REQUEST_BUFFER_SIZE));
    if (requestBufferSize == null) {
        requestBufferSize = REQUEST_BUFFER_SIZE;
    }
    final String httpProxyHost = typeConverter.convertTo(String.class, httpClientProperties.get(HTTP_PROXY_HOST));
    final Integer httpProxyPort = typeConverter.convertTo(Integer.class, httpClientProperties.get(HTTP_PROXY_PORT));
    final boolean isHttpProxySocks4 = typeConverter.convertTo(boolean.class, httpClientProperties.get(HTTP_PROXY_IS_SOCKS4));
    final boolean isHttpProxySecure = typeConverter.convertTo(boolean.class, httpClientProperties.get(HTTP_PROXY_IS_SECURE));
    @SuppressWarnings(""unchecked"")
    final Set<String> httpProxyIncludedAddresses = (Set<String>) httpClientProperties.get(HTTP_PROXY_INCLUDE);
    @SuppressWarnings(""unchecked"")
    final Set<String> httpProxyExcludedAddresses = (Set<String>) httpClientProperties.get(HTTP_PROXY_EXCLUDE);
    final String httpProxyUsername = typeConverter.convertTo(String.class, httpClientProperties.get(HTTP_PROXY_USERNAME));
    final String httpProxyPassword = typeConverter.convertTo(String.class, httpClientProperties.get(HTTP_PROXY_PASSWORD));
    final String httpProxyAuthUri = typeConverter.convertTo(String.class, httpClientProperties.get(HTTP_PROXY_AUTH_URI));
    final String httpProxyRealm = typeConverter.convertTo(String.class, httpClientProperties.get(HTTP_PROXY_REALM));
    final boolean httpProxyUseDigestAuth = typeConverter.convertTo(boolean.class, httpClientProperties.get(HTTP_PROXY_USE_DIGEST_AUTH));
    if (httpIdleTimeout != null) {
        httpClient.setIdleTimeout(httpIdleTimeout);
    }
    if (httpConnectionTimeout != null) {
        httpClient.setConnectTimeout(httpConnectionTimeout);
    }
    if (maxContentLength != null) {
        httpClient.setMaxContentLength(maxContentLength);
    }
    if (httpRequestTimeout != null) {
        httpClient.setTimeout(httpRequestTimeout);
    }
    httpClient.setRequestBufferSize(requestBufferSize);
    if (httpProxyHost != null && httpProxyPort != null) {
        Origin.Address proxyAddress = new Origin.Address(httpProxyHost, httpProxyPort);
        ProxyConfiguration.Proxy proxy;
        if (isHttpProxySocks4) {
            proxy = new Socks4Proxy(proxyAddress, isHttpProxySecure);
        } else {
            proxy = new HttpProxy(proxyAddress, isHttpProxySecure);
        }
        if (httpProxyIncludedAddresses != null && !httpProxyIncludedAddresses.isEmpty()) {
            proxy.getIncludedAddresses().addAll(httpProxyIncludedAddresses);
        }
        if (httpProxyExcludedAddresses != null && !httpProxyExcludedAddresses.isEmpty()) {
            proxy.getExcludedAddresses().addAll(httpProxyExcludedAddresses);
        }
        httpClient.getProxyConfiguration().getProxies().add(proxy);
    }
    if (httpProxyUsername != null && httpProxyPassword != null) {
        StringHelper.notEmpty(httpProxyAuthUri, ""httpProxyAuthUri"");
        StringHelper.notEmpty(httpProxyRealm, ""httpProxyRealm"");
        final Authentication authentication;
        if (httpProxyUseDigestAuth) {
            authentication = new DigestAuthentication(new URI(httpProxyAuthUri), httpProxyRealm, httpProxyUsername, httpProxyPassword);
        } else {
            authentication = new BasicAuthentication(new URI(httpProxyAuthUri), httpProxyRealm, httpProxyUsername, httpProxyPassword);
        }
        httpClient.getAuthenticationStore().addAuthentication(authentication);
    }
    return httpClient;
}",java:S3776,39
"public AuthenticationType getType(){
    if (type != null) {
        return type;
    }
    final boolean hasPassword = ObjectHelper.isNotEmpty(password);
    final boolean hasRefreshToken = ObjectHelper.isNotEmpty(refreshToken);
    final boolean hasKeystore = keystore != null && ObjectHelper.isNotEmpty(keystore.getResource());
    final boolean hasClientCredentials = ObjectHelper.isNotEmpty(clientId) && ObjectHelper.isNotEmpty(clientSecret);
    if (hasPassword && !hasRefreshToken && !hasKeystore) {
        return AuthenticationType.USERNAME_PASSWORD;
    }
    if (!hasPassword && hasRefreshToken && !hasKeystore) {
        return AuthenticationType.REFRESH_TOKEN;
    }
    if (!hasPassword && !hasRefreshToken && hasKeystore) {
        return AuthenticationType.JWT;
    }
    if (!hasPassword && !hasRefreshToken && !hasKeystore && hasClientCredentials) {
        return AuthenticationType.CLIENT_CREDENTIALS;
    }
    if (hasPassword && hasRefreshToken || hasPassword && hasKeystore || hasRefreshToken && hasKeystore) {
        throw new IllegalArgumentException(""The provided authentication configuration can be used in multiple ways"" + "" for instance both with username/password and refresh_token. Either remove some of the configuration"" + "" options, so that authentication method can be auto-determined or explicitly set the authentication"" + "" type."");
    }
    throw new IllegalArgumentException(""You must specify parameters aligned with one of the supported authentication methods:"" + "" for username and password authentication: userName, password, clientSecret;"" + "" for refresh token authentication: refreshToken, clientSecret;"" + "" for JWT: userName, keystore. And for every one of those loginUrl and clientId must be specified also."");
}",java:S3776,39
" void determineSObjectClass(){
    if (!rawPayload) {
        final String sObjectName = endpoint.getConfiguration().getSObjectName();
        if (sObjectName != null) {
            sObjectClass = endpoint.getComponent().getClassMap().get(sObjectName);
            if (sObjectClass == null) {
                throw new IllegalArgumentException(String.format(""SObject Class not found for %s"", sObjectName));
            }
        } else {
            final String className = endpoint.getConfiguration().getSObjectClass();
            if (className != null) {
                sObjectClass = endpoint.getComponent().getCamelContext().getClassResolver().resolveClass(className);
                if (sObjectClass == null) {
                    throw new IllegalArgumentException(String.format(""SObject Class not found %s"", className));
                }
            } else {
                LOG.warn(""Property sObjectName or sObjectClass NOT set, messages will be of type java.lang.Map"");
                sObjectClass = null;
            }
        }
    } else {
        sObjectClass = null;
    }
}",java:S3776,39
"private static void addMatrixGroupValues(ArrayList<List<String>> result, AbstractReportResultsBase reportResults, String[] columnNames, GroupingValue groupingValue, List<String> rowPrefix, boolean includeDetails, boolean includeSummary, String keyPrefix, boolean downGroup){
    final String groupKey = groupingValue.getKey();
    final String newKeyPrefix = keyPrefix + groupKey;
    final List<String> newPrefix = new ArrayList<>(rowPrefix);
    newPrefix.add(groupingValue.getLabel());
    final GroupingValue[] groupings = groupingValue.getGroupings();
    if (groupings.length > 0) {
        for (GroupingValue subGroup : groupings) {
            addMatrixGroupValues(result, reportResults, columnNames, subGroup, newPrefix, includeDetails, includeSummary, newKeyPrefix + ""_"", downGroup);
        }
    } else if (downGroup) {
        for (GroupingValue acrossGroup : reportResults.getGroupingsAcross().getGroupings()) {
            addMatrixGroupValues(result, reportResults, columnNames, acrossGroup, newPrefix, includeDetails, includeSummary, newKeyPrefix + ""!"", false);
        }
    } else if (includeDetails) {
        addDetailRows(result, newPrefix, reportResults.getFactMap().get(newKeyPrefix));
    } else if (!includeSummary) {
        result.add(newPrefix);
    }
    if (includeSummary) {
        final String summaryKey = getGroupTotalKey(keyPrefix, downGroup, groupKey);
        addSummaryValues(result, includeDetails, columnNames, newPrefix, reportResults.getReportMetadata().getAggregates(), reportResults.getFactMap().get(summaryKey).getAggregates());
    }
}",java:S107,1
"private static void addSummaryRows(List<List<String>> result, String[] detailColumns, List<String> rowPrefix, String[] aggregateColumns, SummaryValue[] summaryValues){
    final ArrayList<List<String>> rows = new ArrayList<>(summaryValues.length + 1);
    String rowCount = null;
    for (int i = 0; i < aggregateColumns.length; i++) {
        final String aggregate = aggregateColumns[i];
        final String valueLabel = summaryValues[i].getLabel();
        if (ROW_COUNT.equals(aggregate)) {
            rowCount = valueLabel;
        } else {
            final List<String> summaryRow = rowPrefix == null ? new ArrayList<>() : new ArrayList<>(rowPrefix);
            rows.add(summaryRow);
            for (int j = rowPrefix == null ? 0 : rowPrefix.size(); j < detailColumns.length; j++) {
                final String columnName = detailColumns[j];
                if (aggregate.endsWith(""!"" + columnName)) {
                    final StringBuilder valueBuilder = new StringBuilder();
                    if (aggregate.startsWith(""a!"")) {
                        valueBuilder.append(""avg "");
                    } else if (aggregate.startsWith(""mx!"")) {
                        valueBuilder.append(""max "");
                    } else if (aggregate.startsWith(""m!"")) {
                        valueBuilder.append(""min "");
                    }
                    valueBuilder.append(valueLabel);
                    summaryRow.add(valueBuilder.toString());
                } else {
                    summaryRow.add(EMPTY_VALUE);
                }
            }
        }
    }
    final List<String> grandTotal = new ArrayList<>();
    result.add(grandTotal);
    if (rowCount != null) {
        grandTotal.add(""Grand Totals ("" + rowCount + "" records)"");
    } else {
        grandTotal.add(""Grand Totals"");
    }
    result.addAll(rows);
}",java:S3776,39
"public static Set<JsonSchema> getSObjectJsonSchema(ObjectMapper objectMapper, SObjectDescription description, String idPrefix, boolean addQuerySchema) throws JsonProcessingException{
    Set<JsonSchema> allSchemas = new HashSet<>();
    ObjectSchema sobjectSchema = new ObjectSchema();
    sobjectSchema.setId(idPrefix + "":"" + description.getName());
    sobjectSchema.setTitle(description.getLabel());
    SimpleTypeSchema addressSchema = null;
    SimpleTypeSchema geoLocationSchema = null;
    for (SObjectField field : description.getFields()) {
        SimpleTypeSchema fieldSchema = new NullSchema();
        String soapType = field.getSoapType();
        switch(soapType.substring(soapType.indexOf(':') + 1)) {
            case ""ID"":
            case ""string"":
            case ""base64Binary"":
            case ""anyType"":
                fieldSchema = new StringSchema();
                break;
            case ""integer"":
            case ""int"":
            case ""long"":
            case ""short"":
            case ""byte"":
            case ""unsignedInt"":
            case ""unsignedShort"":
            case ""unsignedByte"":
                fieldSchema = new IntegerSchema();
                break;
            case ""decimal"":
            case ""float"":
            case ""double"":
                fieldSchema = new NumberSchema();
                break;
            case ""boolean"":
                fieldSchema = new BooleanSchema();
                break;
            case ""date"":
                fieldSchema = new StringSchema();
                ((StringSchema) fieldSchema).setFormat(JsonValueFormat.DATE);
                break;
            case ""dateTime"":
            case ""g"":
                fieldSchema = new StringSchema();
                ((StringSchema) fieldSchema).setFormat(JsonValueFormat.DATE_TIME);
                break;
            case ""time"":
                fieldSchema = new StringSchema();
                ((StringSchema) fieldSchema).setFormat(JsonValueFormat.TIME);
                break;
            case ""address"":
                if (addressSchema == null) {
                    addressSchema = getSchemaFromClass(objectMapper, Address.class);
                }
                fieldSchema = addressSchema;
                break;
            case ""location"":
                if (geoLocationSchema == null) {
                    geoLocationSchema = getSchemaFromClass(objectMapper, GeoLocation.class);
                }
                fieldSchema = geoLocationSchema;
                break;
            default:
                throw new IllegalArgumentException(""Unsupported type "" + soapType);
        }
        List<PickListValue> picklistValues = field.getPicklistValues();
        switch(field.getType()) {
            case ""picklist"":
                fieldSchema.asStringSchema().setEnums(picklistValues == null ? Collections.emptySet() : picklistValues.stream().map(PickListValue::getValue).distinct().collect(Collectors.toSet()));
                break;
            case ""multipicklist"":
                fieldSchema.asStringSchema().setPattern(picklistValues == null ? """" : picklistValues.stream().map(val -> ""(,?("" + val.getValue() + ""))"").distinct().collect(joining(""|"", ""("", "")"")));
                break;
            default:
        }
        fieldSchema.setTitle(field.getLabel());
        fieldSchema.setDefault(field.getDefaultValue());
        if (field.isUpdateable() != null) {
            fieldSchema.setReadonly(!field.isUpdateable());
        }
        final String descriptionText = Arrays.asList(new Object[] { ""unique"", field.isUnique() }, new Object[] { ""idLookup"", field.isIdLookup() }, new Object[] { ""autoNumber"", field.isAutoNumber() }, new Object[] { ""calculated"", field.isCalculated() }).stream().filter(ary -> Boolean.TRUE.equals(ary[1])).map(ary -> String.valueOf(ary[0])).collect(Collectors.joining("",""));
        fieldSchema.setDescription(descriptionText);
        if (field.isNillable()) {
            sobjectSchema.putOptionalProperty(field.getName(), fieldSchema);
        } else {
            sobjectSchema.putProperty(field.getName(), fieldSchema);
        }
    }
    allSchemas.add(sobjectSchema);
    if (addQuerySchema) {
        ObjectSchema queryRecords = getSchemaFromClass(objectMapper, AbstractQueryRecordsBase.class);
        queryRecords.setId(idPrefix + "":QueryRecords"" + description.getName());
        ObjectSchema refSchema = new ObjectSchema();
        refSchema.set$ref(sobjectSchema.getId());
        ArraySchema recordsProperty = new ArraySchema();
        recordsProperty.setItems(new ArraySchema.SingleItems(refSchema));
        queryRecords.putProperty(""records"", recordsProperty);
        allSchemas.add(queryRecords);
    }
    return allSchemas;
}",java:S3776,39
"public void attemptLoginUntilSuccessful(long backoffIncrement, long maxBackoff){
    if (!loggingIn.compareAndSet(false, true)) {
        LOG.debug(""waiting on login from another thread"");
        try {
            while (latch == null) {
                Thread.sleep(100);
            }
            latch.await();
        } catch (InterruptedException ex) {
            throw new RuntimeException(""Failed to login."", ex);
        }
        LOG.debug(""done waiting"");
        return;
    }
    LOG.debug(""Attempting to login, no other threads logging in"");
    latch = new CountDownLatch(1);
    long backoff = 0;
    try {
        for (; ; ) {
            try {
                if (isStoppingOrStopped()) {
                    return;
                }
                login(getAccessToken());
                break;
            } catch (SalesforceException e) {
                backoff = backoff + backoffIncrement;
                if (backoff > maxBackoff) {
                    backoff = maxBackoff;
                }
                LOG.warn(String.format(""Salesforce login failed. Pausing for %d milliseconds"", backoff), e);
                try {
                    Thread.sleep(backoff);
                } catch (InterruptedException ex) {
                    throw new RuntimeException(""Failed to login."", ex);
                }
            }
        }
    } finally {
        loggingIn.set(false);
        latch.countDown();
    }
}",java:S3776,39
"protected void doHttpRequest(final Request request, final ClientResponseCallback callback){
    final ContentProvider content = request.getContent();
    if (content instanceof InputStreamContentProvider) {
        final List<ByteBuffer> buffers = new ArrayList<>();
        for (ByteBuffer buffer : content) {
            buffers.add(buffer);
        }
        request.content(new ByteBufferContentProvider(buffers.toArray(new ByteBuffer[0])));
        buffers.clear();
    }
    inflightRequests.register();
    request.send(new BufferingResponseListener(httpClient.getMaxContentLength()) {

        @Override
        public void onComplete(Result result) {
            try {
                Response response = result.getResponse();
                final Map<String, String> headers = determineHeadersFrom(response);
                if (result.isFailed()) {
                    Throwable failure = result.getFailure();
                    if (failure instanceof SalesforceException) {
                        httpClient.getWorkerPool().execute(() -> callback.onResponse(null, headers, (SalesforceException) failure));
                    } else {
                        final String msg = String.format(""Unexpected error {%s:%s} executing {%s:%s}"", response.getStatus(), response.getReason(), request.getMethod(), request.getURI());
                        httpClient.getWorkerPool().execute(() -> callback.onResponse(null, headers, new SalesforceException(msg, response.getStatus(), failure)));
                    }
                } else {
                    final int status = response.getStatus();
                    SalesforceHttpRequest request = (SalesforceHttpRequest) ((SalesforceHttpRequest) result.getRequest()).getConversation().getAttribute(SalesforceSecurityHandler.AUTHENTICATION_REQUEST_ATTRIBUTE);
                    if (status == HttpStatus.BAD_REQUEST_400 && request != null) {
                        ContentResponse contentResponse = new HttpContentResponse(response, getContent(), getMediaType(), getEncoding());
                        try {
                            session.parseLoginResponse(contentResponse, getContentAsString());
                            final String msg = String.format(""Unexpected Error {%s:%s} executing {%s:%s}"", status, response.getReason(), request.getMethod(), request.getURI());
                            httpClient.getWorkerPool().execute(() -> callback.onResponse(null, headers, new SalesforceException(msg, null)));
                        } catch (SalesforceException e) {
                            final String msg = String.format(""Error {%s:%s} executing {%s:%s}"", status, response.getReason(), request.getMethod(), request.getURI());
                            httpClient.getWorkerPool().execute(() -> callback.onResponse(null, headers, new SalesforceException(msg, response.getStatus(), e)));
                        }
                    } else if (status < HttpStatus.OK_200 || status >= HttpStatus.MULTIPLE_CHOICES_300) {
                        final SalesforceException exception = createRestException(response, getContentAsInputStream());
                        httpClient.getWorkerPool().execute(() -> callback.onResponse(getContentAsInputStream(), headers, exception));
                    } else {
                        httpClient.getWorkerPool().execute(() -> callback.onResponse(getContentAsInputStream(), headers, null));
                    }
                }
            } finally {
                inflightRequests.arriveAndDeregister();
            }
        }

        @Override
        public InputStream getContentAsInputStream() {
            if (getContent().length == 0) {
                return null;
            }
            return super.getContentAsInputStream();
        }
    });
}",java:S3776,39
"protected SalesforceException createRestException(Response response, InputStream responseContent){
    final int statusCode = response.getStatus();
    String reason = response.getReason();
    if (reason == null || reason.isEmpty()) {
        reason = HttpStatus.getMessage(statusCode);
    }
    try {
        if (responseContent != null && responseContent.available() > 0) {
            final List<String> choices;
            if (statusCode == HttpStatus.MULTIPLE_CHOICES_300) {
                choices = objectMapper.readValue(responseContent, TypeReferences.STRING_LIST_TYPE);
                return new SalesforceMultipleChoicesException(reason, statusCode, choices);
            } else {
                List<RestError> restErrors = null;
                String body = null;
                try {
                    restErrors = readErrorsFrom(responseContent, objectMapper);
                } catch (IOException ignored) {
                }
                try {
                    responseContent.reset();
                    body = IOUtils.toString(responseContent, StandardCharsets.UTF_8);
                    responseContent.reset();
                } catch (Exception t) {
                    log.warn(""Unable to reset HTTP response content input stream."");
                }
                if (statusCode == HttpStatus.NOT_FOUND_404) {
                    return new NoSuchSObjectException(restErrors);
                }
                return new SalesforceException(restErrors, statusCode, ""Unexpected error: "" + reason + "". See exception `errors` property for detail. "" + body, responseContent);
            }
        }
    } catch (IOException | RuntimeException e) {
        String msg = ""Unexpected Error parsing error response body + ["" + responseContent + ""] : "" + e.getMessage();
        log.warn(msg, e);
    }
    return new SalesforceException(""Unexpected error: "" + reason + "", with content: "" + responseContent, statusCode);
}",java:S3776,39
" ContentProvider serialize(final Object body, final Class<?>... additionalTypes) throws SalesforceException{
    return new InputStreamContentProvider(toJson(body));
}",java:S1172,13
" ContentProvider serialize(final Object body, final Class<?>... additionalTypes) throws SalesforceException{
    return new InputStreamContentProvider(toJson(body));
}",java:S1874,25
"private ContentProvider serialize(final Object body) throws SalesforceException{
    return new InputStreamContentProvider(toJson(body));
}",java:S1874,25
"public void setCloudWatchClient(CloudWatchClient cloudWatchClient){
    this.cloudWatchClient = cloudWatchClient;
}",java:S125,21
"protected final T getParameter(final String propName, final Exchange exchange, final boolean convertInBody, final boolean optional, final Class<T> parameterClass) throws SalesforceException{
    final Message in = exchange.getIn();
    T propValue = in.getHeader(propName, parameterClass);
    if (propValue == null) {
        if (in.getHeader(propName) != null) {
            throw new IllegalArgumentException(""Header "" + propName + "" could not be converted to type "" + parameterClass.getName());
        }
        final Object value = endpointConfigMap.get(propName);
        if (value == null || parameterClass.isInstance(value)) {
            propValue = parameterClass.cast(value);
        } else {
            try {
                propValue = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterClass, value);
            } catch (final NoTypeConversionAvailableException e) {
                throw new SalesforceException(e);
            }
        }
    }
    propValue = propValue == null && convertInBody ? in.getBody(parameterClass) : propValue;
    if (propValue == null && !optional) {
        final String msg = ""Missing property "" + propName + (convertInBody ? "", message body could not be converted to type "" + parameterClass.getName() : """");
        throw new SalesforceException(msg, null);
    }
    return propValue;
}",java:S3776,39
"private void processPublish(Exchange exchange, AsyncCallback callback) throws SalesforceException{
    try {
        LOG.debug(""Publishing on topic: {}"", topic);
        final List<?> body = exchange.getIn().getMandatoryBody(List.class);
        final List<PublishResult> results = pubSubClient.publishMessage(topic, body);
        exchange.getIn().setBody(results);
        callback.done(false);
    } catch (InvalidPayloadException | IOException e) {
        exchange.setException(new SalesforceException(String.format(""Unexpected Error processing %s: \""%s\"""", operationName.value(), e.getMessage()), e));
        callback.done(true);
    }
}",java:S1130,7
"public void createOrUpdateTopic() throws CamelException{
    final String query = config.getSObjectQuery();
    final SyncResponseCallback callback = new SyncResponseCallback();
    try {
        restClient.query(""SELECT Id, Name, Query, ApiVersion, IsActive, "" + ""NotifyForFields, NotifyForOperations, NotifyForOperationCreate, "" + ""NotifyForOperationDelete, NotifyForOperationUndelete, "" + ""NotifyForOperationUpdate, Description "" + ""FROM PushTopic WHERE Name = '"" + topicName + ""'"", Collections.emptyMap(), callback);
        if (!callback.await(API_TIMEOUT, TimeUnit.SECONDS)) {
            throw new SalesforceException(""API call timeout!"", null);
        }
        final SalesforceException callbackException = callback.getException();
        if (callbackException != null) {
            throw callbackException;
        }
        QueryRecordsPushTopic records = OBJECT_MAPPER.readValue(callback.getResponse(), QueryRecordsPushTopic.class);
        if (records.getTotalSize() == 1) {
            PushTopic topic = records.getRecords().get(0);
            LOG.info(""Found existing topic {}: {}"", topicName, topic);
            final boolean notifyOperationsChanged;
            if (preApi29) {
                notifyOperationsChanged = notEquals(config.getNotifyForOperations(), topic.getNotifyForOperations());
            } else {
                notifyOperationsChanged = notEquals(config.getNotifyForOperationCreate(), topic.getNotifyForOperationCreate()) || notEquals(config.getNotifyForOperationDelete(), topic.getNotifyForOperationDelete()) || notEquals(config.getNotifyForOperationUndelete(), topic.getNotifyForOperationUndelete()) || notEquals(config.getNotifyForOperationUpdate(), topic.getNotifyForOperationUpdate());
            }
            if (!query.equals(topic.getQuery()) || notEquals(config.getNotifyForFields(), topic.getNotifyForFields()) || notifyOperationsChanged) {
                if (!config.isUpdateTopic()) {
                    String msg = ""Query doesn't match existing Topic and updateTopic is set to false"";
                    throw new CamelException(msg);
                }
                updateTopic(topic.getId());
            }
        } else {
            createTopic();
        }
    } catch (SalesforceException e) {
        throw new CamelException(String.format(""Error retrieving Topic %s: %s"", topicName, e.getMessage()), e);
    } catch (IOException e) {
        throw new CamelException(String.format(""Un-marshaling error retrieving Topic %s: %s"", topicName, e.getMessage()), e);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new CamelException(String.format(""Un-marshaling error retrieving Topic %s: %s"", topicName, e.getMessage()), e);
    } finally {
        if (callback.getResponse() != null) {
            try {
                callback.getResponse().close();
            } catch (IOException e) {
            }
        }
    }
}",java:S3776,39
"private void initMessageListeners(){
    if (handshakeListener == null) {
        handshakeListener = new ClientSessionChannel.MessageListener() {

            public void onMessage(ClientSessionChannel channel, Message message) {
                component.getHttpClient().getWorkerPool().execute(() -> {
                    LOG.debug(""[CHANNEL:META_HANDSHAKE]: {}"", message);
                    if (!message.isSuccessful()) {
                        LOG.warn(""Handshake failure: {}"", message);
                        handshakeError = (String) message.get(ERROR_FIELD);
                        handshakeException = getFailure(message);
                        if (handshakeError != null) {
                            if (handshakeError.startsWith(""403::"")) {
                                String failureReason = getFailureReason(message);
                                if (failureReason.equals(AUTHENTICATION_INVALID)) {
                                    LOG.debug(""attempting login due to handshake error: 403 -> 401::Authentication invalid"");
                                    session.attemptLoginUntilSuccessful(backoffIncrement, maxBackoff);
                                }
                            }
                        }
                        LOG.debug(""Handshake failed, so try again."");
                        handshake();
                    } else if (!listenerMap.isEmpty()) {
                        reconnecting = true;
                    }
                });
            }
        };
    }
    client.getChannel(META_HANDSHAKE).addListener(handshakeListener);
    if (connectListener == null) {
        connectListener = new ClientSessionChannel.MessageListener() {

            public void onMessage(ClientSessionChannel channel, Message message) {
                component.getHttpClient().getWorkerPool().execute(() -> {
                    LOG.debug(""[CHANNEL:META_CONNECT]: {}"", message);
                    if (!message.isSuccessful()) {
                        LOG.warn(""Connect failure: {}"", message);
                        connectError = (String) message.get(ERROR_FIELD);
                        connectException = getFailure(message);
                        if (connectError != null && connectError.equals(AUTHENTICATION_INVALID)) {
                            LOG.debug(""connectError: {}"", connectError);
                            LOG.debug(""Attempting login..."");
                            session.attemptLoginUntilSuccessful(backoffIncrement, maxBackoff);
                        }
                        if (message.getAdvice() != null && !message.getAdvice().get(""reconnect"").equals(""retry"")) {
                            LOG.debug(""Advice != retry, so handshaking"");
                            handshake();
                        }
                    } else if (reconnecting) {
                        LOG.debug(""Refreshing subscriptions to {} channels on reconnect"", listenerMap.size());
                        final Map<StreamingApiConsumer, MessageListener> map = new HashMap<>(listenerMap);
                        listenerMap.clear();
                        for (Map.Entry<StreamingApiConsumer, ClientSessionChannel.MessageListener> entry : map.entrySet()) {
                            final StreamingApiConsumer consumer = entry.getKey();
                            final String topicName = consumer.getTopicName();
                            subscribe(topicName, consumer);
                        }
                        reconnecting = false;
                    }
                });
            }
        };
    }
    client.getChannel(META_CONNECT).addListener(connectListener);
}",java:S3776,39
"private void doHandshake(){
    if (isStoppingOrStopped()) {
        return;
    }
    LOG.info(""Handshaking after unexpected disconnect from Salesforce..."");
    boolean abort = false;
    LOG.debug(""Waiting to disconnect..."");
    while (!abort && !client.isDisconnected()) {
        try {
            Thread.sleep(DISCONNECT_INTERVAL);
        } catch (InterruptedException e) {
            LOG.error(""Aborting handshake on interrupt!"");
            abort = true;
        }
        abort = abort || isStoppingOrStopped();
    }
    if (!abort) {
        final long backoff = handshakeBackoff.getAndAdd(backoffIncrement);
        if (backoff > maxBackoff) {
            LOG.error(""Handshake aborted after exceeding {} msecs backoff"", maxBackoff);
            abort = true;
        } else {
            LOG.debug(""Pausing for {} msecs before handshake attempt"", backoff);
            try {
                Thread.sleep(backoff);
            } catch (InterruptedException e) {
                LOG.error(""Aborting handshake on interrupt!"");
                abort = true;
            }
        }
        if (!abort) {
            Exception lastError = new SalesforceException(""Unknown error"", null);
            try {
                if (client != null) {
                    client.disconnect();
                    boolean disconnected = client.waitFor(timeout, State.DISCONNECTED);
                    if (!disconnected) {
                        LOG.warn(""Could not disconnect client connected to: {} after: {} msec."", getEndpointUrl(component), timeout);
                        client.abort();
                    }
                    client.handshake();
                    final long waitMs = MILLISECONDS.convert(CONNECT_TIMEOUT, SECONDS);
                    client.waitFor(waitMs, BayeuxClient.State.CONNECTED);
                }
            } catch (Exception e) {
                LOG.error(""Error handshaking: {}"", e.getMessage(), e);
                lastError = e;
            }
            if (client != null && client.isHandshook()) {
                LOG.debug(""Successful handshake!"");
                handshakeBackoff.set(backoffIncrement);
            } else {
                LOG.error(""Failed to handshake after pausing for {} msecs"", backoff);
                if ((backoff + backoffIncrement) > maxBackoff) {
                    String abortMsg = ""Aborting handshake attempt due to: "" + lastError.getMessage();
                    SalesforceException ex = new SalesforceException(abortMsg, lastError);
                    for (StreamingApiConsumer consumer : listenerMap.keySet()) {
                        consumer.handleException(abortMsg, ex);
                    }
                }
            }
        }
    }
}",java:S3776,39
"public void subscribe(final String topicName, final StreamingApiConsumer consumer, final boolean skipReplayId){
    final String channelName = getChannelName(topicName);
    if (!reconnecting && !skipReplayId) {
        setupReplay((SalesforceEndpoint) consumer.getEndpoint());
    }
    LOG.info(""Subscribing to channel {}..."", channelName);
    final ClientSessionChannel.MessageListener listener = new ClientSessionChannel.MessageListener() {

        @Override
        public void onMessage(ClientSessionChannel channel, Message message) {
            LOG.debug(""Received Message: {}"", message);
            consumer.processMessage(channel, message);
        }
    };
    final ClientSessionChannel.MessageListener subscriptionListener = new ClientSessionChannel.MessageListener() {

        public void onMessage(ClientSessionChannel channel, Message message) {
            LOG.debug(""[CHANNEL:META_SUBSCRIBE]: {}"", message);
            final String subscribedChannelName = message.get(SUBSCRIPTION_FIELD).toString();
            if (channelName.equals(subscribedChannelName)) {
                if (!message.isSuccessful()) {
                    String error = (String) message.get(ERROR_FIELD);
                    if (error == null) {
                        error = ""Missing error message"";
                    }
                    Exception failure = getFailure(message);
                    String msg = String.format(""Error subscribing to %s: %s"", topicName, failure != null ? failure.getMessage() : error);
                    boolean abort = true;
                    if (isTemporaryError(message)) {
                        LOG.warn(msg);
                        final long backoff = handshakeBackoff.getAndAdd(backoffIncrement);
                        if (backoff > maxBackoff) {
                            LOG.error(""Subscribe aborted after exceeding {} msecs backoff"", maxBackoff);
                        } else {
                            abort = false;
                            try {
                                LOG.debug(""Pausing for {} msecs before subscribe attempt"", backoff);
                                Thread.sleep(backoff);
                                component.getHttpClient().getWorkerPool().execute(() -> subscribe(topicName, consumer));
                            } catch (InterruptedException e) {
                                LOG.warn(""Aborting subscribe on interrupt!"", e);
                            }
                        }
                    } else if (error.matches(INVALID_REPLAY_ID_PATTERN)) {
                        abort = false;
                        final Long fallBackReplayId = ((SalesforceEndpoint) consumer.getEndpoint()).getConfiguration().getFallBackReplayId();
                        LOG.warn(error);
                        LOG.warn(""Falling back to replayId {} for channel {}"", fallBackReplayId, channelName);
                        REPLAY_EXTENSION.addChannelReplayId(channelName, fallBackReplayId);
                        subscribe(topicName, consumer, true);
                    }
                    if (abort && client != null) {
                        consumer.handleException(msg, new SalesforceException(msg, failure));
                    }
                } else {
                    LOG.info(""Subscribed to channel {}"", subscribedChannelName);
                    listenerMap.put(consumer, listener);
                    handshakeBackoff.set(0);
                }
                if (client != null) {
                    client.getChannel(META_SUBSCRIBE).removeListener(this);
                } else {
                    LOG.warn(""Trying to handle a subscription message but the client is already destroyed"");
                }
            }
        }
    };
    client.getChannel(META_SUBSCRIBE).addListener(subscriptionListener);
    final ClientSessionChannel clientChannel = client.getChannel(channelName);
    clientChannel.subscribe(listener);
}",java:S3776,39
"public List<?> evaluateAsList(Exchange exchange) throws Exception{
    LOG.debug(""evaluateAsList: {} for exchange: {}"", expression, exchange);
    return getExpression().evaluate(createDynamicContext(exchange));
}",java:S1452,23
"@Deprecated
public void assertMatches(String text, Exchange exchange) throws AssertionError{
    List<?> list;
    try {
        list = evaluateAsList(exchange);
    } catch (Exception e) {
        throw new AssertionError(e);
    }
    if (!matches(list)) {
        throw new AssertionError(this + "" failed on "" + exchange + "" as evaluated: "" + list);
    }
}",java:S6355,48
"protected DynamicQueryContext createDynamicContext(Exchange exchange) throws Exception{
    Configuration config = getConfiguration();
    DynamicQueryContext dynamicQueryContext = new DynamicQueryContext(config);
    Message in = exchange.getIn();
    Item item;
    if (ObjectHelper.isNotEmpty(getHeaderName())) {
        item = in.getHeader(getHeaderName(), Item.class);
    } else if (ObjectHelper.isNotEmpty(getPropertyName())) {
        item = exchange.getProperty(getPropertyName(), Item.class);
    } else {
        item = in.getBody(Item.class);
    }
    if (item != null) {
        dynamicQueryContext.setContextItem(item);
    } else {
        Object body;
        if (ObjectHelper.isNotEmpty(getHeaderName())) {
            body = in.getHeader(getHeaderName());
        } else if (ObjectHelper.isNotEmpty(getPropertyName())) {
            body = exchange.getProperty(getPropertyName());
        } else {
            body = in.getBody();
        }
        InputStream is = null;
        try {
            Source source;
            if (isInputStreamNeeded(exchange)) {
                if (ObjectHelper.isNotEmpty(getHeaderName())) {
                    is = exchange.getIn().getHeader(getHeaderName(), InputStream.class);
                } else if (ObjectHelper.isNotEmpty(getPropertyName())) {
                    is = exchange.getProperty(getPropertyName(), InputStream.class);
                } else {
                    is = exchange.getIn().getBody(InputStream.class);
                }
                source = getSource(exchange, is);
            } else {
                source = getSource(exchange, body);
            }
            if (source == null) {
                throw new NoTypeConversionAvailableException(body, Source.class);
            }
            TreeInfo doc = config.buildDocumentTree(source);
            dynamicQueryContext.setContextItem(doc.getRootNode());
        } finally {
            IOHelper.close(is);
        }
    }
    configureQuery(dynamicQueryContext, exchange);
    MessageHelper.resetStreamCache(exchange.getIn());
    return dynamicQueryContext;
}",java:S3776,39
"protected DynamicQueryContext createDynamicContext(Exchange exchange) throws Exception{
    Configuration config = getConfiguration();
    DynamicQueryContext dynamicQueryContext = new DynamicQueryContext(config);
    Message in = exchange.getIn();
    Item item;
    if (ObjectHelper.isNotEmpty(getHeaderName())) {
        item = in.getHeader(getHeaderName(), Item.class);
    } else if (ObjectHelper.isNotEmpty(getPropertyName())) {
        item = exchange.getProperty(getPropertyName(), Item.class);
    } else {
        item = in.getBody(Item.class);
    }
    if (item != null) {
        dynamicQueryContext.setContextItem(item);
    } else {
        Object body;
        if (ObjectHelper.isNotEmpty(getHeaderName())) {
            body = in.getHeader(getHeaderName());
        } else if (ObjectHelper.isNotEmpty(getPropertyName())) {
            body = exchange.getProperty(getPropertyName());
        } else {
            body = in.getBody();
        }
        InputStream is = null;
        try {
            Source source;
            if (isInputStreamNeeded(exchange)) {
                if (ObjectHelper.isNotEmpty(getHeaderName())) {
                    is = exchange.getIn().getHeader(getHeaderName(), InputStream.class);
                } else if (ObjectHelper.isNotEmpty(getPropertyName())) {
                    is = exchange.getProperty(getPropertyName(), InputStream.class);
                } else {
                    is = exchange.getIn().getBody(InputStream.class);
                }
                source = getSource(exchange, is);
            } else {
                source = getSource(exchange, body);
            }
            if (source == null) {
                throw new NoTypeConversionAvailableException(body, Source.class);
            }
            TreeInfo doc = config.buildDocumentTree(source);
            dynamicQueryContext.setContextItem(doc.getRootNode());
        } finally {
            IOHelper.close(is);
        }
    }
    configureQuery(dynamicQueryContext, exchange);
    MessageHelper.resetStreamCache(exchange.getIn());
    return dynamicQueryContext;
}",java:S112,4
"public URL resolveModuleResource(String uri) throws Exception{
    return ResourceHelper.resolveMandatoryResourceAsUrl(getCamelContext(), uri);
}",java:S112,4
"protected void doInitXQuery() throws Exception{
    LOG.debug(""{} using schema resource: {}"", this, resourceUri);
    InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext(), resourceUri);
    this.xquery = XQueryBuilder.xquery(is);
    this.xquery.setConfiguration(getConfiguration());
    this.xquery.setConfigurationProperties(getConfigurationProperties());
    this.xquery.setStaticQueryContext(getStaticQueryContext());
    this.xquery.setParameters(getParameters());
    this.xquery.setNamespaces(namespacePrefixes);
    this.xquery.setResultsFormat(getResultsFormat());
    this.xquery.setProperties(getProperties());
    this.xquery.setResultType(getResultType());
    this.xquery.setStripsAllWhiteSpace(isStripsAllWhiteSpace());
    this.xquery.setAllowStAX(isAllowStAX());
    this.xquery.setHeaderName(getHeaderName());
    this.xquery.setPropertyName(getPropertyName());
    this.xquery.setModuleURIResolver(getModuleURIResolver());
    this.xquery.init(getCamelContext());
    setProcessor(xquery);
}",java:S112,4
"protected int sendTimerExchange(){
    final Exchange exchange = createExchange(false);
    exchange.setProperty(Exchange.TIMER_NAME, getEndpoint().getName());
    Date now = new Date();
    exchange.setProperty(Exchange.TIMER_FIRED_TIME, now);
    exchange.getIn().setHeader(SchedulerConstants.MESSAGE_TIMESTAMP, now.getTime());
    if (LOG.isTraceEnabled()) {
        LOG.trace(""Timer {} is firing"", getEndpoint().getName());
    }
    if (!getEndpoint().isSynchronous()) {
        final AtomicBoolean polled = new AtomicBoolean(true);
        boolean doneSync = getAsyncProcessor().process(exchange, cbDoneSync -> {
            if (exchange.getException() != null) {
                getExceptionHandler().handleException(""Error processing exchange"", exchange, exchange.getException());
            }
            boolean wasPolled = exchange.getProperty(Exchange.SCHEDULER_POLLED_MESSAGES, true, boolean.class);
            if (!wasPolled) {
                polled.set(false);
            }
            if (!cbDoneSync) {
                releaseExchange(exchange, false);
            }
        });
        if (!doneSync) {
            return polled.get() ? 1 : 0;
        }
    } else {
        try {
            getProcessor().process(exchange);
        } catch (Exception e) {
            exchange.setException(e);
        }
        if (exchange.getException() != null) {
            getExceptionHandler().handleException(""Error processing exchange"", exchange, exchange.getException());
        }
    }
    boolean polled = exchange.getProperty(Exchange.SCHEDULER_POLLED_MESSAGES, true, boolean.class);
    releaseExchange(exchange, false);
    return polled ? 1 : 0;
}",java:S3776,39
"public synchronized QueueReference getOrCreateQueue(SedaEndpoint endpoint, Integer size, Boolean multipleConsumers, BlockingQueueFactory<Exchange> customQueueFactory){
    String key = getQueueKey(endpoint.getEndpointUri());
    if (size == null) {
        size = customSize.get(key);
    }
    QueueReference ref = getQueues().get(key);
    if (ref != null) {
        if (size != null && !size.equals(ref.getSize())) {
            throw new IllegalArgumentException(""Cannot use existing queue "" + key + "" as the existing queue size "" + (ref.getSize() != null ? ref.getSize() : SedaConstants.QUEUE_SIZE) + "" does not match given queue size "" + size);
        }
        ref.addReference(endpoint);
        if (log.isDebugEnabled()) {
            log.debug(""Reusing existing queue {} with size {} and reference count {}"", key, size, ref.getCount());
        }
        return ref;
    }
    BlockingQueue<Exchange> queue;
    BlockingQueueFactory<Exchange> queueFactory = customQueueFactory == null ? defaultQueueFactory : customQueueFactory;
    if (size != null && size > 0) {
        queue = queueFactory.create(size);
    } else {
        if (getQueueSize() > 0) {
            size = getQueueSize();
            queue = queueFactory.create(getQueueSize());
        } else {
            queue = queueFactory.create();
        }
    }
    log.debug(""Created queue {} with size {}"", key, size);
    ref = new QueueReference(queue, size, multipleConsumers);
    ref.addReference(endpoint);
    getQueues().put(key, ref);
    return ref;
}",java:S3776,39
"protected void doRun(){
    BlockingQueue<Exchange> queue = getEndpoint().getQueue();
    while (queue != null && isRunAllowed()) {
        if (getEndpoint().getCamelContext().getStatus().isStarting()) {
            LOG.trace(""CamelContext is starting so skip polling"");
            try {
                Thread.sleep(Math.min(pollTimeout, 1000));
            } catch (InterruptedException e) {
                LOG.debug(""Sleep interrupted, are we stopping? {}"", isStopping() || isStopped());
            }
            continue;
        }
        if (isSuspending() || isSuspended() || isStarting()) {
            if (shutdownPending && queue.isEmpty()) {
                LOG.trace(""Consumer is suspended and shutdown is pending, so this consumer thread is breaking out because the task queue is empty."");
                break;
            } else {
                LOG.trace(""Consumer is suspended so skip polling"");
                try {
                    Thread.sleep(Math.min(pollTimeout, 1000));
                } catch (InterruptedException e) {
                    LOG.debug(""Sleep interrupted, are we stopping? {}"", isStopping() || isStopped());
                }
                continue;
            }
        }
        Exchange exchange = null;
        try {
            exchange = queue.poll(pollTimeout, TimeUnit.MILLISECONDS);
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Polled queue {} with timeout {} ms. -> {}"", ObjectHelper.getIdentityHashCode(queue), pollTimeout, exchange);
            }
            if (exchange != null) {
                try {
                    Exchange newExchange = prepareExchange(exchange);
                    sendToConsumers(newExchange);
                    ExchangeHelper.copyResults(exchange, newExchange);
                    if (exchange.getException() != null) {
                        getExceptionHandler().handleException(""Error processing exchange"", exchange, exchange.getException());
                    }
                } catch (Exception e) {
                    getExceptionHandler().handleException(""Error processing exchange"", exchange, e);
                }
            } else if (shutdownPending && queue.isEmpty()) {
                LOG.trace(""Shutdown is pending, so this consumer thread is breaking out because the task queue is empty."");
                break;
            }
        } catch (InterruptedException e) {
            LOG.debug(""Sleep interrupted, are we stopping? {}"", isStopping() || isStopped());
            continue;
        } catch (Exception e) {
            if (exchange != null) {
                getExceptionHandler().handleException(""Error processing exchange"", exchange, e);
            } else {
                getExceptionHandler().handleException(e);
            }
        }
    }
}",java:S3776,39
"protected void sendToConsumers(final Exchange exchange) throws Exception{
    int size = getEndpoint().getConsumers().size();
    if (size > 1 && !getEndpoint().isMultipleConsumersSupported()) {
        throw new IllegalStateException(""Multiple consumers for the same endpoint is not allowed: "" + getEndpoint());
    }
    if (getEndpoint().isMultipleConsumersSupported()) {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Multicasting to {} consumers for Exchange: {}"", size, exchange);
        }
        final List<Synchronization> completions = exchange.getExchangeExtension().handoverCompletions();
        AsyncProcessor mp = getEndpoint().getConsumerMulticastProcessor();
        ObjectHelper.notNull(mp, ""ConsumerMulticastProcessor"", this);
        mp.process(exchange, doneSync -> {
            UnitOfWorkHelper.doneSynchronizations(exchange, completions);
        });
    } else {
        getAsyncProcessor().process(exchange, EmptyAsyncCallback.get());
    }
}",java:S112,4
"public void setQueue(BlockingQueue<Exchange> queue){
    this.queue = queue;
    this.size = queue.remainingCapacity();
}",java:S2886,33
"protected void addToQueue(Exchange exchange, boolean copy) throws SedaConsumerNotAvailableException{
    BlockingQueue<Exchange> queue = null;
    QueueReference queueReference = endpoint.getQueueReference();
    if (queueReference != null) {
        queue = queueReference.getQueue();
    }
    if (queue == null) {
        throw new SedaConsumerNotAvailableException(""No queue available on endpoint: "" + endpoint, exchange);
    }
    boolean empty = !queueReference.hasConsumers();
    if (empty) {
        if (endpoint.isFailIfNoConsumers()) {
            throw new SedaConsumerNotAvailableException(""No consumers available on endpoint: "" + endpoint, exchange);
        } else if (endpoint.isDiscardIfNoConsumers()) {
            LOG.debug(""Discard message as no active consumers on endpoint: {}"", endpoint);
            return;
        }
    }
    Exchange target = exchange;
    if (copy) {
        target = prepareCopy(exchange, true);
    }
    LOG.trace(""Adding Exchange to queue: {}"", target);
    if (discardWhenFull) {
        try {
            boolean added = queue.offer(target, 0, TimeUnit.MILLISECONDS);
            if (!added) {
                LOG.trace(""Discarding Exchange as queue is full: {}"", target);
            }
        } catch (InterruptedException e) {
            LOG.debug(""Offer interrupted, are we stopping? {}"", isStopping() || isStopped());
        }
    } else if (blockWhenFull && offerTimeout == 0) {
        try {
            queue.put(target);
        } catch (InterruptedException e) {
            LOG.debug(""Put interrupted, are we stopping? {}"", isStopping() || isStopped());
        }
    } else if (blockWhenFull && offerTimeout > 0) {
        try {
            boolean added = queue.offer(target, offerTimeout, TimeUnit.MILLISECONDS);
            if (!added) {
                throw new IllegalStateException(""Fails to insert element into queue, "" + ""after timeout of "" + offerTimeout + "" milliseconds"");
            }
        } catch (InterruptedException e) {
            LOG.debug(""Offer interrupted, are we stopping? {}"", isStopping() || isStopped());
        }
    } else {
        queue.add(target);
    }
}",java:S3776,39
"protected AbstractServiceNowProcessor setBody(Message message, Class<?> model, Response response) throws Exception{
    if (message != null && response != null) {
        if (ObjectHelper.isNotEmpty(response.getHeaderString(HttpHeaders.CONTENT_TYPE))) {
            JsonNode root = response.readEntity(JsonNode.class);
            Map<String, String> responseAttributes = null;
            if (root != null) {
                Iterator<Map.Entry<String, JsonNode>> fields = root.fields();
                while (fields.hasNext()) {
                    final Map.Entry<String, JsonNode> entry = fields.next();
                    final String key = entry.getKey();
                    final JsonNode node = entry.getValue();
                    if (ObjectHelper.equal(""result"", key, true)) {
                        Object body = unwrap(node, model);
                        if (body != null) {
                            message.setHeader(ServiceNowConstants.RESPONSE_TYPE, body.getClass());
                            message.setBody(body);
                        }
                    } else {
                        if (responseAttributes == null) {
                            responseAttributes = new HashMap<>();
                        }
                        responseAttributes.put(key, node.textValue());
                    }
                }
                if (responseAttributes != null) {
                    message.setHeader(ServiceNowConstants.RESPONSE_META, responseAttributes);
                }
            }
        }
    }
    return this;
}",java:S3776,39
"protected AbstractServiceNowProcessor setBody(Message message, Class<?> model, Response response) throws Exception{
    if (message != null && response != null) {
        if (ObjectHelper.isNotEmpty(response.getHeaderString(HttpHeaders.CONTENT_TYPE))) {
            JsonNode root = response.readEntity(JsonNode.class);
            Map<String, String> responseAttributes = null;
            if (root != null) {
                Iterator<Map.Entry<String, JsonNode>> fields = root.fields();
                while (fields.hasNext()) {
                    final Map.Entry<String, JsonNode> entry = fields.next();
                    final String key = entry.getKey();
                    final JsonNode node = entry.getValue();
                    if (ObjectHelper.equal(""result"", key, true)) {
                        Object body = unwrap(node, model);
                        if (body != null) {
                            message.setHeader(ServiceNowConstants.RESPONSE_TYPE, body.getClass());
                            message.setBody(body);
                        }
                    } else {
                        if (responseAttributes == null) {
                            responseAttributes = new HashMap<>();
                        }
                        responseAttributes.put(key, node.textValue());
                    }
                }
                if (responseAttributes != null) {
                    message.setHeader(ServiceNowConstants.RESPONSE_META, responseAttributes);
                }
            }
        }
    }
    return this;
}",java:S112,4
"private Response invoke(WebClient client, String httpMethod, Object body) throws Exception{
    Response response = client.invoke(httpMethod, body);
    int code = response.getStatus();
    switch(code) {
        case 200:
        case 201:
        case 204:
            break;
        case 400:
        case 401:
        case 403:
        case 404:
        case 405:
        case 406:
        case 415:
            ServiceNowExceptionModel model = response.readEntity(ServiceNowExceptionModel.class);
            throw new ServiceNowException(code, model.getStatus(), model.getError().get(""message""), model.getError().get(""detail""));
        default:
            throw new ServiceNowException(code, response.readEntity(Map.class));
    }
    return response;
}",java:S112,4
"private String getInstanceName(Map<String, Object> parameters) throws Exception{
    String instanceName = (String) parameters.get(""instanceName"");
    if (ObjectHelper.isEmpty(instanceName) && ObjectHelper.isNotEmpty(getComponent())) {
        instanceName = getComponent(ServiceNowComponent.class).getInstanceName();
    }
    if (ObjectHelper.isEmpty(instanceName)) {
        throw new NoSuchOptionException(""instanceName"");
    }
    return instanceName;
}",java:S112,4
"public static void findOffsets(Response response, BiConsumer<String, Object> consumer) throws Exception{
    List<String> links = response.getStringHeaders().get(HttpHeaders.LINK);
    if (links != null) {
        for (String link : links) {
            String[] parts = link.split("";"");
            if (parts.length != 2) {
                continue;
            }
            String uri = StringHelper.between(parts[0], ""<"", "">"");
            String rel = StringHelper.removeQuotes(StringHelper.after(parts[1], ""=""));
            Map<String, Object> query = URISupport.parseQuery(uri);
            Object offset = query.get(ServiceNowParams.SYSPARM_OFFSET.getId());
            if (offset != null) {
                switch(rel) {
                    case ServiceNowConstants.LINK_FIRST:
                        consumer.accept(ServiceNowConstants.OFFSET_FIRST, offset);
                        break;
                    case ServiceNowConstants.LINK_LAST:
                        consumer.accept(ServiceNowConstants.OFFSET_LAST, offset);
                        break;
                    case ServiceNowConstants.LINK_NEXT:
                        consumer.accept(ServiceNowConstants.OFFSET_NEXT, offset);
                        break;
                    case ServiceNowConstants.LINK_PREV:
                        consumer.accept(ServiceNowConstants.OFFSET_PREV, offset);
                        break;
                    default:
                        break;
                }
            }
        }
    }
}",java:S112,4
"public static Optional<String> findOffset(Response response, String type) throws Exception{
    List<String> links = response.getStringHeaders().get(HttpHeaders.LINK);
    if (links != null) {
        for (String link : links) {
            String[] parts = link.split("";"");
            if (parts.length != 2) {
                continue;
            }
            String uri = StringHelper.between(parts[0], ""<"", "">"");
            String rel = StringHelper.removeQuotes(StringHelper.after(parts[1], ""=""));
            Map<String, Object> query = URISupport.parseQuery(uri);
            Object offset = query.get(ServiceNowParams.SYSPARM_OFFSET.getId());
            if (offset != null && type.equals(rel)) {
                return Optional.of(offset.toString());
            }
        }
    }
    return Optional.empty();
}",java:S112,4
"private Optional<MetaData> tableList(MetaContext context) throws Exception{
    Optional<JsonNode> response = context.getClient().reset().types(MediaType.APPLICATION_JSON_TYPE).path(""now"").path(context.getConfiguration().getApiVersion()).path(""table"").path(""sys_db_object"").query(""sysparm_exclude_reference_link"", ""true"").query(""sysparm_fields"", ""name%2Csys_id"").query(""sysparm_query"", ""name=sys_import_set_row"").trasform(HttpMethod.GET, this::findResultNode);
    if (response.isPresent()) {
        final JsonNode node = response.get();
        final JsonNode sysId = node.findValue(""sys_id"");
        response = context.getClient().reset().types(MediaType.APPLICATION_JSON_TYPE).path(""now"").path(context.getConfiguration().getApiVersion()).path(""table"").path(""sys_db_object"").query(""sysparm_exclude_reference_link"", ""true"").query(""sysparm_fields"", ""name%2Csys_name%2Csuper_class"").trasform(HttpMethod.GET, this::findResultNode);
        if (response.isPresent()) {
            final ObjectNode root = context.getConfiguration().getOrCreateMapper().createObjectNode();
            processResult(response.get(), n -> {
                final JsonNode superClass = n.findValue(""super_class"");
                final JsonNode name = n.findValue(""name"");
                final JsonNode label = n.findValue(""sys_name"");
                if (superClass != null) {
                    final String impId = sysId != null ? sysId.textValue() : null;
                    final String superId = superClass.textValue();
                    if (impId != null && superId != null && ObjectHelper.equal(impId, superId)) {
                        LOGGER.debug(""skip table: name={}, label={} because it refers to an import set"", name, label);
                        return;
                    }
                }
                if (name != null && label != null) {
                    String key = name.textValue();
                    String val = label.textValue();
                    if (ObjectHelper.isEmpty(val)) {
                        val = key;
                    }
                    root.put(key, val);
                }
            });
            return Optional.of(MetaDataBuilder.on(getCamelContext()).withAttribute(MetaData.CONTENT_TYPE, ""application/json"").withAttribute(MetaData.JAVA_TYPE, JsonNode.class).withAttribute(""Meta-Context"", ServiceNowConstants.RESOURCE_IMPORT).withPayload(root).build());
        }
    }
    return Optional.empty();
}",java:S3776,39
"public static void parseXmlRouteEndpoints(InputStream xml, String baseDir, String fullyQualifiedFileName, List<CamelEndpointDetails> endpoints){
    Document dom = getDocument(xml);
    if (dom != null) {
        List<Node> nodes = CamelXmlHelper.findAllEndpoints(dom);
        for (Node node : nodes) {
            String uri = getSafeAttribute(node, ""uri"");
            if (uri != null) {
                uri = trimEndpointUri(uri);
            }
            if (!Strings.isNullOrEmpty(uri)) {
                String id = getSafeAttribute(node, ""id"");
                String lineNumber = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER);
                String lineNumberEnd = (String) node.getUserData(XmlLineNumberParser.LINE_NUMBER_END);
                String fileName = getFileName(baseDir, fullyQualifiedFileName);
                boolean consumerOnly = false;
                boolean producerOnly = false;
                String nodeName = node.getNodeName();
                if (""from"".equals(nodeName) || ""pollEnrich"".equals(nodeName)) {
                    consumerOnly = true;
                } else if (""to"".equals(nodeName) || ""enrich"".equals(nodeName) || ""wireTap"".equals(nodeName)) {
                    producerOnly = true;
                }
                CamelEndpointDetails detail = new CamelEndpointDetails();
                detail.setFileName(fileName);
                detail.setLineNumber(lineNumber);
                detail.setLineNumberEnd(lineNumberEnd);
                String column = (String) node.getUserData(XmlLineNumberParser.COLUMN_NUMBER);
                if (column != null) {
                    detail.setLinePosition(Integer.parseInt(column));
                }
                detail.setEndpointInstance(id);
                detail.setEndpointUri(uri);
                detail.setEndpointComponentName(endpointComponentName(uri));
                detail.setConsumerOnly(consumerOnly);
                detail.setProducerOnly(producerOnly);
                endpoints.add(detail);
            }
        }
    }
}",java:S3776,39
"private void processDictionaryNode(MetaContext context, ObjectNode root, JsonNode node){
    if (node.hasNonNull(""element"")) {
        final String id = node.get(""element"").asText();
        if (ObjectHelper.isNotEmpty(id)) {
            String includeKey = ""object."" + context.getObjectName() + "".fields"";
            String excludeKey = ""object."" + context.getObjectName() + "".fields.exclude.pattern"";
            String fields = (String) context.getParameters().get(includeKey);
            String exclude = (String) context.getParameters().get(excludeKey);
            boolean included = true;
            if (ObjectHelper.isNotEmpty(fields) && ObjectHelper.isNotEmpty(exclude)) {
                boolean isIncluded = Stream.of(fields.split("","")).map(StringHelper::trimToNull).filter(Objects::nonNull).anyMatch(id::equalsIgnoreCase);
                boolean isExcluded = Pattern.compile(exclude).matcher(id).matches();
                included = isIncluded || !isExcluded;
            } else if (ObjectHelper.isNotEmpty(fields)) {
                included = Stream.of(fields.split("","")).map(StringHelper::trimToNull).filter(Objects::nonNull).anyMatch(id::equalsIgnoreCase);
            } else if (ObjectHelper.isNotEmpty(exclude)) {
                included = !Pattern.compile(exclude).matcher(id).matches();
            }
            if (!included) {
                return;
            }
            context.getStack().push(id);
            LOGGER.debug(""Load dictionary element <{}>"", context.getStack());
            try {
                final DictionaryEntry entry = context.getConfiguration().getOrCreateMapper().treeToValue(node, DictionaryEntry.class);
                final ObjectNode property = ((ObjectNode) root.get(""properties"")).putObject(id);
                final ObjectNode servicenow = property.putObject(""servicenow"");
                servicenow.put(""internal_type"", entry.getInternalType().getValue());
                switch(entry.getInternalType().getValue()) {
                    case ""integer"":
                        property.put(""type"", ""integer"");
                        break;
                    case ""float"":
                        property.put(""type"", ""number"");
                        break;
                    case ""boolean"":
                        property.put(""type"", ""boolean"");
                        break;
                    case ""guid"":
                    case ""GUID"":
                        property.put(""type"", ""string"");
                        property.put(""pattern"", ""^[a-fA-F0-9]{32}"");
                        break;
                    case ""glide_date"":
                        property.put(""type"", ""string"");
                        property.put(""format"", ""date"");
                        break;
                    case ""due_date"":
                    case ""glide_date_time"":
                    case ""glide_time"":
                    case ""glide_duration"":
                        property.put(""type"", ""string"");
                        property.put(""format"", ""date-time"");
                        break;
                    case ""reference"":
                        property.put(""type"", ""string"");
                        property.put(""pattern"", ""^[a-fA-F0-9]{32}"");
                        if (entry.getReference().getValue() != null) {
                            servicenow.put(""sys_db_object"", entry.getReference().getValue());
                        }
                        break;
                    default:
                        property.put(""type"", ""string"");
                        if (entry.getMaxLength() != null) {
                            property.put(""maxLength"", entry.getMaxLength());
                        }
                        break;
                }
                if (entry.isMandatory()) {
                    ArrayNode required = (ArrayNode) root.get(""required"");
                    if (required == null) {
                        required = root.putArray(""required"");
                    }
                    required.add(id);
                }
            } catch (JsonProcessingException e) {
                throw new RuntimeCamelException(e);
            } finally {
                context.getStack().pop();
            }
        }
    }
}",java:S3776,39
"private void generateBeanProperty(TypeSpec.Builder typeBuilder, JsonNode schema, String name, JsonNode definition){
    final ArrayNode required = (ArrayNode) schema.get(""required"");
    final String fieldName = toCamelCase(name, true);
    final String methodName = toCamelCase(name, false);
    final JsonNode type = definition.get(""type"");
    final JsonNode format = definition.get(""format"");
    Class<?> javaType = String.class;
    if (type != null) {
        if (""boolean"".equalsIgnoreCase(type.textValue())) {
            javaType = boolean.class;
        }
        if (""integer"".equalsIgnoreCase(type.textValue())) {
            javaType = Integer.class;
        }
        if (""number"".equalsIgnoreCase(type.textValue())) {
            javaType = Double.class;
        }
        if (""string"".equalsIgnoreCase(type.textValue())) {
            javaType = String.class;
        }
    }
    if (javaType == String.class && format != null) {
        if (""date"".equalsIgnoreCase(format.textValue())) {
            javaType = LocalDate.class;
        }
        if (""time"".equalsIgnoreCase(format.textValue())) {
            javaType = LocalTime.class;
        }
        if (""date-time"".equalsIgnoreCase(format.textValue())) {
            javaType = LocalDateTime.class;
        }
    }
    FieldSpec field = FieldSpec.builder(javaType, toCamelCase(name, true)).addModifiers(Modifier.PRIVATE).addAnnotation(AnnotationSpec.builder(JsonProperty.class).addMember(""value"", ""$S"", name).addMember(""required"", ""$L"", required.has(name)).build()).build();
    MethodSpec getter = MethodSpec.methodBuilder(""get"" + methodName).addModifiers(Modifier.PUBLIC).returns(javaType).addStatement(""return this.$L"", fieldName).build();
    MethodSpec setter = MethodSpec.methodBuilder(""set"" + methodName).addModifiers(Modifier.PUBLIC).returns(void.class).addParameter(javaType, fieldName).addStatement(""this.$L = $L"", fieldName, fieldName).build();
    typeBuilder.addField(field);
    typeBuilder.addMethod(getter);
    typeBuilder.addMethod(setter);
}",java:S3776,39
" Consumer doCreateConsumer(CamelContext camelContext, Processor processor, String verb, String basePath, String uriTemplate, RestConfiguration configuration, Map<String, Object> parameters, boolean api) throws Exception{
    String path = basePath;
    if (uriTemplate != null) {
        if (uriTemplate.startsWith(""/"")) {
            path = path + uriTemplate;
        } else {
            path = path + ""/"" + uriTemplate;
        }
    }
    path = FileUtil.stripLeadingSeparator(path);
    RestConfiguration config = configuration;
    if (config == null) {
        config = CamelContextHelper.getRestConfiguration(getCamelContext(), ""servlet"");
    }
    Map<String, Object> map = RestComponentHelper.initRestEndpointProperties(""servlet"", config);
    boolean cors = config.isEnableCORS();
    if (cors) {
        map.put(""optionsEnabled"", ""true"");
    }
    if (api) {
        map.put(""matchOnUriPrefix"", ""true"");
    }
    RestComponentHelper.addHttpRestrictParam(map, verb, cors);
    String url = RestComponentHelper.createRestConsumerUrl(""servlet"", path, map);
    ServletEndpoint endpoint = (ServletEndpoint) camelContext.getEndpoint(url, parameters);
    if (!map.containsKey(""httpBinding"")) {
        HttpBinding binding = new ServletRestHttpBinding();
        binding.setHeaderFilterStrategy(endpoint.getHeaderFilterStrategy());
        binding.setTransferException(endpoint.isTransferException());
        binding.setMuteException(endpoint.isMuteException());
        binding.setEagerCheckContentAvailable(endpoint.isEagerCheckContentAvailable());
        binding.setMapHttpMessageHeaders(endpoint.isMapHttpMessageHeaders());
        binding.setMapHttpMessageFormUrlEncodedBody(endpoint.isMapHttpMessageFormUrlEncodedBody());
        endpoint.setHttpBinding(binding);
    }
    Consumer consumer = endpoint.createConsumer(processor);
    if (config.getConsumerProperties() != null && !config.getConsumerProperties().isEmpty()) {
        setProperties(camelContext, consumer, config.getConsumerProperties());
    }
    return consumer;
}",java:S107,1
"private void applySecurityPolicy(Exchange exchange) throws Exception{
    ByteSource encryptedToken;
    String username = exchange.getIn().getHeader(ShiroSecurityConstants.SHIRO_SECURITY_USERNAME, String.class);
    String password = exchange.getIn().getHeader(ShiroSecurityConstants.SHIRO_SECURITY_PASSWORD, String.class);
    if (username != null && password != null) {
        ShiroSecurityToken token = new ShiroSecurityToken(username, password);
        if (policy.isBase64()) {
            ByteSource bytes = ShiroSecurityHelper.encrypt(token, policy.getPassPhrase(), policy.getCipherService());
            String base64 = bytes.toBase64();
            exchange.getIn().setHeader(ShiroSecurityConstants.SHIRO_SECURITY_TOKEN, base64);
        } else {
            exchange.getIn().setHeader(ShiroSecurityConstants.SHIRO_SECURITY_TOKEN, token);
        }
        exchange.getIn().removeHeader(ShiroSecurityConstants.SHIRO_SECURITY_USERNAME);
        exchange.getIn().removeHeader(ShiroSecurityConstants.SHIRO_SECURITY_PASSWORD);
    }
    Object token = ExchangeHelper.getMandatoryHeader(exchange, ShiroSecurityConstants.SHIRO_SECURITY_TOKEN, Object.class);
    if (token instanceof ShiroSecurityToken) {
        ShiroSecurityToken sst = (ShiroSecurityToken) token;
        encryptedToken = ShiroSecurityHelper.encrypt(sst, policy.getPassPhrase(), policy.getCipherService());
        exchange.getIn().removeHeader(ShiroSecurityConstants.SHIRO_SECURITY_TOKEN);
        exchange.getIn().setHeader(ShiroSecurityConstants.SHIRO_SECURITY_TOKEN, encryptedToken);
    } else if (token instanceof String) {
        String data = (String) token;
        if (policy.isBase64()) {
            byte[] bytes = Base64.decode(data);
            encryptedToken = ByteSource.Util.bytes(bytes);
        } else {
            encryptedToken = ByteSource.Util.bytes(data);
        }
    } else if (token instanceof ByteSource) {
        encryptedToken = (ByteSource) token;
    } else {
        throw new CamelExchangeException(""Shiro security header "" + ShiroSecurityConstants.SHIRO_SECURITY_TOKEN + "" is unsupported type: "" + ObjectHelper.classCanonicalName(token), exchange);
    }
    ByteSource decryptedToken = policy.getCipherService().decrypt(encryptedToken.getBytes(), policy.getPassPhrase());
    ShiroSecurityToken securityToken = ShiroSecurityHelper.deserialize(decryptedToken.getBytes());
    Subject currentUser = SecurityUtils.getSubject();
    try {
        authenticateUser(currentUser, securityToken);
        authorizeUser(currentUser, exchange);
    } finally {
        if (policy.isAlwaysReauthenticate()) {
            currentUser.logout();
        }
    }
}",java:S112,4
"private void authorizeUser(Subject currentUser, Exchange exchange) throws CamelAuthorizationException{
    boolean authorized = false;
    if (!policy.getPermissionsList().isEmpty()) {
        if (policy.isAllPermissionsRequired()) {
            authorized = currentUser.isPermittedAll(policy.getPermissionsList());
        } else {
            for (Permission permission : policy.getPermissionsList()) {
                if (currentUser.isPermitted(permission)) {
                    authorized = true;
                    break;
                }
            }
        }
    } else if (!policy.getRolesList().isEmpty()) {
        if (policy.isAllRolesRequired()) {
            authorized = currentUser.hasAllRoles(policy.getRolesList());
        } else {
            for (String role : policy.getRolesList()) {
                if (currentUser.hasRole(role)) {
                    authorized = true;
                    break;
                }
            }
        }
    } else {
        LOG.trace(""Valid Permissions or Roles List not specified for ShiroSecurityPolicy. "" + ""No authorization checks will be performed for current user."");
        authorized = true;
    }
    if (!authorized) {
        throw new CamelAuthorizationException(""Authorization Failed. Subject's role set does "" + ""not have the necessary roles or permissions to perform further processing."", exchange);
    }
    LOG.debug(""Current user {} is successfully authorized."", currentUser.getPrincipal());
}",java:S3776,39
"private static void validateMepAndReplyTo(Map<String, Object> parameters) throws Exception{
    boolean replyToSet = parameters.containsKey(""replyTo"");
    boolean mepSet = parameters.containsKey(""exchangePattern"");
    if (replyToSet && mepSet) {
        if (!parameters.get(""exchangePattern"").equals(ExchangePattern.InOut.toString())) {
            String replyTo = (String) parameters.get(""replyTo"");
            ExchangePattern mep = ExchangePattern.valueOf((String) parameters.get(""exchangePattern""));
            throw new CamelException(""Setting parameter replyTo="" + replyTo + "" requires a MEP of type InOut. Parameter exchangePattern is set to "" + mep);
        }
    }
}",java:S112,4
"public static void commitIfNeeded(Session session, Message message) throws Exception{
    try {
        if (session.getTransacted()) {
            SjmsHelper.commitIfNecessary(session);
        } else if (message != null && session.getAcknowledgeMode() == Session.CLIENT_ACKNOWLEDGE) {
            message.acknowledge();
        }
    } catch (jakarta.jms.TransactionInProgressException | jakarta.jms.IllegalStateException ex) {
    }
}",java:S112,4
"protected void initReplyManager(){
    if (!started.get()) {
        synchronized (this) {
            if (started.get()) {
                return;
            }
            ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
            ClassLoader ac = endpoint.getCamelContext().getApplicationContextClassLoader();
            try {
                if (ac != null) {
                    Thread.currentThread().setContextClassLoader(ac);
                }
                if (endpoint.getReplyToType() != null) {
                    if (endpoint.getReplyTo() != null && endpoint.getReplyToType().equals(ReplyToType.Temporary)) {
                        throw new IllegalArgumentException(""ReplyToType "" + ReplyToType.Temporary + "" is not supported when replyTo "" + endpoint.getReplyTo() + "" is also configured."");
                    }
                }
                if (endpoint.getReplyTo() != null) {
                    replyManager = createReplyManager(endpoint.getReplyTo());
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Using JmsReplyManager: {} to process replies from: {}"", replyManager, endpoint.getReplyTo());
                    }
                } else {
                    replyManager = createReplyManager();
                    LOG.debug(""Using JmsReplyManager: {} to process replies from temporary queue"", replyManager);
                }
            } catch (Exception e) {
                throw new FailedToCreateProducerException(endpoint, e);
            } finally {
                Thread.currentThread().setContextClassLoader(oldClassLoader);
            }
            started.set(true);
        }
    }
}",java:S3776,39
"private static boolean isSimplePredicate(Node node){
    Node parent = node.getParentNode();
    if (parent == null) {
        return false;
    }
    String name = parent.getNodeName();
    if (name == null) {
        return false;
    }
    if (name.equals(""completionPredicate"") || name.equals(""completion"")) {
        return true;
    }
    if (name.equals(""onWhen"") || name.equals(""when"") || name.equals(""handled"") || name.equals(""continued"")) {
        return true;
    }
    if (name.equals(""retryWhile"") || name.equals(""filter"") || name.equals(""validate"")) {
        return true;
    }
    if (name.equals(""loop"")) {
        String doWhile = null;
        if (parent.getAttributes() != null) {
            Node attr = parent.getAttributes().getNamedItem(""doWhile"");
            if (attr != null) {
                doWhile = attr.getTextContent();
            }
        }
        if (""true"".equalsIgnoreCase(doWhile)) {
            return true;
        }
    }
    return false;
}",java:S3776,39
"protected ReplyManager createReplyManager(String replyTo) throws Exception{
    ReplyManager replyManager = new QueueReplyManager(getEndpoint().getCamelContext());
    replyManager.setEndpoint(getEndpoint());
    String name = ""JmsReplyManagerTimeoutChecker["" + replyTo + ""]"";
    ScheduledExecutorService replyManagerScheduledExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(name, name);
    replyManager.setScheduledExecutorService(replyManagerScheduledExecutorService);
    name = ""JmsReplyManagerOnTimeout["" + replyTo + ""]"";
    int max = getEndpoint().getComponent().getReplyToOnTimeoutMaxConcurrentConsumers();
    if (max <= 0) {
        throw new IllegalArgumentException(""The option replyToOnTimeoutMaxConcurrentConsumers must be >= 1"");
    }
    ExecutorService replyManagerExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newThreadPool(replyManager, name, 0, max);
    replyManager.setOnTimeoutExecutorService(replyManagerExecutorService);
    ServiceHelper.startService(replyManager);
    return replyManager;
}",java:S112,4
"protected ReplyManager createReplyManager() throws Exception{
    ReplyManager temporaryQueueReplyManager = new TemporaryQueueReplyManager(getEndpoint().getCamelContext());
    temporaryQueueReplyManager.setEndpoint(getEndpoint());
    String name = ""JmsReplyManagerTimeoutChecker["" + getEndpoint().getEndpointConfiguredDestinationName() + ""]"";
    ScheduledExecutorService replyManagerScheduledExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(name, name);
    temporaryQueueReplyManager.setScheduledExecutorService(replyManagerScheduledExecutorService);
    name = ""JmsReplyManagerOnTimeout["" + getEndpoint().getEndpointConfiguredDestinationName() + ""]"";
    int max = getEndpoint().getComponent().getReplyToOnTimeoutMaxConcurrentConsumers();
    if (max <= 0) {
        throw new IllegalArgumentException(""The option replyToOnTimeoutMaxConcurrentConsumers must be >= 1"");
    }
    ExecutorService replyManagerExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newThreadPool(temporaryQueueReplyManager, name, 0, max);
    temporaryQueueReplyManager.setOnTimeoutExecutorService(replyManagerExecutorService);
    ServiceHelper.startService(temporaryQueueReplyManager);
    return temporaryQueueReplyManager;
}",java:S112,4
"protected boolean processInOnly(final Exchange exchange, final AsyncCallback callback){
    final org.apache.camel.Message in = exchange.getIn();
    String destinationName = in.getHeader(SjmsConstants.JMS_DESTINATION_NAME, String.class);
    if (destinationName != null) {
        in.removeHeader(SjmsConstants.JMS_DESTINATION_NAME);
    }
    if (destinationName == null) {
        destinationName = endpoint.getDestinationName();
    }
    final String to = destinationName;
    MessageCreator messageCreator = new MessageCreator() {

        public Message createMessage(Session session) throws JMSException {
            Message answer = endpoint.getBinding().makeJmsMessage(exchange, in, session, null);
            Object jmsReplyTo = JmsMessageHelper.getJMSReplyTo(answer);
            if (endpoint.isDisableReplyTo()) {
                LOG.trace(""ReplyTo is disabled on endpoint: {}"", endpoint);
                JmsMessageHelper.setJMSReplyTo(answer, null);
            } else {
                if (jmsReplyTo == null) {
                    jmsReplyTo = exchange.getIn().getHeader(SjmsConstants.JMS_REPLY_TO, String.class);
                    if (jmsReplyTo == null) {
                        jmsReplyTo = endpoint.getReplyTo();
                    }
                }
            }
            if (jmsReplyTo != null && !(endpoint.isPreserveMessageQos() || endpoint.isExplicitQosEnabled())) {
                LOG.debug(""Disabling JMSReplyTo: {} for destination: {}. Use preserveMessageQos=true to force Camel to keep the JMSReplyTo on endpoint: {}"", jmsReplyTo, to, endpoint);
                jmsReplyTo = null;
            }
            if (jmsReplyTo instanceof String) {
                String replyTo = (String) jmsReplyTo;
                jmsReplyTo = resolveOrCreateDestination(replyTo, session);
            }
            Destination replyTo = null;
            String replyToOverride = endpoint.getReplyToOverride();
            if (replyToOverride != null) {
                replyTo = resolveOrCreateDestination(replyToOverride, session);
            } else if (jmsReplyTo != null) {
                replyTo = (Destination) jmsReplyTo;
            }
            if (replyTo != null) {
                LOG.debug(""Using JMSReplyTo destination: {}"", replyTo);
                JmsMessageHelper.setJMSReplyTo(answer, replyTo);
            } else {
                LOG.trace(""Not using JMSReplyTo"");
                JmsMessageHelper.setJMSReplyTo(answer, null);
            }
            LOG.trace(""Created jakarta.jms.Message: {}"", answer);
            return answer;
        }
    };
    try {
        doSend(exchange, false, destinationName, messageCreator);
    } catch (Exception e) {
        exchange.setException(e);
        callback.done(true);
        return true;
    }
    setMessageId(exchange);
    callback.done(true);
    return true;
}",java:S3516,37
"protected boolean processInOnly(final Exchange exchange, final AsyncCallback callback){
    final org.apache.camel.Message in = exchange.getIn();
    String destinationName = in.getHeader(SjmsConstants.JMS_DESTINATION_NAME, String.class);
    if (destinationName != null) {
        in.removeHeader(SjmsConstants.JMS_DESTINATION_NAME);
    }
    if (destinationName == null) {
        destinationName = endpoint.getDestinationName();
    }
    final String to = destinationName;
    MessageCreator messageCreator = new MessageCreator() {

        public Message createMessage(Session session) throws JMSException {
            Message answer = endpoint.getBinding().makeJmsMessage(exchange, in, session, null);
            Object jmsReplyTo = JmsMessageHelper.getJMSReplyTo(answer);
            if (endpoint.isDisableReplyTo()) {
                LOG.trace(""ReplyTo is disabled on endpoint: {}"", endpoint);
                JmsMessageHelper.setJMSReplyTo(answer, null);
            } else {
                if (jmsReplyTo == null) {
                    jmsReplyTo = exchange.getIn().getHeader(SjmsConstants.JMS_REPLY_TO, String.class);
                    if (jmsReplyTo == null) {
                        jmsReplyTo = endpoint.getReplyTo();
                    }
                }
            }
            if (jmsReplyTo != null && !(endpoint.isPreserveMessageQos() || endpoint.isExplicitQosEnabled())) {
                LOG.debug(""Disabling JMSReplyTo: {} for destination: {}. Use preserveMessageQos=true to force Camel to keep the JMSReplyTo on endpoint: {}"", jmsReplyTo, to, endpoint);
                jmsReplyTo = null;
            }
            if (jmsReplyTo instanceof String) {
                String replyTo = (String) jmsReplyTo;
                jmsReplyTo = resolveOrCreateDestination(replyTo, session);
            }
            Destination replyTo = null;
            String replyToOverride = endpoint.getReplyToOverride();
            if (replyToOverride != null) {
                replyTo = resolveOrCreateDestination(replyToOverride, session);
            } else if (jmsReplyTo != null) {
                replyTo = (Destination) jmsReplyTo;
            }
            if (replyTo != null) {
                LOG.debug(""Using JMSReplyTo destination: {}"", replyTo);
                JmsMessageHelper.setJMSReplyTo(answer, replyTo);
            } else {
                LOG.trace(""Not using JMSReplyTo"");
                JmsMessageHelper.setJMSReplyTo(answer, null);
            }
            LOG.trace(""Created jakarta.jms.Message: {}"", answer);
            return answer;
        }
    };
    try {
        doSend(exchange, false, destinationName, messageCreator);
    } catch (Exception e) {
        exchange.setException(e);
        callback.done(true);
        return true;
    }
    setMessageId(exchange);
    callback.done(true);
    return true;
}",java:S3776,39
"public void send(MessageProducer producer, Message message) throws Exception{
    if (preserveMessageQos) {
        long ttl = message.getJMSExpiration();
        if (ttl != 0) {
            ttl = ttl - System.currentTimeMillis();
            if (ttl <= 0) {
                ttl = 1;
            }
        }
        int priority = message.getJMSPriority();
        if (priority < 0 || priority > 9) {
            priority = this.priority;
        }
        int resolvedDeliveryMode = resolveDeliveryMode(message);
        producer.send(message, resolvedDeliveryMode, priority, ttl);
    } else if (explicitQosEnabled) {
        producer.send(message, deliveryMode, priority, timeToLive);
    } else {
        producer.send(message);
    }
}",java:S112,4
"public Connection createConnection() throws Exception{
    return connectionFactory.createConnection();
}",java:S112,4
"public Session createSession(Connection connection) throws Exception{
    return connection.createSession(transacted, acknowledgeMode);
}",java:S112,4
"public void setTemplate(SjmsTemplate template){
    this.template = template;
}",java:S2886,33
"protected Exchange createExchange(Record record){
    Exchange ex = createExchange(true);
    ex.getIn().setBody(record, Record.class);
    return ex;
}",java:S6213,47
"protected void configureConsumer(MessageConsumer consumer, Session session) throws Exception{
    consumer.setMessageListener(new SimpleMessageListener(messageListener, session));
}",java:S112,4
"protected Session createSession(Connection connection, SjmsEndpoint endpoint) throws Exception{
    return connection.createSession(endpoint.isTransacted(), endpoint.getAcknowledgementMode().intValue());
}",java:S112,4
"protected void createConnection() throws Exception{
    synchronized (this.connectionLock) {
        if (this.connection == null) {
            Connection con = null;
            try {
                con = endpoint.getConnectionFactory().createConnection();
                String cid = clientId != null ? clientId : endpoint.getClientId();
                if (cid != null) {
                    con.setClientID(cid);
                }
                con.setExceptionListener(this);
            } catch (JMSException e) {
                closeConnection(con);
                throw e;
            }
            this.connection = con;
            LOG.debug(""Created JMS Connection"");
        }
    }
}",java:S112,4
"protected void startConnection() throws Exception{
    synchronized (this.connectionLock) {
        this.connectionStarted = true;
        if (this.connection != null) {
            try {
                this.connection.start();
            } catch (jakarta.jms.IllegalStateException e) {
            }
        }
    }
}",java:S112,4
"public void appendJmsProperty(Message jmsMessage, Exchange exchange, String headerName, Object headerValue) throws JMSException{
    if (isStandardJMSHeader(headerName)) {
        if (headerName.equals(JmsConstants.JMS_CORRELATION_ID)) {
            jmsMessage.setJMSCorrelationID(ExchangeHelper.convertToType(exchange, String.class, headerValue));
        } else if (headerName.equals(JmsConstants.JMS_REPLY_TO) && headerValue != null) {
            if (headerValue instanceof String) {
                headerValue = normalizeDestinationName((String) headerValue, true);
            }
            Destination replyTo = ExchangeHelper.convertToType(exchange, Destination.class, headerValue);
            JmsMessageHelper.setJMSReplyTo(jmsMessage, replyTo);
        } else if (headerName.equals(""JMSType"")) {
            jmsMessage.setJMSType(ExchangeHelper.convertToType(exchange, String.class, headerValue));
        } else if (headerName.equals(""JMSPriority"")) {
            jmsMessage.setJMSPriority(ExchangeHelper.convertToType(exchange, Integer.class, headerValue));
        } else if (headerName.equals(""JMSDeliveryMode"")) {
            JmsMessageHelper.setJMSDeliveryMode(exchange, jmsMessage, headerValue);
        } else if (headerName.equals(""JMSExpiration"")) {
            jmsMessage.setJMSExpiration(ExchangeHelper.convertToType(exchange, Long.class, headerValue));
        } else {
            LOG.trace(""Ignoring JMS header: {} with value: {}"", headerName, headerValue);
        }
    } else if (shouldOutputHeader(headerName, headerValue, exchange)) {
        Object value = getValidJMSHeaderValue(headerName, headerValue);
        if (value != null) {
            String key = jmsJmsKeyFormatStrategy.encodeKey(headerName);
            JmsMessageHelper.setProperty(jmsMessage, key, value);
        } else if (LOG.isDebugEnabled()) {
            LOG.debug(""Ignoring non primitive header: {} of class: {} with value: {}"", headerName, headerValue.getClass().getName(), headerValue);
        }
    }
}",java:S3776,39
"private MessageConsumer createSubscriptionTopicConsumer(Session session, Destination destination, String messageSelector, String subscriptionId, boolean durable, boolean shared, boolean noLocal) throws JMSException{
    if (shared) {
        if (durable) {
            if (ObjectHelper.isNotEmpty(messageSelector)) {
                return session.createSharedDurableConsumer((Topic) destination, subscriptionId, messageSelector);
            } else {
                return session.createSharedDurableConsumer((Topic) destination, subscriptionId);
            }
        } else {
            if (ObjectHelper.isNotEmpty(messageSelector)) {
                return session.createSharedConsumer((Topic) destination, subscriptionId, messageSelector);
            } else {
                return session.createSharedConsumer((Topic) destination, subscriptionId);
            }
        }
    } else {
        if (durable) {
            if (ObjectHelper.isNotEmpty(messageSelector)) {
                return session.createDurableSubscriber((Topic) destination, subscriptionId, messageSelector, noLocal);
            } else {
                return session.createDurableSubscriber((Topic) destination, subscriptionId);
            }
        } else {
            return createSubscriptionlessTopicConsumer(session, destination, messageSelector, noLocal);
        }
    }
}",java:S3776,39
"private Queue<Exchange> createExchanges(final List<Message> list){
    Queue<Exchange> answer = new LinkedList<>();
    if (ObjectHelper.isNotEmpty(list)) {
        if (slackEndpoint.isNaturalOrder()) {
            for (int i = list.size() - 1; i >= 0; i--) {
                Message message = list.get(i);
                if (i == 0) {
                    timestamp = message.getTs();
                }
                Exchange exchange = createExchange(message);
                answer.add(exchange);
            }
        } else {
            for (int i = 0; i < list.size(); i++) {
                Message message = list.get(i);
                if (i == 0) {
                    timestamp = message.getTs();
                }
                Exchange exchange = createExchange(message);
                answer.add(exchange);
            }
        }
    }
    return answer;
}",java:S3776,39
"@Deprecated
@SuppressWarnings({ ""rawtypes"", ""unchecked"" })
protected List<OptionalParameter> createOptionalParametersByName(Map<String, String> optinalParamaters){
    List<OptionalParameter> optParams = new ArrayList<>();
    for (Entry<String, String> entry : optinalParamaters.entrySet()) {
        OptionalParameter optParam = null;
        String value = entry.getValue();
        try {
            Tag tag = Tag.valueOf(entry.getKey());
            Class type = determineTypeClass(tag);
            Set<Class> ancestorClasses = new HashSet<>(2);
            Class superclass = type.getSuperclass();
            ancestorClasses.add(superclass);
            if (superclass != Object.class) {
                ancestorClasses.add(superclass.getSuperclass());
            }
            if (ancestorClasses.contains(OctetString.class)) {
                optParam = (OptionalParameter) type.getConstructor(byte[].class).newInstance(value.getBytes());
            } else if (ancestorClasses.contains(OptionalParameter.Byte.class)) {
                Byte byteValue = (value == null) ? 0 : Byte.parseByte(value);
                optParam = (OptionalParameter) type.getConstructor(byte.class).newInstance(byteValue);
            } else if (ancestorClasses.contains(OptionalParameter.Int.class)) {
                Integer intValue = (value == null) ? 0 : Integer.parseInt(value);
                optParam = (OptionalParameter) type.getConstructor(int.class).newInstance(intValue);
            } else if (ancestorClasses.contains(OptionalParameter.Short.class)) {
                Short shortValue = (value == null) ? 0 : Short.parseShort(value);
                optParam = (OptionalParameter) type.getConstructor(short.class).newInstance(shortValue);
            }
            optParams.add(optParam);
        } catch (Exception e) {
            log.info(""Couldn't determine optional parameter for key {} and value {}. Skip this one."", entry.getKey(), value);
        }
    }
    return optParams;
}",java:S6355,48
"@Deprecated
public void initiate() throws Exception{
}",java:S6355,48
"public void processPDU(PDU pdu, CommandResponderEvent event){
    if (LOG.isDebugEnabled()) {
        LOG.debug(""Received trap event for {} : {}"", this.endpoint.getAddress(), pdu);
    }
    Exchange exchange = createExchange(pdu, event);
    try {
        getProcessor().process(exchange);
    } catch (Exception e) {
        exchange.setException(e);
    }
    if (exchange.getException() != null) {
        getExceptionHandler().handleException(exchange.getException());
    }
    releaseExchange(exchange, false);
}",java:S1845,24
"public void processPDU(PDU pdu, CommandResponderEvent event){
    if (LOG.isDebugEnabled()) {
        LOG.debug(""Received trap event for {} : {}"", this.endpoint.getAddress(), pdu);
    }
    Exchange exchange = createExchange(pdu, event);
    try {
        getProcessor().process(exchange);
    } catch (Exception e) {
        exchange.setException(e);
    }
    if (exchange.getException() != null) {
        getExceptionHandler().handleException(exchange.getException());
    }
    releaseExchange(exchange, false);
}",java:S3740,38
"public Exchange createExchange(PDU pdu, CommandResponderEvent event){
    Exchange exchange = createExchange(false);
    exchange.setIn(new SnmpMessage(getEndpoint().getCamelContext(), pdu, event));
    return exchange;
}",java:S3740,38
"private void analyzeServiceInterface(Class<?> serviceInterface){
    Method[] methods = serviceInterface.getMethods();
    for (Method method : methods) {
        MethodInfo info = analyzeMethod(method);
        for (int i = 0; i < info.getIn().length; i++) {
            TypeInfo ti = info.getIn()[i];
            if (inTypeNameToQName.containsKey(ti.getTypeName())) {
                if (ti.getTypeName() != null) {
                    if (!ti.getTypeName().equals(""jakarta.xml.ws.Holder"") && !inTypeNameToQName.get(ti.getTypeName()).equals(ti.getElName())) {
                        LOG.warn(""Ambiguous QName mapping. The type [{}] is already mapped to a QName in this context."", ti.getTypeName());
                        continue;
                    }
                }
            }
            inTypeNameToQName.put(ti.getTypeName(), ti.getElName());
        }
        String soapAction = info.getSoapAction();
        if (soapAction != null && !soapAction.isEmpty()) {
            soapActionToMethodInfo.put(soapAction, info);
            addExceptions(soapAction, method);
        } else {
            addExceptions(null, method);
        }
        outTypeNameToQName.put(info.getOut().getTypeName(), info.getOut().getElName());
    }
}",java:S3776,39
"public synchronized Service createService(CamelContext camelContext){
    final ServiceArgs args = new ServiceArgs();
    if (host != null) {
        args.setHost(host);
    }
    if (port > 0) {
        args.setPort(port);
    }
    if (scheme != null) {
        args.setScheme(scheme);
    }
    if (app != null) {
        args.setApp(app);
    }
    if (owner != null) {
        args.setOwner(owner);
    }
    if (username != null) {
        args.setUsername(username);
    }
    if (password != null && token == null) {
        args.setPassword(password);
    }
    if (token != null) {
        args.setToken(String.format(""Bearer %s"", token));
        args.remove(""username"");
        args.remove(""password"");
    }
    if (isUseSunHttpsHandler()) {
        String sunHandlerClassName = ""sun.net.www.protocol.https.Handler"";
        Class<URLStreamHandler> clazz = camelContext.getClassResolver().resolveClass(sunHandlerClassName, URLStreamHandler.class);
        if (clazz != null) {
            URLStreamHandler handler = camelContext.getInjector().newInstance(clazz);
            args.setHTTPSHandler(handler);
            LOG.debug(""using the URLStreamHandler {} for {}"", handler, args);
        } else {
            LOG.warn(""could not resolve and use the URLStreamHandler class '{}'"", sunHandlerClassName);
        }
    }
    ExecutorService executor = camelContext.getExecutorServiceManager().newSingleThreadExecutor(this, ""DefaultSplunkConnectionFactory"");
    Future<Service> future = executor.submit(new Callable<Service>() {

        public Service call() throws Exception {
            if (Service.DEFAULT_SCHEME.equals(getScheme())) {
                LOG.debug(""Https in use. Setting SSL protocol to {}"", getSslProtocol());
                HttpService.setSslSecurityProtocol(getSslProtocol());
            }
            return Service.connect(args);
        }
    });
    try {
        Service service = null;
        if (connectionTimeout > 0) {
            service = future.get(connectionTimeout, TimeUnit.MILLISECONDS);
        } else {
            service = future.get();
        }
        LOG.info(""Successfully connected to Splunk"");
        return service;
    } catch (Exception e) {
        throw new RuntimeException(String.format(""could not connect to Splunk Server @ %s:%d - %s"", host, port, e.getMessage()), e);
    } finally {
        camelContext.getExecutorServiceManager().shutdownNow(executor);
    }
}",java:S3776,39
"private List<SplunkEvent> extractData(Job job, boolean realtime, SplunkResultProcessor callback) throws Exception{
    List<SplunkEvent> result = new ArrayList<>();
    HashMap<String, String> data;
    SplunkEvent splunkData;
    ResultsReader resultsReader = null;
    int total = 0;
    if (realtime) {
        total = job.getResultPreviewCount();
    } else {
        total = job.getResultCount();
    }
    if (getCount() == 0 || total < getCount()) {
        InputStream stream = null;
        JobResultsArgs outputArgs = new JobResultsArgs();
        outputArgs.setOutputMode(OutputMode.JSON);
        if (realtime) {
            if (getCount() > 0) {
                outputArgs.setCount(getCount());
            }
            stream = job.getResultsPreview(outputArgs);
        } else {
            stream = job.getResults(outputArgs);
        }
        resultsReader = new ResultsReaderJson(stream);
        while ((data = resultsReader.getNextEvent()) != null) {
            splunkData = new SplunkEvent(data);
            if (callback != null) {
                callback.process(splunkData);
            } else {
                result.add(splunkData);
            }
        }
        IOHelper.close(stream);
    } else {
        int offset = 0;
        while (offset < total) {
            InputStream stream;
            JobResultsArgs outputArgs = new JobResultsArgs();
            outputArgs.setOutputMode(OutputMode.JSON);
            outputArgs.setCount(getCount());
            outputArgs.setOffset(offset);
            if (realtime) {
                stream = job.getResultsPreview(outputArgs);
            } else {
                stream = job.getResults(outputArgs);
            }
            resultsReader = new ResultsReaderJson(stream);
            while ((data = resultsReader.getNextEvent()) != null) {
                splunkData = new SplunkEvent(data);
                if (callback != null) {
                    callback.process(splunkData);
                } else {
                    result.add(splunkData);
                }
            }
            offset += getCount();
            IOHelper.close(stream);
        }
    }
    if (resultsReader != null) {
        resultsReader.close();
    }
    job.cancel();
    return result;
}",java:S3776,39
"private List<SplunkEvent> extractData(Job job, boolean realtime, SplunkResultProcessor callback) throws Exception{
    List<SplunkEvent> result = new ArrayList<>();
    HashMap<String, String> data;
    SplunkEvent splunkData;
    ResultsReader resultsReader = null;
    int total = 0;
    if (realtime) {
        total = job.getResultPreviewCount();
    } else {
        total = job.getResultCount();
    }
    if (getCount() == 0 || total < getCount()) {
        InputStream stream = null;
        JobResultsArgs outputArgs = new JobResultsArgs();
        outputArgs.setOutputMode(OutputMode.JSON);
        if (realtime) {
            if (getCount() > 0) {
                outputArgs.setCount(getCount());
            }
            stream = job.getResultsPreview(outputArgs);
        } else {
            stream = job.getResults(outputArgs);
        }
        resultsReader = new ResultsReaderJson(stream);
        while ((data = resultsReader.getNextEvent()) != null) {
            splunkData = new SplunkEvent(data);
            if (callback != null) {
                callback.process(splunkData);
            } else {
                result.add(splunkData);
            }
        }
        IOHelper.close(stream);
    } else {
        int offset = 0;
        while (offset < total) {
            InputStream stream;
            JobResultsArgs outputArgs = new JobResultsArgs();
            outputArgs.setOutputMode(OutputMode.JSON);
            outputArgs.setCount(getCount());
            outputArgs.setOffset(offset);
            if (realtime) {
                stream = job.getResultsPreview(outputArgs);
            } else {
                stream = job.getResults(outputArgs);
            }
            resultsReader = new ResultsReaderJson(stream);
            while ((data = resultsReader.getNextEvent()) != null) {
                splunkData = new SplunkEvent(data);
                if (callback != null) {
                    callback.process(splunkData);
                } else {
                    result.add(splunkData);
                }
            }
            offset += getCount();
            IOHelper.close(stream);
        }
    }
    if (resultsReader != null) {
        resultsReader.close();
    }
    job.cancel();
    return result;
}",java:S112,4
"@Deprecated
public String getJobLauncherRef(){
    return jobLauncherRef;
}",java:S6355,48
"@Deprecated
public void setJobLauncherRef(String jobLauncherRef){
    this.jobLauncherRef = jobLauncherRef;
}",java:S6355,48
"protected AbstractApplicationContext createDefaultApplicationContext(){
    ApplicationContext parentContext = getParentApplicationContext();
    if (getFileApplicationContextUri() != null) {
        String[] args = getFileApplicationContextUri().split("";"");
        if (parentContext != null) {
            return new FileSystemXmlApplicationContext(args, parentContext);
        } else {
            return new FileSystemXmlApplicationContext(args);
        }
    }
    String[] args = getApplicationContextUri().split("";"");
    if (parentContext != null) {
        return new ClassPathXmlApplicationContext(args, parentContext);
    } else {
        if (mainConfigurationProperties.getRoutesBuilderClasses() != null) {
            AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext();
            ac.register(SpringCamelContext.class);
            Set<String> packages = new LinkedHashSet<>();
            String[] classes = mainConfigurationProperties.getRoutesBuilderClasses().split("","");
            for (String clazz : classes) {
                if (clazz.contains(""."")) {
                    String packageName = clazz.substring(0, clazz.lastIndexOf('.'));
                    packages.add(packageName);
                }
            }
            LOG.info(""Using Spring annotation scanning in packages: {}"", packages);
            ac.scan(packages.toArray(new String[0]));
            ac.refresh();
            return ac;
        } else {
            return new ClassPathXmlApplicationContext(args);
        }
    }
}",java:S3776,39
"public void setTemplate(RabbitTemplate template){
    this.template = template;
}",java:S2886,33
"public void declareElements(AbstractMessageListenerContainer container){
    AmqpAdmin admin = null;
    if (container instanceof MessageListenerContainer) {
        admin = ((MessageListenerContainer) container).getAmqpAdmin();
    }
    if (admin != null && autoDeclare) {
        if (deadLetterExchange != null) {
            ExchangeBuilder eb = new ExchangeBuilder(deadLetterExchange, deadLetterExchangeType);
            eb.withArguments(getDlqExchangeArgs());
            final org.springframework.amqp.core.Exchange rabbitExchange = eb.build();
            admin.declareExchange(rabbitExchange);
            if (deadLetterQueue != null) {
                QueueBuilder qb = QueueBuilder.durable(deadLetterQueue);
                Map<String, Object> args = getDlqQueueArgs();
                qb.withArguments(args);
                final Queue rabbitQueue = qb.build();
                admin.declareQueue(rabbitQueue);
                Binding binding = new Binding(rabbitQueue.getName(), Binding.DestinationType.QUEUE, rabbitExchange.getName(), deadLetterRoutingKey, getDlqBindingArgs());
                admin.declareBinding(binding);
                LOG.info(""Auto-declaring durable DeadLetterExchange: {} routingKey: {}"", deadLetterExchange, deadLetterRoutingKey);
            }
        }
        Map<String, Object> map = getExchangeArgs();
        boolean durable = parseArgsBoolean(map, ""durable"", ""true"");
        boolean autoDelete = parseArgsBoolean(map, ""autoDelete"", ""false"");
        if (!durable || autoDelete) {
            LOG.info(""Auto-declaring a non-durable or auto-delete Exchange ({}) durable:{}, auto-delete:{}. "" + ""It will be deleted by the broker if it shuts down, and can be redeclared by closing and "" + ""reopening the connection."", exchangeName, durable, autoDelete);
        }
        String en = SpringRabbitMQHelper.isDefaultExchange(getExchangeName()) ? """" : getExchangeName();
        ExchangeBuilder eb = new ExchangeBuilder(en, getExchangeType());
        eb.durable(durable);
        if (autoDelete) {
            eb.autoDelete();
        }
        eb.withArguments(map);
        final org.springframework.amqp.core.Exchange rabbitExchange = eb.build();
        admin.declareExchange(rabbitExchange);
        String queuesToDeclare = queues;
        String autoDeleteDefault = ""false"";
        boolean generateUniqueQueue = false;
        if (queuesToDeclare == null) {
            queuesToDeclare = "" "";
            generateUniqueQueue = true;
        }
        for (String queue : queuesToDeclare.split("","")) {
            queue = queue.trim();
            map = getQueueArgs();
            prepareDeadLetterQueueArgs(map);
            durable = parseArgsBoolean(map, ""durable"", ""false"");
            autoDelete = parseArgsBoolean(map, ""autoDelete"", autoDeleteDefault);
            boolean exclusive = parseArgsBoolean(map, ""exclusive"", ""false"");
            QueueBuilder qb;
            if (queue.isEmpty()) {
                qb = durable ? QueueBuilder.durable() : QueueBuilder.nonDurable();
            } else {
                qb = durable ? QueueBuilder.durable(queue) : QueueBuilder.nonDurable(queue);
            }
            if (autoDelete) {
                qb.autoDelete();
            }
            if (exclusive) {
                qb.exclusive();
            }
            String dle = parseArgsString(args, ""x-dead-letter-exchange"", deadLetterExchange);
            if (dle != null) {
                qb.deadLetterExchange(dle);
            }
            String dlrk = parseArgsString(args, ""x-dead-letter-routing-key"", deadLetterRoutingKey);
            if (dlrk != null) {
                qb.deadLetterRoutingKey(dlrk);
            }
            qb.withArguments(map);
            final Queue rabbitQueue = qb.build();
            if (!durable || autoDelete || exclusive) {
                LOG.info(""Auto-declaring a non-durable, auto-delete, or exclusive Queue ({})"" + ""durable:{}, auto-delete:{}, exclusive:{}. It will be redeclared if the broker stops and "" + ""is restarted while the connection factory is alive, but all messages will be lost."", rabbitQueue.getName(), durable, autoDelete, exclusive);
            }
            String qn = admin.declareQueue(rabbitQueue);
            if (generateUniqueQueue) {
                container.setQueueNames(qn);
            }
            Binding binding = new Binding(qn, Binding.DestinationType.QUEUE, rabbitExchange.getName(), routingKey, getBindingArgs());
            admin.declareBinding(binding);
        }
    }
}",java:S3776,39
"public RedisTemplate<?, ?> getRedisTemplate(){
    return redisTemplate;
}",java:S1452,23
"public RedisTemplate<?, ?> getRedisTemplate(){
    return redisTemplate;
}",java:S1452,23
"public RedisTemplate<?, ?> getRedisTemplate(){
    return redisTemplate;
}",java:S3740,38
"public void setRedisTemplate(RedisTemplate<?, ?> redisTemplate){
    this.redisTemplate = redisTemplate;
}",java:S3740,38
"public RedisTemplate<?, ?> getRedisTemplate(){
    return redisTemplate != null ? redisTemplate : createDefaultTemplate();
}",java:S1452,23
"public RedisTemplate<?, ?> getRedisTemplate(){
    return redisTemplate != null ? redisTemplate : createDefaultTemplate();
}",java:S1452,23
"public RedisTemplate<?, ?> getRedisTemplate(){
    return redisTemplate != null ? redisTemplate : createDefaultTemplate();
}",java:S3740,38
"public void setRedisTemplate(RedisTemplate<?, ?> redisTemplate){
    this.redisTemplate = redisTemplate;
}",java:S3740,38
"public RedisSerializer<?> getSerializer(){
    return serializer != null ? serializer : createDefaultSerializer();
}",java:S1452,23
"public RedisSerializer<?> getSerializer(){
    return serializer != null ? serializer : createDefaultSerializer();
}",java:S3740,38
"public void setSerializer(RedisSerializer<?> serializer){
    this.serializer = serializer;
}",java:S3740,38
"private RedisTemplate<?, ?> createDefaultTemplate(){
    redisTemplate = new RedisTemplate<>();
    redisTemplate.setDefaultSerializer(getSerializer());
    redisTemplate.setConnectionFactory(getConnectionFactory());
    redisTemplate.afterPropertiesSet();
    return redisTemplate;
}",java:S3740,38
"private RedisSerializer<?> createDefaultSerializer(){
    serializer = new JdkSerializationRedisSerializer();
    return serializer;
}",java:S3740,38
"protected void beforeProcess(Exchange exchange) throws Exception{
    List<ConfigAttribute> attributes = accessPolicy.getConfigAttributes();
    try {
        Authentication authToken = getAuthentication(exchange.getIn());
        if (authToken == null) {
            throw new CamelAuthorizationException(""Cannot find the Authentication instance."", exchange);
        }
        Authentication authenticated = authenticateIfRequired(authToken);
        try {
            this.accessDecisionManager.decide(authenticated, exchange, attributes);
        } catch (AccessDeniedException accessDeniedException) {
            exchange.getIn().setHeader(Exchange.AUTHENTICATION_FAILURE_POLICY_ID, getId());
            AuthorizationFailureEvent event = new AuthorizationFailureEvent(exchange, attributes, authenticated, accessDeniedException);
            publishEvent(event);
            throw accessDeniedException;
        }
        publishEvent(new AuthorizedEvent(exchange, attributes, authenticated));
    } catch (RuntimeException exception) {
        exchange.getIn().setHeader(Exchange.AUTHENTICATION_FAILURE_POLICY_ID, getId());
        throw new CamelAuthorizationException(""Cannot access the processor which has been protected."", exchange, exception);
    }
}",java:S112,4
"public AccessDecisionManager getAccessDecisionManager(){
    return accessDecisionManager;
}",java:S1874,25
"public void setAccessDecisionManager(AccessDecisionManager accessDecisionManager){
    this.accessDecisionManager = accessDecisionManager;
}",java:S1874,25
"protected void postProcess(BeanDefinitionBuilder beanDefinition, Element element){
}",java:S1186,16
"private void prepareMessageSenders(SpringWebserviceConfiguration configuration){
    if (!(configuration.getTimeout() > -1) && configuration.getSslContextParameters() == null) {
        return;
    }
    WebServiceTemplate webServiceTemplate = configuration.getWebServiceTemplate();
    WebServiceMessageSender[] messageSenders = webServiceTemplate.getMessageSenders();
    for (int i = 0; i < messageSenders.length; i++) {
        WebServiceMessageSender messageSender = messageSenders[i];
        if (messageSender instanceof HttpComponentsMessageSender) {
            if (configuration.getSslContextParameters() != null) {
                LOG.warn(""Not applying SSLContextParameters based configuration to HttpComponentsMessageSender.  "" + ""If you are using this MessageSender, which you are not by default, you will need "" + ""to configure SSL using the Commons HTTP 3.x Protocol registry."");
            }
            if (configuration.getTimeout() > -1) {
                if (messageSender.getClass().equals(HttpComponentsMessageSender.class)) {
                    ((HttpComponentsMessageSender) messageSender).setReadTimeout(configuration.getTimeout());
                } else {
                    LOG.warn(""Not applying timeout configuration to HttpComponentsMessageSender based implementation.  "" + ""You are using what appears to be a custom MessageSender, which you are not doing by default. "" + ""You will need configure timeout on your own."");
                }
            }
        } else if (messageSender.getClass().equals(HttpUrlConnectionMessageSender.class)) {
            messageSenders[i] = new AbstractHttpWebServiceMessageSenderDecorator((HttpUrlConnectionMessageSender) messageSender, configuration, getEndpoint().getCamelContext());
        } else {
            LOG.warn(""Ignoring the timeout and SSLContextParameters options for {}.  You will need to configure "" + ""these options directly on your custom configured WebServiceMessageSender"", messageSender);
        }
    }
}",java:S3776,39
"protected URI getDefaultResponseAction(Object endpoint, MessageAddressingProperties requestMap){
    URI requestAction = requestMap.getAction();
    if (requestAction != null) {
        return URI.create(requestAction.toString() + getOutputActionSuffix());
    } else {
        return null;
    }
}",java:S1172,13
"protected URI getDefaultFaultAction(Object endpoint, MessageAddressingProperties requestMap){
    URI requestAction = requestMap.getAction();
    if (requestAction != null) {
        return URI.create(requestAction.toString() + getFaultActionSuffix());
    } else {
        return null;
    }
}",java:S1172,13
"public void setDefaultServiceCallConfiguration(ServiceCallConfigurationDefinition defaultServiceCallConfiguration){
    this.defaultServiceCallConfiguration = defaultServiceCallConfiguration;
}",java:S1874,25
"public void setServiceCallConfigurations(List<ServiceCallConfigurationDefinition> serviceCallConfigurations){
    this.serviceCallConfigurations = serviceCallConfigurations;
}",java:S1874,25
"public List<RestDefinition> getRests(){
    return rests;
}",java:S4144,40
"public List<RouteConfigurationDefinition> getRouteConfigurations(){
    return routeConfigurations;
}",java:S4144,40
"public List<RouteDefinition> getRoutes(){
    return routes;
}",java:S4144,40
"public List<RouteTemplateDefinition> getRouteTemplates(){
    return routeTemplates;
}",java:S4144,40
"protected void postProcess(BeanDefinitionBuilder beanDefinition, Element element){
}",java:S1186,16
"public static void doBeforeParse(Node node){
    if (node.getNodeType() == Node.ELEMENT_NODE) {
        Document doc = node.getOwnerDocument();
        if (node.getNamespaceURI().startsWith(SPRING_NS + ""/v"")) {
            doc.renameNode(node, SPRING_NS, node.getNodeName());
        }
        NamedNodeMap map = node.getAttributes();
        for (int i = 0; i < map.getLength(); i++) {
            Node att = map.item(i);
            if (att.getNodeName().equals(""uri"") || att.getNodeName().endsWith(""Uri"")) {
                final String value = att.getNodeValue();
                String before = StringHelper.before(value, ""?"");
                String after = StringHelper.after(value, ""?"");
                if (before != null && after != null) {
                    String changed = after.replaceAll(""\\s{2,}"", """");
                    if (!after.equals(changed)) {
                        String newAtr = before.trim() + ""?"" + changed.trim();
                        LOG.debug(""Removed whitespace noise from attribute {} -> {}"", value, newAtr);
                        att.setNodeValue(newAtr);
                    }
                }
            }
        }
    }
    NodeList list = node.getChildNodes();
    for (int i = 0; i < list.getLength(); ++i) {
        doBeforeParse(list.item(i));
    }
}",java:S3776,39
"protected Object parseUsingJaxb(Element element, ParserContext parserContext, Binder<Node> binder){
    try {
        return binder.unmarshal(element);
    } catch (JAXBException e) {
        throw new BeanDefinitionStoreException(""Failed to parse JAXB element"", e);
    }
}",java:S1172,13
"private void addDependsOnToRouteBuilder(Element childElement, ParserContext parserContext, String contextId){
    String routeBuilderName = childElement.getAttribute(""ref"");
    if (ObjectHelper.isNotEmpty(routeBuilderName)) {
        try {
            BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(routeBuilderName);
            Method getDependsOn = definition.getClass().getMethod(""getDependsOn"", new Class[] {});
            String[] dependsOn = (String[]) getDependsOn.invoke(definition);
            if (dependsOn == null || dependsOn.length == 0) {
                dependsOn = new String[] { contextId };
            } else {
                String[] temp = new String[dependsOn.length + 1];
                System.arraycopy(dependsOn, 0, temp, 0, dependsOn.length);
                temp[dependsOn.length] = contextId;
                dependsOn = temp;
            }
            Method method = definition.getClass().getMethod(""setDependsOn"", String[].class);
            method.invoke(definition, (Object) dependsOn);
        } catch (Exception e) {
        }
    }
}",java:S3398,35
"protected void registerTemplates(Element element, ParserContext parserContext, String contextId){
    boolean template = false;
    boolean fluentTemplate = false;
    boolean consumerTemplate = false;
    NodeList list = element.getChildNodes();
    int size = list.getLength();
    for (int i = 0; i < size; i++) {
        Node child = list.item(i);
        if (child instanceof Element) {
            Element childElement = (Element) child;
            String localName = childElement.getLocalName();
            if (""template"".equals(localName)) {
                template = true;
            } else if (""fluentTemplate"".equals(localName)) {
                fluentTemplate = true;
            } else if (""consumerTemplate"".equals(localName)) {
                consumerTemplate = true;
            }
        }
    }
    if (!template) {
        boolean existing = autoRegisterMap.get(""template"") != null;
        boolean inUse = false;
        try {
            inUse = parserContext.getRegistry().isBeanNameInUse(""template"");
        } catch (BeanCreationException e) {
            LOG.debug(""Error checking isBeanNameInUse(template). This exception will be ignored"", e);
        }
        if (!inUse || existing) {
            String id = ""template"";
            Element templateElement = element.getOwnerDocument().createElement(""template"");
            templateElement.setAttribute(""id"", id);
            BeanDefinitionParser parser = parserMap.get(""template"");
            BeanDefinition definition = parser.parse(templateElement, parserContext);
            autoRegisterBeanDefinition(id, definition, parserContext, contextId);
        }
    }
    if (!fluentTemplate) {
        boolean existing = autoRegisterMap.get(""fluentTemplate"") != null;
        boolean inUse = false;
        try {
            inUse = parserContext.getRegistry().isBeanNameInUse(""fluentTemplate"");
        } catch (BeanCreationException e) {
            LOG.debug(""Error checking isBeanNameInUse(fluentTemplate). This exception will be ignored"", e);
        }
        if (!inUse || existing) {
            String id = ""fluentTemplate"";
            Element templateElement = element.getOwnerDocument().createElement(""fluentTemplate"");
            templateElement.setAttribute(""id"", id);
            BeanDefinitionParser parser = parserMap.get(""fluentTemplate"");
            BeanDefinition definition = parser.parse(templateElement, parserContext);
            autoRegisterBeanDefinition(id, definition, parserContext, contextId);
        }
    }
    if (!consumerTemplate) {
        boolean existing = autoRegisterMap.get(""consumerTemplate"") != null;
        boolean inUse = false;
        try {
            inUse = parserContext.getRegistry().isBeanNameInUse(""consumerTemplate"");
        } catch (BeanCreationException e) {
            LOG.debug(""Error checking isBeanNameInUse(consumerTemplate). This exception will be ignored"", e);
        }
        if (!inUse || existing) {
            String id = ""consumerTemplate"";
            Element templateElement = element.getOwnerDocument().createElement(""consumerTemplate"");
            templateElement.setAttribute(""id"", id);
            BeanDefinitionParser parser = parserMap.get(""consumerTemplate"");
            BeanDefinition definition = parser.parse(templateElement, parserContext);
            autoRegisterBeanDefinition(id, definition, parserContext, contextId);
        }
    }
}",java:S3776,39
"private void registerEndpoint(Element childElement, ParserContext parserContext, String contextId){
    String id = childElement.getAttribute(""id"");
    if (ObjectHelper.isNotEmpty(id)) {
        if (id.startsWith(""_"")) {
            LOG.debug(""Skip registering endpoint starting with underscore: {}"", id);
            return;
        }
        BeanDefinition definition = endpointParser.parse(childElement, parserContext);
        definition.getPropertyValues().addPropertyValue(""camelContext"", new RuntimeBeanReference(contextId));
        try {
            Method method = definition.getClass().getMethod(""setDependsOn"", String[].class);
            method.invoke(definition, (Object) new String[] { contextId });
        } catch (Exception e) {
        }
        parserContext.registerComponent(new BeanComponentDefinition(definition, id));
    }
}",java:S3398,35
"@Deprecated
public Message getResponse(){
    return exchange.getOut();
}",java:S6355,48
"@Deprecated
public static SpringCamelContext springCamelContext(ApplicationContext applicationContext, boolean maybeStart) throws Exception{
    if (applicationContext != null) {
        String[] names = applicationContext.getBeanNamesForType(SpringCamelContext.class);
        if (names.length == 1) {
            return applicationContext.getBean(names[0], SpringCamelContext.class);
        }
    }
    SpringCamelContext answer = new SpringCamelContext();
    answer.setApplicationContext(applicationContext);
    answer.build();
    if (maybeStart) {
        answer.start();
    }
    return answer;
}",java:S6355,48
"private void logTransactionRollback(String redelivered, String ids, Throwable e, boolean rollbackOnly){
    if (rollbackLoggingLevel == LoggingLevel.OFF) {
        return;
    } else if (rollbackLoggingLevel == LoggingLevel.ERROR && LOG.isErrorEnabled()) {
        if (rollbackOnly) {
            LOG.error(""Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly"", transactionKey, redelivered, ids);
        } else {
            LOG.error(""Transaction rollback ({}) redelivered({}) for {} caught: {}"", transactionKey, redelivered, ids, e.getMessage());
        }
    } else if (rollbackLoggingLevel == LoggingLevel.WARN && LOG.isWarnEnabled()) {
        if (rollbackOnly) {
            LOG.warn(""Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly"", transactionKey, redelivered, ids);
        } else {
            LOG.warn(""Transaction rollback ({}) redelivered({}) for {} caught: {}"", transactionKey, redelivered, ids, e.getMessage());
        }
    } else if (rollbackLoggingLevel == LoggingLevel.INFO && LOG.isInfoEnabled()) {
        if (rollbackOnly) {
            LOG.info(""Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly"", transactionKey, redelivered, ids);
        } else {
            LOG.info(""Transaction rollback ({}) redelivered({}) for {} caught: {}"", transactionKey, redelivered, ids, e.getMessage());
        }
    } else if (rollbackLoggingLevel == LoggingLevel.DEBUG && LOG.isDebugEnabled()) {
        if (rollbackOnly) {
            LOG.debug(""Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly"", transactionKey, redelivered, ids);
        } else {
            LOG.debug(""Transaction rollback ({}) redelivered({}) for {} caught: {}"", transactionKey, redelivered, ids, e.getMessage());
        }
    } else if (rollbackLoggingLevel == LoggingLevel.TRACE && LOG.isTraceEnabled()) {
        if (rollbackOnly) {
            LOG.trace(""Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly"", transactionKey, redelivered, ids);
        } else {
            LOG.trace(""Transaction rollback ({}) redelivered({}) for {} caught: {}"", transactionKey, redelivered, ids, e.getMessage());
        }
    }
}",java:S3776,39
"private TransactionTemplate resolveTransactionTemplate(TransactionErrorHandlerDefinition definition){
    TransactionTemplate answer = null;
    SpringTransactionPolicy policy = (SpringTransactionPolicy) definition.getTransactedPolicy();
    if (policy == null && definition.getTransactedPolicyRef() != null) {
        policy = mandatoryLookup(definition.getTransactedPolicyRef(), SpringTransactionPolicy.class);
    }
    if (policy != null) {
        answer = ((SpringTransactionPolicy) policy).getTransactionTemplate();
    }
    if (answer == null) {
        Map<String, SpringTransactionPolicy> mapPolicy = findByTypeWithName(SpringTransactionPolicy.class);
        if (mapPolicy != null && mapPolicy.size() == 1) {
            policy = mapPolicy.values().iterator().next();
            if (policy != null) {
                answer = policy.getTransactionTemplate();
            }
        }
    }
    if (answer == null) {
        policy = lookupByNameAndType(PROPAGATION_REQUIRED, SpringTransactionPolicy.class);
        if (policy != null) {
            answer = policy.getTransactionTemplate();
        }
    }
    if (answer == null) {
        Map<String, TransactionTemplate> mapTemplate = findByTypeWithName(TransactionTemplate.class);
        if (mapTemplate == null || mapTemplate.isEmpty()) {
            LOG.trace(""No TransactionTemplate found in registry."");
        } else if (mapTemplate.size() == 1) {
            answer = mapTemplate.values().iterator().next();
        } else {
            LOG.debug(""Found {} TransactionTemplate in registry. Cannot determine which one to use. "" + ""Please configure a TransactionTemplate on the TransactionErrorHandlerBuilder"", mapTemplate.size());
        }
    }
    if (answer == null) {
        Map<String, PlatformTransactionManager> mapManager = findByTypeWithName(PlatformTransactionManager.class);
        if (mapManager == null || mapManager.isEmpty()) {
            LOG.trace(""No PlatformTransactionManager found in registry."");
        } else if (mapManager.size() == 1) {
            answer = new TransactionTemplate(mapManager.values().iterator().next());
        } else {
            LOG.debug(""Found {} PlatformTransactionManager in registry. Cannot determine which one to use for TransactionTemplate. "" + ""Please configure a TransactionTemplate on the TransactionErrorHandlerBuilder"", mapManager.size());
        }
    }
    if (answer != null) {
        LOG.debug(""Found TransactionTemplate in registry to use: {}"", answer);
    }
    return answer;
}",java:S3776,39
"private Object processInternal(Exchange exchange, PreparedStatementCreator statementCreator, String sql, String preparedQuery, Boolean shouldRetrieveGeneratedKeys){
    LOG.trace(""jdbcTemplate.execute: {}"", preparedQuery);
    return jdbcTemplate.execute(statementCreator, new PreparedStatementCallback<Object>() {

        public Object doInPreparedStatement(PreparedStatement ps) throws SQLException {
            Object data = null;
            ResultSet rs = null;
            try {
                populateStatement(ps, exchange, sql, preparedQuery);
                boolean isResultSet = false;
                if (batch) {
                    int[] updateCounts = ps.executeBatch();
                    int total = 0;
                    for (int count : updateCounts) {
                        total += count;
                    }
                    exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT, total);
                } else {
                    isResultSet = ps.execute();
                    if (isResultSet) {
                        rs = ps.getResultSet();
                        SqlOutputType outputType = getEndpoint().getOutputType();
                        LOG.trace(""Got result list from query: {}, outputType={}"", rs, outputType);
                        int rowCount = 0;
                        if (outputType == SqlOutputType.SelectList) {
                            data = getEndpoint().queryForList(rs, true);
                            rowCount = ((List<?>) data).size();
                        } else if (outputType == SqlOutputType.SelectOne) {
                            data = getEndpoint().queryForObject(rs);
                            if (data != null) {
                                rowCount = 1;
                            } else {
                                data = EMPTY_RESULT;
                            }
                        } else {
                            throw new IllegalArgumentException(""Invalid outputType="" + outputType);
                        }
                        exchange.getIn().setHeader(SqlConstants.SQL_ROW_COUNT, rowCount);
                    } else {
                        exchange.getIn().setHeader(SqlConstants.SQL_UPDATE_COUNT, ps.getUpdateCount());
                    }
                }
                if (shouldRetrieveGeneratedKeys) {
                    if (isResultSet) {
                        exchange.getIn().setHeader(SqlConstants.SQL_GENERATED_KEYS_DATA, Collections.emptyList());
                        exchange.getIn().setHeader(SqlConstants.SQL_GENERATED_KEYS_ROW_COUNT, 0);
                    } else {
                        List<?> generatedKeys = getEndpoint().queryForList(ps.getGeneratedKeys(), false);
                        exchange.getIn().setHeader(SqlConstants.SQL_GENERATED_KEYS_DATA, generatedKeys);
                        exchange.getIn().setHeader(SqlConstants.SQL_GENERATED_KEYS_ROW_COUNT, generatedKeys.size());
                    }
                }
                return data;
            } finally {
                closeResultSet(rs);
            }
        }
    });
}",java:S3776,39
"private void populateStatement(PreparedStatement ps, Exchange exchange, String sql, String preparedQuery) throws SQLException{
    int expected;
    if (parametersCount > 0) {
        expected = parametersCount;
    } else {
        ParameterMetaData meta = ps.getParameterMetaData();
        expected = meta != null ? meta.getParameterCount() : 0;
    }
    if (alwaysPopulateStatement || expected > 0) {
        if (batch) {
            Iterator<?> iterator;
            if (useMessageBodyForSql) {
                iterator = exchange.getIn().getHeader(SqlConstants.SQL_PARAMETERS, Iterator.class);
            } else {
                iterator = exchange.getIn().getBody(Iterator.class);
            }
            while (iterator != null && iterator.hasNext()) {
                Object value = iterator.next();
                Iterator<?> i = sqlPrepareStatementStrategy.createPopulateIterator(sql, preparedQuery, expected, exchange, value);
                sqlPrepareStatementStrategy.populateStatement(ps, i, expected);
                ps.addBatch();
            }
        } else {
            Object value;
            if (useMessageBodyForSql) {
                value = exchange.getIn().getHeader(SqlConstants.SQL_PARAMETERS);
            } else {
                value = exchange.getIn().getBody();
            }
            Iterator<?> i = sqlPrepareStatementStrategy.createPopulateIterator(sql, preparedQuery, expected, exchange, value);
            sqlPrepareStatementStrategy.populateStatement(ps, i, expected);
        }
    }
}",java:S3776,39
"public StatementWrapper create(String sql) throws SQLException{
    return new CallableStatementWrapper(sql, this);
}",java:S1130,7
"private static int getFieldInt(Class<?> clazz, String sqlType){
    Field field = ReflectionUtils.findField(clazz, sqlType);
    if (field == null) {
        throw new ParseRuntimeException(""Field "" + sqlType + "" not found from "" + clazz.getName());
    }
    try {
        return field.getInt(Types.class);
    } catch (IllegalAccessException e) {
        throw new ParseRuntimeException(e);
    }
}",java:S3740,38
"public void push(byte[] keyPart){
    if (keyType == null) {
        this.keyType = new String(keyPart, StandardCharsets.UTF_8);
        if (SSH_ED25519.equals(keyType)) {
            encode(edKeyEncoded, keyType);
        }
        return;
    }
    if (SSH_RSA.equals(keyType)) {
        if (e == null) {
            this.e = new BigInteger(keyPart);
            return;
        }
        if (m == null) {
            this.m = new BigInteger(keyPart);
            return;
        }
    }
    if (SSH_DSS.equals(keyType)) {
        if (p == null) {
            this.p = new BigInteger(keyPart);
            return;
        }
        if (q == null) {
            this.q = new BigInteger(keyPart);
            return;
        }
        if (g == null) {
            this.g = new BigInteger(keyPart);
            return;
        }
        if (y == null) {
            this.y = new BigInteger(keyPart);
            return;
        }
    }
    if (keyType.equals(SSH_ED25519)) {
        encode(edKeyEncoded, keyPart);
        return;
    }
    if (keyType.startsWith(SSH_ECDSA_PREFIX)) {
        if (curveName == null) {
            curveName = new String(keyPart, StandardCharsets.UTF_8);
            return;
        }
        if (ecPoint == null) {
            ecParams = ECCurves.fromKeyType(keyType).getParameters();
            ecPoint = ECCurves.octetStringToEcPoint(keyPart);
        }
    }
}",java:S3776,39
"public static SshResult sendExecCommand(Map<String, Object> headers, String command, SshEndpoint endpoint, SshClient client) throws Exception{
    SshConfiguration configuration = endpoint.getConfiguration();
    if (configuration == null) {
        throw new IllegalStateException(""Configuration must be set"");
    }
    String userName = configuration.getUsername();
    Object userNameHeaderObj = headers.get(SshConstants.USERNAME_HEADER);
    if (userNameHeaderObj instanceof String) {
        userName = (String) headers.get(SshConstants.USERNAME_HEADER);
    }
    ConnectFuture connectFuture = client.connect(userName, configuration.getHost(), configuration.getPort());
    connectFuture.await(configuration.getTimeout());
    if (!connectFuture.isDone() || !connectFuture.isConnected()) {
        throw new RuntimeCamelException(""Failed to connect to "" + configuration.getHost() + "":"" + configuration.getPort() + "" within timeout "" + configuration.getTimeout() + ""ms"");
    }
    LOG.debug(""Connected to {}:{}"", configuration.getHost(), configuration.getPort());
    ClientChannel channel = null;
    ClientSession session = null;
    try {
        AuthFuture authResult;
        session = connectFuture.getSession();
        KeyPairProvider keyPairProvider;
        final String certResource = configuration.getCertResource();
        if (certResource != null) {
            LOG.debug(""Attempting to authenticate using ResourceKey '{}'..."", certResource);
            if (endpoint.getCertResourcePassword() != null) {
                Supplier<char[]> passwordFinder = () -> endpoint.getCertResourcePassword().toCharArray();
                keyPairProvider = new ResourceHelperKeyPairProvider(new String[] { certResource }, passwordFinder, endpoint.getCamelContext());
            } else {
                keyPairProvider = new ResourceHelperKeyPairProvider(new String[] { certResource }, endpoint.getCamelContext());
            }
        } else {
            keyPairProvider = configuration.getKeyPairProvider();
        }
        if (keyPairProvider != null) {
            LOG.debug(""Attempting to authenticate username '{}' using a key identity"", userName);
            KeyPair pair = null;
            if (configuration.getKeyType() == null) {
                Iterator<KeyPair> iterator = keyPairProvider.loadKeys(session).iterator();
                if (iterator.hasNext()) {
                    pair = iterator.next();
                }
            } else {
                pair = keyPairProvider.loadKey(session, configuration.getKeyType());
            }
            session.addPublicKeyIdentity(pair);
        } else {
            String password = configuration.getPassword();
            Object passwordHeaderObj = headers.get(SshConstants.PASSWORD_HEADER);
            if (passwordHeaderObj instanceof String) {
                password = (String) headers.get(SshConstants.PASSWORD_HEADER);
            }
            LOG.debug(""Attempting to authenticate username '{}' using a password identity"", userName);
            session.addPasswordIdentity(password);
        }
        authResult = session.auth();
        authResult.await(configuration.getTimeout());
        if (!authResult.isDone() || authResult.isFailure()) {
            LOG.debug(""Failed to authenticate"");
            throw new RuntimeCamelException(""Failed to authenticate username "" + configuration.getUsername());
        }
        InputStream in = null;
        PipedOutputStream reply = new PipedOutputStream();
        if (Channel.CHANNEL_EXEC.equals(endpoint.getChannelType())) {
            channel = session.createChannel(Channel.CHANNEL_EXEC, command);
            in = new ByteArrayInputStream(new byte[] { 0 });
        } else if (Channel.CHANNEL_SHELL.equals(endpoint.getChannelType())) {
            channel = session.createChannel(Channel.CHANNEL_SHELL);
            in = new PipedInputStream(reply);
        }
        channel.setIn(in);
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        channel.setOut(out);
        ByteArrayOutputStream err = new ByteArrayOutputStream();
        channel.setErr(err);
        OpenFuture openFuture = channel.open();
        openFuture.await(configuration.getTimeout());
        SshResult result = null;
        if (Channel.CHANNEL_EXEC.equals(endpoint.getChannelType())) {
            if (openFuture.isOpened()) {
                Set<ClientChannelEvent> events = channel.waitFor(Arrays.asList(ClientChannelEvent.CLOSED), 0);
                if (!events.contains(ClientChannelEvent.TIMEOUT)) {
                    result = new SshResult(command, channel.getExitStatus(), new ByteArrayInputStream(out.toByteArray()), new ByteArrayInputStream(err.toByteArray()));
                }
            }
        } else if (Channel.CHANNEL_SHELL.equals(endpoint.getChannelType())) {
            getPrompt(channel, out, endpoint);
            reply.write(command.getBytes());
            reply.write(System.lineSeparator().getBytes());
            String response = getPrompt(channel, out, endpoint);
            result = new SshResult(command, channel.getExitStatus(), new ByteArrayInputStream(response.getBytes()), new ByteArrayInputStream(err.toByteArray()));
        }
        return result;
    } finally {
        if (channel != null) {
            channel.close(true);
        }
        if (session != null) {
            session.close(false);
        }
    }
}",java:S3776,39
"private static JAXBContext jaxbContext(Class<?> handled) throws JAXBException{
    if (JAX_CONTEXTS.containsKey(handled)) {
        return JAX_CONTEXTS.get(handled);
    }
    JAXBContext context;
    synchronized (JAX_CONTEXTS) {
        context = JAXBContext.newInstance(handled);
        JAX_CONTEXTS.put(handled, context);
    }
    return context;
}",java:S3398,35
"private void handleStartDocument() throws SAXException{
    if (XMLStreamConstants.START_DOCUMENT == reader.getEventType()) {
        String xmlVersion = reader.getVersion();
        if (ObjectHelper.isNotEmpty(xmlVersion)) {
            this.xmlVersion = xmlVersion;
        }
        this.encoding = reader.getCharacterEncodingScheme();
    }
    if (getContentHandler() != null) {
        final Location location = reader.getLocation();
        getContentHandler().setDocumentLocator(new Locator2() {

            public int getColumnNumber() {
                return location != null ? location.getColumnNumber() : -1;
            }

            public int getLineNumber() {
                return location != null ? location.getLineNumber() : -1;
            }

            public String getPublicId() {
                return location != null ? location.getPublicId() : null;
            }

            public String getSystemId() {
                return location != null ? location.getSystemId() : null;
            }

            public String getXMLVersion() {
                return xmlVersion;
            }

            public String getEncoding() {
                return encoding;
            }
        });
        getContentHandler().startDocument();
        if (reader.standaloneSet()) {
            setStandalone(reader.isStandalone());
        }
    }
}",java:S3776,39
"public void record(){
    recording = true;
}",java:S6213,47
"protected Iterator<?> createIterator(InputStream in, String charset) throws XMLStreamException, UnsupportedEncodingException{
    return createIterator(new InputStreamReader(in, charset));
}",java:S1452,23
"protected Iterator<?> createIterator(InputStream in) throws XMLStreamException, IOException{
    return createIterator(new XmlStreamReader(in));
}",java:S1452,23
"protected Iterator<?> createIterator(Reader in) throws XMLStreamException{
    return new XMLTokenIterator(path, nsmap, mode, group, in);
}",java:S1452,23
"private String createContextualToken(String token){
    StringBuilder sb = new StringBuilder();
    if (mode == 'w' && group == 1) {
        for (int i = 0; i < segments.size(); i++) {
            sb.append(segments.get(i));
        }
        sb.append(token);
        for (int i = path.size() - 1; i >= 0; i--) {
            QName q = path.get(i);
            sb.append(""</"").append(makeName(q)).append("">"");
        }
    } else if (mode == 'i') {
        final String stag = token.substring(0, token.indexOf('>') + 1);
        Set<String> skip = new HashSet<>();
        Matcher matcher = NAMESPACE_PATTERN.matcher(stag);
        char quote = 0;
        while (matcher.find()) {
            String prefix = matcher.group(1);
            if (prefix.length() > 0) {
                prefix = prefix.substring(1);
            }
            skip.add(prefix);
            if (quote == 0) {
                quote = matcher.group(2).charAt(0);
            }
        }
        if (quote == 0) {
            quote = '""';
        }
        boolean empty = stag.endsWith(""/>"");
        sb.append(token, 0, stag.length() - (empty ? 2 : 1));
        for (Entry<String, String> e : getCurrentNamespaceBindings().entrySet()) {
            if (!skip.contains(e.getKey())) {
                boolean defaultNS = e.getKey() == null || e.getKey().length() == 0;
                if (defaultNS) {
                    sb.append("" xmlns"").append(""="").append(quote).append(e.getValue()).append(quote);
                } else {
                    sb.append("" xmlns:"").append(e.getKey()).append(""="").append(quote).append(e.getValue()).append(quote);
                }
            }
        }
        sb.append(token, stag.length() - (empty ? 2 : 1), token.length());
    } else if (mode == 'u') {
        int bp = token.indexOf("">"");
        int ep = token.lastIndexOf(""</"");
        if (bp > 0 && ep > 0) {
            sb.append(token, bp + 1, ep);
        }
    } else if (mode == 't') {
        int bp = 0;
        for (; ; ) {
            int ep = token.indexOf('>', bp);
            bp = token.indexOf('<', ep);
            if (bp < 0) {
                break;
            }
            sb.append(token, ep + 1, bp);
        }
    } else {
        return token;
    }
    return sb.toString();
}",java:S3776,39
"private String getNextToken() throws XMLStreamException{
    int xcode = 0;
    while (xcode != XMLStreamConstants.END_DOCUMENT) {
        xcode = readNext();
        switch(xcode) {
            case XMLStreamConstants.START_ELEMENT:
                depth++;
                QName name = reader.getName();
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""se={}; depth={}; trackdepth={}"", name, depth, trackdepth);
                }
                String token = getCurrentText();
                if (!compliant) {
                    if (token != null && token.startsWith(""<"") && !token.startsWith(""<?"")) {
                        throw new XMLStreamException(""XMLStreamReader does not supporting getting location"");
                    }
                    compliant = true;
                }
                LOG.trace(""token={}"", token);
                if (!backtrack && mode == 'w') {
                    pushSegment(name, token);
                }
                pushName(name);
                if (mode == 'i') {
                    pushNamespaces(reader);
                }
                backtrack = false;
                if (current().matches(name)) {
                    if (isBottom()) {
                        token = getCurrentToken();
                        backtrack = true;
                        trackdepth = depth;
                        if (group > 1) {
                            tokens.add(token);
                            if (group == tokens.size()) {
                                return getGroupedToken();
                            }
                        } else {
                            return token;
                        }
                    } else {
                        down();
                    }
                } else if (isDoS()) {
                } else {
                    readCurrent(false);
                }
                break;
            case XMLStreamConstants.END_ELEMENT:
                if ((backtrack || trackdepth > 0 && depth == trackdepth) && mode == 'w' && group > 1 && !tokens.isEmpty()) {
                    code = XMLStreamConstants.END_ELEMENT;
                    return getGroupedToken();
                }
                depth--;
                QName endname = reader.getName();
                LOG.trace(""ee={}"", endname);
                popName();
                if (mode == 'i') {
                    popNamespaces();
                }
                int pc = 0;
                if (backtrack || trackdepth > 0 && depth == trackdepth - 1) {
                    backtrack = true;
                    trackdepth--;
                    if (mode == 'w') {
                        while (!endname.equals(peekLog())) {
                            pc++;
                            popLog();
                        }
                    }
                }
                if (backtrack) {
                    if (mode == 'w') {
                        for (int i = 0; i < pc; i++) {
                            popSegment();
                        }
                    }
                }
                if (ancestor() == null && !isTop() || ancestor() != null && ancestor().matches(endname)) {
                    up();
                }
                break;
            case XMLStreamConstants.END_DOCUMENT:
                LOG.trace(""depth={}"", depth);
                if (group > 1 && !tokens.isEmpty()) {
                    code = XMLStreamConstants.END_DOCUMENT;
                    return getGroupedToken();
                }
                break;
            default:
                break;
        }
    }
    return null;
}",java:S3776,39
"@Deprecated
public static Expression tokenize(String path){
    return tokenize(null, path, 'i');
}",java:S6355,48
"@Deprecated
public static Expression tokenize(String path, char mode){
    return tokenize(null, path, mode);
}",java:S6355,48
"@Deprecated
public static Expression tokenize(String headerName, String path){
    return tokenize(headerName, path, 'i');
}",java:S6355,48
"@Deprecated
public static Expression tokenize(String headerName, String path, char mode){
    return tokenize(headerName, path, mode, 1, null);
}",java:S6355,48
"@Deprecated
public static Expression tokenize(String headerName, String path, char mode, int group, Namespaces namespaces){
    XMLTokenizeLanguage language = new XMLTokenizeLanguage();
    language.setHeaderName(headerName);
    language.setMode(mode);
    language.setGroup(group);
    language.setNamespaces(namespaces);
    return language.createExpression(path);
}",java:S6355,48
"private BufferedReader initializeStreamLineMode() throws Exception{
    IOHelper.close(inputStreamToClose);
    if (urlConnectionToClose != null) {
        closeURLConnection(urlConnectionToClose);
    }
    if (""in"".equals(uri)) {
        inputStream = System.in;
        inputStreamToClose = null;
    } else if (""file"".equals(uri)) {
        inputStream = resolveStreamFromFile();
        inputStreamToClose = inputStream;
    } else if (""http"".equals(uri)) {
        inputStream = resolveStreamFromUrl();
        inputStreamToClose = inputStream;
    }
    if (inputStream != null) {
        if (""http"".equals(uri)) {
            return IOHelper.buffered(new InputStreamReader(inputStream));
        } else {
            Charset charset = endpoint.getCharset();
            return IOHelper.buffered(new InputStreamReader(inputStream, charset));
        }
    } else {
        return null;
    }
}",java:S112,4
"private InputStream initializeStreamRawMode() throws Exception{
    IOHelper.close(inputStreamToClose);
    if (urlConnectionToClose != null) {
        closeURLConnection(urlConnectionToClose);
    }
    if (""in"".equals(uri)) {
        inputStream = System.in;
        inputStreamToClose = null;
    } else if (""file"".equals(uri)) {
        inputStream = resolveStreamFromFile();
        inputStreamToClose = inputStream;
    } else if (""http"".equals(uri)) {
        inputStream = resolveStreamFromUrl();
        inputStreamToClose = inputStream;
    }
    return inputStream;
}",java:S112,4
"private void readFromStreamRawMode() throws Exception{
    long index = 0;
    InputStream is = initializeStreamRawMode();
    if (endpoint.isScanStream()) {
        while (isRunAllowed()) {
            byte[] data = null;
            try {
                data = is.readAllBytes();
            } catch (IOException e) {
            }
            boolean eos = data == null || data.length == 0;
            if (isRunAllowed() && endpoint.isRetry()) {
                boolean reOpen = true;
                if (endpoint.isFileWatcher()) {
                    reOpen = watchFileChanged;
                }
                if (reOpen) {
                    LOG.debug(""File: {} changed/rollover, re-reading file from beginning"", file);
                    is = initializeStreamRawMode();
                    if (endpoint.isFileWatcher()) {
                        watchFileChanged = false;
                    }
                } else {
                    LOG.trace(""File: {} not changed since last read"", file);
                }
            }
            if (eos) {
                try {
                    Thread.sleep(endpoint.getScanStreamDelay());
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    } else {
        boolean eos = false;
        byte[] data = null;
        while (!eos && isRunAllowed()) {
            if (endpoint.getPromptMessage() != null) {
                doPromptMessage();
            }
            try {
                data = is.readAllBytes();
            } catch (IOException e) {
            }
            eos = data == null || data.length == 0;
            if (!eos) {
                processRaw(data, index);
            }
        }
    }
}",java:S3776,39
"private void readFromStreamLineMode() throws Exception{
    long index = 0;
    String line;
    BufferedReader br = initializeStreamLineMode();
    if (endpoint.isScanStream()) {
        while (isRunAllowed()) {
            if (br != null) {
                line = br.readLine();
                LOG.trace(""Read line: {}"", line);
            } else {
                line = null;
            }
            boolean eos = line == null;
            if (!eos && isRunAllowed()) {
                index = processLine(line, false, index);
            } else if (eos && isRunAllowed() && endpoint.isRetry()) {
                boolean reOpen = true;
                if (endpoint.isFileWatcher()) {
                    reOpen = watchFileChanged;
                }
                if (reOpen) {
                    LOG.debug(""File: {} changed/rollover, re-reading file from beginning"", file);
                    br = initializeStreamLineMode();
                    if (endpoint.isFileWatcher()) {
                        watchFileChanged = false;
                    }
                } else {
                    LOG.trace(""File: {} not changed since last read"", file);
                }
            }
            if (eos) {
                try {
                    Thread.sleep(endpoint.getScanStreamDelay());
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    } else {
        boolean eos = false;
        String line2 = null;
        while (!eos && isRunAllowed()) {
            if (endpoint.getPromptMessage() != null) {
                doPromptMessage();
            }
            if (line2 == null) {
                line = br.readLine();
            } else {
                line = line2;
            }
            LOG.trace(""Read line: {}"", line);
            eos = line == null;
            if (!eos && isRunAllowed()) {
                line2 = readAhead(br);
                boolean last = line2 == null;
                index = processLine(line, last, index);
            }
        }
        processLine(null, true, index);
    }
}",java:S3776,39
"private void openStream() throws Exception{
    if (outputStream != null) {
        return;
    }
    if (""out"".equals(uri)) {
        outputStream = System.out;
    } else if (""err"".equals(uri)) {
        outputStream = System.err;
    } else if (""file"".equals(uri)) {
        outputStream = resolveStreamFromFile();
    }
    count.set(outputStream == null ? 0 : endpoint.getAutoCloseCount());
    LOG.debug(""Opened stream '{}'"", endpoint.getEndpointKey());
}",java:S112,4
"private void closeStream(Exchange exchange, boolean force) throws Exception{
    if (outputStream == null) {
        return;
    }
    boolean systemStream = outputStream == System.out || outputStream == System.err;
    boolean headerStream = ""header"".equals(uri);
    boolean reachedLimit = endpoint.getAutoCloseCount() > 0 && count.decrementAndGet() <= 0;
    boolean isDone = endpoint.isCloseOnDone() && isDone(exchange);
    boolean expiredStream = force || headerStream || isDone || reachedLimit;
    if (!systemStream && expiredStream) {
        outputStream.close();
        outputStream = null;
        LOG.debug(""Closed stream '{}'"", endpoint.getEndpointKey());
    }
}",java:S112,4
"private void validateUri(String uri) throws Exception{
    String[] s = uri.split("":"");
    if (s.length < 2) {
        throw new IllegalArgumentException(INVALID_URI);
    }
    String[] t = s[1].split(""\\?"");
    if (t.length < 1) {
        throw new IllegalArgumentException(INVALID_URI);
    }
    this.uri = t[0].trim();
    if (this.uri.startsWith(""//"")) {
        this.uri = this.uri.substring(2);
    }
    if (!TYPES_LIST.contains(this.uri)) {
        throw new IllegalArgumentException(INVALID_URI);
    }
}",java:S112,4
"public static SyslogMessage parseMessage(byte[] bytes){
    ByteBuffer byteBuffer = ByteBuffer.allocate(bytes.length);
    byteBuffer.put(bytes);
    cast(byteBuffer).rewind();
    Character charFound = (char) byteBuffer.get();
    SyslogFacility foundFacility = null;
    SyslogSeverity foundSeverity = null;
    while (charFound != '<') {
        charFound = (char) byteBuffer.get();
    }
    char priChar = 0;
    if (charFound == '<') {
        int facility = 0;
        while (Character.isDigit(priChar = (char) (byteBuffer.get() & 0xff))) {
            facility *= 10;
            facility += Character.digit(priChar, 10);
        }
        foundFacility = SyslogFacility.values()[facility >> 3];
        foundSeverity = SyslogSeverity.values()[facility & 0x07];
    }
    if (priChar != '>') {
        LOG.error(""Invalid syslog message, missing a > in the Facility/Priority part"");
    }
    SyslogMessage syslogMessage = new SyslogMessage();
    boolean isRfc5424 = false;
    charFound = (char) byteBuffer.get();
    if (charFound == '1') {
        syslogMessage = new Rfc5424SyslogMessage();
        isRfc5424 = true;
    } else {
        byteBuffer.position(byteBuffer.position() - 1);
    }
    syslogMessage.setFacility(foundFacility);
    syslogMessage.setSeverity(foundSeverity);
    if (!isRfc5424) {
        syslogMessage.setTimestamp(parseRfc3164Date(byteBuffer));
    } else {
        charFound = (char) byteBuffer.get();
        if (charFound != ' ') {
            LOG.error(""Invalid syslog message, missing a mandatory space after version"");
        }
        StringBuilder date = new StringBuilder();
        while ((charFound = (char) (byteBuffer.get() & 0xff)) != ' ') {
            date.append(charFound);
        }
        syslogMessage.setTimestamp(DatatypeConverter.parseDateTime(date.toString()));
    }
    StringBuilder host = new StringBuilder();
    while ((charFound = (char) (byteBuffer.get() & 0xff)) != ' ') {
        host.append(charFound);
    }
    syslogMessage.setHostname(host.toString());
    if (isRfc5424) {
        Rfc5424SyslogMessage rfc5424SyslogMessage = (Rfc5424SyslogMessage) syslogMessage;
        StringBuilder appName = new StringBuilder();
        while ((charFound = (char) (byteBuffer.get() & 0xff)) != ' ') {
            appName.append(charFound);
        }
        rfc5424SyslogMessage.setAppName(appName.toString());
        StringBuilder procId = new StringBuilder();
        while ((charFound = (char) (byteBuffer.get() & 0xff)) != ' ') {
            procId.append(charFound);
        }
        rfc5424SyslogMessage.setProcId(procId.toString());
        StringBuilder msgId = new StringBuilder();
        while ((charFound = (char) (byteBuffer.get() & 0xff)) != ' ') {
            msgId.append(charFound);
        }
        rfc5424SyslogMessage.setMsgId(msgId.toString());
        StringBuilder structuredData = new StringBuilder();
        boolean inblock = false;
        while ((charFound = (char) (byteBuffer.get() & 0xff)) != ' ' || inblock) {
            if (charFound == '[') {
                inblock = true;
            }
            if (charFound == ']') {
                inblock = false;
            }
            structuredData.append(charFound);
        }
        rfc5424SyslogMessage.setStructuredData(structuredData.toString());
    }
    StringBuilder msg = new StringBuilder();
    while (byteBuffer.hasRemaining()) {
        charFound = (char) (byteBuffer.get() & 0xff);
        msg.append(charFound);
    }
    syslogMessage.setLogMessage(msg.toString());
    LOG.trace(""Syslog message : {}"", syslogMessage);
    return syslogMessage;
}",java:S3776,39
"protected void buildTextPart(String name, T value){
    buildTextPart(bodyPublisher, name, value);
}",java:S4977,43
"@Test
public void testSendMessage(){
    OutgoingTextMessage msg = new OutgoingTextMessage();
    msg.setChatId(chatId);
    msg.setText(""This is an auto-generated message from the Bot"");
    Assertions.assertDoesNotThrow(() -> template.requestBody(String.format(""telegram://bots?chatId=%s&proxyHost=%s&proxyPort=%s&proxyType=%s"", chatId, proxyHost, proxyPort, proxyType), msg));
}",java:S2699,32
"public static int getSpecificPort(int portNumber, T failurePayload, Function<T, Integer> failureHandler){
    try (Port port = INSTANCE.findPort(portNumber, portNumber)) {
        return port.getPort();
    } catch (IllegalStateException e) {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Unable to obtain the requested TCP port {}: {}"", portNumber, e.getMessage(), e);
        } else {
            LOG.warn(""Unable to obtain the requested TCP port {}: {}"", portNumber, e.getMessage());
        }
        return failureHandler.apply(failurePayload);
    }
}",java:S4276,41
"private void logCoverageSummary(ManagedCamelContextMBean managedCamelContext, ModelCamelContext context) throws Exception{
    StringBuilder builder = new StringBuilder(""\nCoverage summary\n"");
    int routes = managedCamelContext.getTotalRoutes();
    long contextExchangesTotal = managedCamelContext.getExchangesTotal();
    List<String> uncoveredRoutes = new ArrayList<>();
    StringBuilder routesSummary = new StringBuilder();
    routesSummary.append(""\tProcessor coverage\n"");
    MBeanServer server = context.getManagementStrategy().getManagementAgent().getMBeanServer();
    Map<String, List<ManagedProcessorMBean>> processorsForRoute = findProcessorsForEachRoute(server, context);
    for (Route route : context.getRoutes()) {
        ManagedRouteMBean managedRoute = context.getCamelContextExtension().getContextPlugin(ManagedCamelContext.class).getManagedRoute(route.getId());
        if (managedRoute.getExchangesTotal() == 0) {
            uncoveredRoutes.add(route.getId());
        }
        long routeCoveragePercentage = Math.round((double) managedRoute.getExchangesTotal() / contextExchangesTotal * 100);
        routesSummary.append(""\t\tRoute "").append(route.getId()).append("" total: "").append(managedRoute.getExchangesTotal()).append("" ("").append(routeCoveragePercentage).append(""%)\n"");
        if (server != null) {
            List<ManagedProcessorMBean> processors = processorsForRoute.get(route.getId());
            if (processors != null) {
                for (ManagedProcessorMBean managedProcessor : processors) {
                    String processorId = managedProcessor.getProcessorId();
                    long processorExchangesTotal = managedProcessor.getExchangesTotal();
                    long processorCoveragePercentage = Math.round((double) processorExchangesTotal / contextExchangesTotal * 100);
                    routesSummary.append(""\t\t\tProcessor "").append(processorId).append("" total: "").append(processorExchangesTotal).append("" ("").append(processorCoveragePercentage).append(""%)\n"");
                }
            }
        }
    }
    int used = routes - uncoveredRoutes.size();
    long contextPercentage = Math.round((double) used / routes * 100);
    builder.append(""\tRoute coverage: "").append(used).append("" out of "").append(routes).append("" routes used ("").append(contextPercentage).append(""%)\n"");
    builder.append(""\t\tCamelContext ("").append(managedCamelContext.getCamelId()).append("") total: "").append(contextExchangesTotal).append(""\n"");
    if (!uncoveredRoutes.isEmpty()) {
        builder.append(""\t\tUncovered routes: "").append(String.join("", "", uncoveredRoutes)).append(""\n"");
    }
    builder.append(routesSummary);
    LOG.info(builder.toString());
}",java:S112,4
"protected void doPreSetup() throws Exception{
}",java:S112,4
"protected void doPostSetup() throws Exception{
}",java:S112,4
"protected void doSetUp() throws Exception{
    LOG.debug(""setUp test"");
    if (useJmx() || isRouteCoverageEnabled() || isCamelDebugPresent()) {
        enableJMX();
    } else {
        disableJMX();
    }
    context = (ModelCamelContext) createCamelContext();
    THREAD_CAMEL_CONTEXT.set(context);
    assertNotNull(context, ""No context found!"");
    bindToRegistry(context.getRegistry());
    context.getShutdownStrategy().setTimeout(getShutdownTimeout());
    if (isUseDebugger()) {
        if (context.getStatus().equals(ServiceStatus.Started)) {
            LOG.info(""Cannot setting the Debugger to the starting CamelContext, stop the CamelContext now."");
            context.stop();
        }
        context.setDebugging(true);
        context.setDebugger(new DefaultDebugger());
        context.getDebugger().addBreakpoint(breakpoint);
    }
    template = context.createProducerTemplate();
    template.start();
    fluentTemplate = context.createFluentProducerTemplate();
    fluentTemplate.start();
    consumer = context.createConsumerTemplate();
    consumer.start();
    THREAD_TEMPLATE.set(template);
    THREAD_FLUENT_TEMPLATE.set(fluentTemplate);
    THREAD_CONSUMER.set(consumer);
    String pattern = isMockEndpoints();
    if (pattern != null) {
        context.getCamelContextExtension().registerEndpointCallback(new InterceptSendToMockEndpointStrategy(pattern));
    }
    pattern = isMockEndpointsAndSkip();
    if (pattern != null) {
        context.getCamelContextExtension().registerEndpointCallback(new InterceptSendToMockEndpointStrategy(pattern, true));
    }
    PropertiesComponent pc = context.getPropertiesComponent();
    if (extra == null) {
        extra = useOverridePropertiesWithPropertiesComponent();
    }
    if (extra != null && !extra.isEmpty()) {
        pc.setOverrideProperties(extra);
    }
    pc.addPropertiesSource(new PropertiesSource() {

        @Override
        public String getName() {
            return ""junit-store"";
        }

        @Override
        public String getProperty(String name) {
            return globalStore.get(name, String.class);
        }
    });
    Boolean ignore = ignoreMissingLocationWithPropertiesComponent();
    if (ignore != null) {
        pc.setIgnoreMissingLocation(ignore);
    }
    String include = getRouteFilterIncludePattern();
    String exclude = getRouteFilterExcludePattern();
    if (include != null || exclude != null) {
        LOG.info(""Route filtering pattern: include={}, exclude={}"", include, exclude);
        context.getCamelContextExtension().getContextPlugin(Model.class).setRouteFilterPattern(include, exclude);
    }
    postProcessTest();
    if (isUseRouteBuilder()) {
        RoutesBuilder[] builders = createRouteBuilders();
        for (RoutesBuilder builder : builders) {
            if (builder instanceof RouteConfigurationsBuilder) {
                LOG.debug(""Using created route configuration: {}"", builder);
                context.addRoutesConfigurations((RouteConfigurationsBuilder) builder);
            }
        }
        for (RoutesBuilder builder : builders) {
            LOG.debug(""Using created route builder to add routes: {}"", builder);
            context.addRoutes(builder);
        }
        for (RoutesBuilder builder : builders) {
            LOG.debug(""Using created route builder to add templated routes: {}"", builder);
            context.addTemplatedRoutes(builder);
        }
        replaceFromEndpoints();
        boolean skip = ""true"".equalsIgnoreCase(System.getProperty(""skipStartingCamelContext""));
        if (skip) {
            LOG.info(""Skipping starting CamelContext as system property skipStartingCamelContext is set to be true."");
        } else if (isUseAdviceWith()) {
            LOG.info(""Skipping starting CamelContext as isUseAdviceWith is set to true."");
        } else {
            startCamelContext();
        }
    } else {
        replaceFromEndpoints();
        LOG.debug(""Using route builder from the created context: {}"", context);
    }
    LOG.debug(""Routing Rules are: {}"", context.getRoutes());
    assertValidContext(context);
}",java:S3776,39
"private void replaceFromEndpoints() throws Exception{
    for (final Map.Entry<String, String> entry : fromEndpoints.entrySet()) {
        AdviceWith.adviceWith(context.getRouteDefinition(entry.getKey()), context, new AdviceWithRouteBuilder() {

            @Override
            public void configure() {
                replaceFromWith(entry.getValue());
            }
        });
    }
}",java:S112,4
"protected void doPostTearDown() throws Exception{
}",java:S112,4
"protected void setupResources() throws Exception{
}",java:S112,4
"protected void cleanupResources() throws Exception{
}",java:S112,4
"protected void stopCamelContext() throws Exception{
    doStopCamelContext(context, camelContextService);
}",java:S112,4
"protected void stopCamelContext() throws Exception{
    doStopCamelContext(context, camelContextService);
}",java:S1130,7
"protected void startCamelContext() throws Exception{
    if (camelContextService != null) {
        camelContextService.start();
    } else {
        if (context instanceof DefaultCamelContext) {
            DefaultCamelContext defaultCamelContext = (DefaultCamelContext) context;
            if (!defaultCamelContext.isStarted()) {
                defaultCamelContext.start();
            }
        } else {
            context.start();
        }
    }
}",java:S112,4
"protected void startCamelContext() throws Exception{
    if (camelContextService != null) {
        camelContextService.start();
    } else {
        if (context instanceof DefaultCamelContext) {
            DefaultCamelContext defaultCamelContext = (DefaultCamelContext) context;
            if (!defaultCamelContext.isStarted()) {
                defaultCamelContext.start();
            }
        } else {
            context.start();
        }
    }
}",java:S1130,7
"protected void bindToRegistry(Registry registry) throws Exception{
}",java:S112,4
"protected Registry createCamelRegistry() throws Exception{
    return null;
}",java:S112,4
"protected RoutesBuilder createRouteBuilder() throws Exception{
    return new RouteBuilder() {

        @Override
        public void configure() {
        }
    };
}",java:S112,4
"protected RoutesBuilder createRouteBuilder() throws Exception{
    return new RouteBuilder() {

        @Override
        public void configure() {
        }
    };
}",java:S1130,7
"protected void postProcessTestInstance(Object testInstance, ExtensionContext context) throws Exception{
    Class<?> clazz = testInstance.getClass();
    java.util.List<Field> fields = hierarchy(clazz).map(Class::getDeclaredFields).flatMap(Stream::of).filter(f -> isAnnotated(f, Parameter.class)).sorted(Comparator.comparing(f -> (Integer) f.getAnnotation(Parameter.class).value())).toList();
    if (params.length != fields.size()) {
        throw new TestInstantiationException(""Expected "" + fields.size() + "" parameters bug got "" + params.length + "" when instantiating "" + clazz.getName());
    }
    for (int i = 0; i < fields.size(); i++) {
        Field f = fields.get(i);
        f.setAccessible(true);
        f.set(testInstance, DefaultArgumentConverter.INSTANCE.convert(params[i], f.getType(), getContext()));
    }
}",java:S112,4
"private void applyReplaceRouteFromWith(ModelCamelContext context, CamelMainTest annotation) throws Exception{
    for (final String fromEndpoint : annotation.replaceRouteFromWith()) {
        final int index = fromEndpoint.indexOf('=');
        if (index == -1) {
            throw new RuntimeCamelException(""The attribute replaceRouteFromWith doesn't have the expected format, it should be of type \""route-id-1=new-uri-1\"", ..."");
        }
        AdviceWith.adviceWith(context.getRouteDefinition(fromEndpoint.substring(0, index)), context, new AdviceWithRouteBuilder() {

            @Override
            public void configure() {
                replaceFromWith(fromEndpoint.substring(index + 1));
            }
        });
    }
}",java:S112,4
"protected void bindToRegistryAfterInjections(Registry registry) throws Exception{
}",java:S112,4
"protected GenericApplicationContext createContext(Class<?> testClass, MergedContextConfiguration mergedConfig){
    ApplicationContext parentContext = null;
    GenericApplicationContext routeExcludingContext = null;
    if (mergedConfig != null) {
        parentContext = mergedConfig.getParentApplicationContext();
    }
    if (testClass.isAnnotationPresent(ExcludeRoutes.class)) {
        Class<?>[] excludedClasses = testClass.getAnnotation(ExcludeRoutes.class).value();
        if (excludedClasses.length > 0) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Setting up package scanning excluded classes as ExcludeRoutes annotation was found. Excluding [{}]"", StringUtils.arrayToCommaDelimitedString(excludedClasses));
            }
            if (parentContext == null) {
                routeExcludingContext = new GenericApplicationContext();
            } else {
                routeExcludingContext = new GenericApplicationContext(parentContext);
            }
            routeExcludingContext.registerBeanDefinition(""excludingResolver"", new RootBeanDefinition(ExcludingPackageScanClassResolver.class));
            routeExcludingContext.refresh();
            ExcludingPackageScanClassResolver excludingResolver = routeExcludingContext.getBean(""excludingResolver"", ExcludingPackageScanClassResolver.class);
            List<Class<?>> excluded = Arrays.asList(excludedClasses);
            excludingResolver.setExcludedClasses(new HashSet<>(excluded));
        } else {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Not enabling package scanning excluded classes as ExcludeRoutes "" + ""annotation was found but no classes were excluded."");
            }
        }
    }
    GenericApplicationContext context;
    if (routeExcludingContext != null) {
        context = new GenericApplicationContext(routeExcludingContext);
    } else {
        if (parentContext != null) {
            context = new GenericApplicationContext(parentContext);
        } else {
            context = new GenericApplicationContext();
        }
    }
    return context;
}",java:S3776,39
"protected void configureTask(TimerTask task, Timer timer){
    if (endpoint.isFixedRate()) {
        if (endpoint.getTime() != null) {
            timer.scheduleAtFixedRate(task, endpoint.getTime(), endpoint.getPeriod());
        } else {
            timer.scheduleAtFixedRate(task, endpoint.getDelay(), endpoint.getPeriod());
        }
    } else {
        if (endpoint.getTime() != null) {
            if (endpoint.getPeriod() > 0) {
                timer.schedule(task, endpoint.getTime(), endpoint.getPeriod());
            } else {
                timer.schedule(task, endpoint.getTime());
            }
        } else {
            if (endpoint.getPeriod() > 0) {
                timer.schedule(task, endpoint.getDelay(), endpoint.getPeriod());
            } else {
                timer.schedule(task, endpoint.getDelay());
            }
        }
    }
    configured = true;
}",java:S3776,39
"protected String getMessageId(Exchange exchange){
    return null;
}",java:S1172,13
"protected Object doExecute(Object executor, String methodName, Map<String, Object> properties) throws Exception{
    Method method = executor.getClass().getDeclaredMethod(methodName, TwilioRestClient.class);
    return method.invoke(executor, properties.getOrDefault(""client"", getRestClient()));
}",java:S112,4
"private Status updateStatus(StatusUpdate status) throws Exception{
    Status response = endpoint.getProperties().getTwitter().v1().tweets().updateStatus(status);
    LOG.debug(""Updated status: {}"", status);
    LOG.debug(""Status id: {}"", response.getId());
    return response;
}",java:S112,4
"private Status updateStatus(String status) throws Exception{
    Status response = endpoint.getProperties().getTwitter().v1().tweets().updateStatus(status);
    LOG.debug(""Updated status: {}"", status);
    LOG.debug(""Status id: {}"", response.getId());
    return response;
}",java:S112,4
" Consumer doCreateConsumer(CamelContext camelContext, Processor processor, String verb, String basePath, String uriTemplate, String consumes, String produces, RestConfiguration configuration, Map<String, Object> parameters, boolean api) throws Exception{
    String path = basePath;
    if (uriTemplate != null) {
        if (uriTemplate.startsWith(""/"")) {
            path = path + uriTemplate;
        } else {
            path = path + ""/"" + uriTemplate;
        }
    }
    path = FileUtil.stripLeadingSeparator(path);
    String scheme = ""http"";
    String host = """";
    int port = 0;
    RestConfiguration config = configuration;
    if (config == null) {
        config = CamelContextHelper.getRestConfiguration(camelContext, getComponentName());
    }
    if (config.getScheme() != null) {
        scheme = config.getScheme();
    }
    if (config.getHost() != null) {
        host = config.getHost();
    }
    int num = config.getPort();
    if (num > 0) {
        port = num;
    }
    String contextPath = config.getContextPath();
    if (ObjectHelper.isNotEmpty(contextPath)) {
        contextPath = FileUtil.stripTrailingSeparator(contextPath);
        contextPath = FileUtil.stripLeadingSeparator(contextPath);
        if (ObjectHelper.isNotEmpty(contextPath)) {
            path = contextPath + ""/"" + path;
        }
    }
    if (ObjectHelper.isEmpty(host)) {
        host = RestComponentHelper.resolveRestHostName(host, config);
    }
    Map<String, Object> map = RestComponentHelper.initRestEndpointProperties(getComponentName(), config);
    String restrict = verb.toUpperCase(Locale.US);
    boolean explicitOptions = restrict.contains(""OPTIONS"");
    boolean cors = config.isEnableCORS();
    if (cors) {
        map.put(""optionsEnabled"", ""true"");
    } else if (explicitOptions) {
        map.put(""optionsEnabled"", ""true"");
    }
    if (api) {
        map.put(""matchOnUriPrefix"", ""true"");
    }
    RestComponentHelper.addHttpRestrictParam(map, verb, !explicitOptions);
    String url = RestComponentHelper.createRestConsumerUrl(getComponentName(), scheme, host, port, path, map);
    UndertowEndpoint endpoint = (UndertowEndpoint) camelContext.getEndpoint(url, parameters);
    if (!map.containsKey(""undertowHttpBinding"")) {
        endpoint.setUndertowHttpBinding(new RestUndertowHttpBinding(endpoint.isUseStreaming()));
    }
    Consumer consumer = endpoint.createConsumer(processor);
    if (config.getConsumerProperties() != null && !config.getConsumerProperties().isEmpty()) {
        setProperties(camelContext, consumer, config.getConsumerProperties());
    }
    if (consumer instanceof UndertowConsumer) {
        ((UndertowConsumer) consumer).setRest(true);
    }
    return consumer;
}",java:S3776,39
" Consumer doCreateConsumer(CamelContext camelContext, Processor processor, String verb, String basePath, String uriTemplate, String consumes, String produces, RestConfiguration configuration, Map<String, Object> parameters, boolean api) throws Exception{
    String path = basePath;
    if (uriTemplate != null) {
        if (uriTemplate.startsWith(""/"")) {
            path = path + uriTemplate;
        } else {
            path = path + ""/"" + uriTemplate;
        }
    }
    path = FileUtil.stripLeadingSeparator(path);
    String scheme = ""http"";
    String host = """";
    int port = 0;
    RestConfiguration config = configuration;
    if (config == null) {
        config = CamelContextHelper.getRestConfiguration(camelContext, getComponentName());
    }
    if (config.getScheme() != null) {
        scheme = config.getScheme();
    }
    if (config.getHost() != null) {
        host = config.getHost();
    }
    int num = config.getPort();
    if (num > 0) {
        port = num;
    }
    String contextPath = config.getContextPath();
    if (ObjectHelper.isNotEmpty(contextPath)) {
        contextPath = FileUtil.stripTrailingSeparator(contextPath);
        contextPath = FileUtil.stripLeadingSeparator(contextPath);
        if (ObjectHelper.isNotEmpty(contextPath)) {
            path = contextPath + ""/"" + path;
        }
    }
    if (ObjectHelper.isEmpty(host)) {
        host = RestComponentHelper.resolveRestHostName(host, config);
    }
    Map<String, Object> map = RestComponentHelper.initRestEndpointProperties(getComponentName(), config);
    String restrict = verb.toUpperCase(Locale.US);
    boolean explicitOptions = restrict.contains(""OPTIONS"");
    boolean cors = config.isEnableCORS();
    if (cors) {
        map.put(""optionsEnabled"", ""true"");
    } else if (explicitOptions) {
        map.put(""optionsEnabled"", ""true"");
    }
    if (api) {
        map.put(""matchOnUriPrefix"", ""true"");
    }
    RestComponentHelper.addHttpRestrictParam(map, verb, !explicitOptions);
    String url = RestComponentHelper.createRestConsumerUrl(getComponentName(), scheme, host, port, path, map);
    UndertowEndpoint endpoint = (UndertowEndpoint) camelContext.getEndpoint(url, parameters);
    if (!map.containsKey(""undertowHttpBinding"")) {
        endpoint.setUndertowHttpBinding(new RestUndertowHttpBinding(endpoint.isUseStreaming()));
    }
    Consumer consumer = endpoint.createConsumer(processor);
    if (config.getConsumerProperties() != null && !config.getConsumerProperties().isEmpty()) {
        setProperties(camelContext, consumer, config.getConsumerProperties());
    }
    if (consumer instanceof UndertowConsumer) {
        ((UndertowConsumer) consumer).setRest(true);
    }
    return consumer;
}",java:S107,1
"public synchronized HttpHandler add(String path, String methods, boolean prefixMatch, HttpHandler handler){
    String basePath = getBasePath(path);
    HttpHandler basePathHandler = pathHandler.getHandler(basePath);
    CamelMethodHandler targetHandler;
    if (path.contains(""{"")) {
        String relativePath = path.substring(basePath.length());
        if (basePathHandler instanceof CamelPathTemplateHandler) {
            CamelPathTemplateHandler templateHandler = (CamelPathTemplateHandler) basePathHandler;
            targetHandler = templateHandler.get(relativePath);
            if (targetHandler == null) {
                targetHandler = new CamelMethodHandler();
                templateHandler.add(relativePath, targetHandler);
            }
        } else {
            CamelPathTemplateHandler templateHandler;
            if (basePathHandler instanceof CamelMethodHandler) {
                templateHandler = new CamelPathTemplateHandler((CamelMethodHandler) basePathHandler);
            } else if (basePathHandler == null) {
                templateHandler = new CamelPathTemplateHandler(new CamelMethodHandler());
            } else {
                throw new IllegalArgumentException(String.format(""Unsupported handler '%s' was found"", basePathHandler));
            }
            targetHandler = new CamelMethodHandler();
            templateHandler.add(relativePath, targetHandler);
            pathHandler.addPrefixPath(basePath, templateHandler);
        }
    } else {
        if (basePathHandler instanceof CamelPathTemplateHandler) {
            CamelPathTemplateHandler templateHandler = (CamelPathTemplateHandler) basePathHandler;
            if (!prefixMatch) {
                targetHandler = templateHandler.getDefault();
            } else {
                throw new IllegalArgumentException(String.format(""Duplicate handlers on a path '%s'"", path));
            }
        } else {
            if (basePathHandler instanceof CamelMethodHandler) {
                targetHandler = (CamelMethodHandler) basePathHandler;
            } else if (basePathHandler == null) {
                targetHandler = new CamelMethodHandler();
                if (prefixMatch) {
                    pathHandler.addPrefixPath(basePath, targetHandler);
                } else {
                    pathHandler.addExactPath(basePath, targetHandler);
                }
            } else {
                throw new IllegalArgumentException(String.format(""Unsupported handler '%s' was found"", basePathHandler));
            }
        }
    }
    return targetHandler.add(methods, handler);
}",java:S3776,39
"public synchronized void remove(String path, String methods, boolean prefixMatch){
    String basePath = getBasePath(path);
    HttpHandler basePathHandler = pathHandler.getHandler(basePath);
    if (basePathHandler == null) {
        return;
    }
    if (path.contains(""{"")) {
        String relativePath = path.substring(basePath.length());
        CamelPathTemplateHandler templateHandler = (CamelPathTemplateHandler) basePathHandler;
        CamelMethodHandler targetHandler = templateHandler.get(relativePath);
        if (targetHandler.remove(methods)) {
            templateHandler.remove(relativePath);
            if (templateHandler.isEmpty()) {
                pathHandler.removePrefixPath(basePath);
            }
        }
    } else {
        if (basePathHandler instanceof CamelPathTemplateHandler) {
            String relativePath = path.substring(basePath.length());
            CamelPathTemplateHandler templateHandler = (CamelPathTemplateHandler) basePathHandler;
            CamelMethodHandler targetHandler = templateHandler.getDefault();
            if (targetHandler.remove(methods)) {
                templateHandler.remove(relativePath);
                if (templateHandler.isEmpty()) {
                    pathHandler.removePrefixPath(basePath);
                }
            }
        } else {
            CamelMethodHandler targetHandler = (CamelMethodHandler) basePathHandler;
            if (targetHandler.remove(methods)) {
                if (prefixMatch) {
                    pathHandler.removePrefixPath(basePath);
                } else {
                    pathHandler.removeExactPath(basePath);
                }
            }
        }
    }
}",java:S3776,39
" HttpHandler wrapHttpHandler(HttpHandler httpHandler) throws Exception{
    return httpHandler;
}",java:S112,4
"protected void configureValidator(ValidatingProcessor validator) throws Exception{
    validator.setErrorHandler(getErrorHandler());
    validator.setUseSharedSchema(isUseSharedSchema());
    validator.setFailOnNullBody(isFailOnNullBody());
    validator.setFailOnNullHeader(isFailOnNullHeader());
    validator.setHeaderName(getHeaderName());
}",java:S112,4
"protected void configureValidator(ValidatingProcessor validator) throws Exception{
    validator.setErrorHandler(getErrorHandler());
    validator.setUseSharedSchema(isUseSharedSchema());
    validator.setFailOnNullBody(isFailOnNullBody());
    validator.setFailOnNullHeader(isFailOnNullHeader());
    validator.setHeaderName(getHeaderName());
}",java:S1130,7
"private synchronized VelocityEngine getVelocityEngine() throws Exception{
    if (velocityEngine == null) {
        velocityEngine = new VelocityEngine();
        velocityEngine.addProperty(""CamelClassResolver"", getCamelContext().getClassResolver());
        Properties properties = new Properties();
        properties.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_CACHE, isLoaderCache() ? ""true"" : ""false"");
        properties.setProperty(RuntimeConstants.RESOURCE_LOADERS, ""file, class"");
        properties.setProperty(""resource.loader.class.description"", ""Camel Velocity Classpath Resource Loader"");
        properties.setProperty(""resource.loader.class.class"", CamelVelocityClasspathResourceLoader.class.getName());
        final Logger velocityLogger = LoggerFactory.getLogger(""org.apache.camel.maven.Velocity"");
        properties.setProperty(RuntimeConstants.RUNTIME_LOG_NAME, velocityLogger.getName());
        if (ObjectHelper.isNotEmpty(getPropertiesFile())) {
            InputStream reader = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext(), getPropertiesFile());
            try {
                properties.load(reader);
                log.info(""Loaded the velocity configuration file {}"", getPropertiesFile());
            } finally {
                IOHelper.close(reader, getPropertiesFile(), log);
            }
        }
        log.debug(""Initializing VelocityEngine with properties {}"", properties);
        ClassLoader old = Thread.currentThread().getContextClassLoader();
        try {
            ClassLoader delegate = new CamelVelocityDelegateClassLoader(old);
            Thread.currentThread().setContextClassLoader(delegate);
            velocityEngine.init(properties);
        } finally {
            Thread.currentThread().setContextClassLoader(old);
        }
    }
    return velocityEngine;
}",java:S112,4
"public void setVelocityEngine(VelocityEngine velocityEngine){
    this.velocityEngine = velocityEngine;
}",java:S2886,33
"protected void configureWebSocketHandlers(WebSocket webSocket){
    webSocket.binaryMessageHandler(buffer -> this.handleResult(buffer.getBytes()));
    webSocket.textMessageHandler(this::handleResult);
    webSocket.closeHandler(event -> {
        if (isStarted()) {
            LOG.info(""WebSocket disconnected from {}. Attempting to reconnect..."", webSocket.remoteAddress());
            VertxWebsocketConfiguration configuration = getEndpoint().getConfiguration();
            AtomicInteger reconnectAttempts = new AtomicInteger();
            Vertx vertx = getEndpoint().getVertx();
            vertx.setPeriodic(configuration.getReconnectInitialDelay(), configuration.getReconnectInterval(), timerId -> {
                vertx.executeBlocking(promise -> {
                    try {
                        configureWebSocketHandlers(getEndpoint().getWebSocket());
                        vertx.cancelTimer(timerId);
                        promise.complete();
                    } catch (Exception e) {
                        promise.fail(e);
                    }
                }, false, result -> {
                    if (result.failed()) {
                        Throwable cause = result.cause();
                        if (cause != null) {
                            LOG.debug(""WebSocket reconnect to {} failed due to {}"", webSocket.remoteAddress(), cause);
                        }
                        if (configuration.getMaxReconnectAttempts() > 0) {
                            if (reconnectAttempts.incrementAndGet() == configuration.getMaxReconnectAttempts()) {
                                LOG.warn(""Reconnect max attempts ({}) exhausted. Giving up trying to reconnect to {}"", configuration.getMaxReconnectAttempts(), webSocket.remoteAddress());
                                vertx.cancelTimer(timerId);
                            }
                        }
                    }
                });
            });
        }
    });
    webSocket.exceptionHandler(exception -> {
        Throwable cause = exception.getCause();
        if (cause == ConnectionBase.CLOSED_EXCEPTION) {
            return;
        }
        Exchange exchange = createExchange(false);
        getExceptionHandler().handleException(""Error processing exchange"", exchange, cause);
        releaseExchange(exchange, false);
    });
}",java:S3776,39
"public static boolean webSocketHostPathMatches(String hostPath, String targetPath){
    boolean exactPathMatch = true;
    if (ObjectHelper.isEmpty(hostPath) || ObjectHelper.isEmpty(targetPath)) {
        return false;
    }
    if (hostPath.endsWith(""*"")) {
        exactPathMatch = false;
        hostPath = hostPath.substring(0, hostPath.lastIndexOf('*'));
    }
    String normalizedHostPath = HttpUtils.normalizePath(hostPath + ""/"");
    String normalizedTargetPath = HttpUtils.normalizePath(targetPath + ""/"");
    String[] hostPathElements = normalizedHostPath.split(""/"");
    String[] targetPathElements = normalizedTargetPath.split(""/"");
    if (exactPathMatch && hostPathElements.length != targetPathElements.length) {
        return false;
    }
    if (exactPathMatch) {
        return normalizedHostPath.equals(normalizedTargetPath);
    } else {
        return normalizedTargetPath.startsWith(normalizedHostPath);
    }
}",java:S3776,39
"public void connect(VertxWebsocketConsumer consumer){
    VertxWebsocketEndpoint endpoint = consumer.getEndpoint();
    VertxWebsocketConfiguration configuration = endpoint.getConfiguration();
    URI websocketURI = configuration.getWebsocketURI();
    String path = PATH_PARAMETER_PATTERN.matcher(websocketURI.getPath()).replaceAll("":$1"");
    Router router = hostConfiguration.getRouter();
    Route route = router.route(path);
    LOG.info(""Connected consumer for path {}"", path);
    if (!ObjectHelper.isEmpty(configuration.getAllowedOriginPattern())) {
        CorsHandler corsHandler = CorsHandler.create().addRelativeOrigin(configuration.getAllowedOriginPattern());
        route.handler(corsHandler);
    }
    route.handler(routingContext -> {
        HttpServerRequest request = routingContext.request();
        String connectionHeader = request.headers().get(HttpHeaders.CONNECTION);
        if (connectionHeader == null || !connectionHeader.toLowerCase().contains(""upgrade"")) {
            routingContext.response().setStatusCode(400);
            routingContext.response().end(""Can \""Upgrade\"" only to \""WebSocket\""."");
        } else {
            final boolean parseEnded = request.isEnded();
            if (!parseEnded) {
                request.pause();
            }
            request.toWebSocket(toWebSocket -> {
                if (toWebSocket.succeeded()) {
                    if (!parseEnded) {
                        request.resume();
                    }
                    ServerWebSocket webSocket = toWebSocket.result();
                    SocketAddress socketAddress = webSocket.localAddress();
                    SocketAddress remote = webSocket.remoteAddress();
                    VertxWebsocketPeer peer = new VertxWebsocketPeer(webSocket, websocketURI.getPath());
                    connectedPeers.add(peer);
                    if (LOG.isDebugEnabled()) {
                        if (socketAddress != null) {
                            LOG.debug(""WebSocket peer {} connected from {}"", peer.getConnectionKey(), socketAddress.host());
                        }
                    }
                    webSocket.textMessageHandler(message -> consumer.onMessage(peer.getConnectionKey(), message, remote, routingContext));
                    webSocket.binaryMessageHandler(message -> consumer.onMessage(peer.getConnectionKey(), message.getBytes(), remote, routingContext));
                    webSocket.exceptionHandler(exception -> consumer.onException(peer.getConnectionKey(), exception, remote, routingContext));
                    webSocket.closeHandler(closeEvent -> {
                        if (LOG.isDebugEnabled()) {
                            if (socketAddress != null) {
                                LOG.debug(""WebSocket peer {} disconnected from {}"", peer.getConnectionKey(), socketAddress.host());
                            }
                        }
                        if (configuration.isFireWebSocketConnectionEvents()) {
                            consumer.onClose(peer.getConnectionKey(), remote, routingContext);
                        }
                        connectedPeers.remove(peer);
                    });
                    if (configuration.isFireWebSocketConnectionEvents()) {
                        consumer.onOpen(peer.getConnectionKey(), remote, routingContext, webSocket);
                    }
                } else {
                    routingContext.fail(toWebSocket.cause());
                }
            });
        }
    });
    routeRegistry.put(websocketURI.getPath(), route);
}",java:S3776,39
"protected void onEventBusEvent(final Message<?> event){
    LOG.debug(""onEvent {}"", event);
    final boolean reply = event.replyAddress() != null;
    Exchange exchange = createExchange(true);
    exchange.setPattern(reply ? ExchangePattern.InOut : ExchangePattern.InOnly);
    exchange.getIn().setBody(event.body());
    try {
        getAsyncProcessor().process(exchange, new AsyncCallback() {

            @Override
            public void done(boolean doneSync) {
                if (reply) {
                    Object body = exchange.getMessage().getBody();
                    if (body != null) {
                        LOG.debug(""Sending reply to: {} with body: {}"", event.replyAddress(), body);
                        event.reply(body);
                    }
                }
            }
        });
    } catch (Exception e) {
        getExceptionHandler().handleException(""Error processing Vertx event: "" + event, e);
    }
}",java:S3740,38
"private String createContext(){
    String answer;
    if (isBoxedQuery()) {
        if (weatherConfiguration.getWeatherApi() == WeatherApi.Station) {
            answer = ""box/station?"";
        } else {
            answer = ""box/city?"";
        }
    } else if (isGeoLocation() && weatherConfiguration.getCnt() != null) {
        if (weatherConfiguration.getWeatherApi() == WeatherApi.Station) {
            answer = ""station/find?"";
        } else {
            answer = ""find?"";
        }
    } else if (weatherConfiguration.getIds() != null && !weatherConfiguration.getIds().isEmpty()) {
        if (weatherConfiguration.getIds().size() == 1) {
            if (!isEmpty(weatherConfiguration.getPeriod())) {
                if (weatherConfiguration.getWeatherApi() == WeatherApi.Hourly) {
                    answer = ""forecast?"";
                } else {
                    answer = ""forecast/daily?"";
                }
            } else if (weatherConfiguration.getWeatherApi() == WeatherApi.Station) {
                answer = ""station?"";
            } else {
                answer = ""weather?"";
            }
        } else {
            answer = ""group?"";
        }
    } else if (isEmpty(weatherConfiguration.getPeriod())) {
        answer = ""weather?"";
    } else {
        if (weatherConfiguration.getWeatherApi() == WeatherApi.Hourly) {
            answer = ""forecast?"";
        } else {
            answer = ""forecast/daily?"";
        }
    }
    return answer;
}",java:S3776,39
"private void ethPendingTransactionHashObservable(String x){
    LOG.debug(""processEthBlock {}"", x);
    Exchange exchange = this.getEndpoint().createExchange();
    exchange.getIn().setBody(x);
    processEvent(exchange);
}",java:S4144,40
"private static void addTopics(Filter<?> filter, List<String> topics){
    if (topics != null) {
        for (String topic : topics) {
            if (topic != null && topic.length() > 0) {
                filter.addSingleTopic(topic);
            } else {
                filter.addNullTopic();
            }
        }
    }
}",java:S3740,38
"public static RestConsumerFactory locateRestConsumerFactory(CamelContext context, WebhookConfiguration configuration){
    RestConsumerFactory factory = null;
    if (configuration.getWebhookComponentName() != null) {
        Object comp = context.getRegistry().lookupByName(configuration.getWebhookComponentName());
        if (comp instanceof RestConsumerFactory) {
            factory = (RestConsumerFactory) comp;
        } else {
            comp = context.getComponent(configuration.getWebhookComponentName());
            if (comp instanceof RestConsumerFactory) {
                factory = (RestConsumerFactory) comp;
            }
        }
        if (factory == null) {
            if (comp != null) {
                throw new IllegalArgumentException(""Component "" + configuration.getWebhookComponentName() + "" is not a RestConsumerFactory"");
            } else {
                throw new NoSuchBeanException(configuration.getWebhookComponentName(), RestConsumerFactory.class.getName());
            }
        }
    }
    if (factory == null) {
        for (String name : context.getComponentNames()) {
            Component comp = context.getComponent(name);
            if (comp instanceof RestConsumerFactory) {
                factory = (RestConsumerFactory) comp;
                break;
            }
        }
    }
    if (factory == null) {
        Set<RestConsumerFactory> factories = context.getRegistry().findByType(RestConsumerFactory.class);
        if (factories != null && factories.size() == 1) {
            factory = factories.iterator().next();
        }
    }
    if (factory == null) {
        RestConsumerFactory found = null;
        for (String name : DEFAULT_REST_CONSUMER_COMPONENTS) {
            Object comp = context.getComponent(name, true);
            if (comp instanceof RestConsumerFactory) {
                if (found == null) {
                    found = (RestConsumerFactory) comp;
                } else {
                    throw new IllegalArgumentException(""Multiple RestConsumerFactory found on classpath. Configure explicit which component to use"");
                }
            }
        }
        if (found != null) {
            factory = found;
        }
    }
    if (factory == null) {
        throw new IllegalStateException(""Cannot find RestConsumerFactory in Registry or as a Component to use"");
    }
    return factory;
}",java:S3776,39
"private void putEvent(EventBridgeClient eventbridgeClient, Exchange exchange) throws InvalidPayloadException{
    if (getConfiguration().isPojoRequest()) {
        Object payload = exchange.getIn().getMandatoryBody();
        if (payload instanceof PutEventsRequest) {
            PutEventsResponse result;
            try {
                result = eventbridgeClient.putEvents((PutEventsRequest) payload);
            } catch (AwsServiceException ase) {
                LOG.trace(""PutEvents command returned the error code {}"", ase.awsErrorDetails().errorCode());
                throw ase;
            }
            Message message = getMessageForResponse(exchange);
            message.setBody(result);
        }
    } else {
        PutEventsRequest.Builder builder = PutEventsRequest.builder();
        PutEventsRequestEntry.Builder entryBuilder = PutEventsRequestEntry.builder();
        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EventbridgeConstants.EVENT_RESOURCES_ARN))) {
            String resourcesArn = exchange.getIn().getHeader(EventbridgeConstants.EVENT_RESOURCES_ARN, String.class);
            entryBuilder.resources(Stream.of(resourcesArn.split("","")).toList());
        } else {
            throw new IllegalArgumentException(""At least one resource ARN must be specified"");
        }
        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EventbridgeConstants.EVENT_DETAIL_TYPE))) {
            String detailType = exchange.getIn().getHeader(EventbridgeConstants.EVENT_DETAIL_TYPE, String.class);
            entryBuilder.detailType(detailType);
        } else {
            throw new IllegalArgumentException(""Detail Type must be specified"");
        }
        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(EventbridgeConstants.EVENT_SOURCE))) {
            String source = exchange.getIn().getHeader(EventbridgeConstants.EVENT_SOURCE, String.class);
            entryBuilder.source(source);
        } else {
            throw new IllegalArgumentException(""Source must be specified"");
        }
        entryBuilder.eventBusName(getConfiguration().getEventbusName());
        entryBuilder.detail(exchange.getMessage().getMandatoryBody(String.class));
        builder.entries(entryBuilder.build());
        PutEventsResponse result;
        try {
            result = eventbridgeClient.putEvents(builder.build());
        } catch (AwsServiceException ase) {
            LOG.trace(""Put Events command returned the error code {}"", ase.awsErrorDetails().errorCode());
            throw ase;
        }
        Message message = getMessageForResponse(exchange);
        message.setBody(result);
    }
}",java:S3776,39
"public static BodyPublisher ofStreamPart(Map<Object, Object> data, String boundary) throws IOException{
    Supplier<? extends InputStream> streamSupplier = new FileUploadStreamSupplier(data, boundary).generate();
    return BodyPublishers.ofInputStream(streamSupplier);
}",java:S1130,7
"public Supplier<? extends InputStream> generate(){
    return (Supplier<SequenceInputStream>) () -> new SequenceInputStream(preFileIS, new SequenceInputStream(fileIS, postFileIS));
}",java:S1452,23
"public void parseURI(String remaining, Map<String, Object> parameters) throws Exception{
    String entity;
    String path;
    try {
        URI u = new URI(remaining);
        entity = u.getScheme();
        path = u.getPath();
    } catch (Exception e) {
        throw new MalformedURLException(String.format(""An invalid workday remaining uri: '%s' was provided. Error: '%s'"", remaining, e.getMessage()));
    }
    ObjectHelper.notNull(entity, ""Entity"");
    setPath(path);
    setEntity(Entity.valueOf(entity));
    setParameters(parameters);
}",java:S112,4
"private void writeEndNoTypeHints(){
    if (xmlEvent == XMLStreamConstants.START_ELEMENT) {
        if (childs.isEmpty()) {
            if (this.parent.jsonToken == JsonToken.NOT_AVAILABLE) {
                jsonToken = JsonToken.START_OBJECT;
            } else {
                jsonToken = JsonToken.FIELD_NAME;
                final TreeElement treeElement = new TreeElement(this, -1, JsonToken.VALUE_STRING);
                treeElement.setValue("""");
                this.addChild(treeElement);
            }
        } else if (childs.size() == 1 && childs.get(0).xmlEvent == XMLStreamConstants.CHARACTERS) {
            if (this.parent.jsonToken == JsonToken.NOT_AVAILABLE) {
                jsonToken = JsonToken.START_OBJECT;
                final TreeElement child = childs.get(0);
                if (isWhitespace(child.value)) {
                    childs.remove(0);
                } else {
                    final TreeElement treeElement = new TreeElement(this, -1, JsonToken.FIELD_NAME, XJConstants.JSON_WRITER_MIXED_CONTENT_TEXT_KEY);
                    treeElement.addChild(child);
                    childs.set(childs.indexOf(child), treeElement);
                    child.parent = treeElement;
                }
            } else {
                jsonToken = JsonToken.FIELD_NAME;
            }
        } else {
            final Iterator<TreeElement> iterator = childs.iterator();
            while (iterator.hasNext()) {
                TreeElement element = iterator.next();
                if (element.jsonToken == JsonToken.VALUE_STRING) {
                    if (isWhitespace(element.value)) {
                        iterator.remove();
                    } else {
                        final TreeElement treeElement = new TreeElement(this, -1, JsonToken.FIELD_NAME, element.name != null ? element.name : XJConstants.JSON_WRITER_MIXED_CONTENT_TEXT_KEY);
                        treeElement.addChild(element);
                        childs.set(childs.indexOf(element), treeElement);
                        element.parent = treeElement;
                        element.jsonToken = JsonToken.VALUE_STRING;
                    }
                }
            }
            jsonToken = JsonToken.START_OBJECT;
            wrapChildsInArrayIfNecessary();
        }
    } else {
        throw new IllegalStateException(""XMLEvent: "" + xmlEvent + ""; Json Token: "" + jsonToken);
    }
}",java:S3776,39
"private void writeEndHaveTypeHints(){
    switch(jsonToken) {
        case VALUE_NULL:
        case VALUE_STRING:
        case VALUE_NUMBER_INT:
        case VALUE_NUMBER_FLOAT:
        case VALUE_TRUE:
        case VALUE_FALSE:
            if (childs.isEmpty()) {
                final TreeElement treeElement = new TreeElement(this, -1, jsonToken);
                treeElement.setValue("""");
                this.addChild(treeElement);
                jsonToken = JsonToken.FIELD_NAME;
            } else if (childs.size() == 1) {
                childs.get(0).jsonToken = jsonToken;
                jsonToken = JsonToken.FIELD_NAME;
            } else {
                final Iterator<TreeElement> iterator = childs.iterator();
                while (iterator.hasNext()) {
                    TreeElement element = iterator.next();
                    if (isValueToken(element.jsonToken)) {
                        if (isWhitespace(element.value)) {
                            iterator.remove();
                        } else {
                            final TreeElement treeElement = new TreeElement(this, -1, JsonToken.FIELD_NAME, element.name != null ? element.name : XJConstants.JSON_WRITER_MIXED_CONTENT_TEXT_KEY);
                            treeElement.addChild(element);
                            childs.set(childs.indexOf(element), treeElement);
                            element.parent = treeElement;
                            if (element.xmlEvent == XMLStreamConstants.CHARACTERS) {
                                element.jsonToken = jsonToken;
                            }
                        }
                    }
                }
                jsonToken = JsonToken.START_OBJECT;
                wrapChildsInArrayIfNecessary();
            }
            break;
        case START_OBJECT:
        case START_ARRAY:
            final Iterator<TreeElement> iterator = childs.iterator();
            while (iterator.hasNext()) {
                TreeElement element = iterator.next();
                if (isValueToken(element.jsonToken)) {
                    if (isWhitespace(element.value)) {
                        iterator.remove();
                    } else {
                        final TreeElement treeElement = new TreeElement(this, -1, JsonToken.FIELD_NAME, XJConstants.JSON_WRITER_MIXED_CONTENT_TEXT_KEY);
                        treeElement.addChild(element);
                        childs.set(childs.indexOf(element), treeElement);
                        element.parent = treeElement;
                    }
                }
            }
            if (jsonToken != JsonToken.START_ARRAY) {
                wrapChildsInArrayIfNecessary();
            }
            break;
        default:
            throw new IllegalStateException(""XMLEvent: "" + xmlEvent + ""; Json Token: "" + jsonToken);
    }
}",java:S3776,39
"private void wrapChildsInArrayIfNecessary(){
    final Map<String, Set<TreeElement>> childElementsMap = childs.stream().collect(Collectors.groupingBy(o -> o.name, HashMap::new, Collectors.toCollection(LinkedHashSet::new)));
    for (Map.Entry<String, Set<TreeElement>> mapEntry : childElementsMap.entrySet()) {
        if (mapEntry.getValue().size() > 1) {
            if (childElementsMap.size() == 1) {
                jsonToken = JsonToken.START_ARRAY;
            } else {
                final TreeElement treeElement = new TreeElement(this, -1, JsonToken.START_ARRAY, mapEntry.getKey());
                treeElement.childs = new ArrayList<>(mapEntry.getValue());
                for (TreeElement child : treeElement.childs) {
                    child.parent = treeElement;
                }
                final List<TreeElement> newChildList = new ArrayList<>(this.childs.size() - mapEntry.getValue().size() + 1);
                for (TreeElement e : this.childs) {
                    if (!mapEntry.getValue().contains(e)) {
                        newChildList.add(e);
                    }
                }
                childs = newChildList;
                childs.add(treeElement);
            }
        }
    }
}",java:S3776,39
"private X509Certificate[] getCertificateChain() throws Exception{
    KeyStore keystore = getKeyStore();
    if (keystore == null) {
        return null;
    }
    String alias = getAlias();
    if (alias == null) {
        return null;
    }
    Certificate[] certs = keystore.getCertificateChain(alias);
    if (certs == null) {
        return null;
    }
    ArrayList<X509Certificate> certList = new ArrayList<>(certs.length);
    for (Certificate cert : certs) {
        if (cert instanceof X509Certificate) {
            certList.add((X509Certificate) cert);
        }
    }
    return certList.toArray(new X509Certificate[certList.size()]);
}",java:S112,4
"protected void checkSearchValueOfType(Class<?> cl, Input input) throws Exception{
    if (!cl.isAssignableFrom(input.getOutputNodeSearch().getClass())) {
        throw new XMLSignatureException(String.format(""Wrong configuration: Search value is of class %s, the output node search %s requires class %s."", input.getOutputNodeSearch().getClass().getName(), input.getOutputNodeSearchType(), cl.getName()));
    }
}",java:S112,4
"protected void checkStringSarchValueNotEmpty(String searchValue, String outputNodeSearchType) throws Exception{
    if (searchValue.isEmpty()) {
        throw new XMLSignatureException(String.format(""Wrong configuration: Value for output node search %s is empty."", outputNodeSearchType));
    }
}",java:S112,4
"protected void checkSearchValueNotNull(Input input) throws Exception{
    LOG.debug(""Searching for output element with search value '{}' and sarch type {}"", input.getOutputNodeSearch(), input.getOutputNodeSearchType());
    if (input.getOutputNodeSearch() == null) {
        throw new XMLSignatureException(String.format(""Wrong configuration: Value is missing for output node search %s."", input.getOutputNodeSearchType()));
    }
}",java:S112,4
"protected List<Reference> getReferencesForMessageMapping(Input input) throws Exception{
    return input.getReferences();
}",java:S112,4
"protected List<XMLObject> getObjectsForMessageMapping(Input input) throws Exception{
    return input.getObjects();
}",java:S112,4
"protected String addDataObjectFormat(Element signedDataObjectProperties, Document doc, Input input){
    if (!isAddDataObjectFormat()) {
        return null;
    }
    Element dataObjectFormat = createElement(""DataObjectFormat"", doc, input);
    signedDataObjectProperties.appendChild(dataObjectFormat);
    String contentReferenceId = ""_"" + UUID.randomUUID().toString();
    setAttribute(dataObjectFormat, ""ObjectReference"", ""#"" + contentReferenceId);
    if (getDataObjectFormatDescription() != null && !getDataObjectFormatDescription().isEmpty()) {
        Element description = createElement(""Description"", doc, input);
        dataObjectFormat.appendChild(description);
        description.setTextContent(getDataObjectFormatDescription());
    }
    if (getDataObjectFormatIdentifier() != null && !getDataObjectFormatIdentifier().isEmpty()) {
        Element objectIdentifier = createElement(""ObjectIdentifier"", doc, input);
        dataObjectFormat.appendChild(objectIdentifier);
        Element identifier = createElement(""Identifier"", doc, input);
        objectIdentifier.appendChild(identifier);
        identifier.setTextContent(getDataObjectFormatIdentifier());
        if (getDataObjectFormatIdentifierQualifier() != null && !getDataObjectFormatIdentifierQualifier().isEmpty()) {
            setAttribute(identifier, ""Qualifier"", getDataObjectFormatIdentifierQualifier());
        }
        if (getDataObjectFormatIdentifierDescription() != null && !getDataObjectFormatIdentifierDescription().isEmpty()) {
            Element description = createElement(""Description"", doc, input);
            objectIdentifier.appendChild(description);
            description.setTextContent(getDataObjectFormatIdentifierDescription());
        }
        if (!getDataObjectFormatIdentifierDocumentationReferences().isEmpty()) {
            Element documentationReferences = createElement(""DocumentationReferences"", doc, input);
            objectIdentifier.appendChild(documentationReferences);
            List<String> docReferences = getDataObjectFormatIdentifierDocumentationReferences();
            for (String documentationReferenceValue : docReferences) {
                Element documentationReference = createElement(""DocumentationReference"", doc, input);
                documentationReferences.appendChild(documentationReference);
                documentationReference.setTextContent(documentationReferenceValue);
            }
        }
    }
    if (getDataObjectFormatMimeType() != null && !getDataObjectFormatMimeType().isEmpty()) {
        Element mimeType = createElement(""MimeType"", doc, input);
        dataObjectFormat.appendChild(mimeType);
        mimeType.setTextContent(getDataObjectFormatMimeType());
    }
    String encoding = input.getMessage().getHeader(XmlSignatureConstants.HEADER_XADES_DATA_OBJECT_FORMAT_ENCODING, String.class);
    if (encoding != null && !encoding.isEmpty()) {
        Element encodingEl = createElement(""Encoding"", doc, input);
        dataObjectFormat.appendChild(encodingEl);
        encodingEl.setTextContent(encoding);
    }
    return contentReferenceId;
}",java:S3776,39
"protected void addSignaturePolicyIdentifier(Document doc, Element signedProperties, Input input) throws XmlSignatureException, IOException, ParserConfigurationException{
    if (!isAddSignaturePolicy()) {
        return;
    }
    Element signaturePolicyIdentifier = createElement(""SignaturePolicyIdentifier"", doc, input);
    signedProperties.appendChild(signaturePolicyIdentifier);
    if (SIG_POLICY_IMPLIED.equals(getSignaturePolicy())) {
        LOG.debug(""Adding implied signature policy"");
        Element implied = createElement(""SignaturePolicyImplied"", doc, input);
        signaturePolicyIdentifier.appendChild(implied);
    } else if (SIG_POLICY_EXPLICIT_ID.equals(getSignaturePolicy())) {
        LOG.debug(""Adding signatue policy ID"");
        Element id = createElement(""SignaturePolicyId"", doc, input);
        signaturePolicyIdentifier.appendChild(id);
        Element sigPolicyId = createElement(""SigPolicyId"", doc, input);
        id.appendChild(sigPolicyId);
        Element identifier = createElement(""Identifier"", doc, input);
        sigPolicyId.appendChild(identifier);
        if (getSigPolicyId() == null || getSigPolicyId().isEmpty()) {
            throw new XmlSignatureException(""The XAdES-EPES configuration is invalid. The signature policy identifier is missing."");
        }
        identifier.setTextContent(getSigPolicyId());
        if (getSigPolicyIdQualifier() != null && !getSigPolicyIdQualifier().isEmpty()) {
            setAttribute(identifier, ""Qualifier"", getSigPolicyIdQualifier());
        }
        if (getSigPolicyIdDescription() != null && !getSigPolicyIdDescription().isEmpty()) {
            Element description = createElement(""Description"", doc, input);
            sigPolicyId.appendChild(description);
            description.setTextContent(getSigPolicyIdDescription());
        }
        if (!getSigPolicyIdDocumentationReferences().isEmpty()) {
            Element documentationReferences = createElement(""DocumentationReferences"", doc, input);
            sigPolicyId.appendChild(documentationReferences);
            List<String> docReferences = getSigPolicyIdDocumentationReferences();
            for (String documentationReferenceValue : docReferences) {
                Element documentationReference = createElement(""DocumentationReference"", doc, input);
                documentationReferences.appendChild(documentationReference);
                documentationReference.setTextContent(documentationReferenceValue);
            }
        }
        Element sigPolicyHash = createElement(""SigPolicyHash"", doc, input);
        id.appendChild(sigPolicyHash);
        if (getSignaturePolicyDigestAlgorithm() == null || getSignaturePolicyDigestAlgorithm().isEmpty()) {
            throw new XmlSignatureException(""The XAdES-EPES configuration is invalid. The digest algorithm for the signature policy is missing."");
        }
        Element digestMethod = createElementNS(doc, input, ""DigestMethod"");
        sigPolicyHash.appendChild(digestMethod);
        setAttribute(digestMethod, ""Algorithm"", getSignaturePolicyDigestAlgorithm());
        if (getSignaturePolicyDigestValue() == null || getSignaturePolicyDigestValue().isEmpty()) {
            throw new XmlSignatureException(""The XAdES-EPES configuration is invalid. The digest value for the signature policy is missing."");
        }
        Element digestValue = createElementNS(doc, input, ""DigestValue"");
        sigPolicyHash.appendChild(digestValue);
        digestValue.setTextContent(getSignaturePolicyDigestValue());
        List<String> qualifiers = getSigPolicyQualifiers();
        if (!qualifiers.isEmpty()) {
            Element qualifiersEl = createElement(""SigPolicyQualifiers"", doc, input);
            id.appendChild(qualifiersEl);
            String errorMessage = ""The XAdES configuration is invalid. The list of the signatue policy qualifiers contains the invalid entry '%s'."" + "" An entry must either be a text or an XML fragment with the root element '%s' with the namespace '%s'."";
            for (String elementOrText : getSigPolicyQualifiers()) {
                Element child = createChildFromXmlFragmentOrText(doc, input, ""SigPolicyQualifier"", errorMessage, elementOrText);
                qualifiersEl.appendChild(child);
            }
        }
    } else {
        throw new IllegalStateException(String.format(""Invalid value '%s' for parameter 'SignaturePolicy'. Possible values are: 'None', 'Implied', and 'ExplictId'."", getSignaturePolicy()));
    }
}",java:S3776,39
"protected X509Certificate getSigningCertificate() throws Exception{
    return null;
}",java:S112,4
"protected X509Certificate[] getSigningCertificateChain() throws Exception{
    return null;
}",java:S112,4
"protected static InputStream readXslTransform(String path) throws Exception{
    if (path == null) {
        throw new IllegalArgumentException(""path is null"");
    }
    InputStream is = org.apache.camel.util.ObjectHelper.loadResourceAsStream(path);
    if (is == null) {
        is = XmlSignatureHelper.class.getResourceAsStream(path);
    }
    return is;
}",java:S112,4
"@Deprecated
public static void transformToOutputStream(Node node, OutputStream os, boolean omitXmlDeclaration) throws Exception{
    if (node.getNodeType() == Node.TEXT_NODE) {
        byte[] bytes = tranformTextNodeToByteArray(node);
        os.write(bytes);
    } else {
        transformNonTextNodeToOutputStream(node, os, omitXmlDeclaration);
    }
}",java:S6355,48
"@Deprecated
public static void transformNonTextNodeToOutputStream(Node node, OutputStream os, boolean omitXmlDeclaration) throws Exception{
    transformNonTextNodeToOutputStream(node, os, omitXmlDeclaration, null);
}",java:S6355,48
"@Deprecated
public static byte[] tranformTextNodeToByteArray(Node node){
    return tranformTextNodeToByteArray(node, null);
}",java:S6355,48
"public List<? extends XMLObject> getObjects(){
    return objects;
}",java:S1452,23
"public List<? extends Reference> getReferences(){
    return references;
}",java:S1452,23
"public Map<String, ? extends Object> getCryptoContextProperties(){
    return cryptoContextProperties;
}",java:S1452,23
"protected Document sign(final Message out) throws Exception{
    try {
        XMLSignatureFactory fac;
        try {
            fac = XMLSignatureFactory.getInstance(""DOM"", ""ApacheXMLDSig"");
        } catch (NoSuchProviderException ex) {
            fac = XMLSignatureFactory.getInstance(""DOM"");
        }
        final Node node = getMessageBodyNode(out);
        if (getConfiguration().getKeyAccessor() == null) {
            throw new XmlSignatureNoKeyException(""Key accessor is missing for XML signature generation. Specify a key accessor in the configuration."");
        }
        final KeySelector keySelector = getConfiguration().getKeyAccessor().getKeySelector(out);
        if (keySelector == null) {
            throw new XmlSignatureNoKeyException(""Key selector is missing for XML signature generation. Specify a key selector in the configuration."");
        }
        SignatureType signatureType = determineSignatureType(out);
        final List<String> contentReferenceUris = getContentReferenceUris(out, signatureType, node);
        Node lastParent = null;
        for (final String contentReferenceUri : contentReferenceUris) {
            final KeyInfo keyInfo = getConfiguration().getKeyAccessor().getKeyInfo(out, node, fac.getKeyInfoFactory());
            String signatureId = getConfiguration().getSignatureId();
            if (signatureId == null) {
                signatureId = ""_"" + UUID.randomUUID().toString();
            } else if (signatureId.isEmpty()) {
                signatureId = null;
            }
            Node parent = getParentOfSignature(out, node, contentReferenceUri, signatureType);
            if (parent == null) {
                parent = XmlSignatureHelper.newDocumentBuilder(Boolean.TRUE).newDocument();
            }
            lastParent = parent;
            XmlSignatureProperties.Input input = new InputBuilder().contentDigestAlgorithm(getDigestAlgorithmUri()).keyInfo(keyInfo).message(out).messageBodyNode(node).parent(parent).signatureAlgorithm(getConfiguration().getSignatureAlgorithm()).signatureFactory(fac).signatureId(signatureId).contentReferenceUri(contentReferenceUri).signatureType(signatureType).prefixForXmlSignatureNamespace(getConfiguration().getPrefixForXmlSignatureNamespace()).build();
            XmlSignatureProperties.Output properties = getSignatureProperties(input);
            if (properties != null && properties.getSignatureId() != null && !properties.getSignatureId().isEmpty()) {
                signatureId = properties.getSignatureId();
            }
            List<? extends XMLObject> objects = getObjects(input, properties);
            List<? extends Reference> refs = getReferences(input, properties, getKeyInfoId(keyInfo));
            SignedInfo si = createSignedInfo(fac, refs);
            DOMSignContext dsc = createAndConfigureSignContext(parent, keySelector);
            XMLSignature signature = fac.newXMLSignature(si, keyInfo, objects, signatureId, null);
            signature.sign(dsc);
        }
        return XmlSignatureHelper.getDocument(lastParent);
    } catch (XMLSignatureException se) {
        if (se.getCause() instanceof InvalidKeyException) {
            throw new XmlSignatureInvalidKeyException(se.getMessage(), se);
        } else {
            throw new XmlSignatureException(se);
        }
    } catch (GeneralSecurityException e) {
        throw new XmlSignatureException(e);
    }
}",java:S3776,39
"protected SignedInfo createSignedInfo(XMLSignatureFactory fac, List<? extends Reference> refs) throws Exception{
    return fac.newSignedInfo(fac.newCanonicalizationMethod(getConfiguration().getCanonicalizationMethod().getAlgorithm(), (C14NMethodParameterSpec) getConfiguration().getCanonicalizationMethod().getParameterSpec()), getSignatureMethod(getConfiguration().getSignatureAlgorithm(), fac), refs);
}",java:S112,4
"protected Node getMessageBodyNode(Message message) throws Exception{
    InputStream is = message.getMandatoryBody(InputStream.class);
    Boolean isPlainText = isPlainText(message);
    Node node;
    if (isPlainText != null && isPlainText) {
        node = getTextNode(message, is);
    } else {
        ValidatorErrorHandler errorHandler = new DefaultValidationErrorHandler();
        Schema schema = getSchemaForSigner(message, errorHandler);
        Document doc = parseInput(is, getConfiguration().getDisallowDoctypeDecl(), schema, errorHandler);
        errorHandler.handleErrors(message.getExchange(), schema, null);
        node = doc.getDocumentElement();
        LOG.debug(""Root element of document to be signed: {}"", node);
    }
    return node;
}",java:S112,4
"protected Schema getSchemaForSigner(Message message, ValidatorErrorHandler errorHandler) throws XmlSignatureException, SAXException, IOException{
    Schema schema;
    String schemaResourceUri = getSchemaResourceUri(message);
    if (schemaResourceUri == null) {
        schema = null;
    } else {
        schema = getSchema(message);
    }
    return schema;
}",java:S1172,13
"protected Element getParentForEnvelopedCase(Document doc, Message inMessage) throws Exception{
    if (getConfiguration().getParentXpath() != null) {
        XPathFilterParameterSpec xp = getConfiguration().getParentXpath();
        XPathExpression exp;
        try {
            exp = XmlSignatureHelper.getXPathExpression(xp);
        } catch (XPathExpressionException e) {
            throw new XmlSignatureException(""The parent XPath "" + getConfiguration().getParentXpath().getXPath() + "" is wrongly configured: The XPath "" + xp.getXPath() + "" is invalid."", e);
        }
        NodeList list = (NodeList) exp.evaluate(doc.getDocumentElement(), XPathConstants.NODESET);
        if (list == null || list.getLength() == 0) {
            throw new XmlSignatureException(""The parent XPath "" + xp.getXPath() + "" returned no result. Check the configuration of the XML signer component."");
        }
        int length = list.getLength();
        for (int i = 0; i < length; i++) {
            Node node = list.item(i);
            if (node.getNodeType() == Node.ELEMENT_NODE) {
                return (Element) node;
            }
        }
        throw new XmlSignatureException(""The parent XPath "" + xp.getXPath() + "" returned no element. Check the configuration of the XML signer component."");
    } else {
        NodeList parents = doc.getElementsByTagNameNS(getConfiguration().getParentNamespace(), getConfiguration().getParentLocalName());
        if (parents == null || parents.getLength() == 0) {
            throw new XmlSignatureFormatException(String.format(""Incoming message has wrong format: The parent element with the local name %s and the namespace %s was not found in the message to build an enveloped XML signature."", getConfiguration().getParentLocalName(), getConfiguration().getParentNamespace()));
        }
        return (Element) parents.item(0);
    }
}",java:S1172,13
"protected Element getParentForEnvelopedCase(Document doc, Message inMessage) throws Exception{
    if (getConfiguration().getParentXpath() != null) {
        XPathFilterParameterSpec xp = getConfiguration().getParentXpath();
        XPathExpression exp;
        try {
            exp = XmlSignatureHelper.getXPathExpression(xp);
        } catch (XPathExpressionException e) {
            throw new XmlSignatureException(""The parent XPath "" + getConfiguration().getParentXpath().getXPath() + "" is wrongly configured: The XPath "" + xp.getXPath() + "" is invalid."", e);
        }
        NodeList list = (NodeList) exp.evaluate(doc.getDocumentElement(), XPathConstants.NODESET);
        if (list == null || list.getLength() == 0) {
            throw new XmlSignatureException(""The parent XPath "" + xp.getXPath() + "" returned no result. Check the configuration of the XML signer component."");
        }
        int length = list.getLength();
        for (int i = 0; i < length; i++) {
            Node node = list.item(i);
            if (node.getNodeType() == Node.ELEMENT_NODE) {
                return (Element) node;
            }
        }
        throw new XmlSignatureException(""The parent XPath "" + xp.getXPath() + "" returned no element. Check the configuration of the XML signer component."");
    } else {
        NodeList parents = doc.getElementsByTagNameNS(getConfiguration().getParentNamespace(), getConfiguration().getParentLocalName());
        if (parents == null || parents.getLength() == 0) {
            throw new XmlSignatureFormatException(String.format(""Incoming message has wrong format: The parent element with the local name %s and the namespace %s was not found in the message to build an enveloped XML signature."", getConfiguration().getParentLocalName(), getConfiguration().getParentNamespace()));
        }
        return (Element) parents.item(0);
    }
}",java:S112,4
"protected List<? extends Reference> getReferences(XmlSignatureProperties.Input input, XmlSignatureProperties.Output properties, String keyInfoId) throws Exception{
    String referenceId = properties == null ? null : properties.getContentReferenceId();
    Reference ref = createReference(input.getSignatureFactory(), input.getContentReferenceUri(), getContentReferenceType(input.getMessage()), input.getSignatureType(), referenceId, input.getMessage());
    Reference keyInfoRef = createKeyInfoReference(input.getSignatureFactory(), keyInfoId, input.getContentDigestAlgorithm());
    int propsRefsSize = properties == null || properties.getReferences() == null || properties.getReferences().isEmpty() ? 0 : properties.getReferences().size();
    int size = keyInfoRef == null ? propsRefsSize + 1 : propsRefsSize + 2;
    List<Reference> referenceList = new ArrayList<>(size);
    referenceList.add(ref);
    if (keyInfoRef != null) {
        referenceList.add(keyInfoRef);
    }
    if (properties != null && properties.getReferences() != null && !properties.getReferences().isEmpty()) {
        referenceList.addAll(properties.getReferences());
    }
    return referenceList;
}",java:S1452,23
"protected List<? extends XMLObject> getObjects(XmlSignatureProperties.Input input, XmlSignatureProperties.Output properties){
    if (SignatureType.enveloped == input.getSignatureType() || SignatureType.detached == input.getSignatureType()) {
        if (properties == null || properties.getObjects() == null) {
            return Collections.emptyList();
        }
        return properties.getObjects();
    }
    final String objectId = getConfiguration().getContentObjectId();
    LOG.debug(""Object Content Id {}"", objectId);
    XMLObject obj = createXMLObject(input.getSignatureFactory(), input.getMessageBodyNode(), objectId);
    if (properties == null || properties.getObjects() == null || properties.getObjects().isEmpty()) {
        return Collections.singletonList(obj);
    }
    List<XMLObject> result = new ArrayList<>(properties.getObjects().size() + 1);
    result.add(obj);
    result.addAll(properties.getObjects());
    return result;
}",java:S1452,23
"private List<String> getContentReferenceUrisForDetachedCase(Message message, Node messageBodyNode) throws XmlSignatureException, XPathExpressionException{
    List<XPathFilterParameterSpec> xpathsToIdAttributes = getXpathToIdAttributes(message);
    if (xpathsToIdAttributes.isEmpty()) {
        throw new IllegalStateException(""List of XPATHs to ID attributes is empty in detached signature case"");
    }
    List<ComparableNode> result = new ArrayList<>(xpathsToIdAttributes.size());
    for (XPathFilterParameterSpec xp : xpathsToIdAttributes) {
        XPathExpression exp;
        try {
            exp = XmlSignatureHelper.getXPathExpression(xp);
        } catch (XPathExpressionException e) {
            throw new XmlSignatureException(""The configured xpath expression "" + xp.getXPath() + "" is invalid."", e);
        }
        NodeList list = (NodeList) exp.evaluate(messageBodyNode, XPathConstants.NODESET);
        if (list == null) {
            LOG.warn(""No ID attribute found for xpath expression {}. Therfore this xpath expression will be ignored."", xp.getXPath());
            continue;
        }
        int length = list.getLength();
        for (int i = 0; i < length; i++) {
            Node node = list.item(i);
            if (node.getNodeType() == Node.ATTRIBUTE_NODE) {
                Attr attr = (Attr) node;
                String value = attr.getValue();
                Element element = messageBodyNode.getOwnerDocument().getElementById(value);
                if (element == null) {
                    throw new XmlSignatureException(""Wrong configured xpath expression for ID attributes: The evaluation of the xpath expression "" + xp.getXPath() + "" resulted in an attribute which is not of type ID. The attribute value is "" + value + ""."");
                }
                result.add(new ComparableNode(element, ""#"" + value));
                LOG.debug(""ID attribute with value {} found for xpath {}"", value, xp.getXPath());
            } else {
                throw new XmlSignatureException(""Wrong configured xpath expression for ID attributes: The evaluation of the xpath expression "" + xp.getXPath() + "" returned a node which was not of type Attribute."");
            }
        }
    }
    if (result.isEmpty()) {
        throw new XmlSignatureException(""No element to sign found in the detached case. No node found for the configured xpath expressions "" + toString(xpathsToIdAttributes) + "". Either the configuration of the XML signature component is wrong or the incoming message has not the correct structure."");
    }
    Collections.sort(result);
    return ComparableNode.getReferenceUris(result);
}",java:S3776,39
"private List<Transform> getTransforms(XMLSignatureFactory fac, SignatureType sigType, Message message) throws NoSuchAlgorithmException, InvalidAlgorithmParameterException{
    String transformMethodsHeaderValue = message.getHeader(XmlSignatureConstants.HEADER_TRANSFORM_METHODS, String.class);
    if (transformMethodsHeaderValue == null) {
        List<AlgorithmMethod> configuredTrafos = getConfiguration().getTransformMethods();
        if (SignatureType.enveloped == sigType) {
            if (!configuredTrafos.isEmpty()) {
                if (!containsEnvelopedTransform(configuredTrafos)) {
                    configuredTrafos = new ArrayList<>(configuredTrafos.size() + 1);
                    configuredTrafos.add(XmlSignatureHelper.getEnvelopedTransform());
                    configuredTrafos.addAll(getConfiguration().getTransformMethods());
                }
            } else {
                configuredTrafos = new ArrayList<>(2);
                configuredTrafos.add(XmlSignatureHelper.getEnvelopedTransform());
                configuredTrafos.add(XmlSignatureHelper.getCanonicalizationMethod(CanonicalizationMethod.INCLUSIVE));
            }
        }
        List<Transform> transforms = new ArrayList<>(configuredTrafos.size());
        for (AlgorithmMethod trafo : configuredTrafos) {
            Transform transform = fac.newTransform(trafo.getAlgorithm(), (TransformParameterSpec) trafo.getParameterSpec());
            transforms.add(transform);
            LOG.debug(""Transform method: {}"", trafo.getAlgorithm());
        }
        return transforms;
    } else {
        LOG.debug(""Header {} with value '{}' found"", XmlSignatureConstants.HEADER_TRANSFORM_METHODS, transformMethodsHeaderValue);
        String[] transformAlgorithms = transformMethodsHeaderValue.split("","");
        List<Transform> transforms = new ArrayList<>(transformAlgorithms.length);
        for (String transformAlgorithm : transformAlgorithms) {
            transformAlgorithm = transformAlgorithm.trim();
            Transform transform = fac.newTransform(transformAlgorithm, (TransformParameterSpec) null);
            transforms.add(transform);
            LOG.debug(""Transform method: {}"", transformAlgorithm);
        }
        return transforms;
    }
}",java:S3776,39
"private void updateAccessKey(IamClient iamClient, Exchange exchange) throws InvalidPayloadException{
    if (getConfiguration().isPojoRequest()) {
        Object payload = exchange.getIn().getMandatoryBody();
        if (payload instanceof UpdateAccessKeyRequest) {
            UpdateAccessKeyResponse result;
            try {
                result = iamClient.updateAccessKey((UpdateAccessKeyRequest) payload);
            } catch (AwsServiceException ase) {
                LOG.trace(""Update Access Key command returned the error code {}"", ase.awsErrorDetails().errorCode());
                throw ase;
            }
            Message message = getMessageForResponse(exchange);
            message.setBody(result);
        }
    } else {
        UpdateAccessKeyRequest.Builder builder = UpdateAccessKeyRequest.builder();
        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(IAM2Constants.ACCESS_KEY_ID))) {
            String accessKeyId = exchange.getIn().getHeader(IAM2Constants.ACCESS_KEY_ID, String.class);
            builder.accessKeyId(accessKeyId);
        } else {
            throw new IllegalArgumentException(""Key Id must be specified"");
        }
        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(IAM2Constants.ACCESS_KEY_STATUS))) {
            String status = exchange.getIn().getHeader(IAM2Constants.ACCESS_KEY_STATUS, String.class);
            builder.status(StatusType.fromValue(status));
        } else {
            throw new IllegalArgumentException(""Access Key status must be specified"");
        }
        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(IAM2Constants.USERNAME))) {
            String userName = exchange.getIn().getHeader(IAM2Constants.USERNAME, String.class);
            builder.userName(userName);
        }
        UpdateAccessKeyResponse result;
        try {
            result = iamClient.updateAccessKey(builder.build());
        } catch (AwsServiceException ase) {
            LOG.trace(""Update Access Key command returned the error code {}"", ase.awsErrorDetails().errorCode());
            throw ase;
        }
        Message message = getMessageForResponse(exchange);
        message.setBody(result);
    }
}",java:S3776,39
"public KinesisClient getClient(){
    return kinesisClient;
}",java:S2184,29
"private static double log(final double x, final double[] hiPrec){
    if (x == 0) {
        return Double.NEGATIVE_INFINITY;
    }
    long bits = Double.doubleToRawLongBits(x);
    if (((bits & 0x8000000000000000L) != 0 || Double.isNaN(x)) && x != 0.0) {
        if (hiPrec != null) {
            hiPrec[0] = Double.NaN;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (hiPrec != null) {
            hiPrec[0] = Double.POSITIVE_INFINITY;
        }
        return Double.POSITIVE_INFINITY;
    }
    int exp = (int) (bits >> 52) - 1023;
    if ((bits & 0x7ff0000000000000L) == 0) {
        if (x == 0) {
            if (hiPrec != null) {
                hiPrec[0] = Double.NEGATIVE_INFINITY;
            }
            return Double.NEGATIVE_INFINITY;
        }
        bits <<= 1;
        while ((bits & 0x0010000000000000L) == 0) {
            --exp;
            bits <<= 1;
        }
    }
    if ((exp == -1 || exp == 0) && x < 1.01 && x > 0.99 && hiPrec == null) {
        double xa = x - 1.0;
        double xb = xa - x + 1.0;
        double tmp = xa * HEX_40000000;
        double aa = xa + tmp - tmp;
        double ab = xa - aa;
        xa = aa;
        xb = ab;
        final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];
        double ya = lnCoef_last[0];
        double yb = lnCoef_last[1];
        for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {
            aa = ya * xa;
            ab = ya * xb + yb * xa + yb * xb;
            tmp = aa * HEX_40000000;
            ya = aa + tmp - tmp;
            yb = aa - ya + ab;
            final double[] lnCoef_i = LN_QUICK_COEF[i];
            aa = ya + lnCoef_i[0];
            ab = yb + lnCoef_i[1];
            tmp = aa * HEX_40000000;
            ya = aa + tmp - tmp;
            yb = aa - ya + ab;
        }
        aa = ya * xa;
        ab = ya * xb + yb * xa + yb * xb;
        tmp = aa * HEX_40000000;
        ya = aa + tmp - tmp;
        yb = aa - ya + ab;
        return ya + yb;
    }
    final double[] lnm = lnMant.LN_MANT[(int) ((bits & 0x000ffc0000000000L) >> 42)];
    final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));
    double lnza = 0.0;
    double lnzb = 0.0;
    if (hiPrec != null) {
        double tmp = epsilon * HEX_40000000;
        double aa = epsilon + tmp - tmp;
        double ab = epsilon - aa;
        double xa = aa;
        double xb = ab;
        final double numer = bits & 0x3ffffffffffL;
        final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);
        aa = numer - xa * denom - xb * denom;
        xb += aa / denom;
        final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1];
        double ya = lnCoef_last[0];
        double yb = lnCoef_last[1];
        for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {
            aa = ya * xa;
            ab = ya * xb + yb * xa + yb * xb;
            tmp = aa * HEX_40000000;
            ya = aa + tmp - tmp;
            yb = aa - ya + ab;
            final double[] lnCoef_i = LN_HI_PREC_COEF[i];
            aa = ya + lnCoef_i[0];
            ab = yb + lnCoef_i[1];
            tmp = aa * HEX_40000000;
            ya = aa + tmp - tmp;
            yb = aa - ya + ab;
        }
        aa = ya * xa;
        ab = ya * xb + yb * xa + yb * xb;
        lnza = aa + ab;
        lnzb = -(lnza - aa - ab);
    } else {
        lnza = -0.16624882440418567;
        lnza = lnza * epsilon + 0.19999954120254515;
        lnza = lnza * epsilon + -0.2499999997677497;
        lnza = lnza * epsilon + 0.3333333333332802;
        lnza = lnza * epsilon + -0.5;
        lnza = lnza * epsilon + 1.0;
        lnza *= epsilon;
    }
    double a = LN_2_A * exp;
    double b = 0.0;
    double c = a + lnm[0];
    double d = -(c - a - lnm[0]);
    a = c;
    b += d;
    c = a + lnza;
    d = -(c - a - lnza);
    a = c;
    b += d;
    c = a + LN_2_B * exp;
    d = -(c - a - LN_2_B * exp);
    a = c;
    b += d;
    c = a + lnm[1];
    d = -(c - a - lnm[1]);
    a = c;
    b += d;
    c = a + lnzb;
    d = -(c - a - lnzb);
    a = c;
    b += d;
    if (hiPrec != null) {
        hiPrec[0] = a;
        hiPrec[1] = b;
    }
    return a + b;
}",java:S3776,39
"private static double log(final double x, final double[] hiPrec){
    if (x == 0) {
        return Double.NEGATIVE_INFINITY;
    }
    long bits = Double.doubleToRawLongBits(x);
    if (((bits & 0x8000000000000000L) != 0 || Double.isNaN(x)) && x != 0.0) {
        if (hiPrec != null) {
            hiPrec[0] = Double.NaN;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (hiPrec != null) {
            hiPrec[0] = Double.POSITIVE_INFINITY;
        }
        return Double.POSITIVE_INFINITY;
    }
    int exp = (int) (bits >> 52) - 1023;
    if ((bits & 0x7ff0000000000000L) == 0) {
        if (x == 0) {
            if (hiPrec != null) {
                hiPrec[0] = Double.NEGATIVE_INFINITY;
            }
            return Double.NEGATIVE_INFINITY;
        }
        bits <<= 1;
        while ((bits & 0x0010000000000000L) == 0) {
            --exp;
            bits <<= 1;
        }
    }
    if ((exp == -1 || exp == 0) && x < 1.01 && x > 0.99 && hiPrec == null) {
        double xa = x - 1.0;
        double xb = xa - x + 1.0;
        double tmp = xa * HEX_40000000;
        double aa = xa + tmp - tmp;
        double ab = xa - aa;
        xa = aa;
        xb = ab;
        final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];
        double ya = lnCoef_last[0];
        double yb = lnCoef_last[1];
        for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {
            aa = ya * xa;
            ab = ya * xb + yb * xa + yb * xb;
            tmp = aa * HEX_40000000;
            ya = aa + tmp - tmp;
            yb = aa - ya + ab;
            final double[] lnCoef_i = LN_QUICK_COEF[i];
            aa = ya + lnCoef_i[0];
            ab = yb + lnCoef_i[1];
            tmp = aa * HEX_40000000;
            ya = aa + tmp - tmp;
            yb = aa - ya + ab;
        }
        aa = ya * xa;
        ab = ya * xb + yb * xa + yb * xb;
        tmp = aa * HEX_40000000;
        ya = aa + tmp - tmp;
        yb = aa - ya + ab;
        return ya + yb;
    }
    final double[] lnm = lnMant.LN_MANT[(int) ((bits & 0x000ffc0000000000L) >> 42)];
    final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));
    double lnza = 0.0;
    double lnzb = 0.0;
    if (hiPrec != null) {
        double tmp = epsilon * HEX_40000000;
        double aa = epsilon + tmp - tmp;
        double ab = epsilon - aa;
        double xa = aa;
        double xb = ab;
        final double numer = bits & 0x3ffffffffffL;
        final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);
        aa = numer - xa * denom - xb * denom;
        xb += aa / denom;
        final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1];
        double ya = lnCoef_last[0];
        double yb = lnCoef_last[1];
        for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {
            aa = ya * xa;
            ab = ya * xb + yb * xa + yb * xb;
            tmp = aa * HEX_40000000;
            ya = aa + tmp - tmp;
            yb = aa - ya + ab;
            final double[] lnCoef_i = LN_HI_PREC_COEF[i];
            aa = ya + lnCoef_i[0];
            ab = yb + lnCoef_i[1];
            tmp = aa * HEX_40000000;
            ya = aa + tmp - tmp;
            yb = aa - ya + ab;
        }
        aa = ya * xa;
        ab = ya * xb + yb * xa + yb * xb;
        lnza = aa + ab;
        lnzb = -(lnza - aa - ab);
    } else {
        lnza = -0.16624882440418567;
        lnza = lnza * epsilon + 0.19999954120254515;
        lnza = lnza * epsilon + -0.2499999997677497;
        lnza = lnza * epsilon + 0.3333333333332802;
        lnza = lnza * epsilon + -0.5;
        lnza = lnza * epsilon + 1.0;
        lnza *= epsilon;
    }
    double a = LN_2_A * exp;
    double b = 0.0;
    double c = a + lnm[0];
    double d = -(c - a - lnm[0]);
    a = c;
    b += d;
    c = a + lnza;
    d = -(c - a - lnza);
    a = c;
    b += d;
    c = a + LN_2_B * exp;
    d = -(c - a - LN_2_B * exp);
    a = c;
    b += d;
    c = a + lnm[1];
    d = -(c - a - lnm[1]);
    a = c;
    b += d;
    c = a + lnzb;
    d = -(c - a - lnzb);
    a = c;
    b += d;
    if (hiPrec != null) {
        hiPrec[0] = a;
        hiPrec[1] = b;
    }
    return a + b;
}",java:S6541,49
"public static double pow(final double x, final double y){
    if (y == 0) {
        return 1.0;
    } else {
        final long yBits = Double.doubleToRawLongBits(y);
        final int yRawExp = (int) ((yBits & MASK_DOUBLE_EXPONENT) >> 52);
        final long yRawMantissa = yBits & MASK_DOUBLE_MANTISSA;
        final long xBits = Double.doubleToRawLongBits(x);
        final int xRawExp = (int) ((xBits & MASK_DOUBLE_EXPONENT) >> 52);
        final long xRawMantissa = xBits & MASK_DOUBLE_MANTISSA;
        if (yRawExp > 1085) {
            if ((yRawExp == 2047 && yRawMantissa != 0) || (xRawExp == 2047 && xRawMantissa != 0)) {
                return Double.NaN;
            } else if (xRawExp == 1023 && xRawMantissa == 0) {
                if (yRawExp == 2047) {
                    return Double.NaN;
                } else {
                    return 1.0;
                }
            } else {
                if ((y > 0) ^ (xRawExp < 1023)) {
                    return Double.POSITIVE_INFINITY;
                } else {
                    return +0.0;
                }
            }
        } else {
            if (yRawExp >= 1023) {
                final long yFullMantissa = IMPLICIT_HIGH_BIT | yRawMantissa;
                if (yRawExp < 1075) {
                    final long integralMask = (-1L) << (1075 - yRawExp);
                    if ((yFullMantissa & integralMask) == yFullMantissa) {
                        final long l = yFullMantissa >> (1075 - yRawExp);
                        return AccurateMath.pow(x, (y < 0) ? -l : l);
                    }
                } else {
                    final long l = yFullMantissa << (yRawExp - 1075);
                    return AccurateMath.pow(x, (y < 0) ? -l : l);
                }
            }
            if (x == 0) {
                return y < 0 ? Double.POSITIVE_INFINITY : +0.0;
            } else if (xRawExp == 2047) {
                if (xRawMantissa == 0) {
                    return (y < 0) ? +0.0 : Double.POSITIVE_INFINITY;
                } else {
                    return Double.NaN;
                }
            } else if (x < 0) {
                return Double.NaN;
            } else {
                final double tmp = y * HEX_40000000;
                final double ya = (y + tmp) - tmp;
                final double yb = y - ya;
                final double[] lns = new double[2];
                final double lores = log(x, lns);
                if (Double.isInfinite(lores)) {
                    return lores;
                }
                double lna = lns[0];
                double lnb = lns[1];
                final double tmp1 = lna * HEX_40000000;
                final double tmp2 = (lna + tmp1) - tmp1;
                lnb += lna - tmp2;
                lna = tmp2;
                final double aa = lna * ya;
                final double ab = lna * yb + lnb * ya + lnb * yb;
                lna = aa + ab;
                lnb = -(lna - aa - ab);
                double z = 1.0 / 120.0;
                z = z * lnb + (1.0 / 24.0);
                z = z * lnb + (1.0 / 6.0);
                z = z * lnb + 0.5;
                z = z * lnb + 1.0;
                z *= lnb;
                final double result = exp(lna, z, null);
                return result;
            }
        }
    }
}",java:S3776,39
"public static double pow(final double x, final double y){
    if (y == 0) {
        return 1.0;
    } else {
        final long yBits = Double.doubleToRawLongBits(y);
        final int yRawExp = (int) ((yBits & MASK_DOUBLE_EXPONENT) >> 52);
        final long yRawMantissa = yBits & MASK_DOUBLE_MANTISSA;
        final long xBits = Double.doubleToRawLongBits(x);
        final int xRawExp = (int) ((xBits & MASK_DOUBLE_EXPONENT) >> 52);
        final long xRawMantissa = xBits & MASK_DOUBLE_MANTISSA;
        if (yRawExp > 1085) {
            if ((yRawExp == 2047 && yRawMantissa != 0) || (xRawExp == 2047 && xRawMantissa != 0)) {
                return Double.NaN;
            } else if (xRawExp == 1023 && xRawMantissa == 0) {
                if (yRawExp == 2047) {
                    return Double.NaN;
                } else {
                    return 1.0;
                }
            } else {
                if ((y > 0) ^ (xRawExp < 1023)) {
                    return Double.POSITIVE_INFINITY;
                } else {
                    return +0.0;
                }
            }
        } else {
            if (yRawExp >= 1023) {
                final long yFullMantissa = IMPLICIT_HIGH_BIT | yRawMantissa;
                if (yRawExp < 1075) {
                    final long integralMask = (-1L) << (1075 - yRawExp);
                    if ((yFullMantissa & integralMask) == yFullMantissa) {
                        final long l = yFullMantissa >> (1075 - yRawExp);
                        return AccurateMath.pow(x, (y < 0) ? -l : l);
                    }
                } else {
                    final long l = yFullMantissa << (yRawExp - 1075);
                    return AccurateMath.pow(x, (y < 0) ? -l : l);
                }
            }
            if (x == 0) {
                return y < 0 ? Double.POSITIVE_INFINITY : +0.0;
            } else if (xRawExp == 2047) {
                if (xRawMantissa == 0) {
                    return (y < 0) ? +0.0 : Double.POSITIVE_INFINITY;
                } else {
                    return Double.NaN;
                }
            } else if (x < 0) {
                return Double.NaN;
            } else {
                final double tmp = y * HEX_40000000;
                final double ya = (y + tmp) - tmp;
                final double yb = y - ya;
                final double[] lns = new double[2];
                final double lores = log(x, lns);
                if (Double.isInfinite(lores)) {
                    return lores;
                }
                double lna = lns[0];
                double lnb = lns[1];
                final double tmp1 = lna * HEX_40000000;
                final double tmp2 = (lna + tmp1) - tmp1;
                lnb += lna - tmp2;
                lna = tmp2;
                final double aa = lna * ya;
                final double ab = lna * yb + lnb * ya + lnb * yb;
                lna = aa + ab;
                lnb = -(lna - aa - ab);
                double z = 1.0 / 120.0;
                z = z * lnb + (1.0 / 24.0);
                z = z * lnb + (1.0 / 6.0);
                z = z * lnb + 0.5;
                z = z * lnb + 1.0;
                z *= lnb;
                final double result = exp(lna, z, null);
                return result;
            }
        }
    }
}",java:S6541,49
"public static double cosh(double x){
    if (Double.isNaN(x)) {
        return x;
    }
    if (x > 20) {
        if (x >= LOG_MAX_VALUE) {
            final double t = exp(0.5 * x);
            return (0.5 * t) * t;
        } else {
            return 0.5 * exp(x);
        }
    } else if (x < -20) {
        if (x <= -LOG_MAX_VALUE) {
            final double t = exp(-0.5 * x);
            return (0.5 * t) * t;
        } else {
            return 0.5 * exp(-x);
        }
    }
    final double[] hiPrec = new double[2];
    if (x < 0.0) {
        x = -x;
    }
    exp(x, 0.0, hiPrec);
    double ya = hiPrec[0] + hiPrec[1];
    double yb = -(ya - hiPrec[0] - hiPrec[1]);
    double temp = ya * HEX_40000000;
    double yaa = ya + temp - temp;
    double yab = ya - yaa;
    double recip = 1.0 / ya;
    temp = recip * HEX_40000000;
    double recipa = recip + temp - temp;
    double recipb = recip - recipa;
    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
    recipb += -yb * recip * recip;
    temp = ya + recipa;
    yb += -(temp - ya - recipa);
    ya = temp;
    temp = ya + recipb;
    yb += -(temp - ya - recipb);
    ya = temp;
    double result = ya + yb;
    result *= 0.5;
    return result;
}",java:S3776,39
"private static double exp(double x, double extra, double[] hiPrec){
    double intPartA;
    double intPartB;
    int intVal = (int) x;
    if (x < 0.0) {
        if (x < -746d) {
            if (hiPrec != null) {
                hiPrec[0] = 0.0;
                hiPrec[1] = 0.0;
            }
            return 0.0;
        }
        if (intVal < -709) {
            final double result = exp(x + 40.19140625, extra, hiPrec) / 285040095144011776.0;
            if (hiPrec != null) {
                hiPrec[0] /= 285040095144011776.0;
                hiPrec[1] /= 285040095144011776.0;
            }
            return result;
        }
        if (intVal == -709) {
            final double result = exp(x + 1.494140625, extra, hiPrec) / 4.455505956692756620;
            if (hiPrec != null) {
                hiPrec[0] /= 4.455505956692756620;
                hiPrec[1] /= 4.455505956692756620;
            }
            return result;
        }
        intVal--;
    } else {
        if (intVal > 709) {
            if (hiPrec != null) {
                hiPrec[0] = Double.POSITIVE_INFINITY;
                hiPrec[1] = 0.0;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX + intVal];
    intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX + intVal];
    final int intFrac = (int) ((x - intVal) * 1024.0);
    final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];
    final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];
    final double epsilon = x - (intVal + intFrac / 1024.0);
    double z = 0.04168701738764507;
    z = z * epsilon + 0.1666666505023083;
    z = z * epsilon + 0.5000000000042687;
    z = z * epsilon + 1.0;
    z = z * epsilon + -3.940510424527919E-20;
    double tempA = intPartA * fracPartA;
    double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;
    final double tempC = tempB + tempA;
    if (tempC == Double.POSITIVE_INFINITY) {
        return Double.POSITIVE_INFINITY;
    }
    final double result;
    if (extra != 0.0) {
        result = tempC * extra * z + tempC * extra + tempC * z + tempB + tempA;
    } else {
        result = tempC * z + tempB + tempA;
    }
    if (hiPrec != null) {
        hiPrec[0] = tempA;
        hiPrec[1] = tempC * extra * z + tempC * extra + tempC * z + tempB;
    }
    return result;
}",java:S3776,39
"private static void reducePayneHanek(double x, double[] result){
    long inbits = Double.doubleToRawLongBits(x);
    int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;
    inbits &= 0x000fffffffffffffL;
    inbits |= 0x0010000000000000L;
    exponent++;
    inbits <<= 11;
    long shpi0;
    long shpiA;
    long shpiB;
    int idx = exponent >> 6;
    int shift = exponent - (idx << 6);
    if (shift != 0) {
        shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx - 1] << shift);
        shpi0 |= RECIP_2PI[idx] >>> (64 - shift);
        shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx + 1] >>> (64 - shift));
        shpiB = (RECIP_2PI[idx + 1] << shift) | (RECIP_2PI[idx + 2] >>> (64 - shift));
    } else {
        shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx - 1];
        shpiA = RECIP_2PI[idx];
        shpiB = RECIP_2PI[idx + 1];
    }
    long a = inbits >>> 32;
    long b = inbits & 0xffffffffL;
    long c = shpiA >>> 32;
    long d = shpiA & 0xffffffffL;
    long ac = a * c;
    long bd = b * d;
    long bc = b * c;
    long ad = a * d;
    long prodB = bd + (ad << 32);
    long prodA = ac + (ad >>> 32);
    boolean bita = (bd & 0x8000000000000000L) != 0;
    boolean bitb = (ad & 0x80000000L) != 0;
    boolean bitsum = (prodB & 0x8000000000000000L) != 0;
    if ((bita && bitb) || ((bita || bitb) && !bitsum)) {
        prodA++;
    }
    bita = (prodB & 0x8000000000000000L) != 0;
    bitb = (bc & 0x80000000L) != 0;
    prodB += bc << 32;
    prodA += bc >>> 32;
    bitsum = (prodB & 0x8000000000000000L) != 0;
    if ((bita && bitb) || ((bita || bitb) && !bitsum)) {
        prodA++;
    }
    c = shpiB >>> 32;
    d = shpiB & 0xffffffffL;
    ac = a * c;
    bc = b * c;
    ad = a * d;
    ac += (bc + ad) >>> 32;
    bita = (prodB & 0x8000000000000000L) != 0;
    bitb = (ac & 0x8000000000000000L) != 0;
    prodB += ac;
    bitsum = (prodB & 0x8000000000000000L) != 0;
    if ((bita && bitb) || ((bita || bitb) && !bitsum)) {
        prodA++;
    }
    c = shpi0 >>> 32;
    d = shpi0 & 0xffffffffL;
    bd = b * d;
    bc = b * c;
    ad = a * d;
    prodA += bd + ((bc + ad) << 32);
    int intPart = (int) (prodA >>> 62);
    prodA <<= 2;
    prodA |= prodB >>> 62;
    prodB <<= 2;
    a = prodA >>> 32;
    b = prodA & 0xffffffffL;
    c = PI_O_4_BITS[0] >>> 32;
    d = PI_O_4_BITS[0] & 0xffffffffL;
    ac = a * c;
    bd = b * d;
    bc = b * c;
    ad = a * d;
    long prod2B = bd + (ad << 32);
    long prod2A = ac + (ad >>> 32);
    bita = (bd & 0x8000000000000000L) != 0;
    bitb = (ad & 0x80000000L) != 0;
    bitsum = (prod2B & 0x8000000000000000L) != 0;
    if ((bita && bitb) || ((bita || bitb) && !bitsum)) {
        prod2A++;
    }
    bita = (prod2B & 0x8000000000000000L) != 0;
    bitb = (bc & 0x80000000L) != 0;
    prod2B += bc << 32;
    prod2A += bc >>> 32;
    bitsum = (prod2B & 0x8000000000000000L) != 0;
    if ((bita && bitb) || ((bita || bitb) && !bitsum)) {
        prod2A++;
    }
    c = PI_O_4_BITS[1] >>> 32;
    d = PI_O_4_BITS[1] & 0xffffffffL;
    ac = a * c;
    bc = b * c;
    ad = a * d;
    ac += (bc + ad) >>> 32;
    bita = (prod2B & 0x8000000000000000L) != 0;
    bitb = (ac & 0x8000000000000000L) != 0;
    prod2B += ac;
    bitsum = (prod2B & 0x8000000000000000L) != 0;
    if ((bita && bitb) || ((bita || bitb) && !bitsum)) {
        prod2A++;
    }
    a = prodB >>> 32;
    b = prodB & 0xffffffffL;
    c = PI_O_4_BITS[0] >>> 32;
    d = PI_O_4_BITS[0] & 0xffffffffL;
    ac = a * c;
    bc = b * c;
    ad = a * d;
    ac += (bc + ad) >>> 32;
    bita = (prod2B & 0x8000000000000000L) != 0;
    bitb = (ac & 0x8000000000000000L) != 0;
    prod2B += ac;
    bitsum = (prod2B & 0x8000000000000000L) != 0;
    if ((bita && bitb) || ((bita || bitb) && !bitsum)) {
        prod2A++;
    }
    double tmpA = (prod2A >>> 12) / TWO_POWER_52;
    double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52;
    double sumA = tmpA + tmpB;
    double sumB = -(sumA - tmpA - tmpB);
    result[0] = intPart;
    result[1] = sumA * 2.0;
    result[2] = sumB * 2.0;
}",java:S3776,39
"public static double atan2(double y, double x){
    if (Double.isNaN(x) || Double.isNaN(y)) {
        return Double.NaN;
    }
    if (y == 0) {
        final double invx = 1d / x;
        if (invx == 0) {
            if (x > 0) {
                return y;
            }
            return copySign(Math.PI, y);
        }
        if (x < 0 || invx < 0) {
            return copySign(Math.PI, y);
        }
        return x * y;
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI * F_1_4;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * F_3_4;
        }
        return Math.PI * F_1_2;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI * F_1_4;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * F_3_4;
        }
        return -Math.PI * F_1_2;
    }
    if (x == Double.POSITIVE_INFINITY) {
        return y > 0 ? 0d : -0d;
    }
    if (x == Double.NEGATIVE_INFINITY) {
        return y > 0 ? Math.PI : -Math.PI;
    }
    if (x == 0) {
        return y > 0 ? Math.PI * F_1_2 : -Math.PI * F_1_2;
    }
    final double r = y / x;
    if (Double.isInfinite(r)) {
        return atan(r, 0, x < 0);
    }
    double ra = doubleHighPart(r);
    double rb = r - ra;
    final double xa = doubleHighPart(x);
    final double xb = x - xa;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    final double temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    if (ra == 0) {
        ra = copySign(0d, y);
    }
    return atan(ra, rb, x < 0);
}",java:S3776,39
"public static double scalb(final double d, final int n){
    if ((n > -1023) && (n < 1024)) {
        return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);
    }
    if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {
        return d;
    }
    if (n < -2098) {
        return (d > 0) ? 0.0 : -0.0;
    }
    if (n > 2097) {
        return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;
    }
    final long bits = Double.doubleToRawLongBits(d);
    final long sign = bits & 0x8000000000000000L;
    int exponent = ((int) (bits >>> 52)) & 0x7ff;
    long mantissa = bits & 0x000fffffffffffffL;
    int scaledExponent = exponent + n;
    if (n < 0) {
        if (scaledExponent > 0) {
            return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);
        } else if (scaledExponent > -53) {
            mantissa |= 1L << 52;
            final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));
            mantissa >>>= 1 - scaledExponent;
            if (mostSignificantLostBit != 0) {
                mantissa++;
            }
            return Double.longBitsToDouble(sign | mantissa);
        } else {
            return (sign == 0L) ? 0.0 : -0.0;
        }
    } else {
        if (exponent == 0) {
            while ((mantissa >>> 52) != 1) {
                mantissa <<= 1;
                --scaledExponent;
            }
            ++scaledExponent;
            mantissa &= 0x000fffffffffffffL;
            if (scaledExponent < 2047) {
                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);
            } else {
                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;
            }
        } else if (scaledExponent < 2047) {
            return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);
        } else {
            return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;
        }
    }
}",java:S3776,39
"public static float scalb(final float f, final int n){
    if ((n > -127) && (n < 128)) {
        return f * Float.intBitsToFloat((n + 127) << 23);
    }
    if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {
        return f;
    }
    if (n < -277) {
        return (f > 0) ? 0.0f : -0.0f;
    }
    if (n > 276) {
        return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;
    }
    final int bits = Float.floatToIntBits(f);
    final int sign = bits & 0x80000000;
    int exponent = (bits >>> 23) & 0xff;
    int mantissa = bits & 0x007fffff;
    int scaledExponent = exponent + n;
    if (n < 0) {
        if (scaledExponent > 0) {
            return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);
        } else if (scaledExponent > -24) {
            mantissa |= 1 << 23;
            final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));
            mantissa >>>= 1 - scaledExponent;
            if (mostSignificantLostBit != 0) {
                mantissa++;
            }
            return Float.intBitsToFloat(sign | mantissa);
        } else {
            return (sign == 0) ? 0.0f : -0.0f;
        }
    } else {
        if (exponent == 0) {
            while ((mantissa >>> 23) != 1) {
                mantissa <<= 1;
                --scaledExponent;
            }
            ++scaledExponent;
            mantissa &= 0x007fffff;
            if (scaledExponent < 255) {
                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);
            } else {
                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;
            }
        } else if (scaledExponent < 255) {
            return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);
        } else {
            return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;
        }
    }
}",java:S3776,39
"public static double IEEEremainder(final double dividend, final double divisor){
    if (getExponent(dividend) == 1024 || getExponent(divisor) == 1024 || divisor == 0.0) {
        if (Double.isInfinite(divisor) && !Double.isInfinite(dividend)) {
            return dividend;
        } else {
            return Double.NaN;
        }
    } else {
        final double n = AccurateMath.rint(dividend / divisor);
        final double remainder = Double.isInfinite(n) ? 0.0 : dividend - divisor * n;
        return (remainder == 0) ? AccurateMath.copySign(remainder, dividend) : remainder;
    }
}",java:S100,0
"public static double cosh(double x){
    if (Double.isNaN(x)) {
        return x;
    }
    if (x > 20) {
        if (x >= LOG_MAX_VALUE) {
            final double t = exp(0.5 * x);
            return (0.5 * t) * t;
        } else {
            return 0.5 * exp(x);
        }
    } else if (x < -20) {
        if (x <= -LOG_MAX_VALUE) {
            final double t = exp(-0.5 * x);
            return (0.5 * t) * t;
        } else {
            return 0.5 * exp(-x);
        }
    }
    final double[] hiPrec = new double[2];
    if (x < 0.0) {
        x = -x;
    }
    exp(x, 0.0, hiPrec);
    double ya = hiPrec[0] + hiPrec[1];
    double yb = -(ya - hiPrec[0] - hiPrec[1]);
    double temp = ya * HEX_40000000;
    double yaa = ya + temp - temp;
    double yab = ya - yaa;
    double recip = 1.0 / ya;
    temp = recip * HEX_40000000;
    double recipa = recip + temp - temp;
    double recipb = recip - recipa;
    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
    recipb += -yb * recip * recip;
    temp = ya + recipa;
    yb += -(temp - ya - recipa);
    ya = temp;
    temp = ya + recipb;
    yb += -(temp - ya - recipb);
    ya = temp;
    double result = ya + yb;
    result *= 0.5;
    return result;
}",java:S107,1
"public static double sinh(double x){
    boolean negate = false;
    if (Double.isNaN(x)) {
        return x;
    }
    if (x > 20) {
        if (x >= LOG_MAX_VALUE) {
            final double t = exp(0.5 * x);
            return (0.5 * t) * t;
        } else {
            return 0.5 * exp(x);
        }
    } else if (x < -20) {
        if (x <= -LOG_MAX_VALUE) {
            final double t = exp(-0.5 * x);
            return (-0.5 * t) * t;
        } else {
            return -0.5 * exp(-x);
        }
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x > 0.25) {
        double[] hiPrec = new double[2];
        exp(x, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double temp = ya * HEX_40000000;
        double yaa = ya + temp - temp;
        double yab = ya - yaa;
        double recip = 1.0 / ya;
        temp = recip * HEX_40000000;
        double recipa = recip + temp - temp;
        double recipb = recip - recipa;
        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
        recipb += -yb * recip * recip;
        recipa = -recipa;
        recipb = -recipb;
        temp = ya + recipa;
        yb += -(temp - ya - recipa);
        ya = temp;
        temp = ya + recipb;
        yb += -(temp - ya - recipb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    } else {
        double[] hiPrec = new double[2];
        expm1(x, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double denom = 1.0 + ya;
        double denomr = 1.0 / denom;
        double denomb = -(denom - 1.0 - ya) + yb;
        double ratio = ya * denomr;
        double temp = ratio * HEX_40000000;
        double ra = ratio + temp - temp;
        double rb = ratio - ra;
        temp = denom * HEX_40000000;
        double za = denom + temp - temp;
        double zb = denom - za;
        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;
        rb += yb * denomr;
        rb += -ya * denomb * denomr * denomr;
        temp = ya + ra;
        yb += -(temp - ya - ra);
        ya = temp;
        temp = ya + rb;
        yb += -(temp - ya - rb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    }
    if (negate) {
        result = -result;
    }
    return result;
}",java:S3415,36
"public static double asinh(double a){
    boolean negative = false;
    if (a < 0) {
        negative = true;
        a = -a;
    }
    double absAsinh;
    if (a > 0.167) {
        absAsinh = AccurateMath.log(Math.sqrt(a * a + 1) + a);
    } else {
        final double a2 = a * a;
        if (a > 0.097) {
            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);
        } else if (a > 0.036) {
            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);
        } else if (a > 0.0036) {
            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);
        } else {
            absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);
        }
    }
    return negative ? -absAsinh : absAsinh;
}",java:S5778,45
"public static double sinh(double x){
    boolean negate = false;
    if (Double.isNaN(x)) {
        return x;
    }
    if (x > 20) {
        if (x >= LOG_MAX_VALUE) {
            final double t = exp(0.5 * x);
            return (0.5 * t) * t;
        } else {
            return 0.5 * exp(x);
        }
    } else if (x < -20) {
        if (x <= -LOG_MAX_VALUE) {
            final double t = exp(-0.5 * x);
            return (-0.5 * t) * t;
        } else {
            return -0.5 * exp(-x);
        }
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x > 0.25) {
        double[] hiPrec = new double[2];
        exp(x, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double temp = ya * HEX_40000000;
        double yaa = ya + temp - temp;
        double yab = ya - yaa;
        double recip = 1.0 / ya;
        temp = recip * HEX_40000000;
        double recipa = recip + temp - temp;
        double recipb = recip - recipa;
        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
        recipb += -yb * recip * recip;
        recipa = -recipa;
        recipb = -recipb;
        temp = ya + recipa;
        yb += -(temp - ya - recipa);
        ya = temp;
        temp = ya + recipb;
        yb += -(temp - ya - recipb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    } else {
        double[] hiPrec = new double[2];
        expm1(x, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double denom = 1.0 + ya;
        double denomr = 1.0 / denom;
        double denomb = -(denom - 1.0 - ya) + yb;
        double ratio = ya * denomr;
        double temp = ratio * HEX_40000000;
        double ra = ratio + temp - temp;
        double rb = ratio - ra;
        temp = denom * HEX_40000000;
        double za = denom + temp - temp;
        double zb = denom - za;
        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;
        rb += yb * denomr;
        rb += -ya * denomb * denomr * denomr;
        temp = ya + ra;
        yb += -(temp - ya - ra);
        ya = temp;
        temp = ya + rb;
        yb += -(temp - ya - rb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    }
    if (negate) {
        result = -result;
    }
    return result;
}",java:S5783,46
"public static double sinh(double x){
    boolean negate = false;
    if (Double.isNaN(x)) {
        return x;
    }
    if (x > 20) {
        if (x >= LOG_MAX_VALUE) {
            final double t = exp(0.5 * x);
            return (0.5 * t) * t;
        } else {
            return 0.5 * exp(x);
        }
    } else if (x < -20) {
        if (x <= -LOG_MAX_VALUE) {
            final double t = exp(-0.5 * x);
            return (-0.5 * t) * t;
        } else {
            return -0.5 * exp(-x);
        }
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x > 0.25) {
        double[] hiPrec = new double[2];
        exp(x, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double temp = ya * HEX_40000000;
        double yaa = ya + temp - temp;
        double yab = ya - yaa;
        double recip = 1.0 / ya;
        temp = recip * HEX_40000000;
        double recipa = recip + temp - temp;
        double recipb = recip - recipa;
        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
        recipb += -yb * recip * recip;
        recipa = -recipa;
        recipb = -recipb;
        temp = ya + recipa;
        yb += -(temp - ya - recipa);
        ya = temp;
        temp = ya + recipb;
        yb += -(temp - ya - recipb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    } else {
        double[] hiPrec = new double[2];
        expm1(x, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double denom = 1.0 + ya;
        double denomr = 1.0 / denom;
        double denomb = -(denom - 1.0 - ya) + yb;
        double ratio = ya * denomr;
        double temp = ratio * HEX_40000000;
        double ra = ratio + temp - temp;
        double rb = ratio - ra;
        temp = denom * HEX_40000000;
        double za = denom + temp - temp;
        double zb = denom - za;
        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;
        rb += yb * denomr;
        rb += -ya * denomb * denomr * denomr;
        temp = ya + ra;
        yb += -(temp - ya - ra);
        ya = temp;
        temp = ya + rb;
        yb += -(temp - ya - rb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    }
    if (negate) {
        result = -result;
    }
    return result;
}",java:S5778,45
"private byte[] tryChangeMasterKey(String masterKeyName) throws IgniteCheckedException{
    byte[] digest;
    masterKeyChangeLock.writeLock().lock();
    try {
        String curName = getSpi().getMasterKeyName();
        try {
            getSpi().setMasterKeyName(masterKeyName);
            digest = getSpi().masterKeyDigest();
        } catch (Exception e) {
            throw new IgniteException(""Unable to set master key locally [masterKeyName="" + masterKeyName + ']', e);
        } finally {
            getSpi().setMasterKeyName(curName);
        }
    } finally {
        masterKeyChangeLock.writeLock().unlock();
    }
    return digest;
}",java:S1130,7
"private void verifyChecksum(short checksum) throws ClassNotFoundException, IOException{
    if (checksum != this.checksum)
        throw new ClassNotFoundException(""Optimized stream class checksum mismatch "" + ""(is same version of marshalled class present on all nodes?) "" + ""[expected="" + this.checksum + "", actual="" + checksum + "", cls="" + cls + ']');
}",java:S1130,7
"private long fromSegmentIndex(int segIdx, long pageIdx){
    long res = 0;
    res = (res << SEG_BITS) | (segIdx & SEG_MASK);
    res = (res << IDX_BITS) | (pageIdx & IDX_MASK);
    return res;
}",java:S3398,35
"private IgniteInternalFuture<AffinityInfo> affinityInfoFromNode(String cacheName, AffinityTopologyVersion topVer, ClusterNode n){
    IgniteInternalFuture<GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment>> fut = ctx.closure().callAsync(BROADCAST, affinityJob(cacheName, topVer), options(F.asList(n)).withFailoverDisabled().asSystemTask());
    return fut.chain(new CX1<IgniteInternalFuture<GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment>>, AffinityInfo>() {

        @Override
        public AffinityInfo applyx(IgniteInternalFuture<GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment>> fut) throws IgniteCheckedException {
            GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment> t = fut.get();
            AffinityFunction f = (AffinityFunction) unmarshall(ctx, n.id(), t.get1());
            AffinityKeyMapper m = (AffinityKeyMapper) unmarshall(ctx, n.id(), t.get2());
            assert m != null;
            f.reset();
            m.reset();
            CacheConfiguration ccfg = ctx.cache().cacheConfiguration(cacheName);
            return new AffinityInfo(f, m, t.get3(), ctx.cacheObjects().contextForCache(ccfg));
        }
    });
}",java:S3398,35
"private GridAffinityAssignment assignment(){
    return assignment;
}",java:S1874,25
" static Callable<GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment>> affinityJob(String cacheName, AffinityTopologyVersion topVer){
    return new AffinityJob(cacheName, topVer);
}",java:S1874,25
"private static GridAffinityMessage affinityMessage(GridKernalContext ctx, Object o) throws IgniteCheckedException{
    Class cls = o.getClass();
    GridDeployment dep = ctx.deploy().deploy(cls, cls.getClassLoader());
    if (dep == null)
        throw new IgniteDeploymentCheckedException(""Failed to deploy affinity object with class: "" + cls.getName());
    return new GridAffinityMessage(U.marshal(ctx, o), cls.getName(), dep.classLoaderId(), dep.deployMode(), dep.userVersion(), dep.participants());
}",java:S3398,35
"@Override
public GridTuple3<GridAffinityMessage, GridAffinityMessage, GridAffinityAssignment> call() throws Exception{
    assert ignite != null;
    assert log != null;
    IgniteKernal kernal = ((IgniteKernal) ignite);
    GridCacheContext<Object, Object> cctx = kernal.internalCache(cacheName).context();
    assert cctx != null;
    GridKernalContext ctx = kernal.context();
    cctx.affinity().affinityReadyFuture(topVer).get();
    AffinityAssignment assign0 = cctx.affinity().assignment(topVer);
    return F.t(affinityMessage(ctx, cctx.config().getAffinity()), affinityMessage(ctx, cctx.config().getAffinityMapper()), new GridAffinityAssignment(topVer, assign0.assignment(), assign0.idealAssignment()));
}",java:S1874,25
"private void processOperationLocal(UserManagementOperation op) throws IgniteCheckedException{
    assert op != null && op.user() != null : ""Invalid operation: "" + op;
    switch(op.type()) {
        case ADD:
            addUserLocal(op);
            break;
        case REMOVE:
            removeUserLocal(op);
            break;
        case UPDATE:
            updateUserLocal(op);
            break;
    }
}",java:S3398,35
"private void onFinishOperation(IgniteUuid opId, IgniteCheckedException err){
    try {
        UserAcceptedMessage msg = new UserAcceptedMessage(opId, err);
        ctx.discovery().sendCustomEvent(msg);
    } catch (IgniteCheckedException e) {
        if (!e.hasCause(IgniteFutureCancelledException.class))
            U.error(log, ""Unexpected exception on send UserAcceptedMessage."", e);
    }
}",java:S3398,35
"@Nullable
private static String password_bcrypt(String passwd){
    return BCrypt.hashpw(passwd, BCrypt.gensalt(bCryptGensaltLog2Rounds));
}",java:S100,0
"private void handleMessage(UUID nodeId, GridCacheMessage cacheMsg, byte plc){
    handleMessage(nodeId, cacheMsg, cacheMsg.cacheGroupMessage() ? grpHandlers : cacheHandlers, plc);
}",java:S3398,35
"public void addCacheHandler(int hndId, AffinityTopologyVersion startTopVer, Class<Msg> type, IgniteBiInClosure<UUID, ? super Msg> c){
    assert !type.isAssignableFrom(GridCacheGroupIdMessage.class) : type;
    addHandler(hndId, startTopVer, type, c, cacheHandlers);
}",java:S119,17
"public void addCacheHandler(Class<Msg> type, IgniteBiInClosure<UUID, ? super Msg> c){
    assert !type.isAssignableFrom(GridCacheGroupIdMessage.class) : type;
    addHandler(COMMON_MESSAGE_HANDLER_ID, NONE, type, c, cacheHandlers);
}",java:S119,17
"public IgniteBiInClosure<UUID, ? super Msg> cacheHandler(int hndId, Class<? extends GridCacheMessage> msgCls){
    RegularClassHandler clsHnd = cacheHandlers.clsHandlers.get(new ListenerKey(hndId, msgCls));
    return (clsHnd != null) ? clsHnd.hnd : null;
}",java:S119,17
"public void addCacheGroupHandler(int hndId, Class<Msg> type, IgniteBiInClosure<UUID, ? super Msg> c){
    assert !type.isAssignableFrom(GridCacheIdMessage.class) : type;
    addHandler(hndId, NONE, type, c, grpHandlers);
}",java:S119,17
"private void addHandler(int hndId, AffinityTopologyVersion startTopVer, Class<Msg> type, IgniteBiInClosure<UUID, ? super Msg> c, MessageHandlers msgHandlers){
    int msgIdx = messageIndex(type);
    if (msgIdx != -1) {
        Map<Integer, IndexedClassHandler> idxClsHandlers0 = msgHandlers.idxClsHandlers;
        IndexedClassHandler cacheClsHandlers = idxClsHandlers0.compute(hndId, (key, clsHandlers) -> {
            if (clsHandlers == null)
                clsHandlers = new IndexedClassHandler(startTopVer);
            if (clsHandlers.hndls[msgIdx] != null || !Objects.equals(clsHandlers.startTopVer, startTopVer))
                return null;
            clsHandlers.hndls[msgIdx] = c;
            return clsHandlers;
        });
        if (cacheClsHandlers == null)
            throw new IgniteException(""Duplicate cache message ID found [hndId="" + hndId + "", type="" + type + ']');
        return;
    } else {
        ListenerKey key = new ListenerKey(hndId, type);
        RegularClassHandler regHnd = new RegularClassHandler(startTopVer, (IgniteBiInClosure<UUID, GridCacheMessage>) c);
        if (msgHandlers.clsHandlers.putIfAbsent(key, regHnd) != null) {
            assert false : ""Handler for class already registered [hndId="" + hndId + "", cls="" + type + "", old="" + msgHandlers.clsHandlers.get(key) + "", new="" + c + ']';
        }
    }
    IgniteLogger log0 = log;
    if (log0 != null && log0.isTraceEnabled())
        log0.trace(""Registered cache communication handler [hndId="" + hndId + "", type="" + type + "", msgIdx="" + msgIdx + "", handler="" + c + ']');
}",java:S119,17
"private CacheEntryImplEx<K, V> wrapVersionedWithValue(){
    lockEntry();
    try {
        V val = this.val == null ? null : this.val.<V>value(cctx.cacheObjectContext(), false);
        return new CacheEntryImplEx<>(key.<K>value(cctx.cacheObjectContext(), false), val, ver);
    } finally {
        unlockEntry();
    }
}",java:S3398,35
"private void notifyOwnerChanged(final GridCacheEntryEx entry, final GridCacheMvccCandidate owner){
    assert entry != null;
    if (log.isDebugEnabled())
        log.debug(""Received owner changed callback ["" + entry.key() + "", owner="" + owner + ']');
    if (owner != null && (owner.local() || owner.nearLocal())) {
        Collection<GridCacheVersionedFuture<?>> futCol = verFuts.get(owner.version());
        if (futCol != null) {
            ArrayList<GridCacheVersionedFuture<?>> futColCp;
            synchronized (futCol) {
                futColCp = new ArrayList<>(futCol.size());
                futColCp.addAll(futCol);
            }
            for (GridCacheVersionedFuture<?> fut : futColCp) {
                if (!fut.isDone()) {
                    final GridCacheVersionedFuture<Boolean> mvccFut = (GridCacheVersionedFuture<Boolean>) fut;
                    if (mvccFut.onOwnerChanged(entry, owner))
                        return;
                }
            }
        }
    }
    if (log.isDebugEnabled())
        log.debug(""Lock future not found for owner change callback (will try transaction futures) [owner="" + owner + "", entry="" + entry + ']');
    if (cctx.tm().onOwnerChanged(entry, owner)) {
        if (log.isDebugEnabled())
            log.debug(""Found transaction for changed owner: "" + owner);
    } else if (log.isDebugEnabled())
        log.debug(""Failed to find transaction for changed owner: "" + owner);
    if (!finishFuts.isEmptyx()) {
        for (FinishLockFuture f : finishFuts) f.recheck(entry);
    }
}",java:S3398,35
"private void processEventInactive(DiscoveryEvent evt, DiscoCache cache){
    cctx.cache().localJoinCachesContext();
    if (log.isDebugEnabled())
        log.debug(""Ignore event, cluster is inactive: "" + evt);
}",java:S3398,35
"private void onDiscoveryEvent(DiscoveryEvent evt, DiscoCache cache){
    ClusterNode loc = cctx.localNode();
    assert evt.type() == EVT_NODE_JOINED || evt.type() == EVT_NODE_LEFT || evt.type() == EVT_NODE_FAILED || evt.type() == EVT_DISCOVERY_CUSTOM_EVT;
    final ClusterNode n = evt.eventNode();
    GridDhtPartitionExchangeId exchId = null;
    GridDhtPartitionsExchangeFuture exchFut = null;
    if (evt.type() != EVT_DISCOVERY_CUSTOM_EVT) {
        assert evt.type() != EVT_NODE_JOINED || n.isLocal() || n.order() > loc.order() : ""Node joined with smaller-than-local "" + ""order [newOrder="" + n.order() + "", locOrder="" + loc.order() + "", evt="" + evt + ']';
        exchId = exchangeId(n.id(), affinityTopologyVersion(evt), evt);
        ExchangeActions exchActs = null;
        boolean locJoin = evt.type() == EVT_NODE_JOINED && evt.eventNode().isLocal();
        if (locJoin) {
            LocalJoinCachesContext locJoinCtx = cctx.cache().localJoinCachesContext();
            if (locJoinCtx != null) {
                exchActs = new ExchangeActions();
                exchActs.localJoinContext(locJoinCtx);
            }
        }
        if (!n.isClient())
            exchActs = cctx.kernalContext().state().autoAdjustExchangeActions(exchActs);
        exchFut = exchangeFuture(exchId, evt, cache, exchActs, null);
    } else {
        DiscoveryCustomMessage customMsg = ((DiscoveryCustomEvent) evt).customMessage();
        if (customMsg instanceof ChangeGlobalStateMessage) {
            ChangeGlobalStateMessage stateChangeMsg = (ChangeGlobalStateMessage) customMsg;
            ExchangeActions exchActions = stateChangeMsg.exchangeActions();
            if (exchActions != null) {
                exchId = exchangeId(n.id(), affinityTopologyVersion(evt), evt);
                exchFut = exchangeFuture(exchId, evt, cache, exchActions, null);
                boolean baselineChanging;
                if (stateChangeMsg.forceChangeBaselineTopology())
                    baselineChanging = true;
                else {
                    DiscoveryDataClusterState state = cctx.kernalContext().state().clusterState();
                    assert state.transition() : state;
                    baselineChanging = exchActions.changedBaseline() || state.state() != ClusterState.INACTIVE && !state.previouslyActive() && state.previousBaselineTopology() == null;
                }
                exchFut.listen(f -> onClusterStateChangeFinish(f, exchActions, baselineChanging));
            }
        } else if (customMsg instanceof DynamicCacheChangeBatch) {
            DynamicCacheChangeBatch batch = (DynamicCacheChangeBatch) customMsg;
            ExchangeActions exchActions = batch.exchangeActions();
            if (exchActions != null) {
                exchId = exchangeId(n.id(), affinityTopologyVersion(evt), evt);
                exchFut = exchangeFuture(exchId, evt, cache, exchActions, null);
            }
        } else if (customMsg instanceof CacheAffinityChangeMessage) {
            CacheAffinityChangeMessage msg = (CacheAffinityChangeMessage) customMsg;
            if (msg.exchangeId() == null) {
                if (msg.exchangeNeeded()) {
                    exchId = exchangeId(n.id(), affinityTopologyVersion(evt), evt);
                    exchFut = exchangeFuture(exchId, evt, cache, null, msg);
                }
            } else if (msg.exchangeId().topologyVersion().topologyVersion() >= cctx.discovery().localJoinEvent().topologyVersion())
                exchangeFuture(msg.exchangeId(), null, null, null, null).onAffinityChangeMessage(evt.eventNode(), msg);
        } else if (customMsg instanceof DynamicCacheChangeFailureMessage) {
            DynamicCacheChangeFailureMessage msg = (DynamicCacheChangeFailureMessage) customMsg;
            if (msg.exchangeId().topologyVersion().topologyVersion() >= affinityTopologyVersion(cctx.discovery().localJoinEvent()).topologyVersion())
                exchangeFuture(msg.exchangeId(), null, null, null, null).onDynamicCacheChangeFail(evt.eventNode(), msg);
        } else if (customMsg instanceof SnapshotDiscoveryMessage && ((SnapshotDiscoveryMessage) customMsg).needExchange()) {
            exchId = exchangeId(n.id(), affinityTopologyVersion(evt), evt);
            exchFut = exchangeFuture(exchId, evt, null, null, null);
        } else if (customMsg instanceof WalStateAbstractMessage && ((WalStateAbstractMessage) customMsg).needExchange()) {
            exchId = exchangeId(n.id(), affinityTopologyVersion(evt), evt);
            exchFut = exchangeFuture(exchId, evt, null, null, null);
        } else {
            CachePartitionExchangeWorkerTask task = cctx.cache().exchangeTaskForCustomDiscoveryMessage(customMsg);
            if (task != null)
                exchWorker.addCustomTask(task);
        }
    }
    if (exchId != null) {
        if (log.isDebugEnabled())
            log.debug(""Discovery event (will start exchange): "" + exchId);
        exchFut.onEvent(exchId, evt, cache);
        Span span = cctx.kernalContext().tracing().create(EXCHANGE_FUTURE, evt.span());
        if (exchId != null) {
            GridDhtPartitionExchangeId exchIdf = exchId;
            span.addTag(SpanTags.tag(SpanTags.EVENT_NODE, SpanTags.ID), () -> evt.eventNode().id().toString());
            span.addTag(SpanTags.tag(SpanTags.EVENT_NODE, SpanTags.CONSISTENT_ID), () -> evt.eventNode().consistentId().toString());
            span.addTag(SpanTags.tag(SpanTags.EVENT, SpanTags.TYPE), () -> String.valueOf(evt.type()));
            span.addTag(SpanTags.tag(SpanTags.EXCHANGE, SpanTags.ID), () -> String.valueOf(exchIdf.toString()));
            span.addTag(SpanTags.tag(SpanTags.INITIAL, SpanTags.TOPOLOGY_VERSION, SpanTags.MAJOR), () -> String.valueOf(exchIdf.topologyVersion().topologyVersion()));
            span.addTag(SpanTags.tag(SpanTags.INITIAL, SpanTags.TOPOLOGY_VERSION, SpanTags.MINOR), () -> String.valueOf(exchIdf.topologyVersion().minorTopologyVersion()));
        }
        span.addTag(SpanTags.NODE_ID, () -> cctx.localNodeId().toString());
        span.addLog(() -> ""Created"");
        exchFut.span(span);
        addFuture(exchFut);
    } else {
        if (log.isDebugEnabled())
            log.debug(""Do not start exchange for discovery event: "" + evt);
    }
    notifyNodeFail(evt);
    if (evt.type() == EVT_NODE_LEFT || evt.type() == EVT_NODE_FAILED) {
        SecurityContext secCtx = remoteSecurityContext(cctx.kernalContext());
        exchWorker.addCustomTask(new SchemaNodeLeaveExchangeWorkerTask(secCtx, evt.eventNode()));
        exchWorker.addCustomTask(new WalStateNodeLeaveExchangeTask(secCtx, evt.eventNode()));
    }
}",java:S3398,35
"private GridCacheContext<?, ?> startCacheInRecoveryMode(DynamicCacheDescriptor desc) throws IgniteCheckedException{
    desc = enricher().enrich(desc, true);
    CacheConfiguration cfg = desc.cacheConfiguration();
    CacheObjectContext cacheObjCtx = ctx.cacheObjects().contextForCache(cfg);
    preparePageStore(desc, true);
    CacheGroupContext grpCtx;
    GridCacheContext cacheCtx;
    ctx.cache().context().database().checkpointReadLock();
    try {
        grpCtx = getOrCreateCacheGroupContext(desc, AffinityTopologyVersion.NONE, cacheObjCtx, true, cfg.getGroupName(), true);
        cacheCtx = createCacheContext(cfg, grpCtx, null, desc, AffinityTopologyVersion.NONE, cacheObjCtx, true, true, false, true);
        initCacheContext(cacheCtx, cfg);
    } finally {
        ctx.cache().context().database().checkpointReadUnlock();
    }
    cacheCtx.onStarted();
    String dataRegion = cfg.getDataRegionName();
    if (dataRegion == null && ctx.config().getDataStorageConfiguration() != null)
        dataRegion = ctx.config().getDataStorageConfiguration().getDefaultDataRegionConfiguration().getName();
    grpCtx.onCacheStarted(cacheCtx);
    ctx.query().onCacheStart(new GridCacheContextInfo(cacheCtx, false), desc.schema() != null ? desc.schema() : new QuerySchema(), desc.sql());
    if (log.isInfoEnabled()) {
        String expPlcInfo = buildExpirePolicyInfo(cacheCtx);
        log.info(""Started cache in recovery mode [name="" + cfg.getName() + "", id="" + cacheCtx.cacheId() + (cfg.getGroupName() != null ? "", group="" + cfg.getGroupName() : """") + "", dataRegionName="" + dataRegion + "", mode="" + cfg.getCacheMode() + "", atomicity="" + cfg.getAtomicityMode() + "", backups="" + cfg.getBackups() + "", mvcc="" + cacheCtx.mvccEnabled() + (expPlcInfo != null ? "", "" + expPlcInfo : """") + ']');
    }
    return cacheCtx;
}",java:S3398,35
"private static int compareKeys(GridCacheContext cctx1, CacheObject key1, GridCacheContext cctx2, CacheObject key2){
    int key1Hash = key1.hashCode();
    int key2Hash = key2.hashCode();
    int res = Integer.compare(key1Hash, key2Hash);
    if (res == 0) {
        key1 = (CacheObject) cctx1.unwrapTemporary(key1);
        key2 = (CacheObject) cctx2.unwrapTemporary(key2);
        try {
            byte[] key1ValBytes = key1.valueBytes(cctx1.cacheObjectContext());
            byte[] key2ValBytes = key2.valueBytes(cctx2.cacheObjectContext());
            res = Integer.compare(key1ValBytes.length, key2ValBytes.length);
            if (res == 0) {
                for (int i = 0; i < key1ValBytes.length; i++) {
                    res = Byte.compare(key1ValBytes[i], key2ValBytes[i]);
                    if (res != 0)
                        break;
                }
            }
            if (res == 0)
                res = Boolean.compare(cctx1.isNear(), cctx2.isNear());
        } catch (IgniteCheckedException e) {
            throw new IgniteException(e);
        }
    }
    return res;
}",java:S3398,35
"protected void disableWAL(boolean disable) throws IgniteCheckedException{
    dbMgr.checkpointReadLock();
    try {
        disableWal = disable;
        if (log != null)
            log.info(""WAL logging "" + (disable ? ""disabled"" : ""enabled""));
    } finally {
        dbMgr.checkpointReadUnlock();
    }
}",java:S1130,7
"@Override
public GridCacheEntryEx entryEx(KeyCacheObject key, AffinityTopologyVersion topVer) throws GridDhtInvalidPartitionException{
    return super.entryEx(key, topVer);
}",java:S1185,15
"private static RelDataType toSql(RelDataTypeFactory typeFactory, RelDataType type){
    if (type instanceof RelDataTypeFactoryImpl.JavaType) {
        final SqlTypeName typeName = type.getSqlTypeName();
        if (typeName != null && typeName != SqlTypeName.OTHER) {
            return typeFactory.createTypeWithNullability(typeFactory.createSqlType(typeName), type.isNullable());
        }
    }
    return type;
}",java:S3398,35
"private static boolean allSame(List<E> list){
    E prev = null;
    for (E e : list) {
        if (prev != null && !prev.equals(e))
            return false;
        prev = e;
    }
    return true;
}",java:S3398,35
"private static Expression mod(Expression operand, long factor, boolean floorMod){
    if (factor == 1L)
        return operand;
    else {
        return floorMod ? Expressions.call(BuiltInMethod.FLOOR_MOD.method, operand, Expressions.constant(factor)) : Expressions.modulo(operand, Expressions.constant(factor));
    }
}",java:S3398,35
"private static long getFactor(TimeUnit unit){
    switch(unit) {
        case DAY:
            return 1L;
        case HOUR:
            return TimeUnit.DAY.multiplier.longValue();
        case MINUTE:
            return TimeUnit.HOUR.multiplier.longValue();
        case SECOND:
            return TimeUnit.MINUTE.multiplier.longValue();
        case MILLISECOND:
            return TimeUnit.SECOND.multiplier.longValue();
        case MONTH:
            return TimeUnit.YEAR.multiplier.longValue();
        case QUARTER:
            return TimeUnit.YEAR.multiplier.longValue();
        case YEAR:
        case DECADE:
        case CENTURY:
        case MILLENNIUM:
            return 1L;
        default:
            throw Util.unexpected(unit);
    }
}",java:S3398,35
"private void releaseEvictions(Collection<KeyCacheObject> keys, Map<KeyCacheObject, GridNearCacheEntry> saved){
    for (KeyCacheObject key : keys) {
        GridNearCacheEntry entry = saved.get(key);
        if (entry != null) {
            entry.releaseEviction();
            if (tx == null)
                entry.touch();
        }
    }
}",java:S3398,35
"public LinkedHashMap<KeyCacheObject, Boolean> keys(){
    return keyMap;
}",java:S1319,22
"private void startComputation(MvccVersion waiterVer, MvccVersion blockerVer){
    if (log.isDebugEnabled())
        log.debug(""Starting deadlock detection [waiterVer="" + waiterVer + "", blockerVer="" + blockerVer + ']');
    Optional<GridDhtTxLocalAdapter> waitingTx = findTx(waiterVer);
    Optional<GridDhtTxLocalAdapter> blockerTx = findTx(blockerVer);
    if (waitingTx.isPresent() && blockerTx.isPresent()) {
        GridDhtTxLocalAdapter wTx = waitingTx.get();
        GridDhtTxLocalAdapter bTx = blockerTx.get();
        sendProbe(bTx.eventNodeId(), wTx.xidVersion(), singleton(new ProbedTx(wTx.nodeId(), wTx.xidVersion(), wTx.nearXidVersion(), -1, wTx.lockCounter())), new ProbedTx(bTx.nodeId(), bTx.xidVersion(), bTx.nearXidVersion(), -1, bTx.lockCounter()), true);
    }
}",java:S3398,35
"private static CallImplementor createTableFunctionImplementor(final Method method){
    return createImplementor(new ReflectiveCallNotNullImplementor(method) {

        @Override
        public Expression implement(RexToLixTranslator translator, RexCall call, List<Expression> translatedOperands) {
            Expression expr = super.implement(translator, call, translatedOperands);
            final Class<?> returnType = method.getReturnType();
            if (QueryableTable.class.isAssignableFrom(returnType)) {
                Expression queryable = Expressions.call(Expressions.convert_(expr, QueryableTable.class), BuiltInMethod.QUERYABLE_TABLE_AS_QUERYABLE.method, Expressions.call(translator.getRoot(), BuiltInMethod.DATA_CONTEXT_GET_QUERY_PROVIDER.method), Expressions.constant(null, SchemaPlus.class), Expressions.constant(call.getOperator().getName(), String.class));
                expr = Expressions.call(queryable, BuiltInMethod.QUERYABLE_AS_ENUMERABLE.method);
            } else {
                expr = Expressions.call(expr, BuiltInMethod.SCANNABLE_TABLE_SCAN.method, translator.getRoot());
            }
            return expr;
        }
    }, NullPolicy.NONE, false);
}",java:S3398,35
"private void processCoordinatorTxSnapshotRequest(UUID nodeId, MvccTxSnapshotRequest msg){
    ClusterNode node = ctx.discovery().node(nodeId);
    if (node == null) {
        if (log.isDebugEnabled())
            log.debug(""Ignore tx snapshot request processing, node left [msg="" + msg + "", node="" + nodeId + ']');
        return;
    }
    MvccSnapshotResponse res = assignTxSnapshot(msg.futureId(), nodeId, node.isClient());
    boolean finishFailed = true;
    try {
        sendMessage(node.id(), res);
        finishFailed = false;
    } catch (ClusterTopologyCheckedException e) {
        if (log.isDebugEnabled())
            log.debug(""Failed to send tx snapshot response, node left [msg="" + msg + "", node="" + nodeId + ']');
    } catch (IgniteCheckedException e) {
        U.error(log, ""Failed to send tx snapshot response [msg="" + msg + "", node="" + nodeId + ']', e);
    }
    if (finishFailed)
        onTxDone(res.counter(), false);
}",java:S3398,35
"private void processCoordinatorQuerySnapshotRequest(UUID nodeId, MvccQuerySnapshotRequest msg){
    ClusterNode node = ctx.discovery().node(nodeId);
    if (node == null) {
        if (log.isDebugEnabled())
            log.debug(""Ignore query counter request processing, node left [msg="" + msg + "", node="" + nodeId + ']');
        return;
    }
    MvccSnapshotResponse res = activeQueries.assignQueryCounter(nodeId, msg.futureId());
    try {
        sendMessage(node.id(), res);
    } catch (ClusterTopologyCheckedException e) {
        if (log.isDebugEnabled())
            log.debug(""Failed to send query counter response, node left [msg="" + msg + "", node="" + nodeId + ']');
    } catch (IgniteCheckedException e) {
        onQueryDone(nodeId, res.tracking());
        U.error(log, ""Failed to send query counter response [msg="" + msg + "", node="" + nodeId + ']', e);
    }
}",java:S3398,35
"private void processCoordinatorSnapshotResponse(UUID nodeId, MvccSnapshotResponse msg){
    Map<Long, MvccSnapshotResponseListener> map = snapLsnrs.get(nodeId);
    MvccSnapshotResponseListener lsnr;
    if (map != null && (lsnr = map.remove(msg.futureId())) != null)
        lsnr.onResponse(msg);
    else {
        if (ctx.discovery().alive(nodeId))
            U.warn(log, ""Failed to find query version future [node="" + nodeId + "", msg="" + msg + ']');
        else if (log.isDebugEnabled())
            log.debug(""Failed to find query version future [node="" + nodeId + "", msg="" + msg + ']');
    }
}",java:S3398,35
"private void processCoordinatorQueryAckRequest(UUID nodeId, MvccAckRequestQueryCntr msg){
    onQueryDone(nodeId, msg.counter());
}",java:S3398,35
"private void processNewCoordinatorQueryAckRequest(UUID nodeId, MvccAckRequestQueryId msg){
    prevQueries.onQueryDone(nodeId, msg.queryTrackerId());
}",java:S3398,35
"private void processCoordinatorTxAckRequest(UUID nodeId, MvccAckRequestTx msg){
    onTxDone(msg.txCounter(), msg.futureId() >= 0);
    if (msg.queryCounter() != MVCC_COUNTER_NA)
        onQueryDone(nodeId, msg.queryCounter());
    else if (msg.queryTrackerId() != MVCC_TRACKER_ID_NA)
        prevQueries.onQueryDone(nodeId, msg.queryTrackerId());
    if (!msg.skipResponse()) {
        try {
            sendMessage(nodeId, new MvccFutureResponse(msg.futureId()));
        } catch (ClusterTopologyCheckedException e) {
            if (log.isDebugEnabled())
                log.debug(""Failed to send tx ack response, node left [msg="" + msg + "", node="" + nodeId + ']');
        } catch (IgniteCheckedException e) {
            U.error(log, ""Failed to send tx ack response [msg="" + msg + "", node="" + nodeId + ']', e);
        }
    }
}",java:S3398,35
"private void processCoordinatorAckResponse(UUID nodeId, MvccFutureResponse msg){
    WaitAckFuture fut = ackFuts.remove(msg.futureId());
    if (fut != null)
        fut.onResponse();
    else {
        if (ctx.discovery().alive(nodeId))
            U.warn(log, ""Failed to find tx ack future [node="" + nodeId + "", msg="" + msg + ']');
        else if (log.isDebugEnabled())
            log.debug(""Failed to find tx ack future [node="" + nodeId + "", msg="" + msg + ']');
    }
}",java:S3398,35
"private void processActiveQueriesMessage(UUID nodeId, MvccActiveQueriesMessage msg){
    GridLongList queryIds = msg.activeQueries();
    assert queryIds != null;
    prevQueries.addActiveQueries(nodeId, queryIds);
}",java:S3398,35
"private void processRecoveryFinishedMessage(UUID nodeId, MvccRecoveryFinishedMessage msg){
    if (!mvccEnabled)
        return;
    UUID nearNodeId = msg.nearNodeId();
    RecoveryBallotBox ballotBox = recoveryBallotBoxes.computeIfAbsent(nearNodeId, uuid -> new RecoveryBallotBox());
    ballotBox.vote(nodeId);
    tryFinishRecoveryVoting(nearNodeId, ballotBox);
}",java:S3398,35
"private boolean onResponse0(@NotNull MvccSnapshot res, @NotNull MvccSnapshotResponseListener lsnr){
    boolean ackQueryDone = false, needRemap = false;
    synchronized (this) {
        assert snapshot(state) == null : ""[this="" + this + "", rcvdVer="" + res + ""]"";
        if (!done && crdVer != 0) {
            this.state = res;
            return true;
        }
        if (crdVer != 0)
            ackQueryDone = true;
        else if (!done)
            needRemap = true;
    }
    if (needRemap)
        tryRemap(coordinator().topologyVersion(), lsnr);
    else if (ackQueryDone)
        ackQueryDone(res);
    return false;
}",java:S3398,35
"private boolean onError0(IgniteCheckedException e, @NotNull MvccSnapshotResponseListener lsnr){
    synchronized (this) {
        if (done)
            return false;
    }
    if (e instanceof ClusterTopologyCheckedException && !(e instanceof ClusterTopologyServerNotFoundException)) {
        tryRemap(coordinator().topologyVersion(), lsnr);
        return false;
    }
    cctx.shared().coordinators().removeQueryTracker(id);
    return true;
}",java:S3398,35
"public void regionMetrics(Collection<DataRegionMetrics> regionMetrics){
    this.regionMetrics = regionMetrics;
}",java:S1874,25
"public static Supplier<Accumulator<Row>> accumulatorFactory(AggregateCall call, ExecutionContext<Row> ctx){
    Supplier<Accumulator<Row>> supplier = accumulatorFunctionFactory(call, ctx);
    if (call.isDistinct())
        return () -> new DistinctAccumulator<>(call, ctx.rowHandler(), supplier);
    return supplier;
}",java:S119,17
"private static Supplier<Accumulator<Row>> accumulatorFunctionFactory(AggregateCall call, ExecutionContext<Row> ctx){
    RowHandler<Row> hnd = ctx.rowHandler();
    switch(call.getAggregation().getName()) {
        case ""COUNT"":
            return () -> new LongCount<>(call, hnd);
        case ""AVG"":
            return avgFactory(call, hnd);
        case ""SUM"":
            return sumFactory(call, hnd);
        case ""$SUM0"":
            return sumEmptyIsZeroFactory(call, hnd);
        case ""MIN"":
        case ""EVERY"":
            return minFactory(call, hnd);
        case ""MAX"":
        case ""SOME"":
            return maxFactory(call, hnd);
        case ""SINGLE_VALUE"":
            return () -> new SingleVal<>(call, hnd);
        case ""ANY_VALUE"":
            return () -> new AnyVal<>(call, hnd);
        case ""LISTAGG"":
        case ""ARRAY_AGG"":
        case ""ARRAY_CONCAT_AGG"":
            return listAggregateSupplier(call, ctx);
        default:
            throw new AssertionError(call.getAggregation().getName());
    }
}",java:S119,17
"private static Supplier<Accumulator<Row>> listAggregateSupplier(AggregateCall call, ExecutionContext<Row> ctx){
    RowHandler<Row> hnd = ctx.rowHandler();
    Supplier<Accumulator<Row>> accSup;
    String aggName = call.getAggregation().getName();
    if (""LISTAGG"".equals(aggName))
        accSup = () -> new ListAggAccumulator<>(call, hnd);
    else if (""ARRAY_CONCAT_AGG"".equals(aggName))
        accSup = () -> new ArrayConcatAggregateAccumulator<>(call, hnd);
    else if (""ARRAY_AGG"".equals(aggName))
        accSup = () -> new ArrayAggregateAccumulator<>(call, hnd);
    else
        throw new AssertionError(call.getAggregation().getName());
    if (call.getCollation() != null && !call.getCollation().getFieldCollations().isEmpty()) {
        Comparator<Row> cmp = ctx.expressionFactory().comparator(call.getCollation());
        return () -> new SortingAccumulator<>(accSup, cmp);
    }
    return accSup;
}",java:S119,17
"private static Supplier<Accumulator<Row>> avgFactory(AggregateCall call, RowHandler<Row> hnd){
    switch(call.type.getSqlTypeName()) {
        case ANY:
            throw new UnsupportedOperationException(""AVG() is not supported for type '"" + call.type + ""'."");
        case BIGINT:
        case DECIMAL:
            return () -> new DecimalAvg<>(call, hnd);
        case DOUBLE:
        case REAL:
        case FLOAT:
        case INTEGER:
        default:
            return () -> new DoubleAvg<>(call, hnd);
    }
}",java:S119,17
"private static Supplier<Accumulator<Row>> sumFactory(AggregateCall call, RowHandler<Row> hnd){
    switch(call.type.getSqlTypeName()) {
        case ANY:
            throw new UnsupportedOperationException(""SUM() is not supported for type '"" + call.type + ""'."");
        case BIGINT:
        case DECIMAL:
            return () -> new Sum<>(call, new DecimalSumEmptyIsZero<>(call, hnd), hnd);
        case DOUBLE:
        case REAL:
        case FLOAT:
            return () -> new Sum<>(call, new DoubleSumEmptyIsZero<>(call, hnd), hnd);
        case TINYINT:
        case SMALLINT:
        case INTEGER:
        default:
            return () -> new Sum<>(call, new LongSumEmptyIsZero<>(call, hnd), hnd);
    }
}",java:S119,17
"public Collection<DataRegionMetrics> memoryMetrics(){
    return dataRegionMap.values().stream().map(DataRegion::metrics).map(DataRegionMetricsSnapshot::new).collect(Collectors.toList());
}",java:S1874,25
"@Nullable
public DataRegionMetrics memoryMetrics(String dataRegionName){
    DataRegion dataRegion = dataRegionMap.get(dataRegionName);
    return dataRegion == null ? null : new DataRegionMetricsSnapshot(dataRegion.metrics());
}",java:S1874,25
"private static Supplier<Accumulator<Row>> sumEmptyIsZeroFactory(AggregateCall call, RowHandler<Row> hnd){
    switch(call.type.getSqlTypeName()) {
        case ANY:
            throw new UnsupportedOperationException(""SUM() is not supported for type '"" + call.type + ""'."");
        case BIGINT:
        case DECIMAL:
            return () -> new DecimalSumEmptyIsZero<>(call, hnd);
        case DOUBLE:
        case REAL:
        case FLOAT:
            return () -> new DoubleSumEmptyIsZero<>(call, hnd);
        case TINYINT:
        case SMALLINT:
        case INTEGER:
        default:
            return () -> new LongSumEmptyIsZero<>(call, hnd);
    }
}",java:S119,17
"private static Supplier<Accumulator<Row>> minFactory(AggregateCall call, RowHandler<Row> hnd){
    switch(call.type.getSqlTypeName()) {
        case DOUBLE:
        case REAL:
        case FLOAT:
            return () -> new DoubleMinMax<>(call, hnd, true);
        case DECIMAL:
            return () -> new DecimalMinMax<>(call, hnd, true);
        case INTEGER:
            return () -> new IntMinMax<>(call, hnd, true);
        case CHAR:
        case VARCHAR:
            return () -> new VarCharMinMax<>(call, hnd, true);
        case BINARY:
        case VARBINARY:
            return () -> new ComparableMinMax<Row, ByteString>(call, hnd, true, tf -> tf.createTypeWithNullability(tf.createSqlType(VARBINARY), true));
        case ANY:
            if (call.type instanceof UuidType) {
                return () -> new ComparableMinMax<Row, UUID>(call, hnd, true, tf -> tf.createTypeWithNullability(tf.createCustomType(UUID.class), true));
            }
            throw new UnsupportedOperationException(""MIN() is not supported for type '"" + call.type + ""'."");
        case BIGINT:
        default:
            return () -> new LongMinMax<>(call, hnd, true);
    }
}",java:S119,17
"private static Supplier<Accumulator<Row>> maxFactory(AggregateCall call, RowHandler<Row> hnd){
    switch(call.type.getSqlTypeName()) {
        case DOUBLE:
        case REAL:
        case FLOAT:
            return () -> new DoubleMinMax<>(call, hnd, false);
        case DECIMAL:
            return () -> new DecimalMinMax<>(call, hnd, false);
        case INTEGER:
            return () -> new IntMinMax<>(call, hnd, false);
        case CHAR:
        case VARCHAR:
            return () -> new VarCharMinMax<>(call, hnd, false);
        case BINARY:
        case VARBINARY:
            return () -> new ComparableMinMax<Row, ByteString>(call, hnd, false, tf -> tf.createTypeWithNullability(tf.createSqlType(VARBINARY), true));
        case ANY:
            if (call.type instanceof UuidType) {
                return () -> new ComparableMinMax<Row, UUID>(call, hnd, false, tf -> tf.createTypeWithNullability(tf.createCustomType(UUID.class), true));
            }
            throw new UnsupportedOperationException(""MAX() is not supported for type '"" + call.type + ""'."");
        case BIGINT:
        default:
            return () -> new LongMinMax<>(call, hnd, false);
    }
}",java:S119,17
"private synchronized Set<PageLockThreadState> hangThreads(){
    Set<PageLockThreadState> hangsThreads = new HashSet<>();
    Map<Long, PageLockThreadState> currentThreadsOperationState = getThreadOperationState();
    prevThreadsState.forEach((threadId, prevState) -> {
        PageLockThreadState state = currentThreadsOperationState.get(threadId);
        if (state == null)
            return;
        boolean threadHoldedLocks = state.heldLockCnt != 0;
        if (prevState.equals(state) && threadHoldedLocks)
            hangsThreads.add(state);
    });
    prevThreadsState = currentThreadsOperationState;
    return hangsThreads;
}",java:S3398,35
"@Override
public void cleanupPageStoreIfMatch(Predicate<Integer> cacheGrpPred, boolean cleanFiles){
    Map<Integer, CacheStoreHolder> filteredStores = idxCacheStores.entrySet().stream().filter(e -> cacheGrpPred.test(e.getKey())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    idxCacheStores.entrySet().removeIf(e -> cacheGrpPred.test(e.getKey()));
    Runnable doShutdown = () -> {
        IgniteCheckedException ex = shutdown(filteredStores.values(), cleanFiles);
        if (ex != null)
            U.error(log, ""Failed to gracefully stop page store managers"", ex);
        U.log(log, ""Cleanup cache stores [total="" + filteredStores.keySet().size() + "", left="" + idxCacheStores.size() + "", cleanFiles="" + cleanFiles + ']');
    };
    if (cleanFiles) {
        cleanupAsyncExecutor.async(doShutdown);
        U.log(log, ""Cache stores cleanup started asynchronously"");
    } else
        doShutdown.run();
}",java:S4276,41
"public static long getLink(IO io, long pageAddr, int idx){
    assert idx < io.getCount(pageAddr) : idx;
    return PageUtils.getLong(pageAddr, io.offset(idx));
}",java:S119,17
"public static short getKeySize(IO io, long pageAddr, int idx){
    return PageUtils.getShort(pageAddr, io.offset(idx) + 8);
}",java:S119,17
"public static String getKey(IO io, long pageAddr, int idx, MetastorageRowStore rowStore) throws IgniteCheckedException{
    int off = io.offset(idx);
    int len = PageUtils.getShort(pageAddr, off + 8);
    if (len > MetastorageTree.MAX_KEY_LEN) {
        long keyLink = PageUtils.getLong(pageAddr, off + 10);
        byte[] keyBytes = rowStore.readRow(keyLink);
        assert keyBytes != null : ""[pageAddr="" + Long.toHexString(pageAddr) + "", idx="" + idx + ']';
        return new String(keyBytes);
    } else {
        byte[] keyBytes = PageUtils.getBytes(pageAddr, off + 10, len);
        return new String(keyBytes);
    }
}",java:S119,17
"public static MetastorageDataRow getDataRow(IO io, long pageAddr, int idx, MetastorageRowStore rowStore) throws IgniteCheckedException{
    long link = io.getLink(pageAddr, idx);
    int off = io.offset(idx);
    int len = PageUtils.getShort(pageAddr, off + 8);
    if (len > MetastorageTree.MAX_KEY_LEN) {
        long keyLink = PageUtils.getLong(pageAddr, off + 10);
        byte[] keyBytes = rowStore.readRow(keyLink);
        assert keyBytes != null : ""[pageAddr="" + Long.toHexString(pageAddr) + "", idx="" + idx + ']';
        return new MetastorageDataRow(link, new String(keyBytes), keyLink);
    } else {
        byte[] keyBytes = PageUtils.getBytes(pageAddr, off + 10, len);
        return new MetastorageDataRow(link, new String(keyBytes), 0L);
    }
}",java:S119,17
"public static void store(IO dstIo, long dstPageAddr, int dstIdx, BPlusIO<MetastorageRow> srcIo, long srcPageAddr, int srcIdx){
    int srcOff = srcIo.offset(srcIdx);
    int dstOff = dstIo.offset(dstIdx);
    GridUnsafe.copyMemory(srcPageAddr + srcOff, dstPageAddr + dstOff, MetastorageTree.MAX_KEY_LEN + 10);
}",java:S119,17
"public static void storeByOffset(IO io, long pageAddr, int off, MetastorageRow row){
    assert row.link() != 0;
    PageUtils.putLong(pageAddr, off, row.link());
    byte[] bytes = row.key().getBytes();
    assert bytes.length <= Short.MAX_VALUE;
    if (row.keyLink() != 0) {
        PageUtils.putShort(pageAddr, off + 8, (short) bytes.length);
        PageUtils.putLong(pageAddr, off + 10, row.keyLink());
    } else {
        assert bytes.length <= MetastorageTree.MAX_KEY_LEN;
        PageUtils.putShort(pageAddr, off + 8, (short) bytes.length);
        PageUtils.putBytes(pageAddr, off + 10, bytes);
    }
}",java:S119,17
"@Override
public void forEach(BiConsumer<FullPageId, Long> act){
    for (int i = 0; i < capacity; i++) {
        if (isValuePresentAt(i)) {
            long base = entryBase(i);
            int cacheId = GridUnsafe.getInt(base);
            long pageId = GridUnsafe.getLong(base + PAGE_ID_OFFSET);
            long val = GridUnsafe.getLong(base + VALUE_OFFSET);
            act.accept(new FullPageId(pageId, cacheId), val);
        }
    }
}",java:S4276,41
"@Override
public void forEach(BiConsumer<FullPageId, Long> act){
    for (int i = 0; i < numBuckets; i++) {
        if (isEmptyAt(i))
            continue;
        long base = entryBase(i);
        act.accept(getFullPageId(base), getValue(base));
    }
}",java:S4276,41
"private boolean cancelLocalSnapshotTask0(Function<AbstractSnapshotFutureTask<?>, Boolean> filter){
    ClusterSnapshotFuture fut0 = null;
    boolean canceled = false;
    busyLock.enterBusy();
    try {
        for (AbstractSnapshotFutureTask<?> sctx : locSnpTasks.values()) {
            if (filter.apply(sctx))
                canceled |= sctx.cancel();
        }
        synchronized (snpOpMux) {
            if (clusterSnpFut != null)
                fut0 = clusterSnpFut;
        }
    } finally {
        busyLock.leaveBusy();
    }
    try {
        if (fut0 != null)
            fut0.get();
    } catch (IgniteCheckedException e) {
        if (e instanceof IgniteFutureCancelledCheckedException) {
            if (log.isInfoEnabled())
                log.info(""Expected cancelled exception: "" + e.getMessage());
        } else
            throw new IgniteException(e);
    }
    return canceled;
}",java:S4276,41
"private Map<Integer, StoredCacheData> readTxCachesData() throws IgniteCheckedException, IOException{
    File snpDir = ignite.context().cache().context().snapshotMgr().snapshotLocalDir(snpName, snpPath);
    String folderName = ignite.context().pdsFolderResolver().resolveFolders().folderName();
    return GridLocalConfigManager.readCachesData(new File(snpDir, databaseRelativePath(folderName)), MarshallerUtils.jdkMarshaller(ignite.name()), ignite.configuration()).values().stream().filter(data -> data.config().getAtomicityMode() == CacheAtomicityMode.TRANSACTIONAL).collect(Collectors.toMap(StoredCacheData::cacheId, Function.identity()));
}",java:S1130,7
"private boolean mayMerge(int cnt, int cap){
    int minCnt = (int) (minFill * cap);
    if (cnt <= minCnt) {
        assert cnt == 0;
        return true;
    }
    assert cnt > 0;
    int maxCnt = (int) (maxFill * cap);
    if (cnt > maxCnt)
        return false;
    assert false;
    return randomInt(maxCnt - minCnt) >= cnt - minCnt;
}",java:S3398,35
"private boolean splitPage(long pageId, long page, long pageAddr, BPlusIO io, long fwdId, long fwdBuf, int idx) throws IgniteCheckedException{
    int cnt = io.getCount(pageAddr);
    int mid = sequentialWriteOptsEnabled ? (int) (cnt * 0.85) : cnt >>> 1;
    boolean res = false;
    if (idx > mid) {
        mid++;
        res = true;
    }
    io.splitForwardPage(pageAddr, fwdId, fwdBuf, mid, cnt, pageSize(), metrics);
    io.splitExistingPage(pageAddr, mid, fwdId);
    if (needWalDeltaRecord(pageId, page, null))
        wal.log(new SplitExistingPageRecord(grpId, pageId, mid, fwdId));
    return res;
}",java:S3398,35
"private void doVisit(TreeVisitor c) throws IgniteCheckedException{
    for (; ; ) {
        c.init();
        switch(visitDown(c, c.rootId, 0L, c.rootLvl)) {
            case RETRY:
            case RETRY_ROOT:
                checkInterrupted();
                continue;
            default:
                return;
        }
    }
}",java:S3398,35
"private long doAskNeighbor(BPlusIO<L> io, long pageAddr, boolean back){
    long res;
    if (back) {
        int cnt = io.getCount(pageAddr);
        res = inner(io).getLeft(pageAddr, cnt);
    } else
        res = inner(io).getLeft(pageAddr, 0);
    assert res != 0 : ""inner page with no route down: "" + U.hexLong(PageIO.getPageId(pageAddr));
    return res;
}",java:S3398,35
"private void checkWalRolloverRequired(){
    if (walAutoArchiveAfterInactivity <= 0 && walForceArchiveTimeout <= 0)
        return;
    if (lastRecordLoggedMs.get() == 0)
        return;
    if (walForceArchiveTimeout > 0) {
        if (lastDataRecordLoggedMs.get() == 0)
            return;
    } else if (!checkTimeout(lastRecordLoggedMs, walAutoArchiveAfterInactivity))
        return;
    final FileWriteHandle handle = currentHandle();
    try {
        closeBufAndRollover(handle, null, RolloverType.NONE);
    } catch (IgniteCheckedException e) {
        U.error(log, ""Unable to perform segment rollover: "" + e.getMessage(), e);
        cctx.kernalContext().failure().process(new FailureContext(CRITICAL_ERROR, e));
    }
}",java:S3398,35
"@Override
public WALPointer flush(WALPointer ptr, boolean explicitFsync) throws IgniteCheckedException, StorageException{
    return fileHandleManager.flush(ptr, explicitFsync);
}",java:S1130,7
"@Override
public WALRecord read(WALPointer ptr) throws IgniteCheckedException, StorageException{
    try (WALIterator it = replay(ptr)) {
        IgniteBiTuple<WALPointer, WALRecord> rec = it.next();
        if (rec != null && rec.get2().position().equals(ptr))
            return rec.get2();
        else
            throw new StorageException(""Failed to read record by pointer [ptr="" + ptr + "", rec="" + rec + ""]"");
    }
}",java:S1130,7
"@Override
public WALIterator replay(WALPointer start) throws IgniteCheckedException, StorageException{
    return replay(start, null);
}",java:S1130,7
"@Nullable
private FileDescriptor readFileDescriptor(File file, FileIOFactory ioFactory){
    FileDescriptor ds = new FileDescriptor(file);
    try (SegmentIO fileIO = ds.toReadOnlyIO(ioFactory)) {
        if (fileIO.size() == 0)
            return null;
        try (ByteBufferExpander buf = new ByteBufferExpander(HEADER_RECORD_SIZE, ByteOrder.nativeOrder())) {
            final DataInput in = segmentFileInputFactory.createFileInput(fileIO, buf);
            final int type = in.readUnsignedByte();
            if (type == WALRecord.RecordType.STOP_ITERATION_RECORD_TYPE) {
                if (log.isInfoEnabled())
                    log.info(""Reached logical end of the segment for file "" + file);
                return null;
            }
            WALPointer ptr = readPosition(in);
            return new FileDescriptor(file, ptr.index());
        }
    } catch (IOException e) {
        U.warn(log, ""Failed to read file header ["" + file + ""]. Skipping this file"", e);
        return null;
    }
}",java:S3398,35
"private void copy(ByteBuffer src, int srcPos, ByteBuffer dest, int destPos, int len){
    assert mode != MAPPED;
    if (buf.isDirect()) {
        ByteBuffer src0 = src.duplicate();
        src0.limit(srcPos + len);
        src0.position(srcPos);
        ByteBuffer dest0 = dest.duplicate();
        dest0.limit(destPos + len);
        dest0.position(destPos);
        dest0.put(src0);
    } else
        System.arraycopy(src.array(), srcPos, buf.array(), destPos, len);
}",java:S3398,35
"@Override
public WALPointer flush(WALPointer ptr, boolean explicitFsync) throws IgniteCheckedException, StorageException{
    if (serializer == null || mode == WALMode.NONE)
        return null;
    FileWriteHandleImpl cur = currentHandle();
    if (cur == null)
        return null;
    WALPointer filePtr;
    if (ptr == null) {
        long pos = cur.buf.tail();
        filePtr = new WALPointer(cur.getSegmentId(), (int) pos, 0);
    } else
        filePtr = ptr;
    if (mode == LOG_ONLY)
        cur.flushOrWait(filePtr);
    if (!explicitFsync && mode != WALMode.FSYNC)
        return filePtr;
    if (!cur.needFsync(filePtr))
        return filePtr;
    cur.fsync(filePtr);
    return filePtr;
}",java:S1130,7
"private void checkNode() throws StorageException{
    if (cctx.kernalContext().invalid())
        throw new StorageException(""Failed to perform WAL operation (environment was invalidated by a "" + ""previous error)"");
}",java:S3398,35
"private void writeBuffer(long pos, ByteBuffer buf) throws StorageException, IgniteCheckedException{
    FileWriteHandleImpl hdl = currentHandle();
    assert hdl.fileIO != null : ""Writing to a closed segment."";
    checkNode();
    long lastLogged = U.currentTimeMillis();
    long logBackoff = 2_000;
    while (hdl.written != pos) {
        assert hdl.written < pos : ""written = "" + hdl.written + "", pos = "" + pos;
        long now = U.currentTimeMillis();
        if (now - lastLogged >= logBackoff) {
            if (logBackoff < 60 * 60_000)
                logBackoff *= 2;
            U.warn(log, ""Still waiting for a concurrent write to complete [written="" + hdl.written + "", pos="" + pos + "", lastFsyncPos="" + hdl.lastFsyncPos + "", stop="" + hdl.stop.get() + "", actualPos="" + hdl.safePosition() + ']');
            lastLogged = now;
        }
        checkNode();
    }
    int size = buf.remaining();
    assert size > 0 : size;
    try {
        assert hdl.written == hdl.fileIO.position();
        hdl.written += hdl.fileIO.writeFully(buf);
        assert hdl.written == hdl.fileIO.position();
    } catch (IOException e) {
        err = e;
        StorageException se = new StorageException(""Failed to write buffer."", e);
        cctx.kernalContext().failure().process(new FailureContext(CRITICAL_ERROR, se));
        throw se;
    }
}",java:S1130,7
"@Override
@Nullable
public WALPointer addRecord(WALRecord rec) throws StorageException, IgniteCheckedException{
    assert rec.size() > 0 : rec;
    for (; ; ) {
        checkNode();
        SegmentedRingByteBuffer.WriteSegment seg;
        try {
            if (rec.type() == SWITCH_SEGMENT_RECORD && !resume)
                seg = buf.offerSafe(rec.size());
            else
                seg = buf.offer(rec.size());
        } catch (IgniteException e) {
            throw new IgniteCheckedException(e);
        }
        WALPointer ptr = null;
        if (seg != null) {
            try {
                int pos = (int) (seg.position() - rec.size());
                ByteBuffer buf = seg.buffer();
                if (buf == null)
                    return null;
                ptr = new WALPointer(getSegmentId(), pos, rec.size());
                rec.position(ptr);
                fillBuffer(buf, rec);
                if (mmap) {
                    while (true) {
                        long written0 = written;
                        if (seg.position() > written0) {
                            if (WRITTEN_UPD.compareAndSet(this, written0, seg.position()))
                                break;
                        } else
                            break;
                    }
                }
                return ptr;
            } finally {
                seg.release();
                if (mode == WALMode.BACKGROUND && rec instanceof CheckpointRecord)
                    flushOrWait(ptr);
            }
        } else
            walWriter.flushAll();
    }
}",java:S1130,7
"@Override
public void fsync(WALPointer ptr) throws StorageException, IgniteCheckedException{
    lock.lock();
    try {
        if (ptr != null) {
            if (!needFsync(ptr))
                return;
            if (fsyncDelay > 0 && !stop.get()) {
                U.await(fsync, fsyncDelay, TimeUnit.NANOSECONDS);
                if (!needFsync(ptr))
                    return;
            }
        }
        flushOrWait(ptr);
        if (stop.get())
            return;
        long lastFsyncPos0 = lastFsyncPos;
        long written0 = written;
        if (lastFsyncPos0 != written0) {
            assert lastFsyncPos0 < written0 : ""lastFsyncPos="" + lastFsyncPos0 + "", written="" + written0;
            boolean metricsEnabled = metrics.metricsEnabled();
            long start = metricsEnabled ? System.nanoTime() : 0;
            if (mmap) {
                long pos = ptr == null ? -1 : ptr.fileOffset();
                List<SegmentedRingByteBuffer.ReadSegment> segs = buf.poll(pos);
                if (segs != null) {
                    assert segs.size() == 1;
                    SegmentedRingByteBuffer.ReadSegment seg = segs.get(0);
                    int off = seg.buffer().position();
                    int len = seg.buffer().limit() - off;
                    fsync((MappedByteBuffer) buf.buf, off, len);
                    seg.release();
                }
            } else
                walWriter.force();
            lastFsyncPos = written;
            if (fsyncDelay > 0)
                fsync.signalAll();
            long end = metricsEnabled ? System.nanoTime() : 0;
            if (metricsEnabled)
                metrics.onFsync(end - start);
        }
    } finally {
        lock.unlock();
    }
}",java:S1130,7
"@Override
public boolean close(boolean rollOver) throws IgniteCheckedException, StorageException{
    if (stop.compareAndSet(false, true)) {
        lock.lock();
        try {
            flushOrWait(null);
            RecordSerializer backwardSerializer = new RecordSerializerFactoryImpl(cctx).createSerializer(serializerVer);
            SwitchSegmentRecord segmentRecord = new SwitchSegmentRecord();
            int switchSegmentRecSize = backwardSerializer.size(segmentRecord);
            if (rollOver && written + switchSegmentRecSize < maxWalSegmentSize) {
                segmentRecord.size(switchSegmentRecSize);
                WALPointer segRecPtr = addRecord(segmentRecord);
                if (segRecPtr != null) {
                    fsync(segRecPtr);
                    switchSegmentRecordOffset = segRecPtr.fileOffset() + switchSegmentRecSize;
                } else {
                    if (log.isDebugEnabled())
                        log.debug(""Not enough space in wal segment to write segment switch"");
                }
            } else {
                if (log.isDebugEnabled()) {
                    log.debug(""Not enough space in wal segment to write segment switch, written="" + written + "", switchSegmentRecSize="" + switchSegmentRecSize);
                }
            }
            flushOrWait(null);
            if (mmap) {
                List<SegmentedRingByteBuffer.ReadSegment> segs = buf.poll(maxWalSegmentSize);
                if (segs != null) {
                    assert segs.size() == 1;
                    segs.get(0).release();
                }
            }
            if (mode != WALMode.NONE) {
                if (mmap)
                    ((MappedByteBuffer) buf.buf).force();
                else
                    walWriter.force();
                lastFsyncPos = written;
            }
            if (mmap)
                U.closeQuiet(fileIO);
            else
                walWriter.close();
            if (!mmap && !rollOver)
                buf.free();
            if (log.isDebugEnabled())
                log.debug(""Closed WAL write handle [idx="" + getSegmentId() + ""]"");
            return true;
        } finally {
            if (mmap)
                buf.free();
            lock.unlock();
        }
    } else
        return false;
}",java:S1130,7
"@Override
public WALPointer flush(WALPointer ptr, boolean explicitFsync) throws IgniteCheckedException, StorageException{
    if (serializer == null || mode == WALMode.NONE)
        return null;
    FsyncFileWriteHandle cur = currentHandle();
    if (cur == null)
        return null;
    WALPointer filePtr;
    if (ptr == null) {
        WALRecord rec = cur.head.get();
        if (rec instanceof FsyncFileWriteHandle.FakeRecord)
            return null;
        filePtr = rec.position();
    } else
        filePtr = ptr;
    if (!cur.needFsync(filePtr))
        return filePtr;
    cur.fsync(filePtr, false);
    return filePtr;
}",java:S1130,7
"@Override
public void fsync(WALPointer ptr) throws StorageException, IgniteCheckedException{
    fsync(ptr, false);
}",java:S1130,7
"@Override
public GridJobMetricsProcessor jobMetric(){
    return null;
}",java:S1874,25
"private void pruneQueue(){
    assert !recipients.isEmpty();
    assert Thread.holdsLock(recipients);
    int minPos = Collections.min(recipients.values()).pos;
    if (minPos > pruned) {
        queue.remove(minPos - pruned);
        pruned = minPos;
    }
}",java:S3398,35
"@Override
public int compareTo(QueueIterator o){
    return Integer.compare(pos, o.pos);
}",java:S1210,20
"public LinkedHashMap<String, ?> columns(){
    return cols;
}",java:S1319,22
"public GridCacheSqlQuery columns(LinkedHashMap<String, ?> columns){
    this.cols = columns;
    return this;
}",java:S1319,22
"@Override
public GridContinuousHandler clone(){
    return super.clone();
}",java:S1185,15
"@Override
public IgniteAsyncSupport withAsync(){
    throw new UnsupportedOperationException();
}",java:S1874,25
"private TxLocksResponse txLocksInfo(Collection<IgniteTxKey> txKeys){
    TxLocksResponse res = new TxLocksResponse();
    Collection<IgniteInternalTx> txs = activeTransactions();
    for (IgniteInternalTx tx : txs) {
        boolean nearTxLoc = tx instanceof GridNearTxLocal;
        if (!(nearTxLoc || tx instanceof GridDhtTxLocal) || !hasKeys(tx, txKeys))
            continue;
        IgniteTxState state = tx.txState();
        assert state instanceof IgniteTxStateImpl || state instanceof IgniteTxImplicitSingleStateImpl;
        Collection<IgniteTxEntry> txEntries = state instanceof IgniteTxStateImpl ? ((IgniteTxStateImpl) state).allEntriesCopy() : state.allEntries();
        Set<IgniteTxKey> requestedKeys = null;
        if (nearTxLoc) {
            if (tx.pessimistic()) {
                GridDhtColocatedLockFuture fut = (GridDhtColocatedLockFuture) mvccFuture(tx, GridDhtColocatedLockFuture.class);
                if (fut != null)
                    requestedKeys = fut.requestedKeys();
                GridNearLockFuture nearFut = (GridNearLockFuture) mvccFuture(tx, GridNearLockFuture.class);
                if (nearFut != null) {
                    Set<IgniteTxKey> nearRequestedKeys = nearFut.requestedKeys();
                    if (nearRequestedKeys != null)
                        requestedKeys = nearRequestedKeys;
                }
            } else {
                GridNearOptimisticTxPrepareFuture fut = (GridNearOptimisticTxPrepareFuture) mvccFuture(tx, GridNearOptimisticTxPrepareFuture.class);
                if (fut != null)
                    requestedKeys = fut.requestedKeys();
            }
        }
        for (IgniteTxEntry txEntry : txEntries) {
            IgniteTxKey txKey = txEntry.txKey();
            if (res.txLocks(txKey) == null) {
                GridCacheMapEntry e = (GridCacheMapEntry) txEntry.cached();
                List<GridCacheMvccCandidate> locs = e.mvccAllLocal();
                if (locs != null) {
                    boolean owner = false;
                    for (GridCacheMvccCandidate loc : locs) {
                        if (!owner && loc.owner() && loc.tx())
                            owner = true;
                        if (!owner)
                            break;
                        if (loc.tx()) {
                            UUID nearNodeId = loc.otherNodeId();
                            GridCacheVersion txId = loc.otherVersion();
                            TxLock txLock = new TxLock(txId == null ? loc.version() : txId, nearNodeId == null ? loc.nodeId() : nearNodeId, loc.threadId(), loc.owner() ? TxLock.OWNERSHIP_OWNER : TxLock.OWNERSHIP_CANDIDATE);
                            res.addTxLock(txKey, txLock);
                        }
                    }
                } else if (nearTxLoc && requestedKeys != null && requestedKeys.contains(txKey)) {
                    TxLock txLock = new TxLock(tx.nearXidVersion(), tx.nodeId(), tx.threadId(), TxLock.OWNERSHIP_REQUESTED);
                    res.addTxLock(txKey, txLock);
                } else
                    res.addKey(txKey);
            }
        }
    }
    return res;
}",java:S3398,35
"@Override
public IgniteAsyncSupport withAsync(){
    throw new UnsupportedOperationException(""Operation deprecated."");
}",java:S1874,25
"@Override
public IgniteAsyncSupport withAsync(){
    return new TransactionProxyImpl<>(tx, cctx, true);
}",java:S1874,25
"private void updateMetrics(){
    if (ctx.isStopping() || ctx.clientDisconnected())
        return;
    ClusterNode oldest = ctx.discovery().oldestAliveServerNode(AffinityTopologyVersion.NONE);
    if (oldest == null)
        return;
    if (ctx.localNodeId().equals(oldest.id())) {
        IgniteClusterNode locNode = (IgniteClusterNode) ctx.discovery().localNode();
        locNode.setMetrics(metricsProvider.metrics());
        locNode.setCacheMetrics(metricsProvider.cacheMetrics());
        ClusterNodeMetrics metrics = new ClusterNodeMetrics(locNode.metrics(), locNode.cacheMetrics());
        try {
            byte[] metricsBytes = U.zip(U.marshal(ctx.config().getMarshaller(), metrics));
            allNodesMetrics.put(ctx.localNodeId(), metricsBytes);
        } catch (IgniteCheckedException e) {
            U.warn(log, ""Failed to marshal local node metrics: "" + e, e);
        }
        ctx.discovery().metricsUpdateEvent(ctx.discovery().discoCache(), locNode);
        Collection<ClusterNode> allNodes = ctx.discovery().allNodes();
        ClusterMetricsUpdateMessage msg = new ClusterMetricsUpdateMessage(new HashMap<>(allNodesMetrics));
        for (ClusterNode node : allNodes) {
            if (ctx.localNodeId().equals(node.id()) || !ctx.discovery().alive(node.id()))
                continue;
            try {
                ctx.io().sendToGridTopic(node, TOPIC_METRICS, msg, GridIoPolicy.SYSTEM_POOL);
            } catch (ClusterTopologyCheckedException e) {
                if (log.isDebugEnabled())
                    log.debug(""Failed to send metrics update, node failed: "" + e);
            } catch (IgniteCheckedException e) {
                U.warn(log, ""Failed to send metrics update: "" + e, e);
            }
        }
    } else {
        ClusterNodeMetrics metrics = new ClusterNodeMetrics(metricsProvider.metrics(), metricsProvider.cacheMetrics());
        try {
            byte[] metricsBytes = U.zip(U.marshal(ctx.config().getMarshaller(), metrics));
            ClusterMetricsUpdateMessage msg = new ClusterMetricsUpdateMessage(metricsBytes);
            ctx.io().sendToGridTopic(oldest, TOPIC_METRICS, msg, GridIoPolicy.SYSTEM_POOL);
        } catch (ClusterTopologyCheckedException e) {
            if (log.isDebugEnabled())
                log.debug(""Failed to send metrics update to oldest, node failed: "" + e);
        } catch (IgniteCheckedException e) {
            LT.warn(log, e, ""Failed to send metrics update to oldest: "" + e, false, false);
        }
    }
}",java:S3398,35
"public static HashSet<String> parseStringSet(String val){
    HashSet<String> set = new HashSet<>();
    if (val == null || val.trim().isEmpty())
        return set;
    String[] vals = val.split(""\\W+"");
    set.addAll(Arrays.asList(vals));
    return set;
}",java:S1319,22
"private void signalTaskFinished(IgniteInternalFuture<Object> f){
    assert f != null;
    sem.release();
}",java:S3398,35
"@Nullable
private R cast(@Nullable Object obj, Class<R> cls) throws IgniteCheckedException{
    if (obj == null)
        return null;
    if (cls.isInstance(obj))
        return (R) obj;
    else
        return null;
}",java:S1130,7
"public LinkedList<UUID> getNodes(){
    return nodes;
}",java:S1319,22
"public void setNodes(LinkedList<UUID> nodes){
    this.nodes = nodes;
}",java:S1319,22
"public static CollectNode<Row> createCountCollector(ExecutionContext<Row> ctx){
    RelDataType rowType = ctx.getTypeFactory().createSqlType(SqlTypeName.BIGINT);
    Collector<Row> collector = new Counter<>(ctx.rowHandler(), ctx.rowHandler().factory(ctx.getTypeFactory(), rowType), 1);
    return new CollectNode<>(ctx, rowType, collector);
}",java:S119,17
"private static Collector<Row> createCollector(ExecutionContext<Row> ctx, RelDataType rowType){
    IgniteTypeFactory typeFactory = ctx.getTypeFactory();
    RelDataType collectionType = Iterables.getOnlyElement(rowType.getFieldList()).getType();
    RowHandler.RowFactory<Row> rowFactory = ctx.rowHandler().factory(typeFactory, rowType);
    switch(collectionType.getSqlTypeName()) {
        case ARRAY:
            return new ArrayCollector<>(ctx.rowHandler(), rowFactory, IN_BUFFER_SIZE);
        case MAP:
            return new MapCollector<>(ctx.rowHandler(), rowFactory, IN_BUFFER_SIZE);
        default:
            throw new RuntimeException(""Unsupported collectionType: "" + collectionType.getSqlTypeName());
    }
}",java:S119,17
"public ClientProcessorMXBean mxBean(){
    return new ClientProcessorMXBeanImpl();
}",java:S1874,25
"@Override
public int compareTo(@NotNull JdbcOrderedBatchExecuteRequest o){
    return Long.compare(order, o.order);
}",java:S1210,20
"public static EnumSet<JdbcThinFeature> enumSet(byte[] bytes){
    return ThinProtocolFeature.enumSet(bytes, JdbcThinFeature.class);
}",java:S1319,22
"public static EnumSet<JdbcThinFeature> allFeaturesAsEnumSet(){
    return ALL_FEATURES_AS_ENUM_SET.clone();
}",java:S1319,22
"private void CloseCursor(OdbcQueryResults results, long queryId){
    assert (results != null);
    results.closeAll();
    qryResults.remove(queryId);
}",java:S100,0
"@Override
public int compareTo(@NotNull OdbcStreamingBatchRequest o){
    return Long.compare(order, o.order);
}",java:S1210,20
"public static EnumSet<ClientBitmaskFeature> enumSet(byte[] bytes){
    return ThinProtocolFeature.enumSet(bytes, ClientBitmaskFeature.class);
}",java:S1319,22
"public static EnumSet<ClientBitmaskFeature> allFeaturesAsEnumSet(){
    return ALL_FEATURES_AS_ENUM_SET.clone();
}",java:S1319,22
"public EnumSet<ClientBitmaskFeature> features(){
    return features;
}",java:S1319,22
"private void acknowledge(UUID nodeId, int batchId) throws IgniteCheckedException{
    exchange.acknowledge(nodeId, queryId(), srcFragmentId, exchangeId, batchId);
}",java:S3398,35
"private static void writeDataRegionMetrics(BinaryRawWriter writer, DataRegionMetrics metrics){
    assert writer != null;
    assert metrics != null;
    writer.writeString(metrics.getName());
    writer.writeLong(metrics.getTotalAllocatedPages());
    writer.writeLong(metrics.getTotalUsedPages());
    writer.writeLong(metrics.getTotalAllocatedSize());
    writer.writeFloat(metrics.getAllocationRate());
    writer.writeFloat(metrics.getEvictionRate());
    writer.writeFloat(metrics.getLargeEntriesPagesPercentage());
    writer.writeFloat(metrics.getPagesFillFactor());
    writer.writeLong(metrics.getDirtyPages());
    writer.writeFloat(metrics.getPagesReplaceRate());
    writer.writeFloat(metrics.getPagesReplaceAge());
    writer.writeLong(metrics.getPhysicalMemoryPages());
    writer.writeLong(metrics.getPhysicalMemorySize());
    writer.writeLong(metrics.getUsedCheckpointBufferPages());
    writer.writeLong(metrics.getUsedCheckpointBufferSize());
    writer.writeInt(metrics.getPageSize());
    writer.writeLong(metrics.getCheckpointBufferSize());
    writer.writeLong(metrics.getPagesRead());
    writer.writeLong(metrics.getPagesWritten());
    writer.writeLong(metrics.getPagesReplaced());
    writer.writeLong(metrics.getOffHeapSize());
    writer.writeLong(metrics.getOffheapUsedSize());
}",java:S1874,25
"private long session() throws IgniteCheckedException{
    Long sesPtr = (Long) ses.properties().get(KEY_SES);
    if (sesPtr == null) {
        sesPtr = platformCtx.gateway().cacheStoreSessionCreate();
        ses.properties().put(KEY_SES, sesPtr);
    }
    Collection<Long> stores = (Collection<Long>) ses.properties().get(KEY_SES_STORES);
    if (stores == null) {
        stores = new HashSet<>();
        ses.properties().put(KEY_SES_STORES, stores);
    }
    stores.add(ptr);
    return sesPtr;
}",java:S1130,7
"private static void removeOldEntries(final Ignite ignite, final String dataCacheName, final Map<String, EntryProcessorResult<Long>> currentVersions){
    IgniteCache<PlatformDotNetEntityFrameworkCacheKey, PlatformDotNetEntityFrameworkCacheEntry> cache = ignite.cache(dataCacheName);
    Set<PlatformDotNetEntityFrameworkCacheKey> keysToRemove = new TreeSet<>();
    ClusterNode localNode = ignite.cluster().localNode();
    for (Cache.Entry<PlatformDotNetEntityFrameworkCacheKey, PlatformDotNetEntityFrameworkCacheEntry> cacheEntry : cache.localEntries(CachePeekMode.ALL)) {
        if (!ignite.affinity(dataCacheName).isPrimary(localNode, cacheEntry.getKey()))
            continue;
        long[] versions = cacheEntry.getKey().versions();
        String[] entitySets = cacheEntry.getValue().entitySets();
        for (int i = 0; i < entitySets.length; i++) {
            EntryProcessorResult<Long> curVer = currentVersions.get(entitySets[i]);
            if (curVer != null && versions[i] < curVer.get())
                keysToRemove.add(cacheEntry.getKey());
        }
    }
    cache.removeAll(keysToRemove);
}",java:S3398,35
"@Override
public byte readBytePositioned(int pos){
    return super.readBytePositioned(pos);
}",java:S1185,15
"public static IndexSpoolNode<Row> createTreeSpool(ExecutionContext<Row> ctx, RelDataType rowType, RelCollation collation, Comparator<Row> comp, Predicate<Row> filter, RangeIterable<Row> ranges){
    RuntimeSortedIndex<Row> idx = new RuntimeSortedIndex<>(ctx, collation, comp);
    ScanNode<Row> scan = new ScanNode<>(ctx, rowType, idx.scan(ctx, rowType, ranges), filter, null);
    return new IndexSpoolNode<>(ctx, rowType, idx, scan);
}",java:S119,17
"public static IndexSpoolNode<Row> createHashSpool(ExecutionContext<Row> ctx, RelDataType rowType, ImmutableBitSet keys, @Nullable Predicate<Row> filter, Supplier<Row> searchRow, boolean allowNulls){
    RuntimeHashIndex<Row> idx = new RuntimeHashIndex<>(ctx, keys, allowNulls);
    ScanNode<Row> scan = new ScanNode<>(ctx, rowType, idx.scan(searchRow), filter, null);
    return new IndexSpoolNode<>(ctx, rowType, idx, scan);
}",java:S119,17
"public static boolean isCustomAffinityMapper(AffinityKeyMapper affinityKeyMapper){
    return affinityKeyMapper != null && !(affinityKeyMapper instanceof CacheDefaultBinaryAffinityKeyMapper) && !(affinityKeyMapper instanceof GridCacheDefaultAffinityKeyMapper);
}",java:S1874,25
"@NotNull
public static MergeJoinNode<Row> create(ExecutionContext<Row> ctx, RelDataType outputRowType, RelDataType leftRowType, RelDataType rightRowType, JoinRelType joinType, Comparator<Row> comp){
    switch(joinType) {
        case INNER:
            return new InnerJoin<>(ctx, outputRowType, comp);
        case LEFT:
            {
                RowHandler.RowFactory<Row> rightRowFactory = ctx.rowHandler().factory(ctx.getTypeFactory(), rightRowType);
                return new LeftJoin<>(ctx, outputRowType, comp, rightRowFactory);
            }
        case RIGHT:
            {
                RowHandler.RowFactory<Row> leftRowFactory = ctx.rowHandler().factory(ctx.getTypeFactory(), leftRowType);
                return new RightJoin<>(ctx, outputRowType, comp, leftRowFactory);
            }
        case FULL:
            {
                RowHandler.RowFactory<Row> leftRowFactory = ctx.rowHandler().factory(ctx.getTypeFactory(), leftRowType);
                RowHandler.RowFactory<Row> rightRowFactory = ctx.rowHandler().factory(ctx.getTypeFactory(), rightRowType);
                return new FullOuterJoin<>(ctx, outputRowType, comp, leftRowFactory, rightRowFactory);
            }
        case SEMI:
            return new SemiJoin<>(ctx, outputRowType, comp);
        case ANTI:
            return new AntiJoin<>(ctx, outputRowType, comp);
        default:
            throw new IllegalStateException(""Join type \"""" + joinType + ""\"" is not supported yet"");
    }
}",java:S119,17
"public LinkedHashMap<String, IndexKeyDefinition> keyDefinitions(){
    return keyDefs;
}",java:S1319,22
"public void start(String[] schemaNames) throws IgniteCheckedException{
    lsnr = schemaChangeListener(ctx);
    idxDescFactory.putAll(IDX_DESC_FACTORY);
    if (!idxDescFactory.containsKey(QueryIndexType.SORTED))
        idxDescFactory.put(QueryIndexType.SORTED, new SortedIndexDescriptorFactory(log));
    ctx.systemView().registerView(SQL_SCHEMA_VIEW, SQL_SCHEMA_VIEW_DESC, new SqlSchemaViewWalker(), schemas.values(), SqlSchemaView::new);
    ctx.systemView().registerView(SQL_TBLS_VIEW, SQL_TBLS_VIEW_DESC, new SqlTableViewWalker(), id2tbl.values(), SqlTableView::new);
    ctx.systemView().registerView(SQL_VIEWS_VIEW, SQL_VIEWS_VIEW_DESC, new SqlViewViewWalker(), sysViews, SqlViewView::new);
    ctx.systemView().registerInnerCollectionView(SQL_IDXS_VIEW, SQL_IDXS_VIEW_DESC, new SqlIndexViewWalker(), id2tbl.values(), t -> t.indexes().values(), SqlIndexView::new);
    ctx.systemView().registerInnerCollectionView(SQL_TBL_COLS_VIEW, SQL_TBL_COLS_VIEW_DESC, new SqlTableColumnViewWalker(), id2tbl.values(), this::tableColumns, SqlTableColumnView::new);
    ctx.systemView().registerInnerCollectionView(SQL_VIEW_COLS_VIEW, SQL_VIEW_COLS_VIEW_DESC, new SqlViewColumnViewWalker(), sysViews, v -> MetricUtils.systemViewAttributes(v).entrySet(), SqlViewColumnView::new);
    lock.writeLock().lock();
    try {
        createSchema(QueryUtils.DFLT_SCHEMA, true);
        createPredefinedSchemas(schemaNames);
    } finally {
        lock.writeLock().unlock();
    }
}",java:S1130,7
"public void add(Object val) throws IgniteCheckedException{
    total++;
    if (val == null) {
        nullsCnt++;
        return;
    }
    addToHll(val);
    if (isComparable) {
        BigDecimal decVal = toDecimal(val);
        if (null == min || min.compareTo(decVal) > 0)
            min = decVal;
        if (null == max || max.compareTo(decVal) < 0)
            max = decVal;
    }
}",java:S1130,7
"private void processGlobalResponse(UUID nodeId, StatisticsResponse resp) throws IgniteCheckedException{
    StatisticsKeyMessage keyMsg = resp.data().key();
    StatisticsKey key = new StatisticsKey(keyMsg.schema(), keyMsg.obj());
    if (log.isDebugEnabled())
        log.debug(""Got global statistics response "" + resp.reqId() + "" from node "" + nodeId + "" by key "" + key);
    UUID reqId = outGlobalStatisticsRequests.get(key);
    if (reqId != null) {
        if (!resp.reqId().equals(reqId)) {
            if (log.isDebugEnabled())
                log.debug(""Got outdated global statistics response "" + resp + "" instead of "" + reqId);
            return;
        }
        ObjectStatisticsImpl data = StatisticsUtils.toObjectStatistics(null, resp.data());
        globalStatistics.put(key, new CacheEntry(data));
        outGlobalStatisticsRequests.remove(key);
    } else {
        if (log.isDebugEnabled())
            log.debug(""Got outdated global statistics response "" + resp);
    }
}",java:S1130,7
"@Override
public ObjectPartitionStatisticsImpl clone(){
    return new ObjectPartitionStatisticsImpl(partId, rowCount(), updCnt, new HashMap<>(columnsStatistics()));
}",java:S1182,14
"@Override
public ObjectStatisticsImpl clone(){
    return new ObjectStatisticsImpl(rowsCnt, new HashMap<>(colNameToStat));
}",java:S1182,14
"public static StatisticsColumnData toMessage(ColumnStatistics stat) throws IgniteCheckedException{
    StatisticsDecimalMessage msgMin = new StatisticsDecimalMessage(stat.min());
    StatisticsDecimalMessage msgMax = new StatisticsDecimalMessage(stat.max());
    return new StatisticsColumnData(msgMin, msgMax, stat.nulls(), stat.distinct(), stat.total(), stat.size(), stat.raw(), stat.version(), stat.createdAt());
}",java:S1130,7
"@Override
public HLL clone() throws CloneNotSupportedException{
    final int copyExpthresh;
    if (explicitAuto)
        copyExpthresh = -1;
    else if (explicitOff)
        copyExpthresh = 0;
    else {
        copyExpthresh = BitUtil.leastSignificantBit(explicitThreshold) + 1;
    }
    final HLL copy = new HLL(log2m, regwidth, copyExpthresh, !sparseOff, type);
    switch(type) {
        case EMPTY:
            break;
        case EXPLICIT:
            copy.explicitStorage = (HashSet<Long>) this.explicitStorage.clone();
            break;
        case SPARSE:
            copy.sparseProbabilisticStorage = (HashMap<Integer, Byte>) this.sparseProbabilisticStorage.clone();
            break;
        case FULL:
            copy.probabilisticStorage = this.probabilisticStorage.clone();
            break;
        default:
            throw new RuntimeException(""Unsupported HLL type "" + type);
    }
    return copy;
}",java:S1182,14
"@Override
public BitVector clone(){
    final BitVector copy = new BitVector(registerWidth, count);
    System.arraycopy(words, 0, copy.words, 0, words.length);
    return copy;
}",java:S1182,14
"private static T instance(Class<? extends T> cls, String clsName) throws IgniteException{
    try {
        Class<?> implCls = Class.forName(clsName);
        if (!cls.isAssignableFrom(implCls))
            throw new IgniteException(""Failed to create instance (target class does not extend or implement "" + ""required class or interface) [cls="" + cls.getName() + "", clsName="" + clsName + ']');
        Constructor<?> ctor = implCls.getConstructor();
        return (T) ctor.newInstance();
    } catch (ClassNotFoundException e) {
        throw new IgniteException(""Failed to find target class: "" + clsName, e);
    } catch (NoSuchMethodException e) {
        throw new IgniteException(""Failed to find constructor for provided arguments "" + ""[clsName="" + clsName + ']', e);
    } catch (InstantiationException e) {
        throw new IgniteException(""Failed to instantiate target class "" + ""[clsName="" + clsName + ']', e);
    } catch (IllegalAccessException e) {
        throw new IgniteException(""Failed to instantiate class (constructor is not available) "" + ""[clsName="" + clsName + ']', e);
    } catch (InvocationTargetException e) {
        throw new IgniteException(""Failed to instantiate class (constructor threw an exception) "" + ""[clsName="" + clsName + ']', e.getCause());
    }
}",java:S3398,35
"private DiscoveryCustomEvent copyIfNeeded(@NotNull DiscoveryCustomEvent evt){
    DiscoveryCustomMessage msg = evt.customMessage();
    assert msg != null : ""DiscoveryCustomMessage has been nullified concurrently, evt="" + evt;
    if (msg instanceof ServiceChangeBatchRequest)
        return evt;
    DiscoveryCustomEvent cp = new DiscoveryCustomEvent();
    cp.node(evt.node());
    cp.customMessage(msg);
    cp.eventNode(evt.eventNode());
    cp.affinityTopologyVersion(evt.affinityTopologyVersion());
    return cp;
}",java:S3398,35
"public ArrayList<ServiceInfo> registeredServices(){
    return registeredServices;
}",java:S1319,22
"public ArrayList<ServiceInfo> services(){
    return staticServicesInfo;
}",java:S1319,22
"private void processTaskSessionRequest(UUID nodeId, GridTaskSessionRequest msg){
    assert nodeId != null;
    assert msg != null;
    lock.readLock();
    try {
        GridTaskWorker<?, ?> task = tasks.get(msg.getSessionId());
        if (stopping && !waiting) {
            U.warn(log, ""Received task session request while stopping grid (will ignore): "" + msg + tryResolveTaskName(task));
            return;
        }
        if (task == null) {
            if (log.isDebugEnabled())
                log.debug(""Received task session request for unknown task (was task already reduced?): "" + msg);
            return;
        }
        boolean loc = ctx.localNodeId().equals(nodeId) && !ctx.config().isMarshalLocalJobs();
        Map<?, ?> attrs = loc ? msg.getAttributes() : U.<Map<?, ?>>unmarshal(marsh, msg.getAttributesBytes(), U.resolveClassLoader(task.getTask().getClass().getClassLoader(), ctx.config()));
        GridTaskSessionImpl ses = task.getSession();
        sendSessionAttributes(attrs, ses);
    } catch (IgniteCheckedException e) {
        U.error(log, ""Failed to deserialize session request: "" + msg, e);
    } finally {
        lock.readUnlock();
    }
}",java:S3398,35
"@NotNull
public static NestedLoopJoinNode<Row> create(ExecutionContext<Row> ctx, RelDataType outputRowType, RelDataType leftRowType, RelDataType rightRowType, JoinRelType joinType, BiPredicate<Row, Row> cond){
    switch(joinType) {
        case INNER:
            return new InnerJoin<>(ctx, outputRowType, cond);
        case LEFT:
            {
                RowHandler.RowFactory<Row> rightRowFactory = ctx.rowHandler().factory(ctx.getTypeFactory(), rightRowType);
                return new LeftJoin<>(ctx, outputRowType, cond, rightRowFactory);
            }
        case RIGHT:
            {
                RowHandler.RowFactory<Row> leftRowFactory = ctx.rowHandler().factory(ctx.getTypeFactory(), leftRowType);
                return new RightJoin<>(ctx, outputRowType, cond, leftRowFactory);
            }
        case FULL:
            {
                RowHandler.RowFactory<Row> leftRowFactory = ctx.rowHandler().factory(ctx.getTypeFactory(), leftRowType);
                RowHandler.RowFactory<Row> rightRowFactory = ctx.rowHandler().factory(ctx.getTypeFactory(), rightRowType);
                return new FullOuterJoin<>(ctx, outputRowType, cond, leftRowFactory, rightRowFactory);
            }
        case SEMI:
            return new SemiJoin<>(ctx, outputRowType, cond);
        case ANTI:
            return new AntiJoin<>(ctx, outputRowType, cond);
        default:
            throw new IllegalStateException(""Join type \"""" + joinType + ""\"" is not supported yet"");
    }
}",java:S119,17
"public static ConcurrentLinkedQueue<Item> queue(){
    return que.get();
}",java:S1319,22
"@Override
public synchronized Object clone() throws CloneNotSupportedException{
    return set.clone();
}",java:S1182,14
"public GridStringBuilder a(char[] str){
    impl.append(str);
    return this;
}",java:S1197,18
"public GridStringBuilder a(char[] str, int offset, int len){
    impl.append(str, offset, len);
    return this;
}",java:S1197,18
"public GridStringBuilder i(int index, char[] str, int off, int len){
    impl.insert(index, str, off, len);
    return this;
}",java:S1197,18
"public GridStringBuilder i(int off, char[] str){
    impl.insert(off, str);
    return this;
}",java:S1197,18
"@Nullable
public static TreeMap<K, V> readTreeMap(ObjectInput in) throws IOException, ClassNotFoundException{
    int size = in.readInt();
    if (size == -1)
        return null;
    TreeMap<K, V> map = new TreeMap<>();
    for (int i = 0; i < size; i++) map.put((K) in.readObject(), (V) in.readObject());
    return map;
}",java:S1319,22
"@Nullable
public static HashMap<K, V> readHashMap(ObjectInput in) throws IOException, ClassNotFoundException{
    int size = in.readInt();
    if (size == -1)
        return null;
    HashMap<K, V> map = U.newHashMap(size);
    for (int i = 0; i < size; i++) map.put((K) in.readObject(), (V) in.readObject());
    return map;
}",java:S1319,22
"@Nullable
public static LinkedHashMap<K, V> readLinkedMap(ObjectInput in) throws IOException, ClassNotFoundException{
    int size = in.readInt();
    if (size == -1)
        return null;
    LinkedHashMap<K, V> map = new LinkedHashMap<>(size, 1.0f);
    for (int i = 0; i < size; i++) map.put((K) in.readObject(), (V) in.readObject());
    return map;
}",java:S1319,22
"private void sendBatch(UUID nodeId, int batchId, boolean last, List<Row> rows) throws IgniteCheckedException{
    exchange.sendBatch(nodeId, queryId(), targetFragmentId, exchangeId, batchId, last, rows);
}",java:S3398,35
"public static void printConcurrentHashMapInfo(ConcurrentHashMap<K, V> map){
    assert map != null;
    Object[] segs = field(map, ""segments"");
    X.println(""Concurrent map stats [identityHash= "" + System.identityHashCode(map) + "", segsCnt="" + segs.length + ']');
    int emptySegsCnt = 0;
    int totalCollisions = 0;
    for (int i = 0; i < segs.length; i++) {
        int segCnt = IgniteUtils.<Integer>field(segs[i], ""count"");
        if (segCnt == 0) {
            emptySegsCnt++;
            continue;
        }
        Object[] tab = field(segs[i], ""table"");
        int tabLen = tab.length;
        X.println(""    Segment-"" + i + "" [count="" + segCnt + "", len="" + tabLen + ']');
        Map<Integer, Integer> bucketsStats = new TreeMap<>();
        for (Object entry : tab) {
            int cnt = 0;
            while (entry != null) {
                cnt++;
                entry = field(entry, ""next"");
            }
            Integer bucketCnt = bucketsStats.get(cnt);
            if (bucketCnt == null)
                bucketCnt = 0;
            bucketCnt++;
            bucketsStats.put(cnt, bucketCnt);
            if (cnt > 1)
                totalCollisions += (cnt - 1);
        }
        for (Map.Entry<Integer, Integer> e : bucketsStats.entrySet()) X.println(""        Buckets with count "" + e.getKey() + "": "" + e.getValue());
    }
    X.println(""    Map summary [emptySegs="" + emptySegsCnt + "", collisions="" + totalCollisions + ']');
}",java:S1319,22
"public static HashMap<K, V> newHashMap(int expSize){
    return new HashMap<>(capacity(expSize));
}",java:S1319,22
"public static LinkedHashMap<K, V> newLinkedHashMap(int expSize){
    return new LinkedHashMap<>(capacity(expSize));
}",java:S1319,22
"public static HashSet<T> newHashSet(int expSize){
    return new HashSet<>(capacity(expSize));
}",java:S1319,22
"private void sendInboxClose(UUID nodeId){
    try {
        exchange.closeInbox(nodeId, queryId(), targetFragmentId, exchangeId);
    } catch (IgniteCheckedException e) {
        U.warn(context().logger(), ""Failed to send cancel message."", e);
    }
}",java:S3398,35
"public static LinkedHashSet<T> newLinkedHashSet(int expSize){
    return new LinkedHashSet<>(capacity(expSize));
}",java:S1319,22
"private static R getUninterruptibly(Future<R> fut) throws ExecutionException{
    boolean interrupted = false;
    try {
        while (true) {
            try {
                return fut.get();
            } catch (InterruptedException e) {
                interrupted = true;
            }
        }
    } finally {
        if (interrupted)
            Thread.currentThread().interrupt();
    }
}",java:S3398,35
"private String measurementUnitShort(){
    switch(measurementUnit) {
        case MILLISECONDS:
            return ""ms"";
        case SECONDS:
            return ""s"";
        case NANOSECONDS:
            return ""ns"";
        case MICROSECONDS:
            return ""mcs"";
        case HOURS:
            return ""h"";
        case MINUTES:
            return ""min"";
        case DAYS:
            return ""days"";
        default:
            return """";
    }
}",java:S3398,35
"@Override
public int compareTo(@NotNull TimeBag.Stage o){
    if (o.time < time)
        return -1;
    if (o.time > time)
        return 1;
    return o.description.compareTo(description);
}",java:S1210,20
"@Override
public int read(byte[] b, int off, int len){
    if (b == null)
        throw new NullPointerException();
    else if (off < 0 || len < 0 || len > b.length - off)
        throw new IndexOutOfBoundsException();
    if (pos >= cnt)
        return -1;
    if (pos + len > cnt)
        len = cnt - pos;
    if (len <= 0)
        return 0;
    U.arrayCopy(buf, pos, b, off, len);
    pos += len;
    return len;
}",java:S1197,18
"@Override
public void write(byte[] b, int off, int len){
    if ((off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length) || ((off + len) < 0))
        throw new IndexOutOfBoundsException();
    else if (len == 0)
        return;
    int newCnt = cnt + len;
    if (newCnt > buf.length)
        buf = Arrays.copyOf(buf, Math.max(buf.length << 1, newCnt));
    U.arrayCopy(b, off, buf, cnt, len);
    cnt = newCnt;
}",java:S1197,18
"private String readLine() throws IOException{
    String line = null;
    int newLineMatchByteCount;
    boolean isLastFilePart = no == 1;
    int i = currentLastBytePos;
    while (i > -1) {
        if (!isLastFilePart && i < avoidNewlineSplitBufferSize) {
            createLeftOver();
            break;
        }
        if ((newLineMatchByteCount = getNewLineMatchByteCount(data, i)) > 0) {
            final int lineStart = i + 1;
            int lineLengthBytes = currentLastBytePos - lineStart + 1;
            if (lineLengthBytes < 0) {
                throw new IllegalStateException(""Unexpected negative line length="" + lineLengthBytes);
            }
            byte[] lineData = new byte[lineLengthBytes];
            System.arraycopy(data, lineStart, lineData, 0, lineLengthBytes);
            line = new String(lineData, encoding);
            currentLastBytePos = i - newLineMatchByteCount;
            break;
        }
        i -= byteDecrement;
        if (i < 0) {
            createLeftOver();
            break;
        }
    }
    if (isLastFilePart && leftOver != null) {
        line = new String(leftOver, encoding);
        leftOver = null;
    }
    return line;
}",java:S1130,7
"@Override
public int read(byte[] b, int off, int len) throws IOException{
    if (b == null)
        throw new NullPointerException();
    if (off < 0 || len < 0 || len > b.length - off)
        throw new IndexOutOfBoundsException();
    if (len == 0)
        return 0;
    if (in != null)
        return in.read(b, off, len);
    else {
        int toRead = Math.min(len, max - this.off);
        System.arraycopy(buf, offset(toRead), b, off, toRead);
        return toRead;
    }
}",java:S1197,18
"private GridNioFuture<?> send(Message msg){
    assert writeBuf.hasArray();
    try {
        int cnt = U.writeMessageFully(msg, endp.outputStream(), writeBuf, writerFactory.writer(ses));
        sentBytesCntMetric.add(cnt);
    } catch (IOException | IgniteCheckedException e) {
        return new GridNioFinishedFuture<Object>(e);
    }
    return new GridNioFinishedFuture<>((Object) null);
}",java:S3398,35
"@Override
public Object clone(){
    return super.clone();
}",java:S1185,15
"@Override
public Object clone(){
    return super.clone();
}",java:S1185,15
"private GridNioFuture<?> pauseResumeReads(GridNioSession ses, NioOperation op){
    assert ses instanceof GridSelectorNioSessionImpl;
    assert op == NioOperation.PAUSE_READ || op == NioOperation.RESUME_READ;
    GridSelectorNioSessionImpl impl = (GridSelectorNioSessionImpl) ses;
    if (impl.closed())
        return new GridNioFinishedFuture(new IOException(""Failed to pause/resume reads "" + ""(connection was closed): "" + ses));
    NioOperationFuture<?> fut = new NioOperationFuture<Void>(impl, op);
    impl.offerStateChange(fut);
    return fut;
}",java:S3398,35
"private void onRequestsWritten(GridSelectorNioSessionImpl ses, List<SessionWriteRequest> requests){
    for (SessionWriteRequest request : requests) {
        request.onMessageWritten();
        onMessageWritten(ses, (Message) request.message());
    }
}",java:S3398,35
"@Override
public MessageReader reader(UUID rmtNodeId, MessageFactory msgFactory){
    throw new IgniteException(""Failed to read message, node is not started."");
}",java:S1874,25
"@Override
public MessageFactory messageFactory(){
    return msgFactory;
}",java:S1874,25
"public static RowTracker<Row> instance(){
    return (RowTracker<Row>) INSTANCE;
}",java:S119,17
"public void setNioSrvWrapper(GridNioServerWrapper nioSrvWrapper){
    this.nioSrvWrapper = nioSrvWrapper;
}",java:S1874,25
"private UUID nodeId(int nodeIdx){
    return nodes.get(nodeIdx).id();
}",java:S3398,35
"private WorkersRegistry getWorkersRegistry(){
    Ignite ignite = spi.ignite();
    return ignite instanceof IgniteEx ? ((IgniteEx) ignite).context().workersRegistry() : null;
}",java:S3398,35
"private TcpDiscoveryDuplicateIdMessage createTcpDiscoveryDuplicateIdMessage(UUID creatorNodeId, TcpDiscoveryNode node){
    TcpDiscoveryDuplicateIdMessage msg;
    if (nodeCompactRepresentationSupported)
        msg = new TcpDiscoveryDuplicateIdMessage(creatorNodeId, node.id());
    else
        msg = new TcpDiscoveryDuplicateIdMessage(creatorNodeId, node);
    return msg;
}",java:S3398,35
"private void interruptPing(TcpDiscoveryNode node){
    for (InetSocketAddress addr : spi.getNodeAddresses(node)) {
        GridPingFutureAdapter fut = pingMap.get(addr);
        if (fut != null && fut.sock != null) {
            if (fut.nodeId == null || fut.nodeId.equals(node.id()))
                U.closeQuiet(fut.sock);
        }
    }
}",java:S3398,35
"private SecurityCredentials unmarshalCredentials(TcpDiscoveryNode node) throws IgniteSpiException{
    try {
        byte[] credBytes = (byte[]) node.getAttributes().get(IgniteNodeAttributes.ATTR_SECURITY_CREDENTIALS);
        if (credBytes == null)
            return null;
        return U.unmarshal(spi.marshaller(), credBytes, null);
    } catch (IgniteCheckedException e) {
        throw new IgniteSpiException(""Failed to unmarshal node security credentials: "" + node.id(), e);
    }
}",java:S3398,35
" String classToTypeName(Class<? extends RelNode> class_){
    if (IgniteRel.class.isAssignableFrom(class_))
        return class_.getSimpleName();
    String canonicalName = class_.getName();
    for (String package_ : PACKAGES) {
        if (canonicalName.startsWith(package_)) {
            String remaining = canonicalName.substring(package_.length());
            if (remaining.indexOf('.') < 0 && remaining.indexOf('$') < 0)
                return remaining;
        }
    }
    return canonicalName;
}",java:S117,12
"private void clearNodeAddedMessage(TcpDiscoveryAbstractMessage msg){
    if (msg instanceof TcpDiscoveryNodeAddedMessage) {
        TcpDiscoveryNodeAddedMessage nodeAddedMsg = (TcpDiscoveryNodeAddedMessage) msg;
        nodeAddedMsg.topology(null);
        nodeAddedMsg.topologyHistory(null);
        nodeAddedMsg.messages(null, null, null);
        nodeAddedMsg.clearUnmarshalledDiscoveryData();
    }
}",java:S3398,35
"private boolean recordable(TcpDiscoveryAbstractMessage msg){
    return !(msg instanceof TcpDiscoveryMetricsUpdateMessage) && !(msg instanceof TcpDiscoveryStatusCheckMessage) && !(msg instanceof TcpDiscoveryDiscardMessage) && !(msg instanceof TcpDiscoveryConnectionCheckMessage);
}",java:S3398,35
"private boolean permissionsEqual(@Nullable SecurityPermissionSet locPerms, @Nullable SecurityPermissionSet rmtPerms){
    if (locPerms == null || rmtPerms == null)
        return false;
    boolean dfltAllowMatch = locPerms.defaultAllowAll() == rmtPerms.defaultAllowAll();
    boolean bothHaveSamePerms = F.eqNotOrdered(rmtPerms.systemPermissions(), locPerms.systemPermissions()) && F.eqNotOrdered(rmtPerms.cachePermissions(), locPerms.cachePermissions()) && F.eqNotOrdered(rmtPerms.taskPermissions(), locPerms.taskPermissions());
    return dfltAllowMatch && bothHaveSamePerms;
}",java:S3398,35
"private void processMessageFailedNodes(TcpDiscoveryAbstractMessage msg){
    Collection<UUID> msgFailedNodes = msg.failedNodes();
    if (msgFailedNodes != null) {
        UUID sndId = msg.senderNodeId();
        if (sndId != null) {
            if (ring.node(sndId) == null) {
                if (log.isDebugEnabled()) {
                    log.debug(""Ignore message failed nodes, sender node is not alive [nodeId="" + sndId + "", failedNodes="" + msgFailedNodes + ']');
                }
                sweepMessageFailedNodes(msg);
                return;
            }
            synchronized (mux) {
                for (TcpDiscoveryNode failedNode : failedNodes.keySet()) {
                    if (failedNode.id().equals(sndId)) {
                        if (log.isDebugEnabled()) {
                            log.debug(""Ignore message failed nodes, sender node is in fail list [nodeId="" + sndId + "", failedNodes="" + msgFailedNodes + ']');
                        }
                        sweepMessageFailedNodes(msg);
                        return;
                    }
                }
            }
        }
        for (UUID nodeId : msgFailedNodes) {
            TcpDiscoveryNode failedNode = ring.node(nodeId);
            if (failedNode != null) {
                if (!failedNode.isLocal()) {
                    boolean added = false;
                    synchronized (mux) {
                        if (!failedNodes.containsKey(failedNode)) {
                            failedNodes.put(failedNode, msg.senderNodeId() != null ? msg.senderNodeId() : getLocalNodeId());
                            added = true;
                        }
                    }
                    if (added && log.isDebugEnabled())
                        log.debug(""Added node to failed nodes list [node="" + failedNode + "", msg="" + msg + ']');
                }
            }
        }
    }
}",java:S3398,35
"private IgniteSpiOperationTimeoutHelper serverOperationTimeoutHelper(@Nullable CrossRingMessageSendState sndState, long lastOperationNanos){
    long absoluteThreshold = -1;
    if (sndState != null)
        absoluteThreshold = Math.min(sndState.failTimeNanos, System.nanoTime() + U.millisToNanos(connCheckTick));
    return new IgniteSpiOperationTimeoutHelper(spi, true, lastOperationNanos, absoluteThreshold);
}",java:S3398,35
"private void updateLastSentMessageTime(){
    lastRingMsgSentTime = System.nanoTime();
}",java:S3398,35
"@Override
public boolean getBoolean(String tag, boolean default_){
    Boolean b = (Boolean) jsonRel.get(tag);
    return b != null ? b : default_;
}",java:S117,12
"private void explain_(RelNode rel, List<Pair<String, Object>> values){
    final Map<String, Object> map = relJson.map();
    map.put(""id"", null);
    map.put(""relOp"", relJson.classToTypeName(rel.getClass()));
    for (Pair<String, Object> value : values) {
        if (value.right instanceof RelNode)
            continue;
        map.put(value.left, relJson.toJson(value.right));
    }
    final List<Object> list = explainInputs(rel.getInputs());
    if (list.size() != 1 || !list.get(0).equals(previousId)) {
        map.put(""inputs"", list);
    }
    final String id = Integer.toString(relIdMap.size());
    relIdMap.put(rel, id);
    map.put(""id"", id);
    relList.add(map);
    previousId = id;
}",java:S100,0
"private static byte[] serializeMetrics(UUID nodeId, ClusterMetrics metrics){
    assert nodeId != null;
    assert metrics != null;
    byte[] buf = new byte[16 + ClusterMetricsSnapshot.METRICS_SIZE];
    U.longToBytes(nodeId.getMostSignificantBits(), buf, 0);
    U.longToBytes(nodeId.getLeastSignificantBits(), buf, 8);
    ClusterMetricsSnapshot.serialize(buf, 16, metrics);
    return buf;
}",java:S3398,35
"private int getWeight(ClusterNode node){
    Integer weight = (Integer) node.attribute(createSpiAttributeName(NODE_WEIGHT_ATTR_NAME));
    if (weight != null && weight == 0)
        throw new IllegalStateException(""Node weight cannot be zero: "" + node);
    return weight == null ? DFLT_NODE_WEIGHT : weight;
}",java:S3398,35
"private void checkRemoveEldestEntry(){
    assert maxCap > 0;
    assert qPlc == SINGLE_Q;
    int sizex = sizex();
    for (int i = maxCap; i < sizex; i++) {
        HashEntry<K, V> e = entryQ.poll();
        if (e != null)
            segmentFor(e.hash).remove(e.key, e.hash, e.val, false);
        else
            return;
        if (sizex() <= maxCap)
            return;
    }
}",java:S3398,35
"private static String encode_base64(byte[] d, int len) throws IllegalArgumentException{
    int off = 0;
    StringBuffer rs = new StringBuffer();
    int c1, c2;
    if (len <= 0 || len > d.length)
        throw new IllegalArgumentException(""Invalid len"");
    while (off < len) {
        c1 = d[off++] & 0xff;
        rs.append(base64_code[(c1 >> 2) & 0x3f]);
        c1 = (c1 & 0x03) << 4;
        if (off >= len) {
            rs.append(base64_code[c1 & 0x3f]);
            break;
        }
        c2 = d[off++] & 0xff;
        c1 |= (c2 >> 4) & 0x0f;
        rs.append(base64_code[c1 & 0x3f]);
        c1 = (c2 & 0x0f) << 2;
        if (off >= len) {
            rs.append(base64_code[c1 & 0x3f]);
            break;
        }
        c2 = d[off++] & 0xff;
        c1 |= (c2 >> 6) & 0x03;
        rs.append(base64_code[c1 & 0x3f]);
        rs.append(base64_code[c2 & 0x3f]);
    }
    return rs.toString();
}",java:S100,0
"private static String encode_base64(byte[] d, int len) throws IllegalArgumentException{
    int off = 0;
    StringBuffer rs = new StringBuffer();
    int c1, c2;
    if (len <= 0 || len > d.length)
        throw new IllegalArgumentException(""Invalid len"");
    while (off < len) {
        c1 = d[off++] & 0xff;
        rs.append(base64_code[(c1 >> 2) & 0x3f]);
        c1 = (c1 & 0x03) << 4;
        if (off >= len) {
            rs.append(base64_code[c1 & 0x3f]);
            break;
        }
        c2 = d[off++] & 0xff;
        c1 |= (c2 >> 4) & 0x0f;
        rs.append(base64_code[c1 & 0x3f]);
        c1 = (c2 & 0x0f) << 2;
        if (off >= len) {
            rs.append(base64_code[c1 & 0x3f]);
            break;
        }
        c2 = d[off++] & 0xff;
        c1 |= (c2 >> 6) & 0x03;
        rs.append(base64_code[c1 & 0x3f]);
        rs.append(base64_code[c2 & 0x3f]);
    }
    return rs.toString();
}",java:S1197,18
"private static byte[] decode_base64(String s, int maxolen) throws IllegalArgumentException{
    StringBuffer rs = new StringBuffer();
    int off = 0, slen = s.length(), olen = 0;
    byte[] ret;
    byte c1, c2, c3, c4, o;
    if (maxolen <= 0)
        throw new IllegalArgumentException(""Invalid maxolen"");
    while (off < slen - 1 && olen < maxolen) {
        c1 = char64(s.charAt(off++));
        c2 = char64(s.charAt(off++));
        if (c1 == -1 || c2 == -1)
            break;
        o = (byte) (c1 << 2);
        o |= (c2 & 0x30) >> 4;
        rs.append((char) o);
        if (++olen >= maxolen || off >= slen)
            break;
        c3 = char64(s.charAt(off++));
        if (c3 == -1)
            break;
        o = (byte) ((c2 & 0x0f) << 4);
        o |= (c3 & 0x3c) >> 2;
        rs.append((char) o);
        if (++olen >= maxolen || off >= slen)
            break;
        c4 = char64(s.charAt(off++));
        o = (byte) ((c3 & 0x03) << 6);
        o |= c4;
        rs.append((char) o);
        ++olen;
    }
    ret = new byte[olen];
    for (off = 0; off < olen; off++) ret[off] = (byte) rs.charAt(off);
    return ret;
}",java:S100,0
"private static int streamtoword(byte[] data, int[] offp){
    int i;
    int word = 0;
    int off = offp[0];
    for (i = 0; i < 4; i++) {
        word = (word << 8) | (data[off] & 0xff);
        off = (off + 1) % data.length;
    }
    offp[0] = off;
    return word;
}",java:S1197,18
"private static int streamtoword(byte[] data, int[] offp){
    int i;
    int word = 0;
    int off = offp[0];
    for (i = 0; i < 4; i++) {
        word = (word << 8) | (data[off] & 0xff);
        off = (off + 1) % data.length;
    }
    offp[0] = off;
    return word;
}",java:S1197,18
"public static String gensalt(int log_rounds, SecureRandom random){
    StringBuffer rs = new StringBuffer();
    byte[] rnd = new byte[BCRYPT_SALT_LEN];
    random.nextBytes(rnd);
    rs.append(""$2a$"");
    if (log_rounds < 10)
        rs.append(""0"");
    if (log_rounds > 30) {
        throw new IllegalArgumentException(""log_rounds exceeds maximum (30)"");
    }
    rs.append(Integer.toString(log_rounds));
    rs.append(""$"");
    rs.append(encode_base64(rnd, rnd.length));
    return rs.toString();
}",java:S117,12
"public static String gensalt(int log_rounds){
    return gensalt(log_rounds, new SecureRandom());
}",java:S117,12
"private final void encipher(int[] lr, int off){
    int i, n, l = lr[off], r = lr[off + 1];
    l ^= P[0];
    for (i = 0; i <= BLOWFISH_NUM_ROUNDS - 2; ) {
        n = S[(l >> 24) & 0xff];
        n += S[0x100 | ((l >> 16) & 0xff)];
        n ^= S[0x200 | ((l >> 8) & 0xff)];
        n += S[0x300 | (l & 0xff)];
        r ^= n ^ P[++i];
        n = S[(r >> 24) & 0xff];
        n += S[0x100 | ((r >> 16) & 0xff)];
        n ^= S[0x200 | ((r >> 8) & 0xff)];
        n += S[0x300 | (r & 0xff)];
        l ^= n ^ P[++i];
    }
    lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
    lr[off + 1] = l;
}",java:S1197,18
"private void init_key(){
    P = (int[]) P_orig.clone();
    S = (int[]) S_orig.clone();
}",java:S100,0
"private void key(byte[] key){
    int i;
    int[] koffp = { 0 };
    int[] lr = { 0, 0 };
    int plen = P.length, slen = S.length;
    for (i = 0; i < plen; i++) P[i] = P[i] ^ streamtoword(key, koffp);
    for (i = 0; i < plen; i += 2) {
        encipher(lr, 0);
        P[i] = lr[0];
        P[i + 1] = lr[1];
    }
    for (i = 0; i < slen; i += 2) {
        encipher(lr, 0);
        S[i] = lr[0];
        S[i + 1] = lr[1];
    }
}",java:S1197,18
"private void ekskey(byte[] data, byte[] key){
    int i;
    int[] koffp = { 0 }, doffp = { 0 };
    int[] lr = { 0, 0 };
    int plen = P.length, slen = S.length;
    for (i = 0; i < plen; i++) P[i] = P[i] ^ streamtoword(key, koffp);
    for (i = 0; i < plen; i += 2) {
        lr[0] ^= streamtoword(data, doffp);
        lr[1] ^= streamtoword(data, doffp);
        encipher(lr, 0);
        P[i] = lr[0];
        P[i + 1] = lr[1];
    }
    for (i = 0; i < slen; i += 2) {
        lr[0] ^= streamtoword(data, doffp);
        lr[1] ^= streamtoword(data, doffp);
        encipher(lr, 0);
        S[i] = lr[0];
        S[i + 1] = lr[1];
    }
}",java:S1197,18
"private void ekskey(byte[] data, byte[] key){
    int i;
    int[] koffp = { 0 }, doffp = { 0 };
    int[] lr = { 0, 0 };
    int plen = P.length, slen = S.length;
    for (i = 0; i < plen; i++) P[i] = P[i] ^ streamtoword(key, koffp);
    for (i = 0; i < plen; i += 2) {
        lr[0] ^= streamtoword(data, doffp);
        lr[1] ^= streamtoword(data, doffp);
        encipher(lr, 0);
        P[i] = lr[0];
        P[i + 1] = lr[1];
    }
    for (i = 0; i < slen; i += 2) {
        lr[0] ^= streamtoword(data, doffp);
        lr[1] ^= streamtoword(data, doffp);
        encipher(lr, 0);
        S[i] = lr[0];
        S[i + 1] = lr[1];
    }
}",java:S1197,18
"public static IgniteDistribution _distribution(RelNode rel, RelMetadataQuery mq){
    assert mq instanceof RelMetadataQueryEx;
    return (IgniteDistribution) mq.distribution(rel);
}",java:S100,0
"public byte[] crypt_raw(byte[] password, byte[] salt, int log_rounds, int[] cdata){
    int rounds, i, j;
    int clen = cdata.length;
    byte[] ret;
    if (log_rounds < 4 || log_rounds > 30)
        throw new IllegalArgumentException(""Bad number of rounds"");
    rounds = 1 << log_rounds;
    if (salt.length != BCRYPT_SALT_LEN)
        throw new IllegalArgumentException(""Bad salt length"");
    init_key();
    ekskey(salt, password);
    for (i = 0; i != rounds; i++) {
        key(password);
        key(salt);
    }
    for (i = 0; i < 64; i++) {
        for (j = 0; j < (clen >> 1); j++) encipher(cdata, j << 1);
    }
    ret = new byte[clen * 4];
    for (i = 0, j = 0; i < clen; i++) {
        ret[j++] = (byte) ((cdata[i] >> 24) & 0xff);
        ret[j++] = (byte) ((cdata[i] >> 16) & 0xff);
        ret[j++] = (byte) ((cdata[i] >> 8) & 0xff);
        ret[j++] = (byte) (cdata[i] & 0xff);
    }
    return ret;
}",java:S117,12
"public byte[] crypt_raw(byte[] password, byte[] salt, int log_rounds, int[] cdata){
    int rounds, i, j;
    int clen = cdata.length;
    byte[] ret;
    if (log_rounds < 4 || log_rounds > 30)
        throw new IllegalArgumentException(""Bad number of rounds"");
    rounds = 1 << log_rounds;
    if (salt.length != BCRYPT_SALT_LEN)
        throw new IllegalArgumentException(""Bad salt length"");
    init_key();
    ekskey(salt, password);
    for (i = 0; i != rounds; i++) {
        key(password);
        key(salt);
    }
    for (i = 0; i < 64; i++) {
        for (j = 0; j < (clen >> 1); j++) encipher(cdata, j << 1);
    }
    ret = new byte[clen * 4];
    for (i = 0, j = 0; i < clen; i++) {
        ret[j++] = (byte) ((cdata[i] >> 24) & 0xff);
        ret[j++] = (byte) ((cdata[i] >> 16) & 0xff);
        ret[j++] = (byte) ((cdata[i] >> 8) & 0xff);
        ret[j++] = (byte) (cdata[i] & 0xff);
    }
    return ret;
}",java:S100,0
"public byte[] crypt_raw(byte[] password, byte[] salt, int log_rounds, int[] cdata){
    int rounds, i, j;
    int clen = cdata.length;
    byte[] ret;
    if (log_rounds < 4 || log_rounds > 30)
        throw new IllegalArgumentException(""Bad number of rounds"");
    rounds = 1 << log_rounds;
    if (salt.length != BCRYPT_SALT_LEN)
        throw new IllegalArgumentException(""Bad salt length"");
    init_key();
    ekskey(salt, password);
    for (i = 0; i != rounds; i++) {
        key(password);
        key(salt);
    }
    for (i = 0; i < 64; i++) {
        for (j = 0; j < (clen >> 1); j++) encipher(cdata, j << 1);
    }
    ret = new byte[clen * 4];
    for (i = 0, j = 0; i < clen; i++) {
        ret[j++] = (byte) ((cdata[i] >> 24) & 0xff);
        ret[j++] = (byte) ((cdata[i] >> 16) & 0xff);
        ret[j++] = (byte) ((cdata[i] >> 8) & 0xff);
        ret[j++] = (byte) (cdata[i] & 0xff);
    }
    return ret;
}",java:S1197,18
"public byte[] crypt_raw(byte[] password, byte[] salt, int log_rounds, int[] cdata){
    int rounds, i, j;
    int clen = cdata.length;
    byte[] ret;
    if (log_rounds < 4 || log_rounds > 30)
        throw new IllegalArgumentException(""Bad number of rounds"");
    rounds = 1 << log_rounds;
    if (salt.length != BCRYPT_SALT_LEN)
        throw new IllegalArgumentException(""Bad salt length"");
    init_key();
    ekskey(salt, password);
    for (i = 0; i != rounds; i++) {
        key(password);
        key(salt);
    }
    for (i = 0; i < 64; i++) {
        for (j = 0; j < (clen >> 1); j++) encipher(cdata, j << 1);
    }
    ret = new byte[clen * 4];
    for (i = 0, j = 0; i < clen; i++) {
        ret[j++] = (byte) ((cdata[i] >> 24) & 0xff);
        ret[j++] = (byte) ((cdata[i] >> 16) & 0xff);
        ret[j++] = (byte) ((cdata[i] >> 8) & 0xff);
        ret[j++] = (byte) (cdata[i] & 0xff);
    }
    return ret;
}",java:S1197,18
"public static FragmentMapping _fragmentMapping(RelNode rel, RelMetadataQuery mq, MappingQueryContext ctx){
    assert mq instanceof RelMetadataQueryEx;
    return ((RelMetadataQueryEx) mq).fragmentMapping(rel, ctx);
}",java:S100,0
"public static void main(String[] args) throws IgniteCheckedException, IOException{
    System.out.println("">>> Decision tree classification trainer example started."");
    try (Ignite ignite = Ignition.start(""examples/config/example-ignite.xml"")) {
        System.out.println("">>> Ignite grid started."");
        CacheConfiguration<?, ?> cacheCfg = new CacheConfiguration<>(DUMMY_CACHE_NAME).setSqlSchema(""PUBLIC"");
        IgniteCache<?, ?> cache = null;
        try {
            cache = ignite.getOrCreateCache(cacheCfg);
            System.out.println("">>> Creating table with training data..."");
            cache.query(new SqlFieldsQuery(""create table titanic_train (\n"" + ""    passengerid int primary key,\n"" + ""    pclass int,\n"" + ""    survived int,\n"" + ""    name varchar(255),\n"" + ""    sex varchar(255),\n"" + ""    age float,\n"" + ""    sibsp int,\n"" + ""    parch int,\n"" + ""    ticket varchar(255),\n"" + ""    fare float,\n"" + ""    cabin varchar(255),\n"" + ""    embarked varchar(255)\n"" + "") with \""template=partitioned\"";"")).getAll();
            System.out.println("">>> Creating table with test data..."");
            cache.query(new SqlFieldsQuery(""create table titanic_test (\n"" + ""    passengerid int primary key,\n"" + ""    pclass int,\n"" + ""    survived int,\n"" + ""    name varchar(255),\n"" + ""    sex varchar(255),\n"" + ""    age float,\n"" + ""    sibsp int,\n"" + ""    parch int,\n"" + ""    ticket varchar(255),\n"" + ""    fare float,\n"" + ""    cabin varchar(255),\n"" + ""    embarked varchar(255)\n"" + "") with \""template=partitioned\"";"")).getAll();
            loadTitanicDatasets(ignite, cache);
            System.out.println("">>> Prepare trainer..."");
            DecisionTreeClassificationTrainer trainer = new DecisionTreeClassificationTrainer(4, 0);
            System.out.println("">>> Perform training..."");
            DecisionTreeModel mdl = trainer.fit(new SqlDatasetBuilder(ignite, ""SQL_PUBLIC_TITANIC_TRAIN""), new BinaryObjectVectorizer<>(""pclass"", ""age"", ""sibsp"", ""parch"", ""fare"").withFeature(""sex"", BinaryObjectVectorizer.Mapping.create().map(""male"", 1.0).defaultValue(0.0)).labeled(""survived""));
            System.out.println(""Tree is here: "" + mdl.toString(true));
            System.out.println("">>> Perform inference..."");
            try (QueryCursor<List<?>> cursor = cache.query(new SqlFieldsQuery(""select "" + ""pclass, "" + ""sex, "" + ""age, "" + ""sibsp, "" + ""parch, "" + ""fare from titanic_test""))) {
                for (List<?> passenger : cursor) {
                    Vector input = VectorUtils.of(new Double[] { asDouble(passenger.get(0)), ""male"".equals(passenger.get(1)) ? 1.0 : 0.0, asDouble(passenger.get(2)), asDouble(passenger.get(3)), asDouble(passenger.get(4)), asDouble(passenger.get(5)) });
                    double prediction = mdl.predict(input);
                    System.out.printf(""Passenger %s will %s.\n"", passenger, prediction == 0 ? ""die"" : ""survive"");
                }
            }
            System.out.println("">>> Example completed."");
        } finally {
            cache.query(new SqlFieldsQuery(""DROP TABLE titanic_train""));
            cache.query(new SqlFieldsQuery(""DROP TABLE titanic_test""));
            cache.destroy();
        }
    } finally {
        System.out.flush();
    }
}",java:S1130,7
"@Override
public void cancel(ServiceContext ctx){
}",java:S1874,25
"@Override
public void init(ServiceContext ctx) throws Exception{
}",java:S1874,25
"@Override
public void execute(ServiceContext ctx) throws Exception{
}",java:S1874,25
"@Override
public void cancel(ServiceContext ctx){
}",java:S1874,25
"@Override
public void init(ServiceContext ctx) throws Exception{
}",java:S1874,25
"@Override
public void execute(ServiceContext ctx) throws Exception{
}",java:S1874,25
"public GridFutureAdapter<?> disabledFunctions(HashSet<String> disabledFuncs) throws IgniteCheckedException{
    return disabledSqlFuncs.propagateAsync(disabledFuncs);
}",java:S1319,22
"public PreparedStatement prepareStatement(String sql, byte qryFlags) throws IgniteCheckedException{
    return delegate.prepareStatement(sql, qryFlags);
}",java:S1130,7
"public PreparedStatement prepareStatementNoCache(String sql) throws IgniteCheckedException{
    boolean insertHack = GridH2Table.insertHackRequired(sql);
    if (insertHack) {
        GridH2Table.insertHack(true);
        try {
            return delegate.prepareStatementNoCache(sql);
        } finally {
            GridH2Table.insertHack(false);
        }
    } else
        return delegate.prepareStatementNoCache(sql);
}",java:S1130,7
"public H2TreeIndex createCopy(InlineIndexImpl inlineIndex, SortedIndexDefinition idxDef) throws IgniteCheckedException{
    return new H2TreeIndex(inlineIndex, tbl, indexColumns, idxDef.primary(), log);
}",java:S1130,7
"public IgniteBiTuple getRow(Object[] args) throws IgniteCheckedException{
    Object key = keyArg.get(args);
    assert key != null;
    Object newVal = newValArg.get(args);
    return new IgniteBiTuple(key, newVal);
}",java:S1130,7
"private void doDeleteFile0(String name, GridLuceneFile file) throws IOException{
    pendingDeletions.add(name);
    file.delete();
}",java:S1130,7
"private void flush() throws IOException{
    setFileLength();
}",java:S1130,7
"public LinkedHashMap<String, GridSqlColumn> columns(){
    return cols;
}",java:S1319,22
"public void columns(LinkedHashMap<String, GridSqlColumn> cols){
    this.cols = cols;
}",java:S1319,22
"public LinkedHashSet<String> primaryKeyColumns(){
    return pkCols;
}",java:S1319,22
"public void primaryKeyColumns(LinkedHashSet<String> pkCols){
    this.pkCols = pkCols;
}",java:S1319,22
"public GridSqlUpdate cols(ArrayList<GridSqlColumn> cols){
    this.cols = cols;
    return this;
}",java:S1319,22
"public ArrayList<GridSqlColumn> cols(){
    return cols;
}",java:S1319,22
"public GridSqlUpdate set(LinkedHashMap<String, GridSqlElement> set){
    this.set = set;
    return this;
}",java:S1319,22
"public LinkedHashMap<String, GridSqlElement> set(){
    return set;
}",java:S1319,22
"public static void findParamsQuery(GridSqlQuery qry, int paramsCnt, TreeSet<Integer> paramIdxs){
    if (qry instanceof GridSqlSelect)
        findParamsSelect((GridSqlSelect) qry, paramsCnt, paramIdxs);
    else {
        GridSqlUnion union = (GridSqlUnion) qry;
        findParamsQuery(union.left(), paramsCnt, paramIdxs);
        findParamsQuery(union.right(), paramsCnt, paramIdxs);
        findParams(qry.limit(), paramsCnt, paramIdxs);
        findParams(qry.offset(), paramsCnt, paramIdxs);
    }
}",java:S1319,22
"private void onBlockEvict(List<Row> evictedBlock){
    assert evictedBlock.size() == PREFETCH_SIZE;
    lastEvictedRow = requireNonNull(last(evictedBlock));
}",java:S3398,35
"public ConcurrentHashMap<Integer, ConcurrentHashMap<Double, Integer>> getCentroidStat(){
    return centroidStat;
}",java:S1319,22
"private static IgniteBiFunction<List<IgniteModel<IS, IA>>, Vector, Vector> getFeatureExtractorForAggregator(IgniteFunction<IA, Vector> submodelOutput2VectorConverter, IgniteFunction<Vector, IS> vector2SubmodelInputConverter){
    return (List<IgniteModel<IS, IA>> subMdls, Vector v) -> {
        Vector[] vs = subMdls.stream().map(sm -> applyToVector(sm, submodelOutput2VectorConverter, vector2SubmodelInputConverter, v)).toArray(Vector[]::new);
        return VectorUtils.concat(vs);
    };
}",java:S119,17
"private static IgniteBiFunction<List<IgniteModel<IS, IA>>, Vector, Vector> getFeatureExtractorForAggregator(IgniteFunction<IA, Vector> submodelOutput2VectorConverter, IgniteFunction<Vector, IS> vector2SubmodelInputConverter){
    return (List<IgniteModel<IS, IA>> subMdls, Vector v) -> {
        Vector[] vs = subMdls.stream().map(sm -> applyToVector(sm, submodelOutput2VectorConverter, vector2SubmodelInputConverter, v)).toArray(Vector[]::new);
        return VectorUtils.concat(vs);
    };
}",java:S119,17
"private static Vector applyToVector(IgniteModel<IS, IA> mdl, IgniteFunction<IA, Vector> submodelOutput2VectorConverter, IgniteFunction<Vector, IS> vector2SubmodelInputConverter, Vector v){
    return vector2SubmodelInputConverter.andThen(mdl::predict).andThen(submodelOutput2VectorConverter).apply(v);
}",java:S119,17
"private static Vector applyToVector(IgniteModel<IS, IA> mdl, IgniteFunction<IA, Vector> submodelOutput2VectorConverter, IgniteFunction<Vector, IS> vector2SubmodelInputConverter, Vector v){
    return vector2SubmodelInputConverter.andThen(mdl::predict).andThen(submodelOutput2VectorConverter).apply(v);
}",java:S119,17
"public void rulesFilter(Function<RuleSet, RuleSet> rulesFilter){
    this.rulesFilter = rulesFilter;
}",java:S4276,41
"public static SimpleDataset<C> createSimpleDataset(DatasetBuilder<K, V> datasetBuilder, LearningEnvironmentBuilder envBuilder, PartitionContextBuilder<K, V, C> partCtxBuilder, Preprocessor<K, V> featureExtractor){
    LearningEnvironment environment = LearningEnvironmentBuilder.defaultBuilder().buildForTrainer();
    environment.initDeployingContext(featureExtractor);
    return create(datasetBuilder, envBuilder, partCtxBuilder, new SimpleDatasetDataBuilder<>(featureExtractor), environment).wrap(SimpleDataset::new);
}",java:S119,17
"public static SimpleDataset<C> createSimpleDataset(Ignite ignite, IgniteCache<K, V> upstreamCache, LearningEnvironmentBuilder envBuilder, PartitionContextBuilder<K, V, C> partCtxBuilder, Preprocessor<K, V> featureExtractor){
    return createSimpleDataset(new CacheBasedDatasetBuilder<>(ignite, upstreamCache), envBuilder, partCtxBuilder, featureExtractor);
}",java:S119,17
"public static SimpleLabeledDataset<C> createSimpleLabeledDataset(DatasetBuilder<K, V> datasetBuilder, LearningEnvironmentBuilder envBuilder, PartitionContextBuilder<K, V, C> partCtxBuilder, Preprocessor<K, V> vectorizer){
    LearningEnvironment environment = LearningEnvironmentBuilder.defaultBuilder().buildForTrainer();
    environment.initDeployingContext(vectorizer);
    return create(datasetBuilder, envBuilder, partCtxBuilder, new SimpleLabeledDatasetDataBuilder<>(vectorizer), environment).wrap(SimpleLabeledDataset::new);
}",java:S119,17
"public static SimpleLabeledDataset<C> createSimpleLabeledDataset(Ignite ignite, IgniteCache<K, V> upstreamCache, LearningEnvironmentBuilder envBuilder, PartitionContextBuilder<K, V, C> partCtxBuilder, Preprocessor<K, V> vectorizer){
    return createSimpleLabeledDataset(new CacheBasedDatasetBuilder<>(ignite, upstreamCache), envBuilder, partCtxBuilder, vectorizer);
}",java:S119,17
"public static SimpleDataset<EmptyContext> createSimpleDataset(DatasetBuilder<K, V> datasetBuilder, LearningEnvironmentBuilder envBuilder, Preprocessor<K, V> featureExtractor){
    return createSimpleDataset(datasetBuilder, envBuilder, new EmptyContextBuilder<>(), featureExtractor);
}",java:S119,17
"public static SimpleDataset<EmptyContext> createSimpleDataset(Ignite ignite, IgniteCache<K, V> upstreamCache, LearningEnvironmentBuilder envBuilder, Preprocessor<K, V> featureExtractor){
    return createSimpleDataset(new CacheBasedDatasetBuilder<>(ignite, upstreamCache), envBuilder, featureExtractor);
}",java:S119,17
"public static SimpleDataset<EmptyContext> createSimpleDataset(Ignite ignite, IgniteCache<K, V> upstreamCache, Preprocessor<K, V> featureExtractor){
    return createSimpleDataset(new CacheBasedDatasetBuilder<>(ignite, upstreamCache), LearningEnvironmentBuilder.defaultBuilder(), featureExtractor);
}",java:S119,17
"public static SimpleLabeledDataset<EmptyContext> createSimpleLabeledDataset(DatasetBuilder<K, V> datasetBuilder, LearningEnvironmentBuilder envBuilder, Preprocessor<K, V> vectorizer){
    return createSimpleLabeledDataset(datasetBuilder, envBuilder, new EmptyContextBuilder<>(), vectorizer);
}",java:S119,17
"@Override
public void onStart(GridKernalContext ctx){
    super.onStart(ctx);
}",java:S1185,15
"public static SimpleLabeledDataset<EmptyContext> createSimpleLabeledDataset(Ignite ignite, LearningEnvironmentBuilder envBuilder, IgniteCache<K, V> upstreamCache, Preprocessor<K, V> vectorizer){
    return createSimpleLabeledDataset(new CacheBasedDatasetBuilder<>(ignite, upstreamCache), envBuilder, vectorizer);
}",java:S119,17
"public static SimpleDataset<C> createSimpleDataset(Map<K, V> upstreamMap, int partitions, LearningEnvironmentBuilder envBuilder, PartitionContextBuilder<K, V, C> partCtxBuilder, Preprocessor<K, V> featureExtractor){
    return createSimpleDataset(new LocalDatasetBuilder<>(upstreamMap, partitions), envBuilder, partCtxBuilder, featureExtractor);
}",java:S119,17
"public static SimpleLabeledDataset<C> createSimpleLabeledDataset(Map<K, V> upstreamMap, int partitions, LearningEnvironmentBuilder envBuilder, PartitionContextBuilder<K, V, C> partCtxBuilder, Preprocessor<K, V> vectorizer){
    return createSimpleLabeledDataset(new LocalDatasetBuilder<>(upstreamMap, partitions), envBuilder, partCtxBuilder, vectorizer);
}",java:S119,17
"public static SimpleDataset<EmptyContext> createSimpleDataset(Map<K, V> upstreamMap, int partitions, LearningEnvironmentBuilder envBuilder, Preprocessor<K, V> featureExtractor){
    return createSimpleDataset(new LocalDatasetBuilder<>(upstreamMap, partitions), envBuilder, featureExtractor);
}",java:S119,17
"public static SimpleLabeledDataset<EmptyContext> createSimpleLabeledDataset(Map<K, V> upstreamMap, LearningEnvironmentBuilder envBuilder, int partitions, Preprocessor<K, V> vectorizer){
    return createSimpleLabeledDataset(new LocalDatasetBuilder<>(upstreamMap, partitions), envBuilder, vectorizer);
}",java:S119,17
"@Override
public void init(ServiceContext ctx){
    Ignite ignite = Ignition.localIgnite();
    reqQueue = ignite.queue(String.format(INFERENCE_REQUEST_QUEUE_NAME_PATTERN, suffix), QUEUE_CAPACITY, queueCfg);
    resQueue = ignite.queue(String.format(INFERENCE_RESPONSE_QUEUE_NAME_PATTERN, suffix), QUEUE_CAPACITY, queueCfg);
    mdl = parser.parse(reader.read());
}",java:S1874,25
"@Override
public void execute(ServiceContext ctx){
    while (!ctx.isCancelled()) {
        I req;
        try {
            req = reqQueue.take();
        } catch (IllegalStateException e) {
            if (!reqQueue.removed())
                throw e;
            continue;
        }
        O res = mdl.predict(req);
        try {
            resQueue.put(res);
        } catch (IllegalStateException e) {
            if (!resQueue.removed())
                throw e;
        }
    }
}",java:S1874,25
"@Override
public void cancel(ServiceContext ctx){
}",java:S1874,25
"@Override
public int compareTo(PointWithDistance o){
    return Double.compare(distance, o.distance);
}",java:S1210,20
"public static T MAX_GENERIC(T a, T b, Comparator<T> f){
    return f.compare(a, b) > 0 ? a : b;
}",java:S100,0
"public static T MIN_GENERIC(T a, T b, Comparator<T> f){
    return f.compare(a, b) < 0 ? a : b;
}",java:S100,0
"@Override
public GDBBinaryClassifierOnTreesTrainer withEnvironmentBuilder(LearningEnvironmentBuilder envBuilder){
    return super.withEnvironmentBuilder(envBuilder);
}",java:S1185,15
"public T withFeaturesCountSelectionStrgy(Function<List<FeatureMeta>, Integer> strgy){
    this.featuresPerTree = strgy.apply(meta);
    return instance();
}",java:S4276,41
" UnionConverterRule.Config withOperandFor(Class<? extends LogicalUnion> union){
    return withOperandSupplier(o0 -> o0.operand(union).anyInputs()).as(UnionConverterRule.Config.class);
}",java:S4968,42
"public Map<NodeId, NodeImpurityHistograms<S>> aggregateImpurityStatistics(ArrayList<RandomForestTreeModel> roots, Map<Integer, BucketMeta> histMeta, Map<NodeId, TreeNode> nodesToLearn, Dataset<EmptyContext, BootstrappedDatasetPartition> dataset){
    return dataset.compute(x -> aggregateImpurityStatisticsOnPartition(x, roots, histMeta, nodesToLearn), this::reduceImpurityStatistics);
}",java:S1319,22
"public void setValuesForLeaves(ArrayList<RandomForestTreeModel> roots, Dataset<EmptyContext, BootstrappedDatasetPartition> dataset){
    Map<NodeId, TreeNode> leafs = roots.stream().flatMap(r -> r.leafs().stream()).collect(Collectors.toMap(TreeNode::getId, Function.identity()));
    Map<NodeId, T> stats = dataset.compute(data -> computeLeafsStatisticsInPartition(roots, leafs, data), this::mergeLeafStatistics);
    leafs.forEach((id, leaf) -> {
        T stat = stats.get(id);
        if (stat != null) {
            double leafVal = computeLeafValue(stat);
            leaf.setVal(leafVal);
        }
    });
}",java:S1319,22
"@Override
public Iterable<Row> scan(ExecutionContext<Row> execCtx, ColocationGroup grp, RangeIterable<Row> ranges, @Nullable ImmutableBitSet requiredColumns){
    UUID locNodeId = execCtx.localNodeId();
    if (grp.nodeIds().contains(locNodeId) && idx != null) {
        return new IndexScan<>(execCtx, tbl.descriptor(), idx.unwrap(InlineIndex.class), collation.getKeys(), grp.partitions(locNodeId), ranges, requiredColumns);
    }
    return Collections.emptyList();
}",java:S119,17
"@Override
public int compareTo(@NotNull Object o){
    return (int) Math.signum(getFitness() - ((Chromosome) o).getFitness());
}",java:S1210,20
"public double calculateFitnessForChromosome(int idx, Function<Chromosome, Double> fitnessFunction){
    double fitness = fitnessFunction.apply(chromosomes[idx]);
    chromosomes[idx].setFitness(fitness);
    fitnessCalculatedFlags.set(idx);
    return fitness;
}",java:S4276,41
"@Test(expected = ConcurrentModificationException.class)
public void testNextWhenIteratorHasLessElementsThanExpected(){
    List<Integer> list = Arrays.asList(1, 2, 3);
    Iterator<Integer> iter = new IteratorWithConcurrentModificationChecker<>(list.iterator(), 4, ""Exception"");
    assertEquals(Integer.valueOf(1), iter.next());
    assertEquals(Integer.valueOf(2), iter.next());
    assertEquals(Integer.valueOf(3), iter.next());
    iter.next();
}",java:S5777,44
"@Test(expected = ConcurrentModificationException.class)
public void testNextWhenIteratorHasMoreElementsThanExpected(){
    List<Integer> list = Arrays.asList(1, 2, 3);
    Iterator<Integer> iter = new IteratorWithConcurrentModificationChecker<>(list.iterator(), 2, ""Exception"");
    assertEquals(Integer.valueOf(1), iter.next());
    assertEquals(Integer.valueOf(2), iter.next());
    iter.next();
}",java:S5777,44
"@Test(expected = ConcurrentModificationException.class)
public void testHasNextWhenIteratorHasLessElementsThanExpected(){
    List<Integer> list = Arrays.asList(1, 2, 3);
    Iterator<Integer> iter = new IteratorWithConcurrentModificationChecker<>(list.iterator(), 4, ""Exception"");
    assertTrue(iter.hasNext());
    iter.next();
    assertTrue(iter.hasNext());
    iter.next();
    assertTrue(iter.hasNext());
    iter.next();
    iter.hasNext();
}",java:S5777,44
"@Override
public Iterable<Row> firstOrLast(boolean first, ExecutionContext<Row> ectx, ColocationGroup grp, @Nullable ImmutableBitSet requiredColumns){
    UUID localNodeId = ectx.localNodeId();
    if (grp.nodeIds().contains(localNodeId) && idx != null) {
        return new IndexFirstLastScan<>(first, ectx, tbl.descriptor(), idx.unwrap(InlineIndexImpl.class), collation.getKeys(), grp.partitions(localNodeId), requiredColumns);
    }
    return Collections.emptyList();
}",java:S119,17
"@Test(expected = ConcurrentModificationException.class)
public void testHasNextWhenIteratorHasMoreElementsThanExpected(){
    List<Integer> list = Arrays.asList(1, 2, 3);
    Iterator<Integer> iter = new IteratorWithConcurrentModificationChecker<>(list.iterator(), 2, ""Exception"");
    assertTrue(iter.hasNext());
    iter.next();
    assertTrue(iter.hasNext());
    iter.next();
    iter.hasNext();
}",java:S5777,44
"@Test(expected = NullPointerException.class)
public void all(){
    assertNotNull(MathTestConstants.NULL_VAL, testVector.all());
    assertNotNull(MathTestConstants.NULL_VAL, getAbstractVector(createStorage()).all());
    getAbstractVector().all().iterator().next();
}",java:S5777,44
"@Test(expected = UnsupportedOperationException.class)
public void mapInvalidArgsTest(){
    assertEquals(""Expect exception due to invalid args."", IMPOSSIBLE_SIZE, new DenseVector(Collections.singletonMap(""invalid"", 99)).size());
}",java:S5777,44
"@Test(expected = UnsupportedOperationException.class)
public void mapMissingArgsTest(){
    final Map<String, Object> test = new HashMap<>();
    test.put(""arr"", new double[0]);
    test.put(""shallowCopyMissing"", ""whatever"");
    assertEquals(""Expect exception due to missing args."", IMPOSSIBLE_SIZE, new DenseVector(test).size());
}",java:S5777,44
"@Test(expected = ClassCastException.class)
public void mapInvalidArrTypeTest(){
    final Map<String, Object> test = Collections.singletonMap(""size"", ""whatever"");
    assertEquals(""Expect exception due to invalid arr type."", IMPOSSIBLE_SIZE, new DenseVector(test).size());
}",java:S5777,44
"@Test(expected = UnsupportedOperationException.class)
public void mapInvalidCopyTypeTest(){
    final Map<String, Object> test = new HashMap<String, Object>();
    test.put(""arr"", new double[0]);
    test.put(""shallowCopy"", 0);
    assertEquals(""Expect exception due to invalid copy type."", IMPOSSIBLE_SIZE, new DenseVector(test).size());
}",java:S5777,44
"@Test(expected = AssertionError.class)
public void mapNullTest(){
    assertEquals(""Null map args."", IMPOSSIBLE_SIZE, new DenseVector((Map<String, Object>) null).size());
}",java:S5777,44
"@Test(expected = AssertionError.class)
public void negativeSizeTest(){
    assertEquals(""Negative size."", IMPOSSIBLE_SIZE, new DenseVector(-1).size());
}",java:S5777,44
"@Test(expected = AssertionError.class)
public void nullCopyTest(){
    assertEquals(""Null array to non-shallow copy."", IMPOSSIBLE_SIZE, new DenseVector(null, false).size());
}",java:S5777,44
"@Test(expected = AssertionError.class)
public void nullDefaultCopyTest(){
    assertEquals(""Null array default copy."", IMPOSSIBLE_SIZE, new DenseVector((double[]) null).size());
}",java:S5777,44
"@Test(expected = NullPointerException.class)
public void defaultConstructorTest(){
    assertEquals(""Default constructor."", IMPOSSIBLE_SIZE, new DenseVector().size());
}",java:S5777,44
"@Test(expected = AssertionError.class)
public void nullArrShallowCopyTest(){
    assertEquals(""Null array shallow copy."", IMPOSSIBLE_SIZE, new DenseVector(null, true).size());
}",java:S5777,44
"@Test(expected = AssertionError.class)
public void parentNullTest(){
    assertEquals(IMPOSSIBLE_SIZE, new VectorizedViewMatrix(null, 1, 1, 1, 1).size());
}",java:S5777,44
"@Test(expected = IndexException.class)
public void rowNegativeTest(){
    assertEquals(IMPOSSIBLE_SIZE, new VectorizedViewMatrix(parent, -1, 1, 1, 1).size());
}",java:S5777,44
"@Test(expected = IndexException.class)
public void colNegativeTest(){
    assertEquals(IMPOSSIBLE_SIZE, new VectorizedViewMatrix(parent, 1, -1, 1, 1).size());
}",java:S5777,44
"@Test(expected = IndexException.class)
public void rowTooLargeTest(){
    assertEquals(IMPOSSIBLE_SIZE, new VectorizedViewMatrix(parent, parent.rowSize() + 1, 1, 1, 1).size());
}",java:S5777,44
"@Test(expected = IndexException.class)
public void colTooLargeTest(){
    assertEquals(IMPOSSIBLE_SIZE, new VectorizedViewMatrix(parent, 1, parent.columnSize() + 1, 1, 1).size());
}",java:S5777,44
"@Test(expected = AssertionError.class)
public void rowStrideNegativeTest(){
    assertEquals(IMPOSSIBLE_SIZE, new VectorizedViewMatrix(parent, 1, 1, -1, 1).size());
}",java:S5777,44
"@Test(expected = AssertionError.class)
public void colStrideNegativeTest(){
    assertEquals(IMPOSSIBLE_SIZE, new VectorizedViewMatrix(parent, 1, 1, 1, -1).size());
}",java:S5777,44
"@Test(expected = AssertionError.class)
public void rowStrideTooLargeTest(){
    assertEquals(IMPOSSIBLE_SIZE, new VectorizedViewMatrix(parent, 1, 1, parent.rowSize() + 1, 1).size());
}",java:S5777,44
"@Override
public Row toRow(ExecutionContext<Row> ectx, CacheDataRow row, RowHandler.RowFactory<Row> factory, @Nullable ImmutableBitSet requiredColumns) throws IgniteCheckedException{
    RowHandler<Row> handler = factory.handler();
    assert handler == ectx.rowHandler();
    Row res = factory.create();
    assert handler.columnCount(res) == (requiredColumns == null ? descriptors.length : requiredColumns.cardinality());
    if (requiredColumns == null) {
        for (int i = 0; i < descriptors.length; i++) {
            CacheColumnDescriptor desc = descriptors[i];
            handler.set(i, res, TypeUtils.toInternal(ectx, desc.value(ectx, cacheContext(), row), desc.storageType()));
        }
    } else {
        for (int i = 0, j = requiredColumns.nextSetBit(0); j != -1; j = requiredColumns.nextSetBit(j + 1), i++) {
            CacheColumnDescriptor desc = descriptors[j];
            handler.set(i, res, TypeUtils.toInternal(ectx, desc.value(ectx, cacheContext(), row), desc.storageType()));
        }
    }
    return res;
}",java:S119,17
"@Test(expected = AssertionError.class)
public void colStrideTooLargeTest(){
    assertEquals(IMPOSSIBLE_SIZE, new VectorizedViewMatrix(parent, 1, 1, 1, parent.columnSize() + 1).size());
}",java:S5777,44
"@Test(expected = AssertionError.class)
public void bothStridesZeroTest(){
    assertEquals(IMPOSSIBLE_SIZE, new VectorizedViewMatrix(parent, 1, 1, 0, 0).size());
}",java:S5777,44
"@Test(expected = AssertionError.class)
public void negativeSizeTest(){
    assertEquals(""Negative size."", IMPOSSIBLE_SIZE, new SparseVector(-1).size());
}",java:S5777,44
"@Test(expected = AssertionError.class)
public void zeroSizeTest(){
    assertEquals(""0 size."", IMPOSSIBLE_SIZE, new SparseVector(0).size());
}",java:S5777,44
"@Test(expected = org.apache.ignite.ml.math.exceptions.preprocessing.IllegalFeatureTypeException.class)
public void testFitWithExceptionOnMissedEncodedFeatureIndex(){
    Map<Integer, Vector> data = new HashMap<>();
    data.put(1, new DenseVector(new Serializable[] { 1.0, ""Monday"", ""September"" }));
    data.put(2, new DenseVector(new Serializable[] { 2.0, ""Monday"", ""August"" }));
    data.put(3, new DenseVector(new Serializable[] { 3.0, ""Monday"", ""August"" }));
    data.put(4, new DenseVector(new Serializable[] { 4.0, ""Friday"", ""June"" }));
    data.put(5, new DenseVector(new Serializable[] { 5.0, ""Friday"", ""June"" }));
    data.put(6, new DenseVector(new Serializable[] { 6.0, ""Sunday"", ""August"" }));
    final Vectorizer<Integer, Vector, Integer, Double> vectorizer = new DummyVectorizer<Integer>(1, 2).labeled(0);
    DatasetBuilder<Integer, Vector> datasetBuilder = new LocalDatasetBuilder<>(data, parts);
    EncoderTrainer<Integer, Vector> strEncoderTrainer = new EncoderTrainer<Integer, Vector>().withEncoderType(EncoderType.STRING_ENCODER).withEncodedFeature(0);
    EncoderPreprocessor<Integer, Vector> preprocessor = strEncoderTrainer.fit(TestUtils.testEnvBuilder(), datasetBuilder, vectorizer);
    assertArrayEquals(new double[] { 0.0, 2.0 }, preprocessor.apply(7, new DenseVector(new Serializable[] { 7.0, ""Monday"", ""September"" })).features().asArray(), 1e-8);
}",java:S5777,44
"@Test(expected = IllegalArgumentException.class)
public void testAggregateWithThreeLabels(){
    BinaryClassificationEvaluationContext<Double> ctx = new BinaryClassificationEvaluationContext<>();
    ctx.aggregate(VectorUtils.of().labeled(-1.0));
    ctx.aggregate(VectorUtils.of().labeled(1.0));
    assertEquals(ctx.getFirstClsLbl(), -1., 0.);
    assertEquals(ctx.getSecondClsLbl(), 1., 0.);
    ctx.aggregate(VectorUtils.of().labeled(0.0));
}",java:S5777,44
"@Override
public ModifyTuple toTuple(ExecutionContext<Row> ectx, Row row, TableModify.Operation op, Object arg) throws IgniteCheckedException{
    switch(op) {
        case INSERT:
            return insertTuple(row, ectx);
        case DELETE:
            return deleteTuple(row, ectx);
        case UPDATE:
            return updateTuple(row, (List<String>) arg, 0, ectx);
        case MERGE:
            return mergeTuple(row, (List<String>) arg, ectx);
        default:
            throw new AssertionError();
    }
}",java:S119,17
"private ModifyTuple insertTuple(Row row, ExecutionContext<Row> ectx) throws IgniteCheckedException{
    Object key = insertKey(row, ectx);
    Object val = insertVal(row, ectx);
    if (cacheContext().binaryMarshaller()) {
        if (key instanceof BinaryObjectBuilder)
            key = ((BinaryObjectBuilder) key).build();
        if (val instanceof BinaryObjectBuilder)
            val = ((BinaryObjectBuilder) val).build();
    }
    typeDesc.validateKeyAndValue(key, val);
    return new ModifyTuple(key, val, TableModify.Operation.INSERT);
}",java:S119,17
"private Object insertKey(Row row, ExecutionContext<Row> ectx) throws IgniteCheckedException{
    RowHandler<Row> handler = ectx.rowHandler();
    Object key = handler.get(keyField, row);
    if (key != null) {
        key = replaceDefault(key, descriptors[QueryUtils.KEY_COL]);
        return TypeUtils.fromInternal(ectx, key, descriptors[QueryUtils.KEY_COL].storageType());
    }
    for (int i = 2; i < descriptors.length; i++) {
        final CacheColumnDescriptor desc = descriptors[i];
        if (!desc.field() || !desc.key())
            continue;
        Object fieldVal = replaceDefault(handler.get(i, row), desc);
        if (fieldVal != null) {
            if (key == null)
                key = newVal(typeDesc.keyTypeName(), typeDesc.keyClass());
            desc.set(key, TypeUtils.fromInternal(ectx, fieldVal, desc.storageType()));
        }
    }
    if (key == null)
        key = descriptors[QueryUtils.KEY_COL].defaultValue();
    return key;
}",java:S119,17
"@Override
public Collection<DataRegionMetrics> dataRegionMetrics(){
    checkIgnite();
    return g.dataRegionMetrics();
}",java:S1874,25
"@Nullable
@Override
public DataRegionMetrics dataRegionMetrics(String memPlcName){
    checkIgnite();
    return g.dataRegionMetrics(memPlcName);
}",java:S1874,25
"@Override
public Collection<MemoryMetrics> memoryMetrics(){
    return DataRegionMetricsAdapter.collectionOf(dataRegionMetrics());
}",java:S1874,25
"@Nullable
@Override
public MemoryMetrics memoryMetrics(String memPlcName){
    return DataRegionMetricsAdapter.valueOf(dataRegionMetrics(memPlcName));
}",java:S1874,25
"private Object insertVal(Row row, ExecutionContext<Row> ectx) throws IgniteCheckedException{
    RowHandler<Row> handler = ectx.rowHandler();
    Object val = handler.get(valField, row);
    if (val == null) {
        val = newVal(typeDesc.valueTypeName(), typeDesc.valueClass());
        for (int i = 2; i < descriptors.length; i++) {
            final CacheColumnDescriptor desc = descriptors[i];
            Object fieldVal = replaceDefault(handler.get(i, row), desc);
            if (desc.field() && !desc.key() && fieldVal != null)
                desc.set(val, TypeUtils.fromInternal(ectx, fieldVal, desc.storageType()));
        }
    } else {
        val = replaceDefault(val, descriptors[QueryUtils.VAL_COL]);
        val = TypeUtils.fromInternal(ectx, val, descriptors[QueryUtils.VAL_COL].storageType());
    }
    return val;
}",java:S119,17
"private ModifyTuple updateTuple(Row row, List<String> updateColList, int offset, ExecutionContext<Row> ectx) throws IgniteCheckedException{
    RowHandler<Row> handler = ectx.rowHandler();
    Object key = Objects.requireNonNull(handler.get(offset + QueryUtils.KEY_COL, row));
    Object val = clone(Objects.requireNonNull(handler.get(offset + QueryUtils.VAL_COL, row)));
    offset += descriptorsMap.size();
    for (int i = 0; i < updateColList.size(); i++) {
        final CacheColumnDescriptor desc = Objects.requireNonNull(descriptorsMap.get(updateColList.get(i)));
        assert !desc.key();
        Object fieldVal = handler.get(i + offset, row);
        if (desc.field())
            desc.set(val, TypeUtils.fromInternal(ectx, fieldVal, desc.storageType()));
        else
            val = TypeUtils.fromInternal(ectx, fieldVal, desc.storageType());
    }
    if (cacheContext().binaryMarshaller() && val instanceof BinaryObjectBuilder)
        val = ((BinaryObjectBuilder) val).build();
    typeDesc.validateKeyAndValue(key, val);
    return new ModifyTuple(key, val, TableModify.Operation.UPDATE);
}",java:S119,17
"private static String getFileUri(String name){
    assert name != null;
    name = name.replace(""\\"", ""/"");
    return ""file://"" + (name.charAt(0) == '/' ? """" : '/') + name;
}",java:S3398,35
"private ModifyTuple mergeTuple(Row row, List<String> updateColList, ExecutionContext<Row> ectx) throws IgniteCheckedException{
    RowHandler<Row> hnd = ectx.rowHandler();
    int rowColumnsCnt = hnd.columnCount(row);
    if (rowColumnsCnt == descriptors.length)
        return insertTuple(row, ectx);
    else if (rowColumnsCnt == descriptors.length + updateColList.size())
        return updateTuple(row, updateColList, 0, ectx);
    else {
        assert rowColumnsCnt == descriptors.length * 2 + updateColList.size() : ""Unexpected columns count: "" + rowColumnsCnt;
        int updateOffset = descriptors.length;
        if (hnd.get(updateOffset + QueryUtils.KEY_COL, row) != null)
            return updateTuple(row, updateColList, updateOffset, ectx);
        else
            return insertTuple(row, ectx);
    }
}",java:S119,17
"private ModifyTuple deleteTuple(Row row, ExecutionContext<Row> ectx){
    Object key = TypeUtils.fromInternal(ectx, ectx.rowHandler().get(QueryUtils.KEY_COL, row), descriptors[QueryUtils.KEY_COL].storageType());
    return new ModifyTuple(Objects.requireNonNull(key), null, TableModify.Operation.DELETE);
}",java:S119,17
"protected void putData(Map<Integer, Integer> vals) throws Exception{
    IgniteCache<Integer, Object> cache = cacheForOperation();
    cache.putAll(vals);
}",java:S1130,7
"private Collection<Cache.Entry<Integer, Object>> executeQuery(double minSalary, double maxSalary) throws Exception{
    IgniteCache<Integer, Object> cache = cacheForOperation(true);
    SqlQuery qry = new SqlQuery(Person.class, ""salary >= ? and salary <= ?"");
    qry.setArgs(minSalary, maxSalary);
    return cache.query(qry).getAll();
}",java:S1130,7
"@Override
public Iterable<Row> scan(ExecutionContext<Row> execCtx, ColocationGroup grp, @Nullable ImmutableBitSet usedColumns){
    UUID locNodeId = execCtx.localNodeId();
    if (grp.nodeIds().contains(locNodeId))
        return new TableScan<>(execCtx, desc, grp.partitions(locNodeId), usedColumns);
    return Collections.emptyList();
}",java:S119,17
"private Collection<Cache.Entry<Integer, Object>> executeQuery(double minSalary, double maxSalary) throws Exception{
    IgniteCache<Integer, Object> cache = cacheForOperation(true);
    SqlQuery qry = new SqlQuery(PersonNoIndex.class, ""salary >= ? and salary <= ?"");
    qry.setArgs(minSalary, maxSalary);
    return cache.query(qry).getAll();
}",java:S1130,7
"private Collection<List<?>> executeQueryJoin(double minSalary, double maxSalary) throws Exception{
    IgniteCache<Integer, Object> cache = cacheForOperation(true);
    SqlFieldsQuery qry = new SqlFieldsQuery(""select p.id, p.orgId, p.firstName, p.lastName, p.salary, o.name "" + ""from Person p "" + ""left join Organization o "" + ""on p.id = o.id "" + ""where salary >= ? and salary <= ?"");
    qry.setArgs(minSalary, maxSalary);
    return cache.query(qry).getAll();
}",java:S1130,7
"@Override
public void onWarmupFinished(){
    super.onWarmupFinished();
}",java:S1185,15
"private Collection<Cache.Entry<Integer, Object>> executeQuery(double minSalary, double maxSalary) throws Exception{
    SqlQuery qry = new SqlQuery(Person.class, ""salary >= ? and salary <= ?"");
    qry.setArgs(minSalary, maxSalary);
    return cache.query(qry).getAll();
}",java:S1130,7
"@Override
public void setUp(BenchmarkConfiguration cfg) throws Exception{
    super.setUp(cfg);
}",java:S1185,15
"private Collection<Cache.Entry<Integer, Object>> executeQuery(double minSalary, double maxSalary) throws Exception{
    IgniteCache<Integer, Object> cache = cacheForOperation(true);
    SqlQuery qry = new SqlQuery(Person.class, ""salary >= ? and salary <= ?"");
    qry.setArgs(minSalary, maxSalary);
    return cache.query(qry).getAll();
}",java:S1130,7
"@Override
public void setUp(BenchmarkConfiguration cfg) throws Exception{
    super.setUp(cfg);
}",java:S1185,15
"@Override
public void setUp(BenchmarkConfiguration cfg) throws Exception{
    super.setUp(cfg);
}",java:S1185,15
"@Override
public void onWarmupFinished(){
    super.onWarmupFinished();
}",java:S1185,15
"private Collection<Cache.Entry<Integer, Object>> executeQuery(double minSalary, double maxSalary) throws Exception{
    SqlQuery qry = new SqlQuery(Person.class, ""salary >= ? and salary <= ?"");
    qry.setArgs(minSalary, maxSalary);
    return cache.query(qry).getAll();
}",java:S1130,7
"@Override
public void setUp(BenchmarkConfiguration cfg) throws Exception{
    super.setUp(cfg);
}",java:S1185,15
"@Override
public void setUp(final BenchmarkConfiguration cfg) throws Exception{
    super.setUp(cfg);
}",java:S1185,15
"private void setQueries() throws IOException, SQLException{
    if (args.loadTestQueriesFile() != null) {
        try (FileReader fr = new FileReader(args.loadTestQueriesFile())) {
            try (BufferedReader br = new BufferedReader(fr)) {
                String line;
                while ((line = br.readLine()) != null) {
                    if (line.trim().isEmpty())
                        continue;
                    dbqueries.add(line.trim());
                }
            }
        }
    }
}",java:S1130,7
"@Override
public void tearDown() throws Exception{
    super.tearDown();
}",java:S1185,15
"private void doPut(IgniteCache<Object, Object> cache) throws Exception{
    int i = nextRandom(args.range());
    cache.put(createRandomKey(i, cache.getName()), createRandomValue(i, cache.getName()));
}",java:S1130,7
"private void doPutAll(IgniteCache<Object, Object> cache) throws Exception{
    Map<Object, Object> putMap = new TreeMap<>();
    Class keyCass = randomKeyClass(cache.getName());
    for (int cnt = 0; cnt < args.batch(); cnt++) {
        int i = nextRandom(args.range());
        putMap.put(ModelUtil.create(keyCass, i), createRandomValue(i, cache.getName()));
    }
    cache.putAll(putMap);
}",java:S1130,7
"private void doGet(IgniteCache<Object, Object> cache) throws Exception{
    int i = nextRandom(args.range());
    cache.get(createRandomKey(i, cache.getName()));
}",java:S1130,7
"private void doGetAll(IgniteCache<Object, Object> cache) throws Exception{
    Set<Object> keys = new TreeSet<>();
    Class keyCls = randomKeyClass(cache.getName());
    for (int cnt = 0; cnt < args.batch(); cnt++) {
        int i = nextRandom(args.range());
        keys.add(ModelUtil.create(keyCls, i));
    }
    cache.getAll(keys);
}",java:S1130,7
"private void doInvoke(final IgniteCache<Object, Object> cache) throws Exception{
    final int i = nextRandom(args.range());
    if (nextBoolean())
        cache.invoke(createRandomKey(i, cache.getName()), replaceEntryProc, createRandomValue(i + 1, cache.getName()));
    else
        cache.invoke(createRandomKey(i, cache.getName()), rmvEntryProc);
}",java:S1130,7
"private void doRemove(IgniteCache<Object, Object> cache) throws Exception{
    int i = nextRandom(args.range());
    cache.remove(createRandomKey(i, cache.getName()));
}",java:S1130,7
"private void doRemoveAll(IgniteCache<Object, Object> cache) throws Exception{
    Set<Object> keys = new TreeSet<>();
    Class keyCls = randomKeyClass(cache.getName());
    for (int cnt = 0; cnt < args.batch(); cnt++) {
        int i = nextRandom(args.range());
        keys.add(ModelUtil.create(keyCls, i));
    }
    cache.removeAll(keys);
}",java:S1130,7
"@Override
public Iterable<Row> scan(ExecutionContext<Row> execCtx, ColocationGroup grp, RangeIterable<Row> ranges, @Nullable ImmutableBitSet requiredColumns){
    return new SystemViewScan<>(execCtx, tbl.descriptor(), ranges, requiredColumns);
}",java:S119,17
"private void doPutIfAbsent(IgniteCache<Object, Object> cache) throws Exception{
    int i = nextRandom(args.range());
    cache.putIfAbsent(createRandomKey(i, cache.getName()), createRandomValue(i, cache.getName()));
}",java:S1130,7
"private void doReplace(IgniteCache<Object, Object> cache) throws Exception{
    int i = nextRandom(args.range());
    cache.replace(createRandomKey(i, cache.getName()), createRandomValue(i, cache.getName()), createRandomValue(i + 1, cache.getName()));
}",java:S1130,7
"private void doContinuousQuery(IgniteCache<Object, Object> cache, Map<Object, Object> map) throws Exception{
    List<QueryCursor> cursors = (ArrayList<QueryCursor>) map.get(cache.getName());
    if (cursors == null) {
        cursors = new ArrayList<>(CONTINUOUS_QUERY_PER_CACHE);
        map.put(cache.getName(), cursors);
    }
    if (cursors.size() == CONTINUOUS_QUERY_PER_CACHE) {
        QueryCursor cursor = cursors.get(nextRandom(cursors.size()));
        cursor.close();
        cursors.remove(cursor);
    }
    ContinuousQuery qry = new ContinuousQuery();
    qry.setLocalListener(new ContinuousQueryUpdater());
    qry.setRemoteFilterFactory(FactoryBuilder.factoryOf(new ContinuousQueryFilter()));
    cursors.add(cache.query(qry));
}",java:S1130,7
" SqlQuery getSqlQuery(int id){
    return new SqlQuery(valCls, makeQueryCondition(id));
}",java:S1874,25
"@Override
public Iterable<Row> firstOrLast(boolean first, ExecutionContext<Row> ectx, ColocationGroup grp, @Nullable ImmutableBitSet requiredColumns){
    throw new IgniteException(""Taking first or last value is not implemented for system view index."");
}",java:S119,17
"@Override
public void cancel(ServiceContext ctx){
}",java:S1874,25
"@Override
public void init(ServiceContext ctx){
}",java:S1874,25
"@Override
public void execute(ServiceContext ctx){
}",java:S1874,25
"@Override
public Row toRow(ExecutionContext<Row> ectx, ViewRow row, RowHandler.RowFactory<Row> factory, @Nullable ImmutableBitSet requiredColumns){
    RowHandler<Row> hnd = factory.handler();
    assert hnd == ectx.rowHandler();
    Row res = factory.create();
    assert hnd.columnCount(res) == (requiredColumns == null ? descriptors.length : requiredColumns.cardinality());
    sysView.walker().visitAll(row, new SystemViewRowAttributeWalker.AttributeWithValueVisitor() {

        private int colIdx;

        @Override
        public <T> void accept(int idx, String name, Class<T> clazz, T val) {
            if (requiredColumns == null || requiredColumns.get(idx))
                hnd.set(colIdx++, res, TypeUtils.toInternal(ectx, val, descriptors[idx].storageType()));
        }

        @Override
        public void acceptBoolean(int idx, String name, boolean val) {
            accept(idx, name, Boolean.class, val);
        }

        @Override
        public void acceptChar(int idx, String name, char val) {
            accept(idx, name, Character.class, val);
        }

        @Override
        public void acceptByte(int idx, String name, byte val) {
            accept(idx, name, Byte.class, val);
        }

        @Override
        public void acceptShort(int idx, String name, short val) {
            accept(idx, name, Short.class, val);
        }

        @Override
        public void acceptInt(int idx, String name, int val) {
            accept(idx, name, Integer.class, val);
        }

        @Override
        public void acceptLong(int idx, String name, long val) {
            accept(idx, name, Long.class, val);
        }

        @Override
        public void acceptFloat(int idx, String name, float val) {
            accept(idx, name, Float.class, val);
        }

        @Override
        public void acceptDouble(int idx, String name, double val) {
            accept(idx, name, Double.class, val);
        }
    });
    return res;
}",java:S119,17
"private void createAsync(String path, byte[] data, CreateMode createMode, AsyncCallback.StringCallback cb){
    if (data == null)
        data = EMPTY_BYTES;
    CreateOperation op = new CreateOperation(path, data, createMode, cb);
    zk.create(path, data, ZK_ACL, createMode, new CreateCallbackWrapper(op), null);
}",java:S3398,35
"private void doReconnect(UUID newId){
    if (rtState.joined) {
        assert rtState.evtsData != null;
        lsnr.onDiscovery(new DiscoveryNotification(EVT_CLIENT_NODE_DISCONNECTED, rtState.evtsData.topVer, locNode, rtState.top.topologySnapshot(), Collections.emptyNavigableMap(), null, null)).get();
    }
    try {
        locNode.onClientDisconnected(newId);
        joinTopology(rtState);
    } catch (Exception e) {
        if (stopping()) {
            if (log.isDebugEnabled())
                log.debug(""Reconnect failed, node is stopping [err="" + e + ']');
            return;
        }
        U.error(log, ""Failed to reconnect: "" + e, e);
        onSegmented(e);
    }
}",java:S3398,35
"private void checkIsCoordinator(final List<String> aliveNodes) throws Exception{
    assert !locNode.isClient();
    TreeMap<Long, String> aliveSrvs = new TreeMap<>();
    long locInternalOrder = rtState.internalOrder;
    for (String aliveNodePath : aliveNodes) {
        if (ZkIgnitePaths.aliveNodeClientFlag(aliveNodePath))
            continue;
        Long internalId = ZkIgnitePaths.aliveInternalId(aliveNodePath);
        aliveSrvs.put(internalId, aliveNodePath);
    }
    assert !aliveSrvs.isEmpty();
    Map.Entry<Long, String> crdE = aliveSrvs.firstEntry();
    if (locInternalOrder == crdE.getKey())
        onBecomeCoordinator(aliveNodes);
    else {
        assert aliveSrvs.size() > 1 : aliveSrvs;
        Map.Entry<Long, String> prevE = aliveSrvs.floorEntry(locInternalOrder - 1);
        assert prevE != null;
        if (log.isInfoEnabled()) {
            log.info(""Discovery coordinator already exists, watch for previous server node ["" + ""locId="" + locNode.id() + "", watchPath="" + prevE.getValue() + ']');
        }
        PreviousNodeWatcher watcher = new ServerPreviousNodeWatcher(rtState);
        rtState.zkClient.existsAsync(ZkIgnitePaths.join(zkPaths.aliveNodesDir, prevE.getValue()), watcher, watcher);
    }
}",java:S3398,35
"@Override
public Iterable<Row> scan(ExecutionContext<Row> execCtx, ColocationGroup grp, @Nullable ImmutableBitSet usedColumns){
    return new SystemViewScan<>(execCtx, desc, null, usedColumns);
}",java:S119,17
"private void checkClientsStatus(final List<String> aliveNodes) throws Exception{
    assert locNode.isClient() : locNode;
    assert rtState.joined;
    assert rtState.evtsData != null;
    TreeMap<Long, String> aliveClients = new TreeMap<>();
    String srvPath = null;
    Long srvInternalOrder = null;
    long locInternalOrder = rtState.internalOrder;
    for (String aliveNodePath : aliveNodes) {
        Long internalId = ZkIgnitePaths.aliveInternalId(aliveNodePath);
        if (ZkIgnitePaths.aliveNodeClientFlag(aliveNodePath))
            aliveClients.put(internalId, aliveNodePath);
        else {
            if (srvInternalOrder == null || internalId < srvInternalOrder) {
                srvPath = aliveNodePath;
                srvInternalOrder = internalId;
            }
        }
    }
    if (!aliveClients.containsKey(locInternalOrder))
        return;
    Map.Entry<Long, String> oldest = aliveClients.firstEntry();
    boolean oldestClient = locInternalOrder == oldest.getKey();
    if (srvPath == null) {
        if (oldestClient) {
            Stat stat = new Stat();
            ZkDiscoveryEventsData prevEvts = rtState.evtsData;
            byte[] evtsBytes = rtState.zkClient.getData(zkPaths.evtsPath, stat);
            assert evtsBytes.length > 0;
            ZkDiscoveryEventsData newEvts = unmarshalZip(evtsBytes);
            if (prevEvts.clusterId.equals(newEvts.clusterId)) {
                U.warn(log, ""All server nodes failed, notify all clients [locId="" + locNode.id() + ']');
                try {
                    generateNoServersEvent(newEvts, stat);
                } catch (KeeperException.BadVersionException ignored) {
                    if (log.isDebugEnabled())
                        log.debug(""Failed to save no servers message. Path version changed."");
                    rtState.zkClient.getChildrenAsync(zkPaths.aliveNodesDir, null, new CheckClientsStatusCallback(rtState));
                }
            } else
                U.warn(log, ""All server nodes failed (received events from new cluster)."");
        }
    } else {
        String watchPath;
        if (oldestClient) {
            watchPath = srvPath;
            if (log.isInfoEnabled()) {
                log.info(""Servers exists, watch for server node [locId="" + locNode.id() + "", watchPath="" + watchPath + ']');
            }
        } else {
            assert aliveClients.size() > 1 : aliveClients;
            Map.Entry<Long, String> prevE = aliveClients.floorEntry(locInternalOrder - 1);
            assert prevE != null;
            watchPath = prevE.getValue();
            if (log.isInfoEnabled()) {
                log.info(""Servers exists, watch for previous node [locId="" + locNode.id() + "", watchPath="" + watchPath + ']');
            }
        }
        PreviousNodeWatcher watcher = new ClientPreviousNodeWatcher(rtState);
        rtState.zkClient.existsAsync(ZkIgnitePaths.join(zkPaths.aliveNodesDir, watchPath), watcher, watcher);
    }
}",java:S3398,35
"private void generateTopologyEvents(List<String> aliveNodes) throws Exception{
    assert rtState.crd;
    if (log.isInfoEnabled())
        log.info(""Process alive nodes change [alives="" + aliveNodes.size() + ""]"");
    if (rtState.updateAlives) {
        aliveNodes = rtState.zkClient.getChildren(zkPaths.aliveNodesDir);
        rtState.updateAlives = false;
    }
    Set<Long> stoppedNodes = new HashSet<>();
    for (String stoppedFlagPath : rtState.zkClient.getChildren(zkPaths.stoppedNodesFlagsDir)) stoppedNodes.add(ZkIgnitePaths.stoppedFlagNodeInternalId(stoppedFlagPath));
    TreeMap<Long, String> alives = new TreeMap<>();
    for (String child : aliveNodes) {
        Long internalId = ZkIgnitePaths.aliveInternalId(child);
        Object old = alives.put(internalId, child);
        assert old == null;
    }
    TreeMap<Long, ZookeeperClusterNode> curTop = new TreeMap<>(rtState.top.nodesByOrder);
    int newEvts = 0;
    final int MAX_NEW_EVTS = IgniteSystemProperties.getInteger(IGNITE_ZOOKEEPER_DISCOVERY_SPI_MAX_EVTS, DFLT_ZOOKEEPER_DISCOVERY_SPI_MAX_EVTS);
    List<ZookeeperClusterNode> failedNodes = null;
    for (Map.Entry<Long, ZookeeperClusterNode> e : rtState.top.nodesByInternalId.entrySet()) {
        if (!alives.containsKey(e.getKey())) {
            ZookeeperClusterNode failedNode = e.getValue();
            if (failedNodes == null)
                failedNodes = new ArrayList<>();
            failedNodes.add(failedNode);
            generateNodeLeave(curTop, failedNode, !stoppedNodes.contains(failedNode.internalId()));
            newEvts++;
            if (newEvts == MAX_NEW_EVTS) {
                saveAndProcessNewEvents();
                if (log.isInfoEnabled()) {
                    log.info(""Delay alive nodes change process, max event threshold reached [newEvts="" + newEvts + "", totalEvts="" + rtState.evtsData.evts.size() + ']');
                }
                handleProcessedEventsOnNodesFail(failedNodes);
                throttleNewEventsGeneration();
                rtState.zkClient.getChildrenAsync(zkPaths.aliveNodesDir, rtState.watcher, rtState.watcher);
                return;
            }
        }
    }
    if (newEvts > 0) {
        saveAndProcessNewEvents();
        handleProcessedEventsOnNodesFail(failedNodes);
        rtState.zkClient.getChildrenAsync(zkPaths.aliveNodesDir, rtState.watcher, rtState.watcher);
        return;
    }
    generateJoinEvents(curTop, alives, MAX_NEW_EVTS);
    if (failedNodes != null)
        handleProcessedEventsOnNodesFail(failedNodes);
}",java:S3398,35
"private void generateCustomEvents(List<String> customEvtNodes) throws Exception{
    assert rtState.crd;
    ZookeeperClient zkClient = rtState.zkClient;
    ZkDiscoveryEventsData evtsData = rtState.evtsData;
    TreeMap<Integer, String> unprocessedEvts = null;
    for (int i = 0; i < customEvtNodes.size(); i++) {
        String evtPath = customEvtNodes.get(i);
        int evtSeq = ZkIgnitePaths.customEventSequence(evtPath);
        if (evtSeq > evtsData.procCustEvt) {
            if (unprocessedEvts == null)
                unprocessedEvts = new TreeMap<>();
            unprocessedEvts.put(evtSeq, evtPath);
        }
    }
    if (unprocessedEvts == null)
        return;
    for (Map.Entry<Integer, String> evtE : unprocessedEvts.entrySet()) {
        evtsData.procCustEvt = evtE.getKey();
        String evtPath = evtE.getValue();
        UUID sndNodeId = ZkIgnitePaths.customEventSendNodeId(evtPath);
        ZookeeperClusterNode sndNode = rtState.top.nodesById.get(sndNodeId);
        if (sndNode != null) {
            byte[] evtBytes = readCustomEventData(zkClient, evtPath, sndNodeId);
            DiscoverySpiCustomMessage msg;
            try {
                msg = unmarshalZip(evtBytes);
            } catch (Exception e) {
                U.error(log, ""Failed to unmarshal custom discovery message: "" + e, e);
                deleteCustomEventDataAsync(rtState.zkClient, evtPath);
                continue;
            }
            generateAndProcessCustomEventOnCoordinator(evtPath, sndNode, msg);
        } else {
            U.warn(log, ""Ignore custom event from unknown node: "" + sndNodeId);
            deleteCustomEventDataAsync(rtState.zkClient, evtPath);
        }
    }
}",java:S3398,35
"private void updateProcessedEventsOnTimeout(ZkRuntimeState rtState, ZkTimeoutObject procEvtsUpdateTo) throws Exception{
    synchronized (stateMux) {
        if (rtState.procEvtsUpdateTo == procEvtsUpdateTo && rtState.locNodeInfo.needUpdate) {
            if (log.isDebugEnabled())
                log.debug(""Update processed events on timeout: "" + rtState.locNodeInfo.lastProcEvt);
            updateProcessedEvents(rtState);
        }
    }
}",java:S3398,35
"private void handleProcessedJoinEventAsync(ZkDiscoveryNodeJoinEventData evtData) throws Exception{
    if (log.isDebugEnabled())
        log.debug(""All nodes processed node join [evtData="" + evtData + ']');
    for (int i = 0; i < evtData.joinedNodes.size(); i++) {
        ZkJoinedNodeEvtData joinedEvtData = evtData.joinedNodes.get(i);
        deleteJoiningNodeData(joinedEvtData.nodeId, joinedEvtData.joinDataPrefixId, joinedEvtData.joinDataPartCnt);
        if (joinedEvtData.secSubjPartCnt > 0) {
            deleteMultiplePartsAsync(rtState.zkClient, zkPaths.joinEventSecuritySubjectPath(evtData.eventId()), joinedEvtData.secSubjPartCnt);
        }
    }
    deleteDataForJoinedAsync(evtData);
}",java:S1130,7
"@Override
public Destination<Row> destination(ExecutionContext<Row> ctx, AffinityService affinityService, ColocationGroup m, ImmutableIntList k){
    throw new AssertionError();
}",java:S119,17
"@Override
public Destination<Row> destination(ExecutionContext<Row> ctx, AffinityService affinityService, ColocationGroup m, ImmutableIntList k){
    assert m != null && !F.isEmpty(m.nodeIds());
    return new AllNodes<>(m.nodeIds());
}",java:S119,17
"@Override
public Destination<Row> destination(ExecutionContext<Row> ctx, AffinityService affinityService, ColocationGroup m, ImmutableIntList k){
    assert m != null && !F.isEmpty(m.nodeIds());
    return new RandomNode<>(m.nodeIds());
}",java:S119,17
"@Override
public Destination<Row> destination(ExecutionContext<Row> ctx, AffinityService affinityService, ColocationGroup m, ImmutableIntList k){
    if (m == null || m.nodeIds() == null || m.nodeIds().size() != 1)
        throw new AssertionError();
    return new AllNodes<>(Collections.singletonList(Objects.requireNonNull(F.first(m.nodeIds()))));
}",java:S119,17
"@Override
public Destination<Row> destination(ExecutionContext<Row> ctx, AffinityService affSrvc, ColocationGroup m, ImmutableIntList k){
    assert m != null && !F.isEmpty(m.assignments()) && !k.isEmpty();
    List<List<UUID>> assignments = m.assignments();
    if (U.assertionsEnabled()) {
        for (List<UUID> assignment : assignments) assert F.isEmpty(assignment) || assignment.size() == 1;
    }
    AffinityAdapter<Row> affinity = new AffinityAdapter<>(affSrvc.affinity(CU.UNDEFINED_CACHE_ID), k.toIntArray(), ctx.rowHandler());
    return new Partitioned<>(assignments, affinity);
}",java:S119,17
"@Override
public Destination<Row> destination(ExecutionContext<Row> ctx, AffinityService affSrvc, ColocationGroup m, ImmutableIntList k){
    assert m != null && !F.isEmpty(m.assignments()) && k.size() == 1;
    List<List<UUID>> assignments = m.assignments();
    if (U.assertionsEnabled()) {
        for (List<UUID> assignment : assignments) assert F.isEmpty(assignment) || assignment.size() == 1;
    }
    AffinityAdapter<Row> affinity = new AffinityAdapter<>(affSrvc.affinity(cacheId), k.toIntArray(), ctx.rowHandler());
    return new Partitioned<>(assignments, affinity);
}",java:S119,17
"@Override
public Destination<Row> destination(ExecutionContext<Row> ctx, AffinityService affSrvc, ColocationGroup target, ImmutableIntList keys){
    throw new AssertionError(""Correlated distribution should be converted to delegate before using"");
}",java:S119,17
"@Override
public Destination<Row> destination(ExecutionContext<Row> ectx, AffinityService affSrvc, ColocationGroup target){
    return function.destination(ectx, affSrvc, target, keys);
}",java:S119,17
"@Override
public boolean getBoolean(String tag, boolean default_){
    return input.getBoolean(tag, default_);
}",java:S117,12
"public static Object getFieldFromBiRows(RowHandler<Row> hnd, int offset, Row row1, Row row2){
    return offset < hnd.columnCount(row1) ? hnd.get(offset, row1) : hnd.get(offset - hnd.columnCount(row1), row2);
}",java:S119,17
"public static Function<Row, Row> resultTypeConverter(ExecutionContext<Row> ectx, RelDataType resultType){
    assert resultType.isStruct();
    if (hasConvertableFields(resultType)) {
        RowHandler<Row> handler = ectx.rowHandler();
        List<RelDataType> types = RelOptUtil.getFieldTypeList(resultType);
        RowHandler.RowFactory<Row> factory = handler.factory(ectx.getTypeFactory(), types);
        List<Function<Object, Object>> converters = transform(types, t -> fieldConverter(ectx, t));
        return r -> {
            Row newRow = factory.create();
            assert handler.columnCount(newRow) == converters.size();
            assert handler.columnCount(r) == converters.size();
            for (int i = 0; i < converters.size(); i++) handler.set(i, newRow, converters.get(i).apply(handler.get(i, r)));
            return newRow;
        };
    }
    return Function.identity();
}",java:S119,17
"public LinkedHashMap<String, String> getFields(){
    return fields;
}",java:S1319,22
"public QueryEntity setFields(LinkedHashMap<String, String> fields){
    this.fields = fields;
    return this;
}",java:S1319,22
"public LinkedHashMap<String, Boolean> getFields(){
    return fields;
}",java:S1319,22
"public QueryIndex setFields(LinkedHashMap<String, Boolean> fields){
    this.fields = fields;
    return this;
}",java:S1319,22
"@Override
public GridJobMetricsProcessor jobMetric(){
    return jobMetricsProc;
}",java:S1874,25
"@Nullable
public MessageFactory messageFactory() throws IgniteCheckedException{
    Class<?> cls;
    if (msgFactoryCls == null || null == (cls = U.classForName(msgFactoryCls, null)))
        return null;
    return (MessageFactory) U.newInstance(cls);
}",java:S1874,25
"@Override
public Collection<DataRegionMetrics> dataRegionMetrics(){
    guard();
    try {
        return ctx.cache().context().database().memoryMetrics();
    } finally {
        unguard();
    }
}",java:S1874,25
"@Nullable
@Override
public DataRegionMetrics dataRegionMetrics(String memPlcName){
    guard();
    try {
        return ctx.cache().context().database().memoryMetrics(memPlcName);
    } finally {
        unguard();
    }
}",java:S1874,25
"@Override
public Collection<MemoryMetrics> memoryMetrics(){
    return DataRegionMetricsAdapter.collectionOf(dataRegionMetrics());
}",java:S1874,25
"@Nullable
@Override
public MemoryMetrics memoryMetrics(String memPlcName){
    return DataRegionMetricsAdapter.valueOf(dataRegionMetrics(memPlcName));
}",java:S1874,25
"private static void convertLegacyDataStorageConfigurationToNew(IgniteConfiguration cfg) throws IgniteCheckedException{
    PersistentStoreConfiguration psCfg = cfg.getPersistentStoreConfiguration();
    boolean persistenceEnabled = psCfg != null;
    DataStorageConfiguration dsCfg = new DataStorageConfiguration();
    MemoryConfiguration memCfg = cfg.getMemoryConfiguration() != null ? cfg.getMemoryConfiguration() : new MemoryConfiguration();
    dsCfg.setConcurrencyLevel(memCfg.getConcurrencyLevel());
    dsCfg.setPageSize(memCfg.getPageSize());
    dsCfg.setSystemDataRegionConfiguration(new SystemDataRegionConfiguration().setInitialSize(memCfg.getSystemCacheInitialSize()).setMaxSize(memCfg.getSystemCacheMaxSize()));
    List<DataRegionConfiguration> optionalDataRegions = new ArrayList<>();
    boolean customDfltPlc = false;
    if (memCfg.getMemoryPolicies() != null) {
        for (MemoryPolicyConfiguration mpc : memCfg.getMemoryPolicies()) {
            DataRegionConfiguration region = new DataRegionConfiguration();
            region.setPersistenceEnabled(persistenceEnabled);
            if (mpc.getInitialSize() != 0L)
                region.setInitialSize(mpc.getInitialSize());
            region.setEmptyPagesPoolSize(mpc.getEmptyPagesPoolSize());
            region.setEvictionThreshold(mpc.getEvictionThreshold());
            region.setMaxSize(mpc.getMaxSize());
            region.setName(mpc.getName());
            region.setPageEvictionMode(mpc.getPageEvictionMode());
            region.setMetricsRateTimeInterval(mpc.getRateTimeInterval());
            region.setMetricsSubIntervalCount(mpc.getSubIntervals());
            region.setSwapPath(mpc.getSwapFilePath());
            region.setMetricsEnabled(mpc.isMetricsEnabled());
            if (persistenceEnabled)
                region.setCheckpointPageBufferSize(psCfg.getCheckpointingPageBufferSize());
            if (mpc.getName() == null) {
                throw new IgniteCheckedException(new IllegalArgumentException(""User-defined MemoryPolicyConfiguration must have non-null and non-empty name.""));
            }
            if (mpc.getName().equals(memCfg.getDefaultMemoryPolicyName())) {
                customDfltPlc = true;
                dsCfg.setDefaultDataRegionConfiguration(region);
            } else
                optionalDataRegions.add(region);
        }
    }
    if (!optionalDataRegions.isEmpty())
        dsCfg.setDataRegionConfigurations(optionalDataRegions.toArray(new DataRegionConfiguration[optionalDataRegions.size()]));
    if (!customDfltPlc) {
        if (!DFLT_MEM_PLC_DEFAULT_NAME.equals(memCfg.getDefaultMemoryPolicyName())) {
            throw new IgniteCheckedException(new IllegalArgumentException(""User-defined default MemoryPolicy "" + ""name must be presented among configured MemoryPolices: "" + memCfg.getDefaultMemoryPolicyName()));
        }
        dsCfg.setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(memCfg.getDefaultMemoryPolicySize()).setName(memCfg.getDefaultMemoryPolicyName()).setPersistenceEnabled(persistenceEnabled));
    } else {
        if (memCfg.getDefaultMemoryPolicySize() != DFLT_MEMORY_POLICY_MAX_SIZE)
            throw new IgniteCheckedException(new IllegalArgumentException(""User-defined MemoryPolicy "" + ""configuration and defaultMemoryPolicySize properties are set at the same time.""));
    }
    if (persistenceEnabled) {
        dsCfg.setCheckpointFrequency(psCfg.getCheckpointingFrequency());
        dsCfg.setCheckpointThreads(psCfg.getCheckpointingThreads());
        dsCfg.setCheckpointWriteOrder(psCfg.getCheckpointWriteOrder());
        dsCfg.setFileIOFactory(psCfg.getFileIOFactory());
        dsCfg.setLockWaitTime(psCfg.getLockWaitTime());
        dsCfg.setStoragePath(psCfg.getPersistentStorePath());
        dsCfg.setMetricsRateTimeInterval(psCfg.getRateTimeInterval());
        dsCfg.setMetricsSubIntervalCount(psCfg.getSubIntervals());
        dsCfg.setWalThreadLocalBufferSize(psCfg.getTlbSize());
        dsCfg.setWalArchivePath(psCfg.getWalArchivePath());
        dsCfg.setWalAutoArchiveAfterInactivity(psCfg.getWalAutoArchiveAfterInactivity());
        dsCfg.setWalFlushFrequency(psCfg.getWalFlushFrequency());
        dsCfg.setWalFsyncDelayNanos(psCfg.getWalFsyncDelayNanos());
        dsCfg.setWalHistorySize(psCfg.getWalHistorySize());
        dsCfg.setWalMode(psCfg.getWalMode());
        dsCfg.setWalRecordIteratorBufferSize(psCfg.getWalRecordIteratorBufferSize());
        dsCfg.setWalSegments(psCfg.getWalSegments());
        dsCfg.setWalSegmentSize(psCfg.getWalSegmentSize());
        dsCfg.setWalPath(psCfg.getWalStorePath());
        dsCfg.setAlwaysWriteFullPages(psCfg.isAlwaysWriteFullPages());
        dsCfg.setMetricsEnabled(psCfg.isMetricsEnabled());
        dsCfg.setWriteThrottlingEnabled(psCfg.isWriteThrottlingEnabled());
    }
    cfg.setDataStorageConfiguration(dsCfg);
}",java:S3398,35
"public ArrayList<Map<Integer, MappedName>> getCachedMappings(){
    int size = allCaches.size();
    ArrayList<Map<Integer, MappedName>> result = new ArrayList<>(size);
    for (int i = 0; i < size; i++) {
        Map res;
        if (i == JAVA_ID)
            res = ((CombinedMap) allCaches.get(JAVA_ID)).userMap;
        else
            res = allCaches.get(i);
        if (res != null && !res.isEmpty())
            result.add(res);
        else
            result.add(Collections.<Integer, MappedName>emptyMap());
    }
    return result;
}",java:S1319,22
"private static PageLockListener create(String name, String type, boolean barrier){
    PageLockTracker tracker;
    switch(type) {
        case ""HeapArrayLockStack"":
            tracker = PageLockTrackerFactory.create(HEAP_STACK, name);
            break;
        case ""HeapArrayLockLog"":
            tracker = PageLockTrackerFactory.create(HEAP_LOG, name);
            break;
        case ""OffHeapLockStack"":
            tracker = PageLockTrackerFactory.create(OFF_HEAP_STACK, name);
            break;
        case ""OffHeapLockLog"":
            tracker = PageLockTrackerFactory.create(OFF_HEAP_LOG, name);
            break;
        default:
            throw new IllegalArgumentException(""type:"" + type);
    }
    return barrier ? tracker : new LockTrackerNoBarrier(tracker);
}",java:S3398,35
"public static EnumSet<E> enumSet(byte[] in, Class<E> enumCls){
    EnumSet<E> set = EnumSet.noneOf(enumCls);
    if (in == null)
        return set;
    final BitSet bSet = BitSet.valueOf(in);
    for (E e : enumCls.getEnumConstants()) {
        if (bSet.get(e.featureId()))
            set.add(e);
    }
    return set;
}",java:S1319,22
"@Override
public BinaryObject clone() throws CloneNotSupportedException{
    return new BinaryArray(ctx, compTypeId, compClsName, arr.clone());
}",java:S1182,14
"@Override
public BinaryObject clone() throws CloneNotSupportedException{
    return new BinaryEnumArray(ctx, compTypeId, compClsName, arr.clone());
}",java:S1182,14
"@Override
public BinaryObject clone() throws CloneNotSupportedException{
    return super.clone();
}",java:S1185,15
"@Override
public BinaryObject clone() throws CloneNotSupportedException{
    return heapCopy();
}",java:S1182,14
"public LinkedHashMap<String, IndexKeyDefinition> keyDefinitions(){
    return keyDefs;
}",java:S1319,22
"private static void storeByOffset(IO io, long pageAddr, int off, DefragIndexRowImpl row){
    int payloadSize = io.inlineSize();
    assert row.link() != 0;
    PageUtils.putBytes(pageAddr, off, row.values);
    IORowHandler.store(pageAddr, off + payloadSize, row, io.storeMvccInfo());
}",java:S119,17
" ProjectionFilters forResultFilter(Function<List<ClusterNode>, List<ClusterNode>> resultFilter){
    if (this == EMPTY_PROJECTION || resultFilter == null)
        return this;
    return new ProjectionFilters(nodeIds, attrs, nodeType, predicate, this.resultFilter == null ? resultFilter : this.resultFilter.andThen(resultFilter));
}",java:S4276,41
"private TR op(ClientOperation op, Consumer<BinaryRawWriterEx> writer, Function<PayloadInputChannel, TR> reader){
    return ch.service(op, out -> {
        try (BinaryRawWriterEx w = serDes.createBinaryWriter(out.out())) {
            writeIdentity(w);
            if (writer != null)
                writer.accept(w);
        }
    }, reader);
}",java:S119,17
"public static EnumSet<ProtocolBitmaskFeature> enumSet(byte[] bytes){
    EnumSet<ProtocolBitmaskFeature> set = EnumSet.noneOf(ProtocolBitmaskFeature.class);
    if (bytes == null)
        return set;
    final BitSet bSet = BitSet.valueOf(bytes);
    for (ProtocolBitmaskFeature e : ProtocolBitmaskFeature.values()) {
        if (bSet.get(e.featureId()))
            set.add(e);
    }
    return set;
}",java:S1319,22
"public static EnumSet<ProtocolBitmaskFeature> allFeaturesAsEnumSet(){
    return ALL_FEATURES_AS_ENUM_SET.clone();
}",java:S1319,22
"public EnumSet<ProtocolBitmaskFeature> features(){
    return features;
}",java:S1319,22
"private QueryCursor<Cache.Entry<K, V>> sqlQuery(SqlQuery qry){
    Consumer<PayloadOutputChannel> qryWriter = payloadCh -> {
        writeCacheInfo(payloadCh);
        BinaryOutputStream out = payloadCh.out();
        serDes.writeObject(out, qry.getType());
        serDes.writeObject(out, qry.getSql());
        ClientUtils.collection(qry.getArgs(), out, serDes::writeObject);
        out.writeBoolean(qry.isDistributedJoins());
        out.writeBoolean(qry.isLocal());
        out.writeBoolean(qry.isReplicatedOnly());
        out.writeInt(qry.getPageSize());
        out.writeLong(qry.getTimeout());
    };
    return new ClientQueryCursor<>(new ClientQueryPager<>(ch, ClientOperation.QUERY_SQL, ClientOperation.QUERY_SQL_CURSOR_GET_PAGE, qryWriter, keepBinary, marsh));
}",java:S1874,25
"private String readString(BinaryInputStream in) throws BinaryObjectException{
    try {
        try (BinaryReaderExImpl r = serDes.createBinaryReader(in)) {
            return r.readString();
        }
    } catch (IOException e) {
        throw new BinaryObjectException(e);
    }
}",java:S3398,35
"public void onActivate() throws IgniteCheckedException{
    if (log.isInfoEnabled())
        log.info(format(AUTO_ADJUST_CONFIGURED_MESSAGE, (isBaselineAutoAdjustEnabled() ? ""enabled"" : ""disabled""), getBaselineAutoAdjustTimeout()));
}",java:S1130,7
"@Override
public int compareTo(@NotNull Object o){
    assert o instanceof Row;
    Row other = (Row) o;
    int res = Integer.compare(grpId, other.grpId);
    if (res == 0) {
        res = Integer.compare(partId, other.partId);
        if (res == 0)
            res = nodeId.compareTo(other.nodeId);
    }
    return res;
}",java:S1210,20
"private AutoCloseable closeable(Object referent, Object resource){
    if (!(resource instanceof AutoCloseable))
        return null;
    return new CloseableReference(referent, resource);
}",java:S3398,35
"public void features(EnumSet<JdbcThinFeature> features){
    this.features = features;
}",java:S1319,22
"public EnumSet<JdbcThinFeature> features(){
    return features;
}",java:S1319,22
"@Override
public int executeUpdate(String sql, int[] columnIndexes) throws SQLException{
    throw new SQLException(""The method 'executeUpdate(String, int[])' is called on PreparedStatement instance."", SqlStateCode.UNSUPPORTED_OPERATION);
}",java:S1197,18
"@Override
public int executeUpdate(String sql, String[] columnNames) throws SQLException{
    throw new SQLException(""The method 'executeUpdate(String, String[])' is called on PreparedStatement "" + ""instance."", SqlStateCode.UNSUPPORTED_OPERATION);
}",java:S1197,18
"private HandshakeResult handshake_2_1_0() throws IOException, SQLException{
    BinaryWriterExImpl writer = new BinaryWriterExImpl(null, new BinaryHeapOutputStream(HANDSHAKE_MSG_SIZE), null, null);
    writer.writeByte((byte) ClientListenerRequest.HANDSHAKE);
    writer.writeShort(VER_2_1_0.major());
    writer.writeShort(VER_2_1_0.minor());
    writer.writeShort(VER_2_1_0.maintenance());
    writer.writeByte(ClientListenerNioListener.JDBC_CLIENT);
    writer.writeBoolean(connProps.isDistributedJoins());
    writer.writeBoolean(connProps.isEnforceJoinOrder());
    writer.writeBoolean(connProps.isCollocated());
    writer.writeBoolean(connProps.isReplicatedOnly());
    writer.writeBoolean(connProps.isAutoCloseServerCursor());
    send(writer.array());
    BinaryReaderExImpl reader = new BinaryReaderExImpl(null, new BinaryHeapInputStream(read()), null, null, false);
    boolean accepted = reader.readBoolean();
    if (accepted) {
        HandshakeResult handshakeRes = new HandshakeResult();
        handshakeRes.igniteVersion(new IgniteProductVersion((byte) 2, (byte) 1, (byte) 0, ""Unknown"", 0L, null));
        handshakeRes.serverProtocolVersion(VER_2_1_0);
        return handshakeRes;
    } else {
        short maj = reader.readShort();
        short min = reader.readShort();
        short maintenance = reader.readShort();
        String err = reader.readString();
        ClientListenerProtocolVersion ver = ClientListenerProtocolVersion.create(maj, min, maintenance);
        throw new SQLException(""Handshake failed [driverProtocolVer="" + CURRENT_VER + "", remoteNodeProtocolVer="" + ver + "", err="" + err + ']', SqlStateCode.CONNECTION_REJECTED);
    }
}",java:S100,0
"@Override
public void sendBatch(UUID nodeId, UUID qryId, long fragmentId, long exchangeId, int batchId, boolean last, List<Row> rows) throws IgniteCheckedException{
    messageService().send(nodeId, new QueryBatchMessage(qryId, fragmentId, exchangeId, batchId, last, Commons.cast(rows)));
    if (batchId == 0) {
        Query<?> qry = qryRegistry.query(qryId);
        if (qry != null)
            qry.onOutboundExchangeStarted(nodeId, exchangeId);
    }
}",java:S119,17
"protected GridClientNode defaultNode() throws GridClientException{
    return CommandUtils.clusterToClientNode(ignite.localNode());
}",java:S1130,7
"private static boolean hasAtLeastOneIndex(Map<String, Set<String>> cacheToIndexes){
    return cacheToIndexes.values().stream().anyMatch(indexes -> !indexes.isEmpty());
}",java:S3398,35
"private static void makeResult(Map<Boolean, List<IgniteBiTuple<Integer, String>>> res, boolean flag, StringBuilder resStr, String msg){
    if (!res.containsKey(flag))
        return;
    resStr.append(""\n    "").append(msg);
    res.get(flag).forEach(t -> resStr.append(""      Partition "").append(t.get1()).append(' ').append(t.get2()).append('\n'));
}",java:S3398,35
"private static TxVerboseInfo createVerboseInfo(IgniteEx ignite, IgniteInternalTx locTx){
    TxVerboseInfo res = new TxVerboseInfo();
    res.nearXidVersion(locTx.nearXidVersion());
    Map<Integer, String> usedCaches = new HashMap<>();
    Map<Integer, String> usedCacheGroups = new HashMap<>();
    ClusterNode locNode = ignite.context().discovery().localNode();
    res.localNodeId(locNode.id());
    res.localNodeConsistentId(locNode.consistentId());
    if (locTx instanceof GridNearTxLocal) {
        IgniteTxMappings mappings = ((GridNearTxLocal) locTx).mappings();
        List<IgniteTxEntry> nearOnlyEntries = new ArrayList<>();
        List<IgniteTxEntry> locEntries = new ArrayList<>();
        for (GridDistributedTxMapping mapping : mappings.mappings()) {
            if (F.eqNodes(mapping.primary(), locNode))
                locEntries.addAll(mapping.entries());
            else
                nearOnlyEntries.addAll(mapping.entries());
        }
        res.nearNodeId(locNode.id());
        res.nearNodeConsistentId(locNode.consistentId());
        res.txMappingType(TxMappingType.NEAR);
        List<TxVerboseKey> nearOnlyTxKeys = fetchTxEntriesAndFillUsedCaches(ignite, locTx, usedCaches, usedCacheGroups, nearOnlyEntries, true);
        List<TxVerboseKey> locTxKeys = fetchTxEntriesAndFillUsedCaches(ignite, locTx, usedCaches, usedCacheGroups, locEntries, false);
        res.nearOnlyTxKeys(nearOnlyTxKeys);
        res.localTxKeys(locTxKeys);
    } else if (locTx instanceof GridDhtTxLocal) {
        UUID nearNodeId = locTx.masterNodeIds().iterator().next();
        DiscoCache discoCache = ignite.context().discovery().discoCache(locTx.topologyVersion());
        if (discoCache == null)
            discoCache = ignite.context().discovery().discoCache();
        ClusterNode nearNode = discoCache.node(nearNodeId);
        res.nearNodeId(nearNodeId);
        res.nearNodeConsistentId(nearNode.consistentId());
        res.txMappingType(TxMappingType.DHT);
        res.localTxKeys(fetchTxEntriesAndFillUsedCaches(ignite, locTx, usedCaches, usedCacheGroups, locTx.allEntries(), false));
    } else if (locTx instanceof GridDhtTxRemote) {
        Iterator<UUID> masterNodesIter = locTx.masterNodeIds().iterator();
        UUID nearNodeId = masterNodesIter.next();
        UUID dhtNodeId = masterNodesIter.next();
        DiscoCache discoCache = ignite.context().discovery().discoCache(locTx.topologyVersion());
        if (discoCache == null)
            discoCache = ignite.context().discovery().discoCache();
        ClusterNode nearNode = discoCache.node(nearNodeId);
        ClusterNode dhtNode = discoCache.node(dhtNodeId);
        res.nearNodeId(nearNodeId);
        res.nearNodeConsistentId(nearNode.consistentId());
        res.txMappingType(TxMappingType.REMOTE);
        res.dhtNodeId(dhtNodeId);
        res.dhtNodeConsistentId(dhtNode.consistentId());
        res.localTxKeys(fetchTxEntriesAndFillUsedCaches(ignite, locTx, usedCaches, usedCacheGroups, locTx.allEntries(), false));
    }
    res.usedCaches(usedCaches);
    res.usedCacheGroups(usedCacheGroups);
    return res;
}",java:S3398,35
"private static long getIndex(File file){
    return Long.parseLong(file.getName().substring(0, 16));
}",java:S3398,35
"@Override
public MessageFactory messageFactory(){
    return ctx.io().messageFactory();
}",java:S1874,25
"public MessageFactory messageFactory(){
    assert msgFactory != null;
    return msgFactory;
}",java:S1874,25
"@Override
public MessageReader reader(UUID rmtNodeId, MessageFactory msgFactory) throws IgniteCheckedException{
    return new DirectMessageReader(msgFactory, rmtNodeId != null ? U.directProtocolVersion(ctx, rmtNodeId) : DIRECT_PROTO_VER);
}",java:S1874,25
"private boolean isPairedConnection(ClusterNode node, TcpCommunicationSpi tcpCommSpi){
    return tcpCommSpi.isUsePairedConnections() && Boolean.TRUE.equals(node.attribute(U.spiAttribute(tcpCommSpi, ATTR_PAIRED_CONN)));
}",java:S3398,35
"private IgniteInternalFuture<Channel> openChannel(UUID nodeId, Object topic, Message initMsg) throws IgniteCheckedException{
    assert nodeId != null;
    assert topic != null;
    assert !locNodeId.equals(nodeId) : ""Channel cannot be opened to the local node itself: "" + nodeId;
    assert (CommunicationSpi) getSpi() instanceof TcpCommunicationSpi : ""Only TcpCommunicationSpi supports direct "" + ""connections between nodes: "" + getSpi().getClass();
    ClusterNode node = ctx.discovery().node(nodeId);
    if (node == null)
        throw new ClusterTopologyCheckedException(""Failed to open a new channel to remote node (node left): "" + nodeId);
    int topicOrd = topic instanceof GridTopic ? ((Enum<GridTopic>) topic).ordinal() : -1;
    GridIoMessage ioMsg = createGridIoMessage(topic, topicOrd, initMsg, PUBLIC_POOL, false, 0, false);
    try {
        if (topicOrd < 0)
            ioMsg.topicBytes(U.marshal(marsh, topic));
        return ((TcpCommunicationSpi) (CommunicationSpi) getSpi()).openChannel(node, ioMsg);
    } catch (IgniteSpiException e) {
        if (e.getCause() instanceof ClusterTopologyCheckedException)
            throw (ClusterTopologyCheckedException) e.getCause();
        if (!ctx.discovery().alive(node))
            throw new ClusterTopologyCheckedException(""Failed to create channel (node left): "" + node.id(), e);
        throw new IgniteCheckedException(""Failed to create channel (node may have left the grid or "" + ""TCP connection cannot be established due to unknown issues) "" + ""[node="" + node + "", topic="" + topic + ']', e);
    }
}",java:S3398,35
"public GridJobMetrics jobMetrics(){
    if (jobMetrics == null)
        synchronized (jobMetricsMux) {
            if (jobMetrics == null) {
                jobMetricsUpdateTime = U.currentTimeMillis();
                jobMetrics = ctx.jobMetric().getJobMetrics();
            }
        }
    return jobMetrics;
}",java:S1874,25
"private int nodeJavaMajorVersion(ClusterNode node) throws IgniteCheckedException{
    String verStr = node.<String>attribute(""java.version"");
    int res = U.majorJavaVersion(verStr);
    if (res == 0) {
        U.error(log, ""Failed to get java major version (unknown 'java.version' format) [ver="" + node.<String>attribute(""java.version"") + ""]"");
    }
    return res;
}",java:S1130,7
"private static OASClientConfig extractClientDetails(IDLSourceGeneratorContext context, Path openAPI, NodeList<AnnotationNode> annotations) throws IOException, BallerinaOpenApiException{
    OASClientConfig.Builder clientMetaDataBuilder = new OASClientConfig.Builder();
    clientMetaDataBuilder.withPlugin(true);
    Filter filter = new Filter();
    if (annotations == null) {
        OpenAPI openAPIDef = normalizeOpenAPI(openAPI, false);
        clientMetaDataBuilder.withOpenAPI(openAPIDef);
        return clientMetaDataBuilder.build();
    }
    boolean isResources = true;
    for (AnnotationNode annotationNode : annotations) {
        Node refNode = annotationNode.annotReference();
        boolean isNodeExist = refNode.toString().trim().equals(OPENAPI_CLIENT_REFERENCE);
        if (!isNodeExist) {
            continue;
        }
        Optional<MappingConstructorExpressionNode> annotFields = annotationNode.annotValue();
        if (annotFields.isEmpty()) {
            continue;
        }
        for (MappingFieldNode field : annotFields.get().fields()) {
            if (!(field instanceof SpecificFieldNode)) {
                continue;
            }
            SpecificFieldNode specificField = (SpecificFieldNode) field;
            Optional<ExpressionNode> expressionNode = specificField.valueExpr();
            if (expressionNode.isEmpty()) {
                continue;
            }
            ExpressionNode expression = expressionNode.get();
            ListConstructorExpressionNode list;
            List<String> values = new ArrayList<>();
            if (expression instanceof ListConstructorExpressionNode) {
                list = (ListConstructorExpressionNode) expression;
                values = extractListValues(list);
            }
            Node fieldName = specificField.fieldName();
            String attributeName = ((Token) fieldName).text();
            switch(attributeName) {
                case TAGS:
                    filter.setTags(values);
                    break;
                case OPERATIONS:
                    filter.setOperations(values);
                    break;
                case NULLABLE:
                    clientMetaDataBuilder.withNullable(expression.toString().contains(TRUE));
                    break;
                case IS_RESOURCE:
                    isResources = expression.toString().contains(TRUE);
                    clientMetaDataBuilder.withResourceMode(isResources);
                    break;
                case LICENSE:
                    clientMetaDataBuilder.withLicense(expression.kind() == SyntaxKind.STRING_LITERAL && !expression.toString().isBlank() ? getLicenseContent(context, Paths.get(getStringValue((BasicLiteralNode) expression))) : """");
                    break;
                default:
                    break;
            }
        }
    }
    clientMetaDataBuilder.withFilters(filter);
    OpenAPI openAPIDef = normalizeOpenAPI(openAPI, !isResources);
    clientMetaDataBuilder.withOpenAPI(openAPIDef);
    return clientMetaDataBuilder.build();
}",java:S3776,39
"private static void extractPathParameterDetails(Operation operation, List<Node> functionRelativeResourcePath, String pathNode, String pathParam, List<Node> resourceFunctionDocs) throws BallerinaOpenApiException{
    String[] split = pathNode.split(CLOSE_CURLY_BRACE, 2);
    Pattern pattern = Pattern.compile(SPECIAL_CHARACTERS_REGEX);
    Matcher matcher = pattern.matcher(split[1]);
    boolean hasSpecialCharacter = matcher.find();
    for (Parameter parameter : operation.getParameters()) {
        if (parameter.getIn() == null) {
            break;
        }
        if (pathParam.trim().equals(getValidName(parameter.getName().trim(), false)) && parameter.getIn().equals(""path"")) {
            String paramType;
            if (parameter.getSchema().get$ref() != null) {
                paramType = getValidName(extractReferenceType(parameter.getSchema().get$ref()), true);
            } else {
                paramType = convertOpenAPITypeToBallerina(parameter.getSchema());
                if (paramType.endsWith(NILLABLE)) {
                    throw new BallerinaOpenApiException(""Path parameter value cannot be null."");
                }
            }
            BuiltinSimpleNameReferenceNode builtSNRNode = createBuiltinSimpleNameReferenceNode(null, parameter.getSchema() == null ? createIdentifierToken(STRING) : createIdentifierToken(paramType));
            IdentifierToken paramName = createIdentifierToken(hasSpecialCharacter ? getValidName(pathNode, false) : pathParam);
            ResourcePathParameterNode resourcePathParameterNode = createResourcePathParameterNode(SyntaxKind.RESOURCE_PATH_SEGMENT_PARAM, createToken(OPEN_BRACKET_TOKEN), NodeFactory.createEmptyNodeList(), builtSNRNode, null, paramName, createToken(CLOSE_BRACKET_TOKEN));
            functionRelativeResourcePath.add(resourcePathParameterNode);
            functionRelativeResourcePath.add(createToken(SLASH_TOKEN));
            if (resourceFunctionDocs != null) {
                String parameterName = paramName.text();
                String paramComment = parameter.getDescription() != null && !parameter.getDescription().isBlank() ? parameter.getDescription() : DEFAULT_PARAM_COMMENT;
                MarkdownParameterDocumentationLineNode paramAPIDoc = DocCommentsGenerator.createAPIParamDoc(parameterName, paramComment);
                resourceFunctionDocs.add(paramAPIDoc);
            }
            break;
        }
    }
}",java:S3776,39
"public void createComponentSchema(Map<String, Schema> schema, TypeSymbol typeSymbol){
    if (schema == null) {
        schema = new HashMap<>();
    }
    String componentName = ConverterCommonUtils.unescapeIdentifier(typeSymbol.getName().orElseThrow().trim());
    Map<String, String> apiDocs = getRecordFieldsAPIDocsMap((TypeReferenceTypeSymbol) typeSymbol, componentName);
    String typeDoc = null;
    if (apiDocs.size() > 0) {
        typeDoc = apiDocs.get(typeSymbol.getName().get());
    }
    TypeReferenceTypeSymbol typeRef = (TypeReferenceTypeSymbol) typeSymbol;
    TypeSymbol type = typeRef.typeDescriptor();
    if (type.typeKind() == TypeDescKind.INTERSECTION) {
        type = excludeReadonlyIfPresent(type);
    }
    switch(type.typeKind()) {
        case RECORD:
            handleRecordTypeSymbol((RecordTypeSymbol) type, schema, componentName, apiDocs);
            break;
        case TYPE_REFERENCE:
            schema.put(componentName, new ObjectSchema().$ref(ConverterCommonUtils.unescapeIdentifier(type.getName().orElseThrow().trim())));
            components.setSchemas(schema);
            TypeReferenceTypeSymbol referredType = (TypeReferenceTypeSymbol) type;
            if (!visitedTypeDefinitionNames.contains(componentName)) {
                visitedTypeDefinitionNames.add(componentName);
                createComponentSchema(schema, referredType);
            }
            break;
        case STRING:
            schema.put(componentName, new StringSchema().description(typeDoc));
            components.setSchemas(schema);
            break;
        case JSON:
        case XML:
            schema.put(componentName, new ObjectSchema().description(typeDoc));
            components.setSchemas(schema);
            break;
        case INT:
            schema.put(componentName, new IntegerSchema().description(typeDoc));
            components.setSchemas(schema);
            break;
        case DECIMAL:
            schema.put(componentName, new NumberSchema().format(DOUBLE).description(typeDoc));
            components.setSchemas(schema);
            break;
        case FLOAT:
            schema.put(componentName, new NumberSchema().format(FLOAT).description(typeDoc));
            components.setSchemas(schema);
            break;
        case ARRAY:
        case TUPLE:
            ArraySchema arraySchema = mapArrayToArraySchema(schema, type, componentName);
            schema.put(componentName, arraySchema.description(typeDoc));
            components.setSchemas(schema);
            break;
        case UNION:
            if (!visitedTypeDefinitionNames.contains(componentName)) {
                visitedTypeDefinitionNames.add(componentName);
                if (typeRef.definition() instanceof EnumSymbol) {
                    EnumSymbol enumSymbol = (EnumSymbol) typeRef.definition();
                    Schema enumSchema = mapEnumValues(enumSymbol);
                    schema.put(componentName, enumSchema.description(typeDoc));
                } else {
                    Schema unionSchema = handleUnionType((UnionTypeSymbol) type, new Schema<>(), componentName);
                    schema.put(componentName, unionSchema.description(typeDoc));
                }
                if (components.getSchemas() != null) {
                    schema.putAll(components.getSchemas());
                }
                components.setSchemas(schema);
            }
            break;
        case MAP:
            MapTypeSymbol mapTypeSymbol = (MapTypeSymbol) type;
            TypeSymbol typeParam = mapTypeSymbol.typeParam();
            if (typeParam.typeKind() == TypeDescKind.TYPE_REFERENCE) {
                TypeReferenceTypeSymbol typeReferenceTypeSymbol = (TypeReferenceTypeSymbol) typeParam;
                schema.put(componentName, new ObjectSchema().additionalProperties(new ObjectSchema().$ref(ConverterCommonUtils.unescapeIdentifier(typeReferenceTypeSymbol.getName().orElseThrow().trim()))));
                createComponentSchema(schema, typeReferenceTypeSymbol);
            }
            if (!schema.containsKey(componentName)) {
                TypeDescKind typeDescKind = mapTypeSymbol.typeParam().typeKind();
                Schema openApiSchema = ConverterCommonUtils.getOpenApiSchema(typeDescKind.getName());
                schema.put(componentName, new ObjectSchema().additionalProperties(openApiSchema.getType() == null ? true : openApiSchema).description(typeDoc));
            }
            Map<String, Schema> schemas = components.getSchemas();
            if (schemas != null) {
                schemas.putAll(schema);
            } else {
                components.setSchemas(schema);
            }
            break;
        default:
            DiagnosticMessages errorMessage = DiagnosticMessages.OAS_CONVERTOR_114;
            IncompatibleResourceDiagnostic error = new IncompatibleResourceDiagnostic(errorMessage, typeRef.getLocation().get(), type.typeKind().getName());
            diagnostics.add(error);
            break;
    }
}",java:S6541,49
"public static String removeUnusedEntities(SyntaxTree schemaSyntaxTree, String clientContent, String schemaContent, String serviceContent) throws IOException, FormatterException{
    Map<String, String> tempSourceFiles = new HashMap<>();
    tempSourceFiles.put(CLIENT_FILE_NAME, clientContent);
    tempSourceFiles.put(TYPE_FILE_NAME, schemaContent);
    if (serviceContent != null) {
        tempSourceFiles.put(SERVICE_FILE_NAME, schemaContent);
    }
    List<String> unusedTypeDefinitionNameList = getUnusedTypeDefinitionNameList(tempSourceFiles);
    while (unusedTypeDefinitionNameList.size() > 0) {
        ModulePartNode modulePartNode = schemaSyntaxTree.rootNode();
        NodeList<ModuleMemberDeclarationNode> members = modulePartNode.members();
        List<ModuleMemberDeclarationNode> unusedTypeDefinitionNodeList = new ArrayList<>();
        for (ModuleMemberDeclarationNode node : members) {
            if (node.kind().equals(SyntaxKind.TYPE_DEFINITION)) {
                for (ChildNodeEntry childNodeEntry : node.childEntries()) {
                    if (childNodeEntry.name().equals(TYPE_NAME)) {
                        if (unusedTypeDefinitionNameList.contains(childNodeEntry.node().get().toString())) {
                            unusedTypeDefinitionNodeList.add(node);
                        }
                    }
                }
            } else if (node.kind().equals(SyntaxKind.ENUM_DECLARATION)) {
                for (ChildNodeEntry childNodeEntry : node.childEntries()) {
                    if (childNodeEntry.name().equals(IDENTIFIER)) {
                        if (unusedTypeDefinitionNameList.contains(childNodeEntry.node().get().toString())) {
                            unusedTypeDefinitionNodeList.add(node);
                        }
                    }
                }
            }
        }
        NodeList<ModuleMemberDeclarationNode> modifiedMembers = members.removeAll(unusedTypeDefinitionNodeList);
        ModulePartNode modiedModulePartNode = modulePartNode.modify(modulePartNode.imports(), modifiedMembers, modulePartNode.eofToken());
        schemaSyntaxTree = schemaSyntaxTree.modifyWith(modiedModulePartNode);
        schemaContent = Formatter.format(schemaSyntaxTree).toSourceCode();
        tempSourceFiles.put(TYPE_FILE_NAME, schemaContent);
        unusedTypeDefinitionNameList = getUnusedTypeDefinitionNameList(tempSourceFiles);
    }
    ModulePartNode rootNode = schemaSyntaxTree.rootNode();
    NodeList<ImportDeclarationNode> imports = rootNode.imports();
    imports = removeUnusedImports(rootNode, imports);
    ModulePartNode modiedModulePartNode = rootNode.modify(imports, rootNode.members(), rootNode.eofToken());
    schemaSyntaxTree = schemaSyntaxTree.modifyWith(modiedModulePartNode);
    schemaContent = Formatter.format(schemaSyntaxTree).toSourceCode();
    return schemaContent;
}",java:S3776,39
"private static NodeList<ImportDeclarationNode> removeUnusedImports(ModulePartNode rootNode, NodeList<ImportDeclarationNode> imports){
    boolean hasConstraint = false;
    NodeList<ModuleMemberDeclarationNode> members = rootNode.members();
    for (ModuleMemberDeclarationNode member : members) {
        if (member.kind().equals(SyntaxKind.TYPE_DEFINITION)) {
            TypeDefinitionNode typeDefNode = (TypeDefinitionNode) member;
            if (typeDefNode.typeDescriptor().kind().equals(SyntaxKind.RECORD_TYPE_DESC)) {
                RecordTypeDescriptorNode record = (RecordTypeDescriptorNode) typeDefNode.typeDescriptor();
                NodeList<Node> fields = record.fields();
                for (Node node : fields) {
                    if (node instanceof RecordFieldNode) {
                        RecordFieldNode recField = (RecordFieldNode) node;
                        if (recField.metadata().isPresent()) {
                            hasConstraint = traverseAnnotationNode(recField.metadata(), hasConstraint);
                        }
                    }
                    if (hasConstraint) {
                        break;
                    }
                }
            }
            if (typeDefNode.metadata().isPresent()) {
                hasConstraint = traverseAnnotationNode(typeDefNode.metadata(), hasConstraint);
            }
        }
        if (hasConstraint) {
            break;
        }
    }
    if (!hasConstraint) {
        for (ImportDeclarationNode importNode : imports) {
            if (importNode.orgName().isPresent()) {
                if (importNode.orgName().get().toString().equals(""ballerina/"") && importNode.moduleName().get(0).text().equals(CONSTRAINT)) {
                    imports = imports.remove(importNode);
                }
            }
        }
    }
    return imports;
}",java:S3776,39
"public void addAuthRelatedRecords(OpenAPI openAPI) throws BallerinaOpenApiException{
    List<TypeDefinitionNode> nodes = new ArrayList<>();
    if (openAPI.getComponents() != null) {
        if (openAPI.getComponents().getSecuritySchemes() != null) {
            Map<String, SecurityScheme> securitySchemeMap = openAPI.getComponents().getSecuritySchemes();
            setAuthTypes(securitySchemeMap);
        }
        if (openAPI.getExtensions() != null && openAPI.getExtensions().containsKey(X_BALLERINA_HTTP_CONFIGURATIONS)) {
            LinkedHashMap<String, String> extFields = (LinkedHashMap<String, String>) openAPI.getExtensions().get(X_BALLERINA_HTTP_CONFIGURATIONS);
            if (extFields.containsKey(HTTP_VERIONS_EXT)) {
                String httpVersion = extFields.get(HTTP_VERIONS_EXT);
                if (httpVersion != null && HTTP_VERSION_MAP.containsKey(httpVersion)) {
                    this.httpVersion = HTTP_VERSION_MAP.get(httpVersion);
                }
            }
        }
        TypeDefinitionNode connectionConfigRecord = generateConnectionConfigRecord();
        TypeDefinitionNode clientHttp1SettingsRecord = getClientHttp1SettingsRecord();
        TypeDefinitionNode customProxyConfigRecord = getCustomProxyRecord();
        nodes.addAll(Arrays.asList(connectionConfigRecord, clientHttp1SettingsRecord, customProxyConfigRecord));
        if (isApiKey()) {
            nodes.add(generateApiKeysConfig());
        }
        if (clientCredGrantTokenUrl != null) {
            nodes.add(getOAuth2ClientCredsGrantConfigRecord());
        }
        if (passwordGrantTokenUrl != null) {
            nodes.add(getOAuth2PasswordGrantConfigRecord());
        }
        if (refreshTokenUrl != null) {
            nodes.add(getOAuth2RefreshTokenGrantConfigRecord());
        }
    }
    this.authRelatedTypeDefinitionNodes = nodes;
}",java:S3776,39
"private ObjectSchema generateObjectSchemaFromRecordFields(Map<String, Schema> schema, String componentName, Map<String, RecordFieldSymbol> rfields, Map<String, String> apiDocs){
    ObjectSchema componentSchema = new ObjectSchema();
    List<String> required = new ArrayList<>();
    componentSchema.setDescription(apiDocs.get(componentName));
    Map<String, Schema> schemaProperties = new LinkedHashMap<>();
    for (Map.Entry<String, RecordFieldSymbol> field : rfields.entrySet()) {
        String fieldName = ConverterCommonUtils.unescapeIdentifier(field.getKey().trim());
        if (!field.getValue().isOptional()) {
            required.add(fieldName);
        }
        TypeDescKind fieldTypeKind = field.getValue().typeDescriptor().typeKind();
        String type = fieldTypeKind.toString().toLowerCase(Locale.ENGLISH);
        if (fieldTypeKind == TypeDescKind.INTERSECTION) {
            TypeSymbol readOnlyExcludedType = excludeReadonlyIfPresent(field.getValue().typeDescriptor());
            type = readOnlyExcludedType.typeKind().toString().toLowerCase(Locale.ENGLISH);
        }
        Schema property = ConverterCommonUtils.getOpenApiSchema(type);
        if (fieldTypeKind == TypeDescKind.TYPE_REFERENCE) {
            TypeReferenceTypeSymbol typeReference = (TypeReferenceTypeSymbol) field.getValue().typeDescriptor();
            property = handleTypeReference(schema, typeReference, property, isSameRecord(ConverterCommonUtils.unescapeIdentifier(typeReference.definition().getName().get()), typeReference));
            schema = components.getSchemas();
        } else if (fieldTypeKind == TypeDescKind.UNION) {
            property = handleUnionType((UnionTypeSymbol) field.getValue().typeDescriptor(), property, componentName);
            schema = components.getSchemas();
        } else if (fieldTypeKind == TypeDescKind.MAP) {
            MapTypeSymbol mapTypeSymbol = (MapTypeSymbol) field.getValue().typeDescriptor();
            property = handleMapType(schema, componentName, property, mapTypeSymbol);
            schema = components.getSchemas();
        }
        if (property instanceof ArraySchema && !(((ArraySchema) property).getItems() instanceof ComposedSchema)) {
            Boolean nullable = property.getNullable();
            property = mapArrayToArraySchema(schema, field.getValue().typeDescriptor(), componentName);
            property.setNullable(nullable);
            schema = components.getSchemas();
        }
        if (apiDocs.containsKey(fieldName)) {
            property.setDescription(apiDocs.get(fieldName));
        }
        schemaProperties.put(fieldName, property);
    }
    componentSchema.setProperties(schemaProperties);
    componentSchema.setRequired(required);
    if (componentName != null && schema != null && !schema.containsKey(componentName)) {
        schema.put(componentName, componentSchema);
        if (this.components.getSchemas() != null) {
            schema.putAll(this.components.getSchemas());
        }
        this.components.setSchemas(schema);
    } else if (schema == null && componentName != null) {
        schema = new LinkedHashMap<>();
        schema.put(componentName, componentSchema);
        this.components.setSchemas(schema);
    }
    visitedTypeDefinitionNames.add(componentName);
    return componentSchema;
}",java:S3776,39
"public void setAuthTypes(Map<String, SecurityScheme> securitySchemeMap) throws BallerinaOpenApiException{
    for (Map.Entry<String, SecurityScheme> securitySchemeEntry : securitySchemeMap.entrySet()) {
        SecurityScheme schemaValue = securitySchemeEntry.getValue();
        if (schemaValue != null && schemaValue.getType() != null) {
            String schemaType = schemaValue.getType().name().toLowerCase(Locale.getDefault());
            switch(schemaType) {
                case HTTP:
                    httpOROAuth = true;
                    String scheme = schemaValue.getScheme();
                    if (scheme.equals(BASIC)) {
                        authTypes.add(BASIC);
                    } else if (scheme.equals(BEARER)) {
                        authTypes.add(BEARER);
                    }
                    break;
                case OAUTH2:
                    httpOROAuth = true;
                    if (schemaValue.getFlows().getClientCredentials() != null) {
                        if (schemaValue.getFlows().getClientCredentials().getTokenUrl() != null) {
                            clientCredGrantTokenUrl = schemaValue.getFlows().getClientCredentials().getTokenUrl();
                        }
                        authTypes.add(CLIENT_CRED);
                    }
                    if (schemaValue.getFlows().getPassword() != null) {
                        if (schemaValue.getFlows().getPassword().getTokenUrl() != null) {
                            passwordGrantTokenUrl = schemaValue.getFlows().getPassword().getTokenUrl();
                        }
                        authTypes.add(PASSWORD);
                    }
                    if (schemaValue.getFlows().getAuthorizationCode() != null) {
                        if (schemaValue.getFlows().getAuthorizationCode().getTokenUrl() != null) {
                            refreshTokenUrl = schemaValue.getFlows().getAuthorizationCode().getTokenUrl();
                        }
                        authTypes.addAll(Arrays.asList(BEARER, REFRESH_TOKEN));
                    }
                    if (schemaValue.getFlows().getImplicit() != null) {
                        authTypes.add(BEARER);
                    }
                    break;
                case API_KEY:
                    apiKey = true;
                    String apiKeyType = schemaValue.getIn().name().toLowerCase(Locale.getDefault());
                    authTypes.add(API_KEY);
                    setApiKeysConfigRecordFields(schemaValue);
                    switch(apiKeyType) {
                        case ""query"":
                            queryApiKeyNameList.put(securitySchemeEntry.getKey(), schemaValue.getName());
                            break;
                        case ""header"":
                            headerApiKeyNameList.put(securitySchemeEntry.getKey(), schemaValue.getName());
                            break;
                        default:
                            break;
                    }
                    break;
            }
        }
    }
    if (!(apiKey || httpOROAuth)) {
        throw new BallerinaOpenApiException(""Unsupported type of security schema"");
    }
}",java:S3776,39
"private String getAuthFieldTypeName(){
    Set<String> httpFieldTypeNames = new HashSet<>();
    for (String authType : authTypes) {
        switch(authType) {
            case BEARER:
                httpFieldTypeNames.add(GeneratorConstants.AuthConfigTypes.BEARER.getValue());
                break;
            case BASIC:
                httpFieldTypeNames.add(GeneratorConstants.AuthConfigTypes.BASIC.getValue());
                break;
            case CLIENT_CRED:
                if (clientCredGrantTokenUrl != null && !clientCredGrantTokenUrl.isBlank()) {
                    httpFieldTypeNames.add(GeneratorConstants.AuthConfigTypes.CUSTOM_CLIENT_CREDENTIAL.getValue());
                } else {
                    httpFieldTypeNames.add(GeneratorConstants.AuthConfigTypes.CLIENT_CREDENTIAL.getValue());
                }
                break;
            case PASSWORD:
                if (passwordGrantTokenUrl != null && !passwordGrantTokenUrl.isBlank()) {
                    httpFieldTypeNames.add(GeneratorConstants.AuthConfigTypes.CUSTOM_PASSWORD.getValue());
                } else {
                    httpFieldTypeNames.add(GeneratorConstants.AuthConfigTypes.PASSWORD.getValue());
                }
                break;
            case REFRESH_TOKEN:
                if (refreshTokenUrl != null && !refreshTokenUrl.isBlank()) {
                    httpFieldTypeNames.add(GeneratorConstants.AuthConfigTypes.CUSTOM_REFRESH_TOKEN.getValue());
                } else {
                    httpFieldTypeNames.add(GeneratorConstants.AuthConfigTypes.REFRESH_TOKEN.getValue());
                }
                break;
            default:
                break;
        }
    }
    return buildConfigRecordFieldTypes(httpFieldTypeNames).toString();
}",java:S3776,39
"private List<FunctionDefinitionNode> createRemoteFunctions(Paths paths, Filter filter) throws BallerinaOpenApiException{
    List<String> filterTags = filter.getTags();
    List<String> filterOperations = filter.getOperations();
    List<FunctionDefinitionNode> functionDefinitionNodeList = new ArrayList<>();
    Set<Map.Entry<String, PathItem>> pathsItems = paths.entrySet();
    for (Map.Entry<String, PathItem> path : pathsItems) {
        if (!path.getValue().readOperationsMap().isEmpty()) {
            for (Map.Entry<PathItem.HttpMethod, Operation> operation : path.getValue().readOperationsMap().entrySet()) {
                List<AnnotationNode> functionLevelAnnotationNodes = new ArrayList<>();
                if (operation.getValue().getExtensions() != null) {
                    Map<String, Object> extensions = operation.getValue().getExtensions();
                    DocCommentsGenerator.extractDisplayAnnotation(extensions, functionLevelAnnotationNodes);
                }
                List<String> operationTags = operation.getValue().getTags();
                String operationId = operation.getValue().getOperationId();
                if (!filterTags.isEmpty() || !filterOperations.isEmpty()) {
                    if (operationTags != null || ((!filterOperations.isEmpty()) && (operationId != null))) {
                        if (GeneratorUtils.hasTags(operationTags, filterTags) || ((operationId != null) && filterOperations.contains(operationId.trim()))) {
                            FunctionDefinitionNode functionDefinitionNode = getClientMethodFunctionDefinitionNode(functionLevelAnnotationNodes, path.getKey(), operation);
                            functionDefinitionNodeList.add(functionDefinitionNode);
                        }
                    }
                } else {
                    FunctionDefinitionNode functionDefinitionNode = getClientMethodFunctionDefinitionNode(functionLevelAnnotationNodes, path.getKey(), operation);
                    functionDefinitionNodeList.add(functionDefinitionNode);
                }
            }
        }
    }
    return functionDefinitionNodeList;
}",java:S3776,39
"private String getServerURL(List<Server> servers) throws BallerinaOpenApiException{
    String serverURL;
    Server selectedServer = servers.get(0);
    if (!selectedServer.getUrl().startsWith(""https:"") && servers.size() > 1) {
        for (Server server : servers) {
            if (server.getUrl().startsWith(""https:"")) {
                selectedServer = server;
                break;
            }
        }
    }
    if (selectedServer.getUrl() == null) {
        serverURL = ""http://localhost:9090/v1"";
    } else if (selectedServer.getVariables() != null) {
        ServerVariables variables = selectedServer.getVariables();
        URL url;
        String resolvedUrl = GeneratorUtils.buildUrl(selectedServer.getUrl(), variables);
        try {
            url = new URL(resolvedUrl);
            serverURL = url.toString();
        } catch (MalformedURLException e) {
            throw new BallerinaOpenApiException(""Failed to read endpoint details of the server: "" + selectedServer.getUrl(), e);
        }
    } else {
        serverURL = selectedServer.getUrl();
    }
    return serverURL;
}",java:S1845,24
"private Schema handleUnionType(UnionTypeSymbol unionType, Schema property, String parentComponentName){
    List<TypeSymbol> unionTypes = unionType.memberTypeDescriptors();
    List<Schema> properties = new ArrayList<>();
    boolean nullable = false;
    for (TypeSymbol union : unionTypes) {
        if (union.typeKind() == TypeDescKind.INTERSECTION) {
            union = excludeReadonlyIfPresent(union);
        }
        if (union.typeKind() == TypeDescKind.NIL) {
            nullable = true;
        } else if (union.typeKind() == TypeDescKind.TYPE_REFERENCE) {
            if (union.getModule().isPresent() && union.getModule().get().id().modulePrefix().equals(HTTP) && union.getName().isPresent() && HTTP_CODES.containsKey(union.getName().get())) {
                continue;
            }
            property = ConverterCommonUtils.getOpenApiSchema(union.typeKind().getName().trim());
            TypeReferenceTypeSymbol typeReferenceTypeSymbol = (TypeReferenceTypeSymbol) union;
            property = handleTypeReference(components.getSchemas(), typeReferenceTypeSymbol, property, isSameRecord(parentComponentName, typeReferenceTypeSymbol));
            visitedTypeDefinitionNames.add(typeReferenceTypeSymbol.getName().get());
            properties.add(property);
        } else if (union.typeKind() == TypeDescKind.UNION) {
            property = handleUnionType((UnionTypeSymbol) union, property, parentComponentName);
            properties.add(property);
        } else if (union.typeKind() == TypeDescKind.ARRAY || union.typeKind() == TypeDescKind.TUPLE) {
            property = mapArrayToArraySchema(components.getSchemas(), union, parentComponentName);
            properties.add(property);
        } else if (union.typeKind() == TypeDescKind.MAP) {
            MapTypeSymbol mapTypeSymbol = (MapTypeSymbol) union;
            TypeDescKind typeDescKind = mapTypeSymbol.typeParam().typeKind();
            Schema openApiSchema = ConverterCommonUtils.getOpenApiSchema(typeDescKind.getName());
            property = new ObjectSchema().additionalProperties(openApiSchema);
            properties.add(property);
            if (components.getSchemas() != null) {
                Map<String, Schema> schemas = components.getSchemas();
                schemas.put(parentComponentName, property);
                components.setSchemas(schemas);
            } else {
                Map<String, Schema> schema = new HashMap<>();
                schema.put(parentComponentName, property);
                components.setSchemas(schema);
            }
        } else {
            property = ConverterCommonUtils.getOpenApiSchema(union.typeKind().getName().trim());
            properties.add(property);
        }
    }
    property = generateOneOfSchema(property, properties);
    if (nullable) {
        property.setNullable(true);
    }
    return property;
}",java:S3776,39
"public SyntaxTree generateUtilSyntaxTree() throws IOException{
    Set<String> functionNameList = new LinkedHashSet<>();
    if (requestBodyEncodingFound) {
        functionNameList.addAll(Arrays.asList(CREATE_FORM_URLENCODED_REQUEST_BODY, GET_DEEP_OBJECT_STYLE_REQUEST, GET_FORM_STYLE_REQUEST, GET_ENCODED_URI, GET_ORIGINAL_KEY, GET_SERIALIZED_ARRAY, GET_SERIALIZED_RECORD_ARRAY));
    }
    if (queryParamsFound) {
        functionNameList.addAll(Arrays.asList(GET_DEEP_OBJECT_STYLE_REQUEST, GET_FORM_STYLE_REQUEST, GET_ENCODED_URI, GET_ORIGINAL_KEY, GET_SERIALIZED_ARRAY, GET_PATH_FOR_QUERY_PARAM, GET_SERIALIZED_RECORD_ARRAY));
    }
    if (headersFound) {
        functionNameList.add(GET_MAP_FOR_HEADERS);
    }
    if (pathParametersFound) {
        functionNameList.add(GET_ENCODED_URI);
    }
    if (requestBodyMultipartFormDatafound) {
        functionNameList.add(CREATE_MULTIPART_BODY_PARTS);
    }
    List<ModuleMemberDeclarationNode> memberDeclarationNodes = new ArrayList<>();
    getUtilTypeDeclarationNodes(memberDeclarationNodes);
    Path path = getResourceFilePath();
    Project project = ProjectLoader.loadProject(path);
    Package currentPackage = project.currentPackage();
    DocumentId docId = currentPackage.getDefaultModule().documentIds().iterator().next();
    SyntaxTree syntaxTree = currentPackage.getDefaultModule().document(docId).syntaxTree();
    ModulePartNode modulePartNode = syntaxTree.rootNode();
    NodeList<ModuleMemberDeclarationNode> members = modulePartNode.members();
    for (ModuleMemberDeclarationNode node : members) {
        if (node.kind().equals(SyntaxKind.FUNCTION_DEFINITION)) {
            for (ChildNodeEntry childNodeEntry : node.childEntries()) {
                if (childNodeEntry.name().equals(""functionName"")) {
                    if (functionNameList.contains(childNodeEntry.node().get().toString())) {
                        memberDeclarationNodes.add(node);
                    }
                }
            }
        }
    }
    List<ImportDeclarationNode> imports = new ArrayList<>();
    if (functionNameList.contains(GET_ENCODED_URI)) {
        ImportDeclarationNode importForUrl = GeneratorUtils.getImportDeclarationNode(BALLERINA, URL);
        imports.add(importForUrl);
    }
    if (requestBodyMultipartFormDatafound) {
        ImportDeclarationNode importMime = GeneratorUtils.getImportDeclarationNode(BALLERINA, MIME);
        imports.add(importMime);
    }
    NodeList<ImportDeclarationNode> importsList = createNodeList(imports);
    ModulePartNode utilModulePartNode = createModulePartNode(importsList, createNodeList(memberDeclarationNodes), createToken(EOF_TOKEN));
    TextDocument textDocument = TextDocuments.from("""");
    SyntaxTree utilSyntaxTree = SyntaxTree.from(textDocument);
    return utilSyntaxTree.modifyWith(utilModulePartNode);
}",java:S3776,39
"private void addUpdatedPathAndHeaders(List<StatementNode> statementsList, List<String> queryApiKeyNameList, List<Parameter> queryParameters, List<String> headerApiKeyNameList, List<Parameter> headerParameters) throws BallerinaOpenApiException{
    List<StatementNode> ifBodyStatementsList = new ArrayList<>();
    if (!headerParameters.isEmpty() || !headerApiKeyNameList.isEmpty()) {
        if (!headerParameters.isEmpty()) {
            statementsList.add(getMapForParameters(headerParameters, ""map<any>"", HEADER_VALUES, new ArrayList<>()));
        } else {
            ExpressionStatementNode headerMapCreation = GeneratorUtils.getSimpleExpressionStatementNode(""map<any> "" + HEADER_VALUES + "" = {}"");
            statementsList.add(headerMapCreation);
        }
        if (!headerApiKeyNameList.isEmpty()) {
            addApiKeysToMap(HEADER_VALUES, headerApiKeyNameList, ifBodyStatementsList);
        }
        isHeader = true;
        ballerinaUtilGenerator.setHeadersFound(true);
    }
    if (!queryParameters.isEmpty() || !queryApiKeyNameList.isEmpty()) {
        ballerinaUtilGenerator.setQueryParamsFound(true);
        if (!queryParameters.isEmpty()) {
            statementsList.add(getMapForParameters(queryParameters, ""map<anydata>"", QUERY_PARAM, new ArrayList<>()));
        } else {
            ExpressionStatementNode queryParamMapCreation = GeneratorUtils.getSimpleExpressionStatementNode(""map<anydata> "" + QUERY_PARAM + "" = {}"");
            statementsList.add(queryParamMapCreation);
        }
        if (!queryApiKeyNameList.isEmpty()) {
            addApiKeysToMap(QUERY_PARAM, queryApiKeyNameList, ifBodyStatementsList);
        }
    }
    generateIfBlockToAddApiKeysToMaps(statementsList, ifBodyStatementsList);
    if (!queryParameters.isEmpty() || !queryApiKeyNameList.isEmpty()) {
        getUpdatedPathHandlingQueryParamEncoding(statementsList, queryParameters);
    }
    if (!headerParameters.isEmpty() || !headerApiKeyNameList.isEmpty()) {
        statementsList.add(GeneratorUtils.getSimpleExpressionStatementNode(""map<string|string[]> "" + HTTP_HEADERS + "" = getMapForHeaders(headerValues)""));
    }
}",java:S3776,39
"public String getReturnType(Operation operation, boolean isSignature) throws BallerinaOpenApiException{
    Set<String> returnTypes = new HashSet<>();
    boolean noContentResponseFound = false;
    if (operation.getResponses() != null) {
        ApiResponses responses = operation.getResponses();
        for (Map.Entry<String, ApiResponse> entry : responses.entrySet()) {
            String statusCode = entry.getKey();
            ApiResponse response = entry.getValue();
            if (statusCode.startsWith(""2"")) {
                Content content = response.getContent();
                if (content != null && content.size() > 0) {
                    Set<Map.Entry<String, MediaType>> mediaTypes = content.entrySet();
                    for (Map.Entry<String, MediaType> media : mediaTypes) {
                        String type = """";
                        if (media.getValue().getSchema() != null) {
                            Schema schema = media.getValue().getSchema();
                            type = getDataType(operation, isSignature, response, media, type, schema);
                        } else {
                            type = GeneratorUtils.getBallerinaMediaType(media.getKey().trim(), false);
                        }
                        returnTypes.add(type);
                        break;
                    }
                } else {
                    noContentResponseFound = true;
                }
            }
        }
    }
    if (returnTypes.size() > 0) {
        StringBuilder finalReturnType = new StringBuilder();
        finalReturnType.append(String.join(PIPE_TOKEN.stringValue(), returnTypes));
        finalReturnType.append(PIPE_TOKEN.stringValue());
        finalReturnType.append(ERROR);
        if (noContentResponseFound) {
            finalReturnType.append(NILLABLE);
        }
        return finalReturnType.toString();
    } else {
        return DEFAULT_RETURN;
    }
}",java:S3776,39
"private void setFunctionParameters(Operation operation, List<Node> parameterList, Token comma, List<Node> remoteFunctionDoc) throws BallerinaOpenApiException{
    List<Parameter> parameters = operation.getParameters();
    List<Node> defaultable = new ArrayList<>();
    List<Node> deprecatedParamDocComments = new ArrayList<>();
    if (parameters != null) {
        for (Parameter parameter : parameters) {
            if (parameter.getDescription() != null && !parameter.getDescription().isBlank()) {
                MarkdownDocumentationNode paramAPIDoc = DocCommentsGenerator.createAPIParamDocFromSring(getValidName(parameter.getName(), false), parameter.getDescription());
                remoteFunctionDoc.add(paramAPIDoc);
            }
            List<AnnotationNode> parameterAnnotationNodeList = getParameterAnnotationNodeList(parameter, deprecatedParamDocComments);
            String in = parameter.getIn();
            switch(in) {
                case ""path"":
                    Node param = getPathParameters(parameter, createNodeList(parameterAnnotationNodeList));
                    if (!isResource) {
                        parameterList.add(param);
                        parameterList.add(comma);
                    }
                    break;
                case ""query"":
                    Node paramq = getQueryParameters(parameter, createNodeList(parameterAnnotationNodeList));
                    if (paramq instanceof RequiredParameterNode) {
                        parameterList.add(paramq);
                        parameterList.add(comma);
                    } else {
                        defaultable.add(paramq);
                        defaultable.add(comma);
                    }
                    break;
                case ""header"":
                    Node paramh = getHeaderParameter(parameter, createNodeList(parameterAnnotationNodeList));
                    if (paramh instanceof RequiredParameterNode) {
                        parameterList.add(paramh);
                        parameterList.add(comma);
                    } else {
                        defaultable.add(paramh);
                        defaultable.add(comma);
                    }
                    break;
                default:
                    break;
            }
        }
    }
    if (operation.getRequestBody() != null) {
        setRequestBodyParameters(operation.getOperationId(), operation.getRequestBody(), remoteFunctionDoc, parameterList, defaultable);
    }
    remoteFunctionDoc.addAll(deprecatedParamDocComments);
    if (!defaultable.isEmpty()) {
        parameterList.addAll(defaultable);
    }
}",java:S3776,39
"public Node getQueryParameters(Parameter parameter, NodeList<AnnotationNode> parameterAnnotationNodeList) throws BallerinaOpenApiException{
    TypeDescriptorNode typeName;
    Schema parameterSchema = parameter.getSchema();
    String paramType = """";
    if (parameterSchema.get$ref() != null) {
        paramType = getValidName(extractReferenceType(parameterSchema.get$ref()), true);
        parameterSchema = openAPI.getComponents().getSchemas().get(paramType.trim());
    } else {
        paramType = convertOpenAPITypeToBallerina(parameterSchema);
        if (parameterSchema instanceof ArraySchema) {
            ArraySchema arraySchema = (ArraySchema) parameterSchema;
            if (arraySchema.getItems().getType() != null) {
                String itemType = arraySchema.getItems().getType();
                if (itemType.equals(STRING) || itemType.equals(INTEGER) || itemType.equals(BOOLEAN) || itemType.equals(NUMBER)) {
                    if (arraySchema.getItems().getEnum() != null && !arraySchema.getItems().getEnum().isEmpty()) {
                        paramType = OPEN_PAREN_TOKEN.stringValue() + convertOpenAPITypeToBallerina(arraySchema.getItems()) + CLOSE_PAREN_TOKEN.stringValue() + SQUARE_BRACKETS;
                    } else {
                        paramType = convertOpenAPITypeToBallerina(arraySchema.getItems()) + SQUARE_BRACKETS;
                    }
                } else {
                    throw new BallerinaOpenApiException(""Unsupported parameter type is found in the parameter : "" + parameter.getName());
                }
            } else if (arraySchema.getItems().get$ref() != null) {
                paramType = getValidName(extractReferenceType(arraySchema.getItems().get$ref().trim()), true) + SQUARE_BRACKETS;
            } else {
                throw new BallerinaOpenApiException(""Please define the array item type of the parameter : "" + parameter.getName());
            }
        }
    }
    if (parameter.getRequired()) {
        typeName = createBuiltinSimpleNameReferenceNode(null, createIdentifierToken(paramType));
        IdentifierToken paramName = createIdentifierToken(getValidName(parameter.getName().trim(), false));
        return createRequiredParameterNode(parameterAnnotationNodeList, typeName, paramName);
    } else {
        IdentifierToken paramName = createIdentifierToken(getValidName(parameter.getName().trim(), false));
        if (parameterSchema.getDefault() != null) {
            typeName = createBuiltinSimpleNameReferenceNode(null, createIdentifierToken(paramType));
            LiteralValueToken literalValueToken;
            if (parameterSchema.getType().equals(STRING)) {
                literalValueToken = createLiteralValueToken(null, '""' + parameterSchema.getDefault().toString() + '""', createEmptyMinutiaeList(), createEmptyMinutiaeList());
            } else {
                literalValueToken = createLiteralValueToken(null, parameterSchema.getDefault().toString(), createEmptyMinutiaeList(), createEmptyMinutiaeList());
            }
            return createDefaultableParameterNode(parameterAnnotationNodeList, typeName, paramName, createToken(EQUAL_TOKEN), literalValueToken);
        } else {
            paramType = paramType.endsWith(NILLABLE) ? paramType : paramType + NILLABLE;
            typeName = createBuiltinSimpleNameReferenceNode(null, createIdentifierToken(paramType));
            NilLiteralNode nilLiteralNode = createNilLiteralNode(createToken(OPEN_PAREN_TOKEN), createToken(CLOSE_PAREN_TOKEN));
            return createDefaultableParameterNode(parameterAnnotationNodeList, typeName, paramName, createToken(EQUAL_TOKEN), nilLiteralNode);
        }
    }
}",java:S3776,39
"public Node getQueryParameters(Parameter parameter, NodeList<AnnotationNode> parameterAnnotationNodeList) throws BallerinaOpenApiException{
    TypeDescriptorNode typeName;
    Schema parameterSchema = parameter.getSchema();
    String paramType = """";
    if (parameterSchema.get$ref() != null) {
        paramType = getValidName(extractReferenceType(parameterSchema.get$ref()), true);
        parameterSchema = openAPI.getComponents().getSchemas().get(paramType.trim());
    } else {
        paramType = convertOpenAPITypeToBallerina(parameterSchema);
        if (parameterSchema instanceof ArraySchema) {
            ArraySchema arraySchema = (ArraySchema) parameterSchema;
            if (arraySchema.getItems().getType() != null) {
                String itemType = arraySchema.getItems().getType();
                if (itemType.equals(STRING) || itemType.equals(INTEGER) || itemType.equals(BOOLEAN) || itemType.equals(NUMBER)) {
                    if (arraySchema.getItems().getEnum() != null && !arraySchema.getItems().getEnum().isEmpty()) {
                        paramType = OPEN_PAREN_TOKEN.stringValue() + convertOpenAPITypeToBallerina(arraySchema.getItems()) + CLOSE_PAREN_TOKEN.stringValue() + SQUARE_BRACKETS;
                    } else {
                        paramType = convertOpenAPITypeToBallerina(arraySchema.getItems()) + SQUARE_BRACKETS;
                    }
                } else {
                    throw new BallerinaOpenApiException(""Unsupported parameter type is found in the parameter : "" + parameter.getName());
                }
            } else if (arraySchema.getItems().get$ref() != null) {
                paramType = getValidName(extractReferenceType(arraySchema.getItems().get$ref().trim()), true) + SQUARE_BRACKETS;
            } else {
                throw new BallerinaOpenApiException(""Please define the array item type of the parameter : "" + parameter.getName());
            }
        }
    }
    if (parameter.getRequired()) {
        typeName = createBuiltinSimpleNameReferenceNode(null, createIdentifierToken(paramType));
        IdentifierToken paramName = createIdentifierToken(getValidName(parameter.getName().trim(), false));
        return createRequiredParameterNode(parameterAnnotationNodeList, typeName, paramName);
    } else {
        IdentifierToken paramName = createIdentifierToken(getValidName(parameter.getName().trim(), false));
        if (parameterSchema.getDefault() != null) {
            typeName = createBuiltinSimpleNameReferenceNode(null, createIdentifierToken(paramType));
            LiteralValueToken literalValueToken;
            if (parameterSchema.getType().equals(STRING)) {
                literalValueToken = createLiteralValueToken(null, '""' + parameterSchema.getDefault().toString() + '""', createEmptyMinutiaeList(), createEmptyMinutiaeList());
            } else {
                literalValueToken = createLiteralValueToken(null, parameterSchema.getDefault().toString(), createEmptyMinutiaeList(), createEmptyMinutiaeList());
            }
            return createDefaultableParameterNode(parameterAnnotationNodeList, typeName, paramName, createToken(EQUAL_TOKEN), literalValueToken);
        } else {
            paramType = paramType.endsWith(NILLABLE) ? paramType : paramType + NILLABLE;
            typeName = createBuiltinSimpleNameReferenceNode(null, createIdentifierToken(paramType));
            NilLiteralNode nilLiteralNode = createNilLiteralNode(createToken(OPEN_PAREN_TOKEN), createToken(CLOSE_PAREN_TOKEN));
            return createDefaultableParameterNode(parameterAnnotationNodeList, typeName, paramName, createToken(EQUAL_TOKEN), nilLiteralNode);
        }
    }
}",java:S6541,49
"private Node getHeader(boolean isRequiredHeader, Schema schema, IdentifierToken paramName, NodeList<AnnotationNode> parameterAnnotationNodeList) throws BallerinaOpenApiException{
    if (isRequiredHeader) {
        String type = convertOpenAPITypeToBallerina(schema);
        if (schema instanceof ArraySchema) {
            ArraySchema arraySchema = (ArraySchema) schema;
            if (arraySchema.getItems().get$ref() != null) {
                type = extractReferenceType(arraySchema.getItems().get$ref()) + SQUARE_BRACKETS;
            } else if (arraySchema.getItems().getEnum() != null && !arraySchema.getItems().getEnum().isEmpty()) {
                type = OPEN_PAREN_TOKEN.stringValue() + convertOpenAPITypeToBallerina(arraySchema.getItems()) + CLOSE_PAREN_TOKEN.stringValue() + SQUARE_BRACKETS;
            } else {
                type = convertOpenAPITypeToBallerina(arraySchema.getItems()) + SQUARE_BRACKETS;
            }
        }
        BuiltinSimpleNameReferenceNode typeName = createBuiltinSimpleNameReferenceNode(null, createIdentifierToken(type));
        return createRequiredParameterNode(parameterAnnotationNodeList, typeName, paramName);
    } else {
        if (schema.getDefault() != null) {
            BuiltinSimpleNameReferenceNode typeName = createBuiltinSimpleNameReferenceNode(null, createIdentifierToken(convertOpenAPITypeToBallerina(schema)));
            LiteralValueToken literalValueToken;
            if (schema.getType().equals(STRING)) {
                literalValueToken = createLiteralValueToken(null, '""' + schema.getDefault().toString() + '""', createEmptyMinutiaeList(), createEmptyMinutiaeList());
            } else {
                literalValueToken = createLiteralValueToken(null, schema.getDefault().toString(), createEmptyMinutiaeList(), createEmptyMinutiaeList());
            }
            return createDefaultableParameterNode(parameterAnnotationNodeList, typeName, paramName, createToken(EQUAL_TOKEN), literalValueToken);
        } else {
            String type = convertOpenAPITypeToBallerina(schema);
            String nillableType = type.endsWith(NILLABLE) ? type : type + NILLABLE;
            if (schema instanceof ArraySchema) {
                ArraySchema arraySchema = (ArraySchema) schema;
                if (arraySchema.getItems().get$ref() != null) {
                    nillableType = extractReferenceType(arraySchema.getItems().get$ref()) + SQUARE_BRACKETS + NILLABLE;
                } else if (arraySchema.getItems().getEnum() != null && !arraySchema.getItems().getEnum().isEmpty()) {
                    nillableType = OPEN_PAREN_TOKEN.stringValue() + convertOpenAPITypeToBallerina(arraySchema.getItems()) + CLOSE_PAREN_TOKEN.stringValue() + SQUARE_BRACKETS + NILLABLE;
                } else {
                    nillableType = convertOpenAPITypeToBallerina(arraySchema.getItems()) + SQUARE_BRACKETS + NILLABLE;
                }
            }
            BuiltinSimpleNameReferenceNode typeName = createBuiltinSimpleNameReferenceNode(null, createIdentifierToken(nillableType));
            NilLiteralNode nilLiteralNode = createNilLiteralNode(createToken(OPEN_PAREN_TOKEN), createToken(CLOSE_PAREN_TOKEN));
            return createDefaultableParameterNode(parameterAnnotationNodeList, typeName, paramName, createToken(EQUAL_TOKEN), nilLiteralNode);
        }
    }
}",java:S3776,39
"private void setRequestBodyParameters(String operationId, RequestBody requestBody, List<Node> requestBodyDoc, List<Node> parameterList, List<Node> defaultable) throws BallerinaOpenApiException{
    Content requestBodyContent;
    String referencedRequestBodyName = """";
    if (requestBody.get$ref() != null) {
        referencedRequestBodyName = extractReferenceType(requestBody.get$ref()).trim();
        RequestBody referencedRequestBody = openAPI.getComponents().getRequestBodies().get(referencedRequestBodyName);
        requestBodyContent = referencedRequestBody.getContent();
        requestBody.setDescription(referencedRequestBody.getDescription());
    } else {
        requestBodyContent = requestBody.getContent();
    }
    Iterator<Map.Entry<String, MediaType>> iterator = requestBodyContent.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, MediaType> mediaTypeEntry = iterator.next();
        Schema schema = mediaTypeEntry.getValue().getSchema();
        String paramType = """";
        if (schema != null && GeneratorUtils.isSupportedMediaType(mediaTypeEntry)) {
            String mediaTypeEntryKey = mediaTypeEntry.getKey();
            if (mediaTypeEntryKey.equals(APPLICATION_OCTET_STREAM) || mediaTypeEntryKey.matches(""application/.*\\+octet-stream"")) {
                paramType = getBallerinaMediaType(mediaTypeEntryKey, true);
            } else {
                if (schema.get$ref() != null) {
                    paramType = getValidName(extractReferenceType(schema.get$ref().trim()), true);
                } else if (schema.getType() != null && !schema.getType().equals(ARRAY) && !schema.getType().equals(OBJECT)) {
                    paramType = convertOpenAPITypeToBallerina(schema);
                } else if (schema instanceof ArraySchema) {
                    ArraySchema arraySchema = (ArraySchema) schema;
                    paramType = getRequestBodyParameterForArraySchema(operationId, mediaTypeEntry, arraySchema);
                } else if (schema instanceof ObjectSchema) {
                    ObjectSchema objectSchema = (ObjectSchema) schema;
                    paramType = getRequestBodyParameterForObjectSchema(referencedRequestBodyName, objectSchema);
                } else {
                    paramType = getBallerinaMediaType(mediaTypeEntryKey, true);
                }
            }
        } else {
            paramType = getBallerinaMediaType(mediaTypeEntry.getKey(), true);
        }
        String paramName = paramType.equals(HTTP_REQUEST) ? REQUEST : PAYLOAD;
        if (!paramType.isBlank()) {
            List<AnnotationNode> annotationNodes = new ArrayList<>();
            DocCommentsGenerator.extractDisplayAnnotation(requestBody.getExtensions(), annotationNodes);
            SimpleNameReferenceNode typeName = createSimpleNameReferenceNode(createIdentifierToken(paramType));
            IdentifierToken paramNameToken = createIdentifierToken(paramName);
            RequiredParameterNode payload = createRequiredParameterNode(createNodeList(annotationNodes), typeName, paramNameToken);
            if (requestBody.getDescription() != null && !requestBody.getDescription().isBlank()) {
                MarkdownDocumentationNode paramAPIDoc = DocCommentsGenerator.createAPIParamDocFromSring(escapeIdentifier(paramName), requestBody.getDescription().split(""\n"")[0]);
                requestBodyDoc.add(paramAPIDoc);
            }
            parameterList.add(payload);
            parameterList.add(createToken((COMMA_TOKEN)));
        }
        if (mediaTypeEntry.getKey().equals(javax.ws.rs.core.MediaType.MULTIPART_FORM_DATA) && mediaTypeEntry.getValue().getEncoding() != null) {
            List<String> headerList = new ArrayList<>();
            for (Map.Entry<String, Encoding> entry : mediaTypeEntry.getValue().getEncoding().entrySet()) {
                if (entry.getValue().getHeaders() != null) {
                    for (Map.Entry<String, Header> header : entry.getValue().getHeaders().entrySet()) {
                        if (!headerList.contains(header.getKey())) {
                            Node headerParameter = getHeaderEncoding(header, requestBodyDoc);
                            if (headerParameter instanceof RequiredParameterNode) {
                                parameterList.add(headerParameter);
                                parameterList.add(createToken((COMMA_TOKEN)));
                            } else {
                                defaultable.add(headerParameter);
                                defaultable.add(createToken((COMMA_TOKEN)));
                            }
                            headerList.add(header.getKey());
                        }
                    }
                }
            }
        }
        break;
    }
}",java:S3776,39
"private void setRequestBodyParameters(String operationId, RequestBody requestBody, List<Node> requestBodyDoc, List<Node> parameterList, List<Node> defaultable) throws BallerinaOpenApiException{
    Content requestBodyContent;
    String referencedRequestBodyName = """";
    if (requestBody.get$ref() != null) {
        referencedRequestBodyName = extractReferenceType(requestBody.get$ref()).trim();
        RequestBody referencedRequestBody = openAPI.getComponents().getRequestBodies().get(referencedRequestBodyName);
        requestBodyContent = referencedRequestBody.getContent();
        requestBody.setDescription(referencedRequestBody.getDescription());
    } else {
        requestBodyContent = requestBody.getContent();
    }
    Iterator<Map.Entry<String, MediaType>> iterator = requestBodyContent.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, MediaType> mediaTypeEntry = iterator.next();
        Schema schema = mediaTypeEntry.getValue().getSchema();
        String paramType = """";
        if (schema != null && GeneratorUtils.isSupportedMediaType(mediaTypeEntry)) {
            String mediaTypeEntryKey = mediaTypeEntry.getKey();
            if (mediaTypeEntryKey.equals(APPLICATION_OCTET_STREAM) || mediaTypeEntryKey.matches(""application/.*\\+octet-stream"")) {
                paramType = getBallerinaMediaType(mediaTypeEntryKey, true);
            } else {
                if (schema.get$ref() != null) {
                    paramType = getValidName(extractReferenceType(schema.get$ref().trim()), true);
                } else if (schema.getType() != null && !schema.getType().equals(ARRAY) && !schema.getType().equals(OBJECT)) {
                    paramType = convertOpenAPITypeToBallerina(schema);
                } else if (schema instanceof ArraySchema) {
                    ArraySchema arraySchema = (ArraySchema) schema;
                    paramType = getRequestBodyParameterForArraySchema(operationId, mediaTypeEntry, arraySchema);
                } else if (schema instanceof ObjectSchema) {
                    ObjectSchema objectSchema = (ObjectSchema) schema;
                    paramType = getRequestBodyParameterForObjectSchema(referencedRequestBodyName, objectSchema);
                } else {
                    paramType = getBallerinaMediaType(mediaTypeEntryKey, true);
                }
            }
        } else {
            paramType = getBallerinaMediaType(mediaTypeEntry.getKey(), true);
        }
        String paramName = paramType.equals(HTTP_REQUEST) ? REQUEST : PAYLOAD;
        if (!paramType.isBlank()) {
            List<AnnotationNode> annotationNodes = new ArrayList<>();
            DocCommentsGenerator.extractDisplayAnnotation(requestBody.getExtensions(), annotationNodes);
            SimpleNameReferenceNode typeName = createSimpleNameReferenceNode(createIdentifierToken(paramType));
            IdentifierToken paramNameToken = createIdentifierToken(paramName);
            RequiredParameterNode payload = createRequiredParameterNode(createNodeList(annotationNodes), typeName, paramNameToken);
            if (requestBody.getDescription() != null && !requestBody.getDescription().isBlank()) {
                MarkdownDocumentationNode paramAPIDoc = DocCommentsGenerator.createAPIParamDocFromSring(escapeIdentifier(paramName), requestBody.getDescription().split(""\n"")[0]);
                requestBodyDoc.add(paramAPIDoc);
            }
            parameterList.add(payload);
            parameterList.add(createToken((COMMA_TOKEN)));
        }
        if (mediaTypeEntry.getKey().equals(javax.ws.rs.core.MediaType.MULTIPART_FORM_DATA) && mediaTypeEntry.getValue().getEncoding() != null) {
            List<String> headerList = new ArrayList<>();
            for (Map.Entry<String, Encoding> entry : mediaTypeEntry.getValue().getEncoding().entrySet()) {
                if (entry.getValue().getHeaders() != null) {
                    for (Map.Entry<String, Header> header : entry.getValue().getHeaders().entrySet()) {
                        if (!headerList.contains(header.getKey())) {
                            Node headerParameter = getHeaderEncoding(header, requestBodyDoc);
                            if (headerParameter instanceof RequiredParameterNode) {
                                parameterList.add(headerParameter);
                                parameterList.add(createToken((COMMA_TOKEN)));
                            } else {
                                defaultable.add(headerParameter);
                                defaultable.add(createToken((COMMA_TOKEN)));
                            }
                            headerList.add(header.getKey());
                        }
                    }
                }
            }
        }
        break;
    }
}",java:S6541,49
"public MimeType getMimeType(Map.Entry<String, MediaType> mediaTypeEntry, BallerinaUtilGenerator ballerinaUtilGenerator, List<ImportDeclarationNode> imports) throws BallerinaOpenApiException{
    Schema requestBodySchema = mediaTypeEntry.getValue().getSchema();
    if (requestBodySchema != null && (requestBodySchema.get$ref() != null || requestBodySchema.getType() != null || requestBodySchema.getProperties() != null)) {
        String mediaType = mediaTypeEntry.getKey();
        if (mediaType.matches("".*/json"") || mediaType.matches(""application/.*\\+json"")) {
            return new JsonType();
        } else if (mediaType.startsWith(TEXT_PREFIX) || mediaType.contains(PDF) || mediaType.startsWith(IMAGE)) {
            return new CustomType();
        } else if (mediaType.matches("".*/xml"") || mediaType.matches(""application/.*\\+xml"")) {
            return new XmlType(imports);
        } else if (mediaType.equals(APPLICATION_FORM_URLENCODED)) {
            return new UrlEncodedType(ballerinaUtilGenerator);
        } else if (mediaType.equals(APPLICATION_OCTET_STREAM) || mediaType.matches(""application/.*\\+octet-stream"")) {
            return new OctetStreamType();
        } else if (mediaType.equals(MULTIPART_FORM_DATA)) {
            return new MultipartFormData(imports, ballerinaUtilGenerator);
        } else if (mediaType.contains(VENDOR_SPECIFIC_TYPE)) {
            return new CustomType();
        } else {
            throw new BallerinaOpenApiException(String.format(UNSUPPORTED_MEDIA_ERROR, mediaType));
        }
    } else {
        return new CustomType();
    }
}",java:S3776,39
"public static ImmutablePair<List<Node>, Set<String>> updateRecordFieldListWithImports(List<String> required, List<Node> recordFieldList, Map.Entry<String, Schema<?>> field, Schema<?> fieldSchema, NodeList<Node> schemaDocNodes, IdentifierToken fieldName, TypeDescriptorNode fieldTypeName, PrintStream outStream){
    MarkdownDocumentationNode documentationNode = createMarkdownDocumentationNode(schemaDocNodes);
    Set<String> imports = new HashSet<>();
    AnnotationNode constraintNode = generateConstraintNode(fieldName.text(), fieldSchema);
    MetadataNode metadataNode;
    boolean isConstraintSupport = constraintNode != null && fieldSchema.getNullable() != null && fieldSchema.getNullable() || (fieldSchema instanceof ComposedSchema && (fieldSchema.getOneOf() != null || fieldSchema.getAnyOf() != null));
    boolean nullable = GeneratorMetaData.getInstance().isNullable();
    if (nullable) {
        constraintNode = null;
    } else if (isConstraintSupport) {
        outStream.printf(""WARNING: constraints in the OpenAPI contract will be ignored for the "" + ""field `%s`, as constraints are not supported on Ballerina union types%n"", fieldName.toString().trim());
        constraintNode = null;
    }
    if (constraintNode == null) {
        metadataNode = createMetadataNode(documentationNode, createEmptyNodeList());
    } else {
        metadataNode = createMetadataNode(documentationNode, createNodeList(constraintNode));
    }
    if (required != null) {
        setRequiredFields(required, recordFieldList, field, fieldSchema, fieldName, fieldTypeName, metadataNode);
    } else {
        RecordFieldNode recordFieldNode = NodeFactory.createRecordFieldNode(metadataNode, null, fieldTypeName, fieldName, createToken(QUESTION_MARK_TOKEN), createToken(SEMICOLON_TOKEN));
        recordFieldList.add(recordFieldNode);
    }
    if (constraintNode != null) {
        ImportDeclarationNode constraintImport = GeneratorUtils.getImportDeclarationNode(BALLERINA, CONSTRAINT);
        constraintImport.toSourceCode();
        imports.add(constraintImport.toSourceCode());
    }
    return new ImmutablePair<>(recordFieldList, imports);
}",java:S107,1
"private static List<String> getNumberAnnotFields(Schema<?> numberSchema){
    List<String> fields = new ArrayList<>();
    boolean isInt = numberSchema instanceof IntegerSchema;
    if (numberSchema.getMinimum() != null && numberSchema.getExclusiveMinimum() == null) {
        String value = numberSchema.getMinimum().toString();
        String fieldRef = GeneratorConstants.MINIMUM + GeneratorConstants.COLON + (isInt ? numberSchema.getMinimum().intValue() : value);
        fields.add(fieldRef);
    }
    if (numberSchema.getMaximum() != null && numberSchema.getExclusiveMaximum() == null) {
        String value = numberSchema.getMaximum().toString();
        String fieldRef = GeneratorConstants.MAXIMUM + GeneratorConstants.COLON + (isInt ? numberSchema.getMaximum().intValue() : value);
        fields.add(fieldRef);
    }
    if (numberSchema.getExclusiveMinimum() != null && numberSchema.getExclusiveMinimum() && numberSchema.getMinimum() != null) {
        String value = numberSchema.getMinimum().toString();
        String fieldRef = GeneratorConstants.EXCLUSIVE_MIN + GeneratorConstants.COLON + (isInt ? numberSchema.getMinimum().intValue() : value);
        fields.add(fieldRef);
    }
    if (numberSchema.getExclusiveMaximum() != null && numberSchema.getExclusiveMaximum() && numberSchema.getMaximum() != null) {
        String value = numberSchema.getMaximum().toString();
        String fieldRef = GeneratorConstants.EXCLUSIVE_MAX + GeneratorConstants.COLON + (isInt ? numberSchema.getMaximum().intValue() : value);
        fields.add(fieldRef);
    }
    return fields;
}",java:S3776,39
"public LinkedHashSet<String> getImports(){
    return imports;
}",java:S1319,22
"private List<Node> applyFiltersForOperations(Filter filter, String path, Map<PathItem.HttpMethod, Operation> operationMap) throws BallerinaOpenApiException{
    List<Node> functions = new ArrayList<>();
    for (Map.Entry<PathItem.HttpMethod, Operation> operation : operationMap.entrySet()) {
        List<Node> resourceFunctionDocs = new ArrayList<>();
        addFunctionDescToAPIDocs(operation, resourceFunctionDocs);
        List<String> filterTags = filter.getTags();
        List<String> operationTags = operation.getValue().getTags();
        List<String> filterOperations = filter.getOperations();
        if (!filterTags.isEmpty() || !filterOperations.isEmpty()) {
            if (operationTags != null || ((!filterOperations.isEmpty()) && (operation.getValue().getOperationId() != null))) {
                if ((operationTags != null && GeneratorUtils.hasTags(operationTags, filterTags)) || ((operation.getValue().getOperationId() != null) && filterOperations.contains(operation.getValue().getOperationId().trim()))) {
                    List<Node> functionRelativeResourcePath = GeneratorUtils.getRelativeResourcePath(path, operation.getValue(), resourceFunctionDocs);
                    FunctionDefinitionNode functionDefinitionNode = generateWithoutDataBinding ? generateGenericResourceFunctions(operation, functionRelativeResourcePath, path, resourceFunctionDocs) : getResourceFunction(operation, functionRelativeResourcePath, path, resourceFunctionDocs);
                    functions.add(functionDefinitionNode);
                }
            }
        } else {
            List<Node> relativeResourcePath = GeneratorUtils.getRelativeResourcePath(path, operation.getValue(), resourceFunctionDocs);
            FunctionDefinitionNode resourceFunction = generateWithoutDataBinding ? generateGenericResourceFunctions(operation, relativeResourcePath, path, resourceFunctionDocs) : getResourceFunction(operation, relativeResourcePath, path, resourceFunctionDocs);
            functions.add(resourceFunction);
        }
    }
    return functions;
}",java:S3776,39
"private FunctionDefinitionNode getResourceFunction(Map.Entry<PathItem.HttpMethod, Operation> operation, List<Node> pathNodes, String path, List<Node> resourceFunctionDocs) throws BallerinaOpenApiException{
    NodeList<Token> qualifiersList = createNodeList(createIdentifierToken(GeneratorConstants.RESOURCE, GeneratorUtils.SINGLE_WS_MINUTIAE, GeneratorUtils.SINGLE_WS_MINUTIAE));
    Token functionKeyWord = createIdentifierToken(GeneratorConstants.FUNCTION, GeneratorUtils.SINGLE_WS_MINUTIAE, GeneratorUtils.SINGLE_WS_MINUTIAE);
    IdentifierToken functionName = createIdentifierToken(operation.getKey().name().toLowerCase(Locale.ENGLISH), GeneratorUtils.SINGLE_WS_MINUTIAE, GeneratorUtils.SINGLE_WS_MINUTIAE);
    NodeList<Node> relativeResourcePath = createNodeList(pathNodes);
    ParametersGenerator parametersGenerator = new ParametersGenerator(false, openAPI);
    parametersGenerator.generateResourcesInputs(operation, resourceFunctionDocs);
    List<Node> params = new ArrayList<>(parametersGenerator.getRequiredParams());
    if (operation.getValue().getRequestBody() != null) {
        RequestBody requestBody = operation.getValue().getRequestBody();
        requestBody = resolveRequestBodyReference(requestBody);
        RequiredParameterNode nodeForRequestBody = null;
        if (requestBody.getContent() != null) {
            RequestBodyGenerator requestBodyGen = new RequestBodyGenerator(requestBody);
            nodeForRequestBody = requestBodyGen.createNodeForRequestBody();
            params.add(nodeForRequestBody);
            params.add(createToken(SyntaxKind.COMMA_TOKEN));
        }
        if (nodeForRequestBody != null && nodeForRequestBody.paramName().isPresent()) {
            String description = requestBody.getDescription() != null && !requestBody.getDescription().isBlank() ? requestBody.getDescription() : DEFAULT_PARAM_COMMENT;
            MarkdownParameterDocumentationLineNode paramAPIDoc = DocCommentsGenerator.createAPIParamDoc(escapeIdentifier(nodeForRequestBody.paramName().get().text()), description.split(""\n"")[0]);
            resourceFunctionDocs.add(paramAPIDoc);
        }
    }
    if (!parametersGenerator.getDefaultableParams().isEmpty()) {
        params.addAll(parametersGenerator.getDefaultableParams());
    }
    if (params.size() > 1) {
        params.remove(params.size() - 1);
    }
    if (!isNullableRequired) {
        isNullableRequired = parametersGenerator.isNullableRequired();
    }
    SeparatedNodeList<ParameterNode> parameters = createSeparatedNodeList(params);
    String pathForRecord = Objects.equals(path, SLASH) || Objects.equals(path, CATCH_ALL_PATH) ? """" : GeneratorUtils.getValidName(path, true);
    ReturnTypeGenerator returnTypeGenerator = new ReturnTypeGenerator(ballerinaSchemaGenerator, pathForRecord);
    if (!paths.contains(path)) {
        returnTypeGenerator.setCountForRecord(0);
        paths.add(path);
    }
    ReturnTypeDescriptorNode returnNode = returnTypeGenerator.getReturnTypeDescriptorNode(operation, createEmptyNodeList(), path, resourceFunctionDocs);
    typeInclusionRecords.putAll(returnTypeGenerator.getTypeInclusionRecords());
    FunctionSignatureNode functionSignatureNode = createFunctionSignatureNode(createToken(SyntaxKind.OPEN_PAREN_TOKEN), parameters, createToken(SyntaxKind.CLOSE_PAREN_TOKEN), returnNode);
    List<StatementNode> bodyStatements = GeneratorUtils.generateBodyStatementForComplexUrl(path);
    FunctionBodyBlockNode functionBodyBlockNode = createFunctionBodyBlockNode(createToken(SyntaxKind.OPEN_BRACE_TOKEN), null, bodyStatements.isEmpty() ? createEmptyNodeList() : createNodeList(bodyStatements), createToken(SyntaxKind.CLOSE_BRACE_TOKEN), null);
    List<AnnotationNode> annotationNodes = new ArrayList<>();
    MetadataNode metadataNode = createMetadataNode(createMarkdownDocumentationNode(createNodeList(resourceFunctionDocs)), createNodeList(annotationNodes));
    return createFunctionDefinitionNode(SyntaxKind.RESOURCE_ACCESSOR_DEFINITION, metadataNode, qualifiersList, functionKeyWord, functionName, relativeResourcePath, functionSignatureNode, functionBodyBlockNode);
}",java:S3776,39
"public void generateResourcesInputs(Map.Entry<PathItem.HttpMethod, Operation> operation, List<Node> resourceFunctionDocs) throws BallerinaOpenApiException{
    Token comma = createToken(SyntaxKind.COMMA_TOKEN);
    if (operation.getValue().getParameters() != null) {
        List<Parameter> parameters = operation.getValue().getParameters();
        for (Parameter parameter : parameters) {
            Node param = null;
            if (parameter.getIn().trim().equals(GeneratorConstants.HEADER)) {
                param = handleHeader(parameter);
                if (param.kind() == SyntaxKind.DEFAULTABLE_PARAM) {
                    defaultableParams.add(param);
                    defaultableParams.add(comma);
                } else {
                    requiredParams.add(param);
                    requiredParams.add(comma);
                }
            } else if (parameter.getIn().trim().equals(GeneratorConstants.QUERY)) {
                if (parameter.getRequired() != null && parameter.getRequired() && (parameter.getSchema() != null && parameter.getSchema().getNullable() != null && parameter.getSchema().getNullable())) {
                    isNullableRequired = true;
                }
                param = createNodeForQueryParam(parameter);
                if (param != null) {
                    if (param.kind() == SyntaxKind.DEFAULTABLE_PARAM) {
                        defaultableParams.add(param);
                        defaultableParams.add(comma);
                    } else {
                        requiredParams.add(param);
                        requiredParams.add(comma);
                    }
                }
            }
            if (param != null) {
                String parameterName = param instanceof RequiredParameterNode ? ((RequiredParameterNode) param).paramName().get().text() : ((DefaultableParameterNode) param).paramName().get().text();
                String paramComment = parameter.getDescription() != null && !parameter.getDescription().isBlank() ? parameter.getDescription() : DEFAULT_PARAM_COMMENT;
                MarkdownParameterDocumentationLineNode paramAPIDoc = DocCommentsGenerator.createAPIParamDoc(parameterName, paramComment);
                resourceFunctionDocs.add(paramAPIDoc);
            }
        }
    }
}",java:S3776,39
"private ParameterNode handleHeader(Parameter parameter) throws BallerinaOpenApiException{
    Schema<?> schema = parameter.getSchema();
    String headerType;
    TypeDescriptorNode headerTypeName;
    IdentifierToken parameterName = createIdentifierToken(GeneratorUtils.escapeIdentifier(parameter.getName().toLowerCase(Locale.ENGLISH)), AbstractNodeFactory.createEmptyMinutiaeList(), GeneratorUtils.SINGLE_WS_MINUTIAE);
    if (schema.getType() == null && schema.get$ref() == null) {
        throw new BallerinaOpenApiException(String.format(OAS_SERVICE_106.getDescription(), parameter.getName()));
    } else if (schema.get$ref() != null) {
        String type = getValidName(extractReferenceType(schema.get$ref()), true);
        Schema<?> refSchema = openAPI.getComponents().getSchemas().get(type.trim());
        if (paramSupportedTypes.contains(refSchema.getType()) || refSchema instanceof ArraySchema) {
            headerType = type;
        } else {
            throw new BallerinaOpenApiException(String.format(OAS_SERVICE_105.getDescription(), parameter.getName(), refSchema.getType()));
        }
    } else if (paramSupportedTypes.contains(schema.getType()) || schema instanceof ArraySchema) {
        headerType = convertOpenAPITypeToBallerina(schema).trim();
    } else {
        throw new BallerinaOpenApiException(String.format(OAS_SERVICE_105.getDescription(), parameter.getName(), schema.getType()));
    }
    if (schema instanceof ArraySchema) {
        Schema<?> items = ((ArraySchema) schema).getItems();
        String arrayType;
        if (items.getType() == null && items.get$ref() == null) {
            throw new BallerinaOpenApiException(String.format(OAS_SERVICE_104.getDescription(), parameter.getName()));
        } else if (items.get$ref() != null) {
            String type = getValidName(extractReferenceType(items.get$ref()), true);
            Schema<?> refSchema = openAPI.getComponents().getSchemas().get(type.trim());
            if (paramSupportedTypes.contains(refSchema.getType())) {
                arrayType = type;
            } else {
                throw new BallerinaOpenApiException(String.format(OAS_SERVICE_103.getDescription(), parameter.getName(), type));
            }
        } else if (!paramSupportedTypes.contains(items.getType())) {
            throw new BallerinaOpenApiException(String.format(OAS_SERVICE_103.getDescription(), parameter.getName(), items.getType()));
        } else if (items.getEnum() != null && !items.getEnum().isEmpty()) {
            arrayType = OPEN_PAREN_TOKEN.stringValue() + convertOpenAPITypeToBallerina(items) + CLOSE_PAREN_TOKEN.stringValue();
        } else {
            arrayType = GeneratorUtils.convertOpenAPITypeToBallerina(items);
        }
        BuiltinSimpleNameReferenceNode headerArrayItemTypeName = createBuiltinSimpleNameReferenceNode(null, createIdentifierToken(arrayType));
        ArrayDimensionNode dimensionNode = NodeFactory.createArrayDimensionNode(createToken(SyntaxKind.OPEN_BRACKET_TOKEN), null, createToken(SyntaxKind.CLOSE_BRACKET_TOKEN));
        NodeList<ArrayDimensionNode> nodeList = createNodeList(dimensionNode);
        headerTypeName = createArrayTypeDescriptorNode(headerArrayItemTypeName, nodeList);
    } else {
        headerTypeName = createBuiltinSimpleNameReferenceNode(null, createIdentifierToken(headerType, GeneratorUtils.SINGLE_WS_MINUTIAE, GeneratorUtils.SINGLE_WS_MINUTIAE));
    }
    AnnotationNode headerNode = getAnnotationNode(GeneratorConstants.HEADER_ANNOT, null);
    NodeList<AnnotationNode> headerAnnotations = createNodeList(headerNode);
    if (!parameter.getRequired()) {
        headerTypeName = headerTypeName.toString().trim().endsWith(NILLABLE) ? headerTypeName : createOptionalTypeDescriptorNode(headerTypeName, createToken(SyntaxKind.QUESTION_MARK_TOKEN));
    }
    if (schema.getDefault() != null) {
        return getDefaultableHeaderNode(schema, headerTypeName, parameterName, headerAnnotations);
    }
    if (parameter.getRequired() && schema.getNullable() != null && schema.getNullable().equals(true)) {
        isNullableRequired = true;
        headerTypeName = headerTypeName.toString().trim().endsWith(NILLABLE) ? headerTypeName : createOptionalTypeDescriptorNode(headerTypeName, createToken(SyntaxKind.QUESTION_MARK_TOKEN));
    }
    return createRequiredParameterNode(headerAnnotations, headerTypeName, parameterName);
}",java:S3776,39
"private ParameterNode handleHeader(Parameter parameter) throws BallerinaOpenApiException{
    Schema<?> schema = parameter.getSchema();
    String headerType;
    TypeDescriptorNode headerTypeName;
    IdentifierToken parameterName = createIdentifierToken(GeneratorUtils.escapeIdentifier(parameter.getName().toLowerCase(Locale.ENGLISH)), AbstractNodeFactory.createEmptyMinutiaeList(), GeneratorUtils.SINGLE_WS_MINUTIAE);
    if (schema.getType() == null && schema.get$ref() == null) {
        throw new BallerinaOpenApiException(String.format(OAS_SERVICE_106.getDescription(), parameter.getName()));
    } else if (schema.get$ref() != null) {
        String type = getValidName(extractReferenceType(schema.get$ref()), true);
        Schema<?> refSchema = openAPI.getComponents().getSchemas().get(type.trim());
        if (paramSupportedTypes.contains(refSchema.getType()) || refSchema instanceof ArraySchema) {
            headerType = type;
        } else {
            throw new BallerinaOpenApiException(String.format(OAS_SERVICE_105.getDescription(), parameter.getName(), refSchema.getType()));
        }
    } else if (paramSupportedTypes.contains(schema.getType()) || schema instanceof ArraySchema) {
        headerType = convertOpenAPITypeToBallerina(schema).trim();
    } else {
        throw new BallerinaOpenApiException(String.format(OAS_SERVICE_105.getDescription(), parameter.getName(), schema.getType()));
    }
    if (schema instanceof ArraySchema) {
        Schema<?> items = ((ArraySchema) schema).getItems();
        String arrayType;
        if (items.getType() == null && items.get$ref() == null) {
            throw new BallerinaOpenApiException(String.format(OAS_SERVICE_104.getDescription(), parameter.getName()));
        } else if (items.get$ref() != null) {
            String type = getValidName(extractReferenceType(items.get$ref()), true);
            Schema<?> refSchema = openAPI.getComponents().getSchemas().get(type.trim());
            if (paramSupportedTypes.contains(refSchema.getType())) {
                arrayType = type;
            } else {
                throw new BallerinaOpenApiException(String.format(OAS_SERVICE_103.getDescription(), parameter.getName(), type));
            }
        } else if (!paramSupportedTypes.contains(items.getType())) {
            throw new BallerinaOpenApiException(String.format(OAS_SERVICE_103.getDescription(), parameter.getName(), items.getType()));
        } else if (items.getEnum() != null && !items.getEnum().isEmpty()) {
            arrayType = OPEN_PAREN_TOKEN.stringValue() + convertOpenAPITypeToBallerina(items) + CLOSE_PAREN_TOKEN.stringValue();
        } else {
            arrayType = GeneratorUtils.convertOpenAPITypeToBallerina(items);
        }
        BuiltinSimpleNameReferenceNode headerArrayItemTypeName = createBuiltinSimpleNameReferenceNode(null, createIdentifierToken(arrayType));
        ArrayDimensionNode dimensionNode = NodeFactory.createArrayDimensionNode(createToken(SyntaxKind.OPEN_BRACKET_TOKEN), null, createToken(SyntaxKind.CLOSE_BRACKET_TOKEN));
        NodeList<ArrayDimensionNode> nodeList = createNodeList(dimensionNode);
        headerTypeName = createArrayTypeDescriptorNode(headerArrayItemTypeName, nodeList);
    } else {
        headerTypeName = createBuiltinSimpleNameReferenceNode(null, createIdentifierToken(headerType, GeneratorUtils.SINGLE_WS_MINUTIAE, GeneratorUtils.SINGLE_WS_MINUTIAE));
    }
    AnnotationNode headerNode = getAnnotationNode(GeneratorConstants.HEADER_ANNOT, null);
    NodeList<AnnotationNode> headerAnnotations = createNodeList(headerNode);
    if (!parameter.getRequired()) {
        headerTypeName = headerTypeName.toString().trim().endsWith(NILLABLE) ? headerTypeName : createOptionalTypeDescriptorNode(headerTypeName, createToken(SyntaxKind.QUESTION_MARK_TOKEN));
    }
    if (schema.getDefault() != null) {
        return getDefaultableHeaderNode(schema, headerTypeName, parameterName, headerAnnotations);
    }
    if (parameter.getRequired() && schema.getNullable() != null && schema.getNullable().equals(true)) {
        isNullableRequired = true;
        headerTypeName = headerTypeName.toString().trim().endsWith(NILLABLE) ? headerTypeName : createOptionalTypeDescriptorNode(headerTypeName, createToken(SyntaxKind.QUESTION_MARK_TOKEN));
    }
    return createRequiredParameterNode(headerAnnotations, headerTypeName, parameterName);
}",java:S6541,49
"public void getResourceInputs(Components components, SemanticModel semanticModel){
    List<Parameter> parameters = new LinkedList<>();
    NodeList<Node> pathParams = functionDefinitionNode.relativeResourcePath();
    createPathParameters(parameters, pathParams);
    FunctionSignatureNode functionSignature = functionDefinitionNode.functionSignature();
    SeparatedNodeList<ParameterNode> parameterList = functionSignature.parameters();
    for (ParameterNode parameterNode : parameterList) {
        OpenAPIQueryParameterMapper queryParameterMapper = new OpenAPIQueryParameterMapper(apidocs, components, semanticModel);
        if (parameterNode.kind() == SyntaxKind.REQUIRED_PARAM) {
            RequiredParameterNode requiredParameterNode = (RequiredParameterNode) parameterNode;
            if (requiredParameterNode.typeName().kind() == SyntaxKind.QUALIFIED_NAME_REFERENCE) {
                QualifiedNameReferenceNode referenceNode = (QualifiedNameReferenceNode) requiredParameterNode.typeName();
                String typeName = (referenceNode).modulePrefix().text() + "":"" + (referenceNode).identifier().text();
                if (typeName.equals(HTTP_REQUEST) && (Constants.GET.equalsIgnoreCase(operationAdaptor.getHttpOperation()))) {
                    DiagnosticMessages errorMessage = DiagnosticMessages.OAS_CONVERTOR_113;
                    IncompatibleResourceDiagnostic error = new IncompatibleResourceDiagnostic(errorMessage, referenceNode.location());
                    errors.add(error);
                } else if (typeName.equals(HTTP_REQUEST)) {
                    RequestBody requestBody = new RequestBody();
                    MediaType mediaType = new MediaType();
                    mediaType.setSchema(new Schema<>().description(WILD_CARD_SUMMARY));
                    requestBody.setContent(new Content().addMediaType(WILD_CARD_CONTENT_KEY, mediaType));
                    operationAdaptor.getOperation().setRequestBody(requestBody);
                }
            }
            if (requiredParameterNode.typeName().kind() != SyntaxKind.QUALIFIED_NAME_REFERENCE && requiredParameterNode.annotations().isEmpty()) {
                parameters.add(queryParameterMapper.createQueryParameter(requiredParameterNode));
            }
            if (requiredParameterNode.typeName() instanceof TypeDescriptorNode && !requiredParameterNode.annotations().isEmpty()) {
                handleAnnotationParameters(components, semanticModel, parameters, requiredParameterNode);
            }
        } else if (parameterNode.kind() == SyntaxKind.DEFAULTABLE_PARAM) {
            DefaultableParameterNode defaultableParameterNode = (DefaultableParameterNode) parameterNode;
            if (defaultableParameterNode.typeName() instanceof TypeDescriptorNode && !defaultableParameterNode.annotations().isEmpty()) {
                parameters.addAll(handleDefaultableAnnotationParameters(defaultableParameterNode));
            } else {
                parameters.add(queryParameterMapper.createQueryParameter(defaultableParameterNode));
            }
        }
    }
    if (parameters.isEmpty()) {
        operationAdaptor.getOperation().setParameters(null);
    } else {
        operationAdaptor.getOperation().setParameters(parameters);
    }
}",java:S3776,39
"public ReturnTypeDescriptorNode getReturnTypeDescriptorNode(Map.Entry<PathItem.HttpMethod, Operation> operation, NodeList<AnnotationNode> annotations, String path, List<Node> resourceFunctionDocs) throws BallerinaOpenApiException{
    ReturnTypeDescriptorNode returnNode;
    List<String> returnDescriptions = new ArrayList<>();
    httpMethod = operation.getKey().name().toLowerCase(Locale.ENGLISH);
    if (operation.getValue().getResponses() != null) {
        ApiResponses responses = operation.getValue().getResponses();
        if (responses.size() > 1) {
            TypeDescriptorNode type = handleMultipleResponse(responses, returnDescriptions);
            returnNode = createReturnTypeDescriptorNode(createToken(RETURNS_KEYWORD), annotations, type);
        } else if (responses.size() == 1) {
            Iterator<Map.Entry<String, ApiResponse>> responseIterator = responses.entrySet().iterator();
            Map.Entry<String, ApiResponse> response = responseIterator.next();
            returnNode = handleSingleResponse(annotations, response);
            if (response.getValue().getDescription() != null && !response.getValue().getDescription().isEmpty()) {
                returnDescriptions.add(response.getValue().getDescription());
            } else {
                returnDescriptions.add(DEFAULT_RETURN_COMMENT);
            }
        } else {
            TypeDescriptorNode defaultType = createSimpleNameReferenceNode(createIdentifierToken(HTTP_RESPONSE));
            returnNode = createReturnTypeDescriptorNode(createToken(RETURNS_KEYWORD), annotations, defaultType);
            returnDescriptions.add(HTTP_RESPONSE);
        }
    } else {
        returnNode = createReturnTypeDescriptorNode(createToken(SyntaxKind.RETURNS_KEYWORD), createEmptyNodeList(), createSimpleNameReferenceNode(createIdentifierToken(""error?"")));
        returnDescriptions.add(ERROR);
    }
    if (returnDescriptions.size() > 1) {
        StringBuilder returnDescriptionForUnions = new StringBuilder(""# + return - returns can be any of following types\n"");
        String typeDescriptionTemplate = ""#            %s (%s)%n"";
        for (String description : returnDescriptions) {
            String[] values = description.split(""\\|"");
            String responseDescription = values[1].replaceAll(""[\\r\\n\\t]"", "" "");
            returnDescriptionForUnions.append(String.format(typeDescriptionTemplate, values[0], responseDescription));
        }
        String dummyTypeWithDescription = returnDescriptionForUnions.toString() + ""type a A;"";
        ModuleMemberDeclarationNode moduleMemberDeclarationNode = NodeParser.parseModuleMemberDeclaration(dummyTypeWithDescription);
        TypeDefinitionNode typeDefinitionNode = (TypeDefinitionNode) moduleMemberDeclarationNode;
        MetadataNode metadataNode = typeDefinitionNode.metadata().get();
        MarkdownDocumentationNode returnDoc = (MarkdownDocumentationNode) metadataNode.children().get(0);
        resourceFunctionDocs.add(returnDoc);
    } else {
        MarkdownParameterDocumentationLineNode returnDoc = DocCommentsGenerator.createAPIParamDoc(RETURN_KEYWORD.stringValue(), returnDescriptions.get(0));
        resourceFunctionDocs.add(returnDoc);
    }
    if (GeneratorUtils.isComplexURL(path)) {
        assert returnNode != null;
        String returnStatement = returnNode.toString().trim().replace(RETURNS, """") + ""|error"";
        return createReturnTypeDescriptorNode(createToken(SyntaxKind.RETURNS_KEYWORD), createEmptyNodeList(), createSimpleNameReferenceNode(createIdentifierToken(returnStatement)));
    }
    return returnNode;
}",java:S3776,39
"private ReturnTypeDescriptorNode handleSingleResponse(NodeList<AnnotationNode> annotations, Map.Entry<String, ApiResponse> response) throws BallerinaOpenApiException{
    ReturnTypeDescriptorNode returnNode = null;
    Token returnKeyWord = createToken(RETURNS_KEYWORD);
    ApiResponse responseValue = response.getValue();
    Content responseContent = responseValue.getContent();
    if (responseContent == null && responseValue.get$ref() == null || (responseContent != null && responseContent.size() == 0)) {
        String code = GeneratorConstants.HTTP_CODES_DES.get(response.getKey().trim());
        TypeDescriptorNode statues;
        if (response.getKey().trim().equals(GeneratorConstants.DEFAULT)) {
            statues = createSimpleNameReferenceNode(createIdentifierToken(HTTP_RESPONSE));
        } else {
            statues = GeneratorUtils.getQualifiedNameReferenceNode(GeneratorConstants.HTTP, code);
        }
        returnNode = createReturnTypeDescriptorNode(returnKeyWord, annotations, statues);
    } else if (responseContent != null) {
        String responseCode = response.getKey().trim();
        boolean isWithOutStatusCode = (httpMethod.equals(POST) && responseCode.equals(GeneratorConstants.HTTP_201)) || (!httpMethod.equals(POST) && responseCode.equals(GeneratorConstants.HTTP_200));
        if (isWithOutStatusCode) {
            Set<Map.Entry<String, MediaType>> contentEntries = responseContent.entrySet();
            returnNode = getReturnNodeForSchemaType(contentEntries);
        } else if (response.getKey().trim().equals(GeneratorConstants.DEFAULT)) {
            BuiltinSimpleNameReferenceNode type = createBuiltinSimpleNameReferenceNode(null, createIdentifierToken(HTTP_RESPONSE));
            returnNode = createReturnTypeDescriptorNode(returnKeyWord, createEmptyNodeList(), type);
        } else {
            String code = GeneratorConstants.HTTP_CODES_DES.get(response.getKey().trim());
            TypeDescriptorNode type;
            if (responseContent.entrySet().size() > 1) {
                type = handleMultipleContents(responseContent.entrySet());
            } else {
                Iterator<Map.Entry<String, MediaType>> contentItr = responseContent.entrySet().iterator();
                Map.Entry<String, MediaType> mediaTypeEntry = contentItr.next();
                String recordName = getNewRecordName();
                ImmutablePair<Optional<TypeDescriptorNode>, Optional<TypeDefinitionNode>> mediaTypeToken = handleMediaType(mediaTypeEntry, recordName);
                Optional<TypeDefinitionNode> rightNode = mediaTypeToken.right;
                if (rightNode.isPresent()) {
                    typeInclusionRecords.put(recordName, rightNode.get());
                    setCountForRecord(countForRecord++);
                    type = createSimpleNameReferenceNode(createIdentifierToken(recordName));
                } else {
                    type = mediaTypeToken.left.orElseGet(() -> createSimpleNameReferenceNode(createIdentifierToken(ANYDATA)));
                }
            }
            if (!type.toString().equals(HTTP_RESPONSE)) {
                SimpleNameReferenceNode recordType = createReturnTypeInclusionRecord(code, type);
                NodeList<AnnotationNode> annotation = createEmptyNodeList();
                returnNode = createReturnTypeDescriptorNode(returnKeyWord, annotation, recordType);
            }
        }
    }
    return returnNode;
}",java:S3776,39
"public Parameter createQueryParameter(RequiredParameterNode queryParam){
    String queryParamName = unescapeIdentifier(queryParam.paramName().get().text());
    boolean isQuery = !queryParam.paramName().get().text().equals(Constants.PATH) && queryParam.annotations().isEmpty();
    if (queryParam.typeName() instanceof BuiltinSimpleNameReferenceNode && isQuery) {
        QueryParameter queryParameter = new QueryParameter();
        queryParameter.setName(unescapeIdentifier(queryParamName));
        Schema openApiSchema = ConverterCommonUtils.getOpenApiSchema(queryParam.typeName().toString().trim());
        queryParameter.setSchema(openApiSchema);
        queryParameter.setRequired(true);
        if (!apidocs.isEmpty() && queryParam.paramName().isPresent() && apidocs.containsKey(queryParamName)) {
            queryParameter.setDescription(apidocs.get(queryParamName.trim()));
        }
        return queryParameter;
    } else if (queryParam.typeName().kind() == OPTIONAL_TYPE_DESC && isQuery) {
        NodeList<AnnotationNode> annotations = getAnnotationNodesFromServiceNode(queryParam);
        String isOptional = Constants.TRUE;
        if (!annotations.isEmpty()) {
            Optional<String> values = ConverterCommonUtils.extractServiceAnnotationDetails(annotations, ""http:ServiceConfig"", ""treatNilableAsOptional"");
            if (values.isPresent()) {
                isOptional = values.get();
            }
        }
        return setOptionalQueryParameter(queryParamName, ((OptionalTypeDescriptorNode) queryParam.typeName()), isOptional);
    } else if (queryParam.typeName().kind() == SyntaxKind.ARRAY_TYPE_DESC && isQuery) {
        ArrayTypeDescriptorNode arrayNode = (ArrayTypeDescriptorNode) queryParam.typeName();
        return handleArrayTypeQueryParameter(queryParamName, arrayNode);
    } else if (queryParam.typeName() instanceof SimpleNameReferenceNode && isQuery) {
        QueryParameter queryParameter = new QueryParameter();
        queryParameter.setName(unescapeIdentifier(queryParamName));
        SimpleNameReferenceNode queryNode = (SimpleNameReferenceNode) queryParam.typeName();
        OpenAPIComponentMapper componentMapper = new OpenAPIComponentMapper(components);
        TypeSymbol typeSymbol = (TypeSymbol) semanticModel.symbol(queryNode).orElseThrow();
        componentMapper.createComponentSchema(components.getSchemas(), typeSymbol);
        Schema<?> schema = new Schema<>();
        schema.set$ref(unescapeIdentifier(queryNode.name().text().trim()));
        queryParameter.setSchema(schema);
        queryParameter.setRequired(true);
        if (!apidocs.isEmpty() && queryParam.paramName().isPresent() && apidocs.containsKey(queryParamName)) {
            queryParameter.setDescription(apidocs.get(queryParamName.trim()));
        }
        return queryParameter;
    } else if (queryParam.typeName().kind() == SIMPLE_NAME_REFERENCE) {
        QueryParameter queryParameter = new QueryParameter();
        Schema<?> refSchema = handleReference(semanticModel, components, (SimpleNameReferenceNode) queryParam.typeName());
        queryParameter.setSchema(refSchema);
        queryParameter.setRequired(true);
        if (!apidocs.isEmpty() && apidocs.containsKey(queryParamName)) {
            queryParameter.setDescription(apidocs.get(queryParamName));
        }
        return queryParameter;
    } else {
        QueryParameter queryParameter = createContentTypeForMapJson(queryParamName, false);
        if (!apidocs.isEmpty() && queryParam.paramName().isPresent() && apidocs.containsKey(queryParamName)) {
            queryParameter.setDescription(apidocs.get(queryParamName.trim()));
        }
        return queryParameter;
    }
}",java:S3776,39
"private TypeDescriptorNode handleMultipleResponse(ApiResponses responses, List<String> returnDescription) throws BallerinaOpenApiException{
    Set<String> qualifiedNodes = new LinkedHashSet<>();
    for (Map.Entry<String, ApiResponse> response : responses.entrySet()) {
        String responseCode = response.getKey().trim();
        String code = GeneratorConstants.HTTP_CODES_DES.get(responseCode);
        Content content = response.getValue().getContent();
        String typeName = null;
        if (code == null && !responseCode.equals(GeneratorConstants.DEFAULT)) {
            throw new BallerinaOpenApiException(String.format(OAS_SERVICE_107.getDescription(), responseCode));
        }
        if (responseCode.equals(GeneratorConstants.DEFAULT)) {
            TypeDescriptorNode record = createSimpleNameReferenceNode(createIdentifierToken(HTTP_RESPONSE));
            typeName = record.toSourceCode();
        } else if (content == null && response.getValue().get$ref() == null || content != null && content.size() == 0) {
            QualifiedNameReferenceNode node = GeneratorUtils.getQualifiedNameReferenceNode(GeneratorConstants.HTTP, code);
            typeName = node.toSourceCode();
        } else if (content != null) {
            TypeDescriptorNode bodyType = handleMultipleContents(content.entrySet());
            boolean isWithOutStatusCode = (httpMethod.equals(POST) && responseCode.equals(GeneratorConstants.HTTP_201)) || (!httpMethod.equals(POST) && responseCode.equals(GeneratorConstants.HTTP_200));
            if (isWithOutStatusCode) {
                typeName = bodyType.toSourceCode();
            } else {
                SimpleNameReferenceNode node = createReturnTypeInclusionRecord(code, bodyType);
                typeName = node.name().text();
            }
        }
        if (typeName != null) {
            qualifiedNodes.add(typeName);
            if (response.getValue().getDescription() != null && !response.getValue().getDescription().isEmpty()) {
                returnDescription.add(typeName.trim() + PIPE + response.getValue().getDescription().trim());
            }
        }
    }
    String unionType = String.join(PIPE, qualifiedNodes);
    if (qualifiedNodes.contains(ANYDATA)) {
        return NodeParser.parseTypeDescriptor(ANYDATA);
    }
    return NodeParser.parseTypeDescriptor(unionType);
}",java:S3776,39
"public Parameter createQueryParameter(DefaultableParameterNode defaultableQueryParam){
    String queryParamName = defaultableQueryParam.paramName().get().text();
    boolean isQuery = !defaultableQueryParam.paramName().get().text().equals(Constants.PATH) && defaultableQueryParam.annotations().isEmpty();
    QueryParameter queryParameter = new QueryParameter();
    if (defaultableQueryParam.typeName() instanceof BuiltinSimpleNameReferenceNode && isQuery) {
        queryParameter.setName(unescapeIdentifier(queryParamName));
        Schema openApiSchema = ConverterCommonUtils.getOpenApiSchema(defaultableQueryParam.typeName().toString().trim());
        queryParameter.setSchema(openApiSchema);
        if (!apidocs.isEmpty() && defaultableQueryParam.paramName().isPresent() && apidocs.containsKey(queryParamName)) {
            queryParameter.setDescription(apidocs.get(queryParamName.trim()));
        }
    } else if (defaultableQueryParam.typeName().kind() == OPTIONAL_TYPE_DESC && isQuery) {
        queryParameter = setOptionalQueryParameter(queryParamName, ((OptionalTypeDescriptorNode) defaultableQueryParam.typeName()), Constants.TRUE);
    } else if (defaultableQueryParam.typeName() instanceof ArrayTypeDescriptorNode && isQuery) {
        ArrayTypeDescriptorNode arrayNode = (ArrayTypeDescriptorNode) defaultableQueryParam.typeName();
        queryParameter = handleArrayTypeQueryParameter(queryParamName, arrayNode);
    } else if (defaultableQueryParam.typeName().kind() == SIMPLE_NAME_REFERENCE) {
        queryParameter.setName(unescapeIdentifier(queryParamName));
        Schema<?> refSchema = handleReference(semanticModel, components, (SimpleNameReferenceNode) defaultableQueryParam.typeName());
        queryParameter.setSchema(refSchema);
        queryParameter.setRequired(true);
        if (!apidocs.isEmpty() && apidocs.containsKey(queryParamName)) {
            queryParameter.setDescription(apidocs.get(queryParamName));
        }
    } else {
        queryParameter = createContentTypeForMapJson(queryParamName, false);
        if (!apidocs.isEmpty() && defaultableQueryParam.paramName().isPresent() && apidocs.containsKey(queryParamName)) {
            queryParameter.setDescription(apidocs.get(queryParamName.trim()));
        }
    }
    if (Arrays.stream(validExpressionKind).anyMatch(syntaxKind -> syntaxKind == defaultableQueryParam.expression().kind())) {
        String defaultValue = defaultableQueryParam.expression().toString().replaceAll(""\"""", """");
        if (defaultableQueryParam.expression().kind() == NIL_LITERAL) {
            defaultValue = null;
        }
        if (queryParameter.getContent() != null) {
            Content content = queryParameter.getContent();
            for (Map.Entry<String, MediaType> stringMediaTypeEntry : content.entrySet()) {
                Schema schema = stringMediaTypeEntry.getValue().getSchema();
                schema.setDefault(defaultValue);
                io.swagger.v3.oas.models.media.MediaType media = new io.swagger.v3.oas.models.media.MediaType();
                media.setSchema(schema);
                content.addMediaType(stringMediaTypeEntry.getKey(), media);
            }
        } else {
            Schema schema = queryParameter.getSchema();
            schema.setDefault(defaultValue);
            queryParameter.setSchema(schema);
        }
    }
    return queryParameter;
}",java:S3776,39
"private QueryParameter setOptionalQueryParameter(String queryParamName, OptionalTypeDescriptorNode typeNode, String isOptional){
    QueryParameter queryParameter = new QueryParameter();
    if (isOptional.equals(Constants.FALSE)) {
        queryParameter.setRequired(true);
    }
    queryParameter.setName(unescapeIdentifier(queryParamName));
    Node node = typeNode.typeDescriptor();
    if (node.kind() == SyntaxKind.ARRAY_TYPE_DESC) {
        ArraySchema arraySchema = new ArraySchema();
        arraySchema.setNullable(true);
        ArrayTypeDescriptorNode arrayNode = (ArrayTypeDescriptorNode) node;
        TypeDescriptorNode itemTypeNode = arrayNode.memberTypeDesc();
        Schema itemSchema;
        if (arrayNode.memberTypeDesc().kind() == SIMPLE_NAME_REFERENCE) {
            itemSchema = getItemSchemaForReference(arrayNode);
        } else {
            itemSchema = ConverterCommonUtils.getOpenApiSchema(itemTypeNode.toString().trim());
        }
        arraySchema.setItems(itemSchema);
        queryParameter.schema(arraySchema);
        queryParameter.setName(unescapeIdentifier(queryParamName));
        if (!apidocs.isEmpty() && apidocs.containsKey(queryParamName)) {
            queryParameter.setDescription(apidocs.get(queryParamName));
        }
        return queryParameter;
    } else if (node.kind() == SyntaxKind.MAP_TYPE_DESC) {
        queryParameter = createContentTypeForMapJson(queryParamName, true);
        if (isOptional.equals(Constants.FALSE)) {
            queryParameter.setRequired(true);
        }
        if (!apidocs.isEmpty() && apidocs.containsKey(queryParamName)) {
            queryParameter.setDescription(apidocs.get(queryParamName));
        }
        return queryParameter;
    } else if (node.kind() == SIMPLE_NAME_REFERENCE) {
        Schema<?> refSchema = handleReference(semanticModel, components, (SimpleNameReferenceNode) node);
        queryParameter.setSchema(refSchema);
        if (isOptional.equals(Constants.FALSE)) {
            queryParameter.setRequired(true);
        }
        if (!apidocs.isEmpty() && apidocs.containsKey(queryParamName)) {
            queryParameter.setDescription(apidocs.get(queryParamName));
        }
        return queryParameter;
    } else {
        Schema<?> openApiSchema = ConverterCommonUtils.getOpenApiSchema(node.toString().trim());
        openApiSchema.setNullable(true);
        queryParameter.setSchema(openApiSchema);
        if (!apidocs.isEmpty() && apidocs.containsKey(queryParamName)) {
            queryParameter.setDescription(apidocs.get(queryParamName));
        }
        return queryParameter;
    }
}",java:S3776,39
"private void handleSinglePayloadType(RequiredParameterNode payloadNode, Map<String, Schema> schema, RequestBody bodyParameter, String customMediaPrefix){
    String consumes = payloadNode.typeName().toString().trim();
    String mediaTypeString;
    switch(consumes) {
        case Constants.JSON:
            mediaTypeString = customMediaPrefix == null ? MediaType.APPLICATION_JSON : APPLICATION_PREFIX + customMediaPrefix + JSON_POSTFIX;
            addConsumes(operationAdaptor, bodyParameter, mediaTypeString);
            break;
        case Constants.XML:
            mediaTypeString = customMediaPrefix == null ? MediaType.APPLICATION_XML : APPLICATION_PREFIX + customMediaPrefix + XML_POSTFIX;
            addConsumes(operationAdaptor, bodyParameter, mediaTypeString);
            break;
        case Constants.STRING:
            mediaTypeString = customMediaPrefix == null ? MediaType.TEXT_PLAIN : TEXT_PREFIX + customMediaPrefix + TEXT_POSTFIX;
            addConsumes(operationAdaptor, bodyParameter, mediaTypeString);
            break;
        case Constants.BYTE_ARRAY:
            mediaTypeString = customMediaPrefix == null ? MediaType.APPLICATION_OCTET_STREAM : APPLICATION_PREFIX + customMediaPrefix + OCTECT_STREAM_POSTFIX;
            addConsumes(operationAdaptor, bodyParameter, mediaTypeString);
            break;
        case Constants.MAP_STRING:
            mediaTypeString = customMediaPrefix == null ? MediaType.APPLICATION_JSON : APPLICATION_PREFIX + customMediaPrefix + JSON_POSTFIX;
            Schema objectSchema = new ObjectSchema();
            objectSchema.additionalProperties(new StringSchema());
            io.swagger.v3.oas.models.media.MediaType mediaType = new io.swagger.v3.oas.models.media.MediaType();
            mediaType.setSchema(objectSchema);
            bodyParameter.setContent(new Content().addMediaType(mediaTypeString, mediaType));
            operationAdaptor.getOperation().setRequestBody(bodyParameter);
            break;
        default:
            Node node = payloadNode.typeName();
            mediaTypeString = customMediaPrefix == null ? MediaType.APPLICATION_JSON : APPLICATION_PREFIX + customMediaPrefix + JSON_POSTFIX;
            if (node.kind() == SyntaxKind.SIMPLE_NAME_REFERENCE) {
                SimpleNameReferenceNode record = (SimpleNameReferenceNode) node;
                TypeSymbol typeSymbol = getReferenceTypeSymbol(semanticModel.symbol(record));
                String recordName = record.name().toString().trim();
                handleReferencePayload(typeSymbol, recordName, schema, mediaTypeString, bodyParameter);
            } else if (node instanceof ArrayTypeDescriptorNode) {
                handleArrayTypePayload(schema, (ArrayTypeDescriptorNode) node, mediaTypeString, bodyParameter);
            } else if (node.kind() == SyntaxKind.QUALIFIED_NAME_REFERENCE) {
                QualifiedNameReferenceNode separateRecord = (QualifiedNameReferenceNode) node;
                TypeSymbol typeSymbol = getReferenceTypeSymbol(semanticModel.symbol(separateRecord));
                String recordName = ((QualifiedNameReferenceNode) payloadNode.typeName()).identifier().text();
                handleReferencePayload(typeSymbol, recordName, schema, mediaTypeString, bodyParameter);
            }
            break;
    }
}",java:S3776,39
"private void validateSimpleNameReference(SimpleNameReferenceNode simpleRefNode, ApiResponses responses){
    Optional<Symbol> symbol = validatorContext.getContext().semanticModel().symbol(simpleRefNode);
    if (symbol.isEmpty()) {
        return;
    }
    if (symbol.get() instanceof TypeReferenceTypeSymbol) {
        TypeReferenceTypeSymbol refType = (TypeReferenceTypeSymbol) symbol.get();
        TypeSymbol type = refType.typeDescriptor();
        if (type instanceof RecordTypeSymbol) {
            RecordTypeSymbol typeSymbol = (RecordTypeSymbol) type;
            List<TypeSymbol> typeInclusions = typeSymbol.typeInclusions();
            boolean isHttp = false;
            Map<String, Schema> oasSchemas = validatorContext.getOpenAPI().getComponents().getSchemas();
            if (!typeInclusions.isEmpty()) {
                for (TypeSymbol typeInSymbol : typeInclusions) {
                    if (HTTP.equals(typeInSymbol.getModule().orElseThrow().getName().orElseThrow())) {
                        isHttp = true;
                        Optional<String> code = generateApiResponseCode(typeInSymbol.getName().orElseThrow().trim());
                        if (code.isEmpty()) {
                            return;
                        }
                        balStatusCodes.put(code.get(), simpleRefNode);
                        if (responses.containsKey(code.get())) {
                            ApiResponse apiResponse = responses.get(code.get());
                            Map<String, RecordFieldSymbol> fields = typeSymbol.fieldDescriptors();
                            TypeSymbol bodyFieldType = fields.get(BODY).typeDescriptor();
                            TypeDescKind bodyKind = bodyFieldType.typeKind();
                            String mediaType = getMediaType(bodyKind);
                            fillMediaTypes(code.get(), mediaType);
                            Content content = apiResponse.getContent();
                            if (content != null) {
                                MediaType oasMtype = content.get(mediaType);
                                if (!content.containsKey(mediaType)) {
                                    return;
                                }
                                if (oasMtype.getSchema() != null && oasMtype.getSchema().get$ref() != null && bodyKind == TypeDescKind.TYPE_REFERENCE) {
                                    Optional<String> schemaName = extractReferenceType(oasMtype.getSchema().get$ref());
                                    if (schemaName.isEmpty()) {
                                        return;
                                    }
                                    TypeValidatorUtils.validateRecordType(oasSchemas.get(schemaName.get()), bodyFieldType, ((TypeReferenceTypeSymbol) bodyFieldType).definition().getName().get(), validatorContext.getContext(), validatorContext.getOpenAPI(), schemaName.get(), validatorContext.getSeverity());
                                }
                            }
                        }
                    }
                }
            }
            if (!isHttp) {
                if (responses.containsKey(HTTP_200)) {
                    ApiResponse apiResponse = responses.get(HTTP_200);
                    Content content = apiResponse.getContent();
                    MediaType oasMType = content.get(APPLICATION_JSON);
                    balStatusCodes.put(HTTP_200, simpleRefNode);
                    fillMediaTypes(HTTP_200, APPLICATION_JSON);
                    if (oasMType != null && oasMType.getSchema() != null && oasMType.getSchema().get$ref() != null) {
                        Optional<String> schemaName = extractReferenceType(oasMType.getSchema().get$ref());
                        if (schemaName.isEmpty()) {
                            return;
                        }
                        TypeValidatorUtils.validateRecordType(oasSchemas.get(schemaName.get()), typeSymbol, refType.definition().getName().orElse(null), validatorContext.getContext(), validatorContext.getOpenAPI(), schemaName.orElse(null), validatorContext.getSeverity());
                    }
                }
            }
        }
    }
}",java:S3776,39
"private void validateSimpleNameReference(SimpleNameReferenceNode simpleRefNode, ApiResponses responses){
    Optional<Symbol> symbol = validatorContext.getContext().semanticModel().symbol(simpleRefNode);
    if (symbol.isEmpty()) {
        return;
    }
    if (symbol.get() instanceof TypeReferenceTypeSymbol) {
        TypeReferenceTypeSymbol refType = (TypeReferenceTypeSymbol) symbol.get();
        TypeSymbol type = refType.typeDescriptor();
        if (type instanceof RecordTypeSymbol) {
            RecordTypeSymbol typeSymbol = (RecordTypeSymbol) type;
            List<TypeSymbol> typeInclusions = typeSymbol.typeInclusions();
            boolean isHttp = false;
            Map<String, Schema> oasSchemas = validatorContext.getOpenAPI().getComponents().getSchemas();
            if (!typeInclusions.isEmpty()) {
                for (TypeSymbol typeInSymbol : typeInclusions) {
                    if (HTTP.equals(typeInSymbol.getModule().orElseThrow().getName().orElseThrow())) {
                        isHttp = true;
                        Optional<String> code = generateApiResponseCode(typeInSymbol.getName().orElseThrow().trim());
                        if (code.isEmpty()) {
                            return;
                        }
                        balStatusCodes.put(code.get(), simpleRefNode);
                        if (responses.containsKey(code.get())) {
                            ApiResponse apiResponse = responses.get(code.get());
                            Map<String, RecordFieldSymbol> fields = typeSymbol.fieldDescriptors();
                            TypeSymbol bodyFieldType = fields.get(BODY).typeDescriptor();
                            TypeDescKind bodyKind = bodyFieldType.typeKind();
                            String mediaType = getMediaType(bodyKind);
                            fillMediaTypes(code.get(), mediaType);
                            Content content = apiResponse.getContent();
                            if (content != null) {
                                MediaType oasMtype = content.get(mediaType);
                                if (!content.containsKey(mediaType)) {
                                    return;
                                }
                                if (oasMtype.getSchema() != null && oasMtype.getSchema().get$ref() != null && bodyKind == TypeDescKind.TYPE_REFERENCE) {
                                    Optional<String> schemaName = extractReferenceType(oasMtype.getSchema().get$ref());
                                    if (schemaName.isEmpty()) {
                                        return;
                                    }
                                    TypeValidatorUtils.validateRecordType(oasSchemas.get(schemaName.get()), bodyFieldType, ((TypeReferenceTypeSymbol) bodyFieldType).definition().getName().get(), validatorContext.getContext(), validatorContext.getOpenAPI(), schemaName.get(), validatorContext.getSeverity());
                                }
                            }
                        }
                    }
                }
            }
            if (!isHttp) {
                if (responses.containsKey(HTTP_200)) {
                    ApiResponse apiResponse = responses.get(HTTP_200);
                    Content content = apiResponse.getContent();
                    MediaType oasMType = content.get(APPLICATION_JSON);
                    balStatusCodes.put(HTTP_200, simpleRefNode);
                    fillMediaTypes(HTTP_200, APPLICATION_JSON);
                    if (oasMType != null && oasMType.getSchema() != null && oasMType.getSchema().get$ref() != null) {
                        Optional<String> schemaName = extractReferenceType(oasMType.getSchema().get$ref());
                        if (schemaName.isEmpty()) {
                            return;
                        }
                        TypeValidatorUtils.validateRecordType(oasSchemas.get(schemaName.get()), typeSymbol, refType.definition().getName().orElse(null), validatorContext.getContext(), validatorContext.getOpenAPI(), schemaName.orElse(null), validatorContext.getSeverity());
                    }
                }
            }
        }
    }
}",java:S6541,49
"private void validateObjectSchema(ObjectSchema objectSchema, SimpleNameReferenceNode simpleRefNode){
    Optional<Symbol> symbol = validatorContext.getContext().semanticModel().symbol(simpleRefNode);
    if (symbol.isEmpty()) {
        return;
    }
    if (symbol.get() instanceof TypeReferenceTypeSymbol) {
        TypeReferenceTypeSymbol refType = (TypeReferenceTypeSymbol) symbol.get();
        TypeSymbol type = refType.typeDescriptor();
        if (type instanceof RecordTypeSymbol) {
            RecordTypeSymbol typeSymbol = (RecordTypeSymbol) type;
            List<TypeSymbol> typeInclusions = typeSymbol.typeInclusions();
            boolean isHttp = false;
            if (!typeInclusions.isEmpty()) {
                for (TypeSymbol typeInSymbol : typeInclusions) {
                    if (HTTP.equals(typeInSymbol.getModule().orElseThrow().getName().orElseThrow())) {
                        isHttp = true;
                        Map<String, RecordFieldSymbol> fields = typeSymbol.fieldDescriptors();
                        TypeSymbol bodyFieldType = fields.get(BODY).typeDescriptor();
                        if (bodyFieldType instanceof TypeReferenceTypeSymbol) {
                            TypeValidatorUtils.validateObjectSchema(objectSchema, bodyFieldType, validatorContext.getContext(), ((TypeReferenceTypeSymbol) bodyFieldType).definition().getName().orElse(ANONYMOUS_RECORD), validatorContext.getLocation(), validatorContext.getSeverity());
                        }
                    }
                }
                if (!isHttp) {
                    TypeValidatorUtils.validateObjectSchema(objectSchema, typeSymbol, validatorContext.getContext(), ((TypeReferenceTypeSymbol) typeSymbol).definition().getName().orElse(ANONYMOUS_RECORD), validatorContext.getLocation(), validatorContext.getSeverity());
                }
            } else {
                TypeValidatorUtils.validateObjectSchema(objectSchema, typeSymbol, validatorContext.getContext(), refType.definition().getName().orElse(ANONYMOUS_RECORD), validatorContext.getLocation(), validatorContext.getSeverity());
            }
        }
    }
}",java:S3776,39
"private List<OpenAPIPathSummary> validateMissingBalResources(List<OpenAPIPathSummary> operations, Map<String, ResourcePathSummary> resources){
    boolean filterEnable = filter.getOperation() != null || filter.getTag() != null || filter.getExcludeTag() != null || filter.getExcludeOperation() != null;
    Iterator<OpenAPIPathSummary> openAPIPathIterator = operations.iterator();
    while (openAPIPathIterator.hasNext()) {
        OpenAPIPathSummary operationPath = openAPIPathIterator.next();
        if (!resources.containsKey(operationPath.getPath())) {
            if (!filterEnable) {
                reportDiagnostic(context, CompilationError.MISSING_RESOURCE_PATH, context.node().location(), filter.getKind(), getNormalizedPath(operationPath.getPath()));
            }
            openAPIPathIterator.remove();
        } else {
            ResourcePathSummary resourcePath = resources.get(operationPath.getPath());
            Map<String, ResourceMethod> resourceMethods = resourcePath.getMethods();
            Map<String, Operation> methods = operationPath.getOperations();
            for (Map.Entry<String, Operation> operation : methods.entrySet()) {
                if (!resourceMethods.containsKey(operation.getKey().trim())) {
                    if (!filterEnable) {
                        reportDiagnostic(context, CompilationError.MISSING_RESOURCE_FUNCTION, context.node().location(), filter.getKind(), operation.getKey().trim(), getNormalizedPath(operationPath.getPath()));
                    }
                    methods.remove(operation.getKey());
                }
            }
        }
    }
    return operations;
}",java:S3776,39
"private Map<String, ResourcePathSummary> validateUndefinedBalResources(List<OpenAPIPathSummary> operations, Map<String, ResourcePathSummary> resourcePathMap){
    boolean filterEnable = filter.getOperation() != null || filter.getTag() != null || filter.getExcludeTag() != null || filter.getExcludeOperation() != null;
    Iterator<Map.Entry<String, ResourcePathSummary>> resourcePathIter = resourcePathMap.entrySet().iterator();
    while (resourcePathIter.hasNext()) {
        Map.Entry<String, ResourcePathSummary> resourcePath = resourcePathIter.next();
        boolean isPathDocumented = false;
        for (OpenAPIPathSummary operationPath : operations) {
            if (operationPath.getPath().equals(resourcePath.getKey())) {
                isPathDocumented = true;
                Set<Map.Entry<String, ResourceMethod>> methods = resourcePath.getValue().getMethods().entrySet();
                Iterator<Map.Entry<String, ResourceMethod>> methodsIter = methods.iterator();
                while (methodsIter.hasNext()) {
                    Map.Entry<String, ResourceMethod> method = methodsIter.next();
                    if (!operationPath.getOperations().containsKey(method.getKey().trim())) {
                        if (!filterEnable) {
                            reportDiagnostic(context, CompilationError.UNDEFINED_RESOURCE_FUNCTIONS, method.getValue().getLocation(), filter.getKind(), method.getKey(), getNormalizedPath(resourcePath.getKey()));
                        }
                        methodsIter.remove();
                    }
                }
                break;
            }
        }
        if (!isPathDocumented) {
            if (!filterEnable) {
                reportDiagnostic(context, CompilationError.UNDEFINED_RESOURCE_PATH, context.node().location(), filter.getKind(), getNormalizedPath(resourcePath.getKey()));
            }
            resourcePathIter.remove();
        }
    }
    return resourcePathMap;
}",java:S3776,39
"public static void validateRecordType(Schema<?> schema, TypeSymbol typeSymbol, String balRecord, SyntaxNodeAnalysisContext context, OpenAPI openAPI, String oasName, DiagnosticSeverity severity){
    if (typeSymbol instanceof RecordTypeSymbol || typeSymbol instanceof TypeReferenceTypeSymbol) {
        Map<String, Schema> properties = schema.getProperties();
        if (schema instanceof ObjectSchema) {
            properties = schema.getProperties();
        }
        if (typeSymbol instanceof TypeReferenceTypeSymbol) {
            typeSymbol = ((TypeReferenceTypeSymbol) typeSymbol).typeDescriptor();
        }
        RecordTypeSymbol recordTypeSymbol = (RecordTypeSymbol) typeSymbol;
        Map<String, RecordFieldSymbol> fieldSymbolList = recordTypeSymbol.fieldDescriptors();
        for (Map.Entry<String, RecordFieldSymbol> field : fieldSymbolList.entrySet()) {
            boolean isFieldExist = false;
            for (Map.Entry<String, Schema> property : properties.entrySet()) {
                if (field.getKey().trim().equals(property.getKey().trim())) {
                    isFieldExist = true;
                    String fieldType = field.getValue().typeDescriptor().signature();
                    if (field.getValue().typeDescriptor() instanceof TypeReferenceTypeSymbol) {
                        TypeReferenceTypeSymbol typeRef = (TypeReferenceTypeSymbol) field.getValue().typeDescriptor();
                        fieldType = typeRef.definition().getName().get();
                    }
                    Schema<?> schemaValue = property.getValue();
                    String oas = getNumberFormatType(schemaValue);
                    Optional<String> oasType = convertOpenAPITypeToBallerina(oas);
                    if (schemaValue instanceof ArraySchema) {
                        ArraySchema arraySchema = (ArraySchema) schemaValue;
                        validateArrayTypeMismatch(balRecord, context, field, arraySchema, severity);
                    } else if (schemaValue.get$ref() != null) {
                        Schema<?> componentSchema = openAPI.getComponents().getSchemas().get(extractReferenceType(schemaValue.get$ref()).orElse(null));
                        validateRecordType(componentSchema, field.getValue().typeDescriptor(), fieldType, context, openAPI, extractReferenceType(schemaValue.get$ref()).orElse(null), severity);
                    } else if (schemaValue instanceof ObjectSchema) {
                        return;
                    } else if (oasType.isEmpty() || !fieldType.equals(oasType.get())) {
                        reportDiagnostic(context, CompilationError.TYPE_MISMATCH_FIELD, field.getValue().getLocation().orElse(null), severity, oas, fieldType, field.getKey(), balRecord);
                    }
                    break;
                }
            }
            if (!isFieldExist) {
                reportDiagnostic(context, CompilationError.UNDEFINED_BRECORD_FIELD, field.getValue().getLocation().orElse(null), severity, field.getKey(), balRecord, oasName);
            }
        }
    }
}",java:S3776,39
"private static boolean applyFilter(Filter filter, List<String> tags, String operationId, SyntaxNodeAnalysisContext context){
    boolean tagEnabled = filter.getTag() != null;
    boolean operationEnabled = filter.getOperation() != null;
    boolean excludeTagsEnabled = filter.getExcludeTag() != null;
    boolean excludeOperationEnable = filter.getExcludeOperation() != null;
    if (excludeTagsEnabled && excludeOperationEnable) {
        return tags == null || Collections.disjoint(tags, filter.getExcludeTag()) && operationId != null && !filter.getExcludeOperation().contains(operationId);
    }
    if (tagEnabled && operationEnabled) {
        return operationId != null && filter.getOperation().contains(operationId) || tags != null && !Collections.disjoint(tags, filter.getTag());
    }
    if (operationEnabled) {
        if (excludeTagsEnabled) {
            return tags == null || Collections.disjoint(tags, filter.getExcludeTag());
        }
        return operationId != null && filter.getOperation().contains(operationId);
    }
    if (tagEnabled) {
        if (tags != null && !Collections.disjoint(tags, filter.getTag())) {
            if (excludeOperationEnable) {
                return operationId != null && !filter.getExcludeOperation().contains(operationId);
            }
        }
        return tags != null && !Collections.disjoint(tags, filter.getTag());
    }
    if (excludeOperationEnable) {
        return operationId != null && !filter.getExcludeOperation().contains(operationId);
    }
    if (excludeTagsEnabled) {
        return tags == null || filter.getExcludeTag() != null && Collections.disjoint(tags, filter.getExcludeTag());
    }
    return true;
}",java:S3776,39
"public static List<OpenAPIPathSummary> summarizeOpenAPI(OpenAPI contract, SyntaxNodeAnalysisContext context, Filter filter){
    List<OpenAPIPathSummary> openAPISummaries = new ArrayList<>();
    io.swagger.v3.oas.models.Paths paths = contract.getPaths();
    paths.forEach((path, value) -> {
        OpenAPIPathSummary openAPISummary = new OpenAPIPathSummary();
        if (value != null) {
            openAPISummary.setPath(path);
            if (value.getGet() != null) {
                addOpenAPISummary(openAPISummary, Constants.GET, value.getGet(), filter, context);
            }
            if (value.getPost() != null) {
                addOpenAPISummary(openAPISummary, Constants.POST, value.getPost(), filter, context);
            }
            if (value.getPut() != null) {
                addOpenAPISummary(openAPISummary, Constants.PUT, value.getPut(), filter, context);
            }
            if (value.getDelete() != null) {
                addOpenAPISummary(openAPISummary, Constants.DELETE, value.getDelete(), filter, context);
            }
            if (value.getHead() != null) {
                addOpenAPISummary(openAPISummary, Constants.HEAD, value.getHead(), filter, context);
            }
            if (value.getPatch() != null) {
                addOpenAPISummary(openAPISummary, Constants.PATCH, value.getPatch(), filter, context);
            }
            if (value.getOptions() != null) {
                addOpenAPISummary(openAPISummary, Constants.OPTIONS, value.getOptions(), filter, context);
            }
            if (value.getTrace() != null) {
                addOpenAPISummary(openAPISummary, Constants.TRACE, value.getTrace(), filter, context);
            }
        }
        if (openAPISummary.getOperations().size() > 0) {
            openAPISummaries.add(openAPISummary);
        }
    });
    return openAPISummaries;
}",java:S3776,39
"private static void extractResourceMethodDetails(FunctionDefinitionNode resourceNode, String path, ResourcePathSummary resourcePath, Map<String, Node> parameterNodes, SyntaxNodeAnalysisContext context){
    FunctionSignatureNode signatureNode = resourceNode.functionSignature();
    String httpMethod = resourceNode.functionName().text().trim();
    SeparatedNodeList<ParameterNode> parameters = signatureNode.parameters();
    ResourceMethod.ResourceMethodBuilder resourceMethodBuilder = new ResourceMethod.ResourceMethodBuilder();
    resourceMethodBuilder.withPath(path);
    resourceMethodBuilder.withMethod(httpMethod);
    resourceMethodBuilder.withLocation(resourceNode.location());
    Map<String, Node> headers = new HashMap<>();
    for (ParameterNode param : parameters) {
        if (param instanceof RequiredParameterNode) {
            RequiredParameterNode requiredParamNode = (RequiredParameterNode) param;
            NodeList<AnnotationNode> annotations = requiredParamNode.annotations();
            if (!requiredParamNode.typeName().toString().trim().equals(HTTP_CALLER) && !requiredParamNode.typeName().toString().trim().equals(HTTP_REQUEST)) {
                for (AnnotationNode annotation : annotations) {
                    if ((annotation.annotReference().toString()).trim().equals(Constants.HTTP_HEADER)) {
                        List<String> annotationHeaders = extractAnnotationFieldDetails(HTTP_HEADER, HEADER_NAME, annotations, context.semanticModel());
                        String headerName = unescapeIdentifier(requiredParamNode.paramName().orElseThrow().text());
                        if (!annotationHeaders.isEmpty()) {
                            headerName = annotationHeaders.get(0);
                        }
                        headers.put(headerName, requiredParamNode);
                    } else if ((annotation.annotReference().toString()).trim().equals(Constants.HTTP_PAYLOAD)) {
                        resourceMethodBuilder.withBody(requiredParamNode);
                    }
                }
                if (annotations.isEmpty()) {
                    parameterNodes.put(requiredParamNode.paramName().orElseThrow().text(), requiredParamNode);
                }
            }
        } else if (param instanceof DefaultableParameterNode) {
            DefaultableParameterNode defaultParam = (DefaultableParameterNode) param;
            NodeList<AnnotationNode> annotations = defaultParam.annotations();
            if (!defaultParam.typeName().toString().equals(HTTP_CALLER) && !defaultParam.typeName().toString().equals(HTTP_REQUEST)) {
                for (AnnotationNode annotation : annotations) {
                    if ((annotation.annotReference().toString()).trim().equals(Constants.HTTP_HEADER)) {
                        headers.put(defaultParam.paramName().orElseThrow().text(), defaultParam);
                    }
                }
                if (annotations.isEmpty()) {
                    parameterNodes.put(defaultParam.paramName().orElseThrow().text(), defaultParam);
                }
            }
        }
    }
    resourceMethodBuilder.withHeaders(headers);
    resourceMethodBuilder.withParameters(parameterNodes);
    resourceMethodBuilder.withReturnNode(signatureNode.returnTypeDesc().orElse(null));
    resourcePath.addMethod(httpMethod, resourceMethodBuilder.build());
}",java:S3776,39
"public static List<String> extractAnnotationFieldDetails(String annotationReference, String annotationField, NodeList<AnnotationNode> annotations, SemanticModel semanticModel){
    List<String> fieldValues = new ArrayList<>();
    Iterator<AnnotationNode> iterator = annotations.stream().iterator();
    while (iterator.hasNext()) {
        AnnotationNode annotation = iterator.next();
        Node annotReference = annotation.annotReference();
        if (annotReference.toString().trim().equals(annotationReference) && annotation.annotValue().isPresent()) {
            MappingConstructorExpressionNode listOfAnnotValue = annotation.annotValue().get();
            for (MappingFieldNode field : listOfAnnotValue.fields()) {
                SpecificFieldNode fieldNode = (SpecificFieldNode) field;
                if (!((fieldNode).fieldName().toString().trim().equals(annotationField)) && fieldNode.valueExpr().isEmpty()) {
                    continue;
                }
                ExpressionNode expressionNode = fieldNode.valueExpr().get();
                if (expressionNode instanceof ListConstructorExpressionNode) {
                    SeparatedNodeList mimeList = ((ListConstructorExpressionNode) expressionNode).expressions();
                    for (Object mime : mimeList) {
                        if (!(mime instanceof BasicLiteralNode)) {
                            continue;
                        }
                        fieldValues.add(((BasicLiteralNode) mime).literalToken().text().trim().replaceAll(""\"""", """"));
                    }
                } else if (expressionNode instanceof QualifiedNameReferenceNode && semanticModel != null) {
                    QualifiedNameReferenceNode moduleRef = (QualifiedNameReferenceNode) expressionNode;
                    Optional<Symbol> refSymbol = semanticModel.symbol(moduleRef);
                    if (refSymbol.isPresent() && (refSymbol.get().kind() == SymbolKind.CONSTANT) && ((ConstantSymbol) refSymbol.get()).resolvedValue().isPresent()) {
                        String mediaType = ((ConstantSymbol) refSymbol.get()).resolvedValue().get();
                        fieldValues.add(mediaType.replaceAll(""\"""", """"));
                    }
                } else {
                    fieldValues.add(expressionNode.toString().trim().replaceAll(""\"""", """"));
                }
            }
        }
    }
    return fieldValues;
}",java:S3776,39
"private void generatePathItem(String httpMethod, Paths path, Operation operation, String pathName){
    PathItem pathItem = new PathItem();
    switch(httpMethod.trim().toUpperCase(Locale.ENGLISH)) {
        case Constants.GET:
            if (pathObject.containsKey(pathName)) {
                pathObject.get(pathName).setGet(operation);
            } else {
                pathItem.setGet(operation);
                path.addPathItem(pathName, pathItem);
            }
            break;
        case Constants.PUT:
            if (pathObject.containsKey(pathName)) {
                pathObject.get(pathName).setPut(operation);
            } else {
                pathItem.setPut(operation);
                path.addPathItem(pathName, pathItem);
            }
            break;
        case Constants.POST:
            if (pathObject.containsKey(pathName)) {
                pathObject.get(pathName).setPost(operation);
            } else {
                pathItem.setPost(operation);
                path.addPathItem(pathName, pathItem);
            }
            break;
        case Constants.DELETE:
            if (pathObject.containsKey(pathName)) {
                pathObject.get(pathName).setDelete(operation);
            } else {
                pathItem.setDelete(operation);
                path.addPathItem(pathName, pathItem);
            }
            break;
        case Constants.OPTIONS:
            if (pathObject.containsKey(pathName)) {
                pathObject.get(pathName).setOptions(operation);
            } else {
                pathItem.setOptions(operation);
                path.addPathItem(pathName, pathItem);
            }
            break;
        case Constants.PATCH:
            if (pathObject.containsKey(pathName)) {
                pathObject.get(pathName).setPatch(operation);
            } else {
                pathItem.setPatch(operation);
                path.addPathItem(pathName, pathItem);
            }
            break;
        case Constants.HEAD:
            if (pathObject.containsKey(pathName)) {
                pathObject.get(pathName).setHead(operation);
            } else {
                pathItem.setHead(operation);
                path.addPathItem(pathName, pathItem);
            }
            break;
        default:
            break;
    }
}",java:S3776,39
"private ApiResponses overrideMediaType(Optional<String> customMediaType, List<String> overrideMediaType, ApiResponses responses){
    ApiResponses updatedResponse = new ApiResponses();
    for (Map.Entry<String, ApiResponse> next : responses.entrySet()) {
        ApiResponse response = next.getValue();
        Content content = response.getContent();
        if (content == null) {
            continue;
        }
        Set<Map.Entry<String, io.swagger.v3.oas.models.media.MediaType>> entries = content.entrySet();
        Iterator<Map.Entry<String, io.swagger.v3.oas.models.media.MediaType>> iterMediaType = entries.iterator();
        Content updatedContent = new Content();
        while (iterMediaType.hasNext()) {
            Map.Entry<String, io.swagger.v3.oas.models.media.MediaType> currentMedia = iterMediaType.next();
            for (String mediaType : overrideMediaType) {
                if (customMediaType.isPresent()) {
                    Optional<String> media = convertBallerinaMIMEToOASMIMETypes(mediaType, customMediaType);
                    if (media.isPresent()) {
                        mediaType = media.get();
                    } else {
                        StringBuilder mediaTypeBuilder = new StringBuilder();
                        String[] splits = mediaType.split(SLASH);
                        mediaTypeBuilder.append(splits[0]).append(SLASH).append(customMediaType.get()).append(PLUS).append(splits[1]);
                        mediaType = mediaTypeBuilder.toString();
                    }
                }
                updatedContent.addMediaType(mediaType, currentMedia.getValue());
            }
        }
        response.setContent(updatedContent);
        updatedResponse.addApiResponse(next.getKey(), response);
    }
    return updatedResponse;
}",java:S3776,39
"private Optional<ApiResponses> handleQualifiedNameType(ApiResponses apiResponses, Optional<String> customMediaPrefix, Map<String, Header> headers, ApiResponse apiResponse, QualifiedNameReferenceNode qNode){
    if (qNode.modulePrefix().text().equals(HTTP)) {
        String typeName = qNode.modulePrefix().text() + "":"" + qNode.identifier().text();
        if (typeName.equals(HTTP_RESPONSE)) {
            apiResponse = new ApiResponse();
            apiResponse.description(""Any Response"");
            Content content = new Content();
            io.swagger.v3.oas.models.media.MediaType mediaType = new io.swagger.v3.oas.models.media.MediaType();
            mediaType.setSchema(new Schema<>().description(WILD_CARD_SUMMARY));
            content.put(WILD_CARD_CONTENT_KEY, mediaType);
            apiResponse.setContent(content);
            apiResponses.put(Constants.DEFAULT, apiResponse);
            return Optional.of(apiResponses);
        } else {
            Optional<String> code = generateApiResponseCode(qNode.identifier().toString().trim());
            if (code.isPresent()) {
                apiResponse.description(qNode.identifier().toString().trim());
                setCacheHeader(headers, apiResponse, code.get());
                apiResponses.put(code.get(), apiResponse);
                return Optional.of(apiResponses);
            } else {
                return Optional.empty();
            }
        }
    } else {
        Symbol symbol = semanticModel.symbol(qNode).get();
        if (symbol instanceof TypeReferenceTypeSymbol) {
            TypeReferenceTypeSymbol typeRef = (TypeReferenceTypeSymbol) symbol;
            TypeSymbol typeSymbol = typeRef.typeDescriptor();
            if (typeSymbol.typeKind() == TypeDescKind.INTERSECTION) {
                List<TypeSymbol> memberTypes = ((IntersectionTypeSymbol) typeSymbol).memberTypeDescriptors();
                for (TypeSymbol memberType : memberTypes) {
                    if (!(memberType instanceof ReadonlyTypeSymbol)) {
                        typeSymbol = memberType;
                        break;
                    }
                }
            }
            if (typeSymbol.typeKind() == TypeDescKind.RECORD) {
                ApiResponses responses = handleRecordTypeSymbol(qNode.identifier().text().trim(), components.getSchemas(), customMediaPrefix, typeRef, new OpenAPIComponentMapper(components), headers);
                apiResponses.putAll(responses);
                return Optional.of(apiResponses);
            }
        }
    }
    return Optional.empty();
}",java:S3776,39
"private Optional<ApiResponses> mapInlineRecordInReturn(OperationAdaptor operationAdaptor, ApiResponses apiResponses, RecordTypeDescriptorNode typeNode, ApiResponse apiResponse, io.swagger.v3.oas.models.media.MediaType mediaType, Optional<String> customMediaPrefix, Map<String, Header> headers){
    String statusCode = httpMethod.equals(POST) ? HTTP_201 : HTTP_200;
    String description = httpMethod.equals(POST) ? HTTP_201_DESCRIPTION : HTTP_200_DESCRIPTION;
    NodeList<Node> fields = typeNode.fields();
    Optional<String> httpCode = Optional.of(statusCode);
    Schema<?> inlineSchema = new Schema<>();
    Optional<String> mediaTypeResponse = Optional.of(APPLICATION_JSON);
    boolean ishttpTypeInclusion = false;
    Map<String, Schema> properties = new HashMap<>();
    if (fields.stream().anyMatch(module -> module.kind() == TYPE_REFERENCE)) {
        ishttpTypeInclusion = true;
    }
    for (Node field : fields) {
        if (field.kind() == TYPE_REFERENCE) {
            TypeReferenceNode typeFieldNode = (TypeReferenceNode) field;
            if (typeFieldNode.typeName().kind() == QUALIFIED_NAME_REFERENCE) {
                QualifiedNameReferenceNode identifierNode = (QualifiedNameReferenceNode) typeFieldNode.typeName();
                httpCode = generateApiResponseCode(identifierNode.identifier().text().trim());
                description = identifierNode.identifier().text().trim();
                apiResponse.description(identifierNode.identifier().text().trim());
            }
        }
        if (field.kind() == RECORD_FIELD) {
            RecordFieldNode recordField = (RecordFieldNode) field;
            Node type01 = recordField.typeName();
            if (recordField.typeName().kind() == SIMPLE_NAME_REFERENCE) {
                Map<String, Schema> componentsSchemas = components.getSchemas();
                SimpleNameReferenceNode nameRefNode = (SimpleNameReferenceNode) type01;
                handleReferenceResponse(operationAdaptor, nameRefNode, componentsSchemas, apiResponses, customMediaPrefix, headers);
                Schema<?> referenceSchema = new Schema<>();
                referenceSchema.set$ref(ConverterCommonUtils.unescapeIdentifier(recordField.typeName().toString().trim()));
                properties.put(recordField.fieldName().text(), referenceSchema);
            } else {
                mediaTypeResponse = convertBallerinaMIMEToOASMIMETypes(recordField.typeName().toString().trim(), customMediaPrefix);
                Schema<?> propertySchema = ConverterCommonUtils.getOpenApiSchema(recordField.typeName().toString().trim());
                properties.put(recordField.fieldName().text(), propertySchema);
            }
        }
    }
    if (!ishttpTypeInclusion) {
        inlineSchema = new ObjectSchema();
        inlineSchema.setProperties(properties);
        mediaTypeResponse = Optional.of(APPLICATION_JSON);
        if (customMediaPrefix.isPresent()) {
            mediaTypeResponse = Optional.of(APPLICATION_PREFIX + customMediaPrefix.get() + JSON_POSTFIX);
        }
    }
    mediaType.setSchema(inlineSchema);
    apiResponse.description(description);
    if (mediaTypeResponse.isPresent() && httpCode.isPresent()) {
        apiResponse.content(new Content().addMediaType(mediaTypeResponse.get(), mediaType));
        setCacheHeader(headers, apiResponse, httpCode.get());
        apiResponses.put(httpCode.get(), apiResponse);
        return Optional.of(apiResponses);
    } else {
        return Optional.empty();
    }
}",java:S3776,39
"private static void addResponse(ApiResponses apiResponses, Optional<ApiResponses> apiResponse){
    apiResponse.ifPresent(responses -> responses.forEach((key, value) -> {
        if (apiResponses.containsKey(key)) {
            ApiResponse res = apiResponses.get(key);
            Content content = res.getContent();
            if (content == null) {
                content = new Content();
            }
            if (value.getContent() != null) {
                String mediaType = value.getContent().keySet().iterator().next();
                Schema newSchema = value.getContent().values().iterator().next().getSchema();
                if (content.containsKey(mediaType)) {
                    Schema<?> schema = content.get(mediaType).getSchema();
                    if (schema instanceof ComposedSchema && ((ComposedSchema) schema).getOneOf() != null) {
                        schema.getOneOf().add(newSchema);
                        content.put(mediaType, new io.swagger.v3.oas.models.media.MediaType().schema(schema));
                    } else {
                        ComposedSchema composedSchema = new ComposedSchema();
                        composedSchema.addOneOfItem(schema);
                        composedSchema.addOneOfItem(newSchema);
                        io.swagger.v3.oas.models.media.MediaType updatedMediaContent = new io.swagger.v3.oas.models.media.MediaType().schema(composedSchema);
                        content.put(mediaType, updatedMediaContent);
                    }
                } else {
                    content.put(mediaType, value.getContent().values().iterator().next());
                }
            }
            res.content(content);
            apiResponses.put(key, res);
        } else {
            apiResponses.put(key, value);
        }
    }));
}",java:S3776,39
"private void handleReferenceResponse(OperationAdaptor operationAdaptor, SimpleNameReferenceNode referenceNode, Map<String, Schema> schema, ApiResponses apiResponses, Optional<String> customMediaPrefix, Map<String, Header> headers){
    ApiResponse apiResponse = new ApiResponse();
    Optional<Symbol> symbol = semanticModel.symbol(referenceNode);
    TypeSymbol typeSymbol = (TypeSymbol) symbol.orElseThrow();
    OpenAPIComponentMapper componentMapper = new OpenAPIComponentMapper(components);
    String mediaTypeString;
    if (referenceNode.parent().kind().equals(ARRAY_TYPE_DESC)) {
        String statusCode = httpMethod.equals(POST) ? HTTP_201 : HTTP_200;
        String description = httpMethod.equals(POST) ? HTTP_201_DESCRIPTION : HTTP_200_DESCRIPTION;
        setCacheHeader(headers, apiResponse, statusCode);
        io.swagger.v3.oas.models.media.MediaType media = new io.swagger.v3.oas.models.media.MediaType();
        ArraySchema arraySchema = new ArraySchema();
        componentMapper.createComponentSchema(schema, typeSymbol);
        errors.addAll(componentMapper.getDiagnostics());
        arraySchema.setItems(new Schema<>().$ref(ConverterCommonUtils.unescapeIdentifier(referenceNode.name().toString().trim())));
        media.setSchema(arraySchema);
        apiResponse.description(description);
        mediaTypeString = customMediaPrefix.isPresent() ? APPLICATION_PREFIX + customMediaPrefix + JSON_POSTFIX : APPLICATION_JSON;
        apiResponse.content(new Content().addMediaType(mediaTypeString, media));
        apiResponses.put(statusCode, apiResponse);
    } else if (typeSymbol.typeKind() == TypeDescKind.TYPE_REFERENCE) {
        TypeReferenceTypeSymbol typeReferenceTypeSymbol = (TypeReferenceTypeSymbol) typeSymbol;
        TypeSymbol referredTypeSymbol = typeReferenceTypeSymbol.typeDescriptor();
        if (referredTypeSymbol.typeKind() == TypeDescKind.INTERSECTION) {
            referredTypeSymbol = componentMapper.excludeReadonlyIfPresent(referredTypeSymbol);
        }
        String referenceName = referenceNode.name().toString().trim();
        String referredTypeName = referredTypeSymbol.getName().isPresent() ? referredTypeSymbol.getName().get() : """";
        if (referredTypeSymbol.typeKind() == TypeDescKind.RECORD) {
            ApiResponses responses = handleRecordTypeSymbol(referenceName, schema, customMediaPrefix, typeReferenceTypeSymbol, componentMapper, headers);
            apiResponses.putAll(responses);
        } else if (referredTypeSymbol.typeKind() == TypeDescKind.ERROR) {
            io.swagger.v3.oas.models.media.MediaType mediaType = new io.swagger.v3.oas.models.media.MediaType();
            apiResponse.description(HTTP_500_DESCRIPTION);
            mediaType.setSchema(new StringSchema());
            apiResponse.content(new Content().addMediaType(MediaType.TEXT_PLAIN, mediaType));
            apiResponses.put(HTTP_500, apiResponse);
        } else if (referredTypeSymbol.typeKind() == TypeDescKind.TYPE_REFERENCE && generateApiResponseCode(referredTypeName).isPresent()) {
            Optional<String> code = generateApiResponseCode(referredTypeName);
            apiResponse.description(referredTypeName);
            setCacheHeader(headers, apiResponse, code.get());
            apiResponses.put(code.get(), apiResponse);
        } else {
            ApiResponses responses = createResponseForTypeReferenceTypeReturns(referenceName, typeReferenceTypeSymbol, schema, customMediaPrefix, componentMapper, headers);
            apiResponses.putAll(responses);
        }
    }
    operationAdaptor.getOperation().setResponses(apiResponses);
}",java:S3776,39
"private Optional<ApiResponses> handleRecordHasHttpTypeInclusionField(Map<String, Schema> schema, TypeSymbol typeSymbol, OpenAPIComponentMapper componentMapper, RecordTypeSymbol returnRecord, List<TypeSymbol> typeInclusions, Optional<String> customMediaPrefix, Map<String, Header> headers){
    ApiResponses apiResponses = new ApiResponses();
    ApiResponse apiResponse = new ApiResponse();
    io.swagger.v3.oas.models.media.MediaType media = new io.swagger.v3.oas.models.media.MediaType();
    boolean isHttpModule = false;
    String mediaTypeString;
    for (TypeSymbol typeInSymbol : typeInclusions) {
        if (HTTP.equals(typeInSymbol.getModule().orElseThrow().getName().orElseThrow())) {
            isHttpModule = true;
            Optional<String> code = generateApiResponseCode(typeInSymbol.getName().orElseThrow().trim());
            if (code.isEmpty()) {
                return Optional.empty();
            }
            Map<String, RecordFieldSymbol> fieldsOfRecord = returnRecord.fieldDescriptors();
            RecordFieldSymbol header = fieldsOfRecord.get(RESPONSE_HEADERS);
            extractResponseHeaders(headers, header);
            setCacheHeader(headers, apiResponse, code.get());
            if (code.get().equals(HTTP_204)) {
                apiResponse.description(typeInSymbol.getName().orElseThrow().trim());
                apiResponses.put(code.get(), apiResponse);
                return Optional.of(apiResponses);
            }
            RecordFieldSymbol body = fieldsOfRecord.get(BODY);
            TypeDescKind typeDescKind = body.typeDescriptor().typeKind();
            if (typeDescKind == TypeDescKind.TYPE_REFERENCE) {
                componentMapper.createComponentSchema(schema, body.typeDescriptor());
                errors.addAll(componentMapper.getDiagnostics());
                media.setSchema(new Schema<>().$ref(ConverterCommonUtils.unescapeIdentifier(body.typeDescriptor().getName().orElseThrow().trim())));
                mediaTypeString = customMediaPrefix.map(s -> APPLICATION_PREFIX + s + JSON_POSTFIX).orElse(APPLICATION_JSON);
                apiResponse.content(new Content().addMediaType(mediaTypeString, media));
            } else if (typeDescKind == TypeDescKind.STRING) {
                media.setSchema(new StringSchema());
                mediaTypeString = customMediaPrefix.map(s -> TEXT_PREFIX + s + TEXT_POSTFIX).orElse(MediaType.TEXT_PLAIN);
                apiResponse.content(new Content().addMediaType(mediaTypeString, media));
            } else if (typeDescKind == TypeDescKind.XML) {
                media.setSchema(new ObjectSchema());
                mediaTypeString = customMediaPrefix.map(s -> APPLICATION_PREFIX + s + XML_POSTFIX).orElse(MediaType.APPLICATION_XML);
                apiResponse.content(new Content().addMediaType(mediaTypeString, media));
            } else if (typeDescKind == TypeDescKind.MAP && (((MapTypeSymbol) body.typeDescriptor()).typeParam().typeKind() == TypeDescKind.STRING)) {
                mediaTypeString = customMediaPrefix.map(s -> APPLICATION_PREFIX + s + X_WWW_FORM_URLENCODED_POSTFIX).orElse(MediaType.APPLICATION_FORM_URLENCODED);
                Schema<?> objectSchema = new ObjectSchema();
                objectSchema.additionalProperties(new StringSchema());
                media.setSchema(objectSchema);
                apiResponse.content(new Content().addMediaType(mediaTypeString, media));
            } else if (typeDescKind == TypeDescKind.UNION) {
                UnionTypeSymbol unionType = (UnionTypeSymbol) body.typeDescriptor();
                List<TypeSymbol> typeSymbols = unionType.memberTypeDescriptors();
                Map<String, Schema> contentDetails = new LinkedHashMap<>();
                for (TypeSymbol type : typeSymbols) {
                    ImmutablePair<String, String> mediaTypes = getMediaTypeForTypeReferenceTypeReturns(type, type.typeKind(), customMediaPrefix);
                    mediaTypeString = customMediaPrefix.map(s -> APPLICATION_PREFIX + s + mediaTypes.getRight()).orElseGet(mediaTypes::getLeft);
                    Schema<?> mediaSchema = getOpenApiSchema(type.typeKind().getName());
                    if (type.typeKind() == TypeDescKind.TYPE_REFERENCE) {
                        componentMapper.createComponentSchema(schema, type);
                        errors.addAll(componentMapper.getDiagnostics());
                        String recordName = type.getName().orElseThrow().trim();
                        mediaSchema.set$ref(ConverterCommonUtils.unescapeIdentifier(recordName));
                    }
                    if (contentDetails.containsKey(mediaTypeString)) {
                        Schema<?> oldSchema = contentDetails.get(mediaTypeString);
                        if (oldSchema instanceof ComposedSchema && oldSchema.getOneOf() != null) {
                            oldSchema.getOneOf().add(mediaSchema);
                            contentDetails.put(mediaTypeString, oldSchema);
                        } else {
                            ComposedSchema composedSchema = new ComposedSchema();
                            composedSchema.addOneOfItem(oldSchema);
                            composedSchema.addOneOfItem(mediaSchema);
                            contentDetails.put(mediaTypeString, composedSchema);
                        }
                    } else {
                        contentDetails.put(mediaTypeString, mediaSchema);
                    }
                }
                Content content = new Content();
                for (Map.Entry<String, Schema> entry : contentDetails.entrySet()) {
                    io.swagger.v3.oas.models.media.MediaType mediaType = new io.swagger.v3.oas.models.media.MediaType();
                    mediaTypeString = entry.getKey();
                    mediaType.setSchema(entry.getValue());
                    content.addMediaType(mediaTypeString, mediaType);
                }
                apiResponse.content(content);
            }
            apiResponse.description(typeInSymbol.getName().orElseThrow().trim());
            apiResponses.put(code.get(), apiResponse);
        }
    }
    if (!isHttpModule) {
        componentMapper.createComponentSchema(schema, typeSymbol);
        errors.addAll(componentMapper.getDiagnostics());
        media.setSchema(new Schema<>().$ref(ConverterCommonUtils.unescapeIdentifier(typeSymbol.getName().get())));
        mediaTypeString = APPLICATION_JSON;
        if (customMediaPrefix.isPresent()) {
            mediaTypeString = APPLICATION_PREFIX + customMediaPrefix.get() + JSON_POSTFIX;
        }
        String statusCode = httpMethod.equals(POST) ? HTTP_201 : HTTP_200;
        String description = httpMethod.equals(POST) ? HTTP_201_DESCRIPTION : HTTP_200_DESCRIPTION;
        setCacheHeader(headers, apiResponse, statusCode);
        apiResponse.content(new Content().addMediaType(mediaTypeString, media));
        apiResponse.description(description);
        apiResponses.put(statusCode, apiResponse);
    }
    return Optional.of(apiResponses);
}",java:S3776,39
"private Optional<ApiResponses> handleRecordHasHttpTypeInclusionField(Map<String, Schema> schema, TypeSymbol typeSymbol, OpenAPIComponentMapper componentMapper, RecordTypeSymbol returnRecord, List<TypeSymbol> typeInclusions, Optional<String> customMediaPrefix, Map<String, Header> headers){
    ApiResponses apiResponses = new ApiResponses();
    ApiResponse apiResponse = new ApiResponse();
    io.swagger.v3.oas.models.media.MediaType media = new io.swagger.v3.oas.models.media.MediaType();
    boolean isHttpModule = false;
    String mediaTypeString;
    for (TypeSymbol typeInSymbol : typeInclusions) {
        if (HTTP.equals(typeInSymbol.getModule().orElseThrow().getName().orElseThrow())) {
            isHttpModule = true;
            Optional<String> code = generateApiResponseCode(typeInSymbol.getName().orElseThrow().trim());
            if (code.isEmpty()) {
                return Optional.empty();
            }
            Map<String, RecordFieldSymbol> fieldsOfRecord = returnRecord.fieldDescriptors();
            RecordFieldSymbol header = fieldsOfRecord.get(RESPONSE_HEADERS);
            extractResponseHeaders(headers, header);
            setCacheHeader(headers, apiResponse, code.get());
            if (code.get().equals(HTTP_204)) {
                apiResponse.description(typeInSymbol.getName().orElseThrow().trim());
                apiResponses.put(code.get(), apiResponse);
                return Optional.of(apiResponses);
            }
            RecordFieldSymbol body = fieldsOfRecord.get(BODY);
            TypeDescKind typeDescKind = body.typeDescriptor().typeKind();
            if (typeDescKind == TypeDescKind.TYPE_REFERENCE) {
                componentMapper.createComponentSchema(schema, body.typeDescriptor());
                errors.addAll(componentMapper.getDiagnostics());
                media.setSchema(new Schema<>().$ref(ConverterCommonUtils.unescapeIdentifier(body.typeDescriptor().getName().orElseThrow().trim())));
                mediaTypeString = customMediaPrefix.map(s -> APPLICATION_PREFIX + s + JSON_POSTFIX).orElse(APPLICATION_JSON);
                apiResponse.content(new Content().addMediaType(mediaTypeString, media));
            } else if (typeDescKind == TypeDescKind.STRING) {
                media.setSchema(new StringSchema());
                mediaTypeString = customMediaPrefix.map(s -> TEXT_PREFIX + s + TEXT_POSTFIX).orElse(MediaType.TEXT_PLAIN);
                apiResponse.content(new Content().addMediaType(mediaTypeString, media));
            } else if (typeDescKind == TypeDescKind.XML) {
                media.setSchema(new ObjectSchema());
                mediaTypeString = customMediaPrefix.map(s -> APPLICATION_PREFIX + s + XML_POSTFIX).orElse(MediaType.APPLICATION_XML);
                apiResponse.content(new Content().addMediaType(mediaTypeString, media));
            } else if (typeDescKind == TypeDescKind.MAP && (((MapTypeSymbol) body.typeDescriptor()).typeParam().typeKind() == TypeDescKind.STRING)) {
                mediaTypeString = customMediaPrefix.map(s -> APPLICATION_PREFIX + s + X_WWW_FORM_URLENCODED_POSTFIX).orElse(MediaType.APPLICATION_FORM_URLENCODED);
                Schema<?> objectSchema = new ObjectSchema();
                objectSchema.additionalProperties(new StringSchema());
                media.setSchema(objectSchema);
                apiResponse.content(new Content().addMediaType(mediaTypeString, media));
            } else if (typeDescKind == TypeDescKind.UNION) {
                UnionTypeSymbol unionType = (UnionTypeSymbol) body.typeDescriptor();
                List<TypeSymbol> typeSymbols = unionType.memberTypeDescriptors();
                Map<String, Schema> contentDetails = new LinkedHashMap<>();
                for (TypeSymbol type : typeSymbols) {
                    ImmutablePair<String, String> mediaTypes = getMediaTypeForTypeReferenceTypeReturns(type, type.typeKind(), customMediaPrefix);
                    mediaTypeString = customMediaPrefix.map(s -> APPLICATION_PREFIX + s + mediaTypes.getRight()).orElseGet(mediaTypes::getLeft);
                    Schema<?> mediaSchema = getOpenApiSchema(type.typeKind().getName());
                    if (type.typeKind() == TypeDescKind.TYPE_REFERENCE) {
                        componentMapper.createComponentSchema(schema, type);
                        errors.addAll(componentMapper.getDiagnostics());
                        String recordName = type.getName().orElseThrow().trim();
                        mediaSchema.set$ref(ConverterCommonUtils.unescapeIdentifier(recordName));
                    }
                    if (contentDetails.containsKey(mediaTypeString)) {
                        Schema<?> oldSchema = contentDetails.get(mediaTypeString);
                        if (oldSchema instanceof ComposedSchema && oldSchema.getOneOf() != null) {
                            oldSchema.getOneOf().add(mediaSchema);
                            contentDetails.put(mediaTypeString, oldSchema);
                        } else {
                            ComposedSchema composedSchema = new ComposedSchema();
                            composedSchema.addOneOfItem(oldSchema);
                            composedSchema.addOneOfItem(mediaSchema);
                            contentDetails.put(mediaTypeString, composedSchema);
                        }
                    } else {
                        contentDetails.put(mediaTypeString, mediaSchema);
                    }
                }
                Content content = new Content();
                for (Map.Entry<String, Schema> entry : contentDetails.entrySet()) {
                    io.swagger.v3.oas.models.media.MediaType mediaType = new io.swagger.v3.oas.models.media.MediaType();
                    mediaTypeString = entry.getKey();
                    mediaType.setSchema(entry.getValue());
                    content.addMediaType(mediaTypeString, mediaType);
                }
                apiResponse.content(content);
            }
            apiResponse.description(typeInSymbol.getName().orElseThrow().trim());
            apiResponses.put(code.get(), apiResponse);
        }
    }
    if (!isHttpModule) {
        componentMapper.createComponentSchema(schema, typeSymbol);
        errors.addAll(componentMapper.getDiagnostics());
        media.setSchema(new Schema<>().$ref(ConverterCommonUtils.unescapeIdentifier(typeSymbol.getName().get())));
        mediaTypeString = APPLICATION_JSON;
        if (customMediaPrefix.isPresent()) {
            mediaTypeString = APPLICATION_PREFIX + customMediaPrefix.get() + JSON_POSTFIX;
        }
        String statusCode = httpMethod.equals(POST) ? HTTP_201 : HTTP_200;
        String description = httpMethod.equals(POST) ? HTTP_201_DESCRIPTION : HTTP_200_DESCRIPTION;
        setCacheHeader(headers, apiResponse, statusCode);
        apiResponse.content(new Content().addMediaType(mediaTypeString, media));
        apiResponse.description(description);
        apiResponses.put(statusCode, apiResponse);
    }
    return Optional.of(apiResponses);
}",java:S6541,49
"private void extractResponseHeaders(Map<String, Header> headers, RecordFieldSymbol header){
    if (header.typeDescriptor().typeKind() == TypeDescKind.TYPE_REFERENCE) {
        TypeReferenceTypeSymbol headerType = (TypeReferenceTypeSymbol) header.typeDescriptor();
        if (headerType.typeDescriptor() instanceof RecordTypeSymbol) {
            RecordTypeSymbol recordTypeSymbol = (RecordTypeSymbol) headerType.typeDescriptor();
            Map<String, RecordFieldSymbol> rfields = recordTypeSymbol.fieldDescriptors();
            for (Map.Entry<String, RecordFieldSymbol> field : rfields.entrySet()) {
                Header headerSchema = new Header();
                TypeSymbol fieldType = field.getValue().typeDescriptor();
                String type = fieldType.typeKind().toString().trim().toLowerCase(Locale.ENGLISH);
                Schema<?> openApiSchema = ConverterCommonUtils.getOpenApiSchema(type);
                if (fieldType instanceof ArrayTypeSymbol) {
                    ArrayTypeSymbol array = (ArrayTypeSymbol) fieldType;
                    TypeSymbol itemType = array.memberTypeDescriptor();
                    String item = itemType.typeKind().toString().trim().toLowerCase(Locale.ENGLISH);
                    Schema<?> itemSchema = ConverterCommonUtils.getOpenApiSchema(item);
                    if (openApiSchema instanceof ArraySchema) {
                        ((ArraySchema) openApiSchema).setItems(itemSchema);
                    }
                }
                headerSchema.setSchema(openApiSchema);
                Optional<Documentation> fieldDoc = ((Documentable) field.getValue()).documentation();
                if (fieldDoc.isPresent() && fieldDoc.get().description().isPresent()) {
                    headerSchema.setDescription(fieldDoc.get().description().get().trim());
                }
                String headerKey = getValidHeaderKey(field);
                headers.put(headerKey, headerSchema);
            }
        }
    }
}",java:S3776,39
"public static List<String> extractAnnotationFieldDetails(String annotationReference, String annotationField, AnnotationNode annotation, SemanticModel semanticModel){
    List<String> mediaTypes = new ArrayList<>();
    Node annotReference = annotation.annotReference();
    if (annotReference.toString().trim().equals(annotationReference) && annotation.annotValue().isPresent()) {
        MappingConstructorExpressionNode listOfAnnotValue = annotation.annotValue().get();
        for (MappingFieldNode field : listOfAnnotValue.fields()) {
            SpecificFieldNode fieldNode = (SpecificFieldNode) field;
            if (!((fieldNode).fieldName().toString().trim().equals(annotationField)) || fieldNode.valueExpr().isEmpty()) {
                continue;
            }
            ExpressionNode expressionNode = fieldNode.valueExpr().get();
            if (expressionNode instanceof ListConstructorExpressionNode) {
                SeparatedNodeList<Node> mimeList = ((ListConstructorExpressionNode) expressionNode).expressions();
                for (Object mime : mimeList) {
                    if (!(mime instanceof BasicLiteralNode)) {
                        continue;
                    }
                    mediaTypes.add(((BasicLiteralNode) mime).literalToken().text().trim().replaceAll(""\"""", """"));
                }
            } else if (expressionNode instanceof QualifiedNameReferenceNode && semanticModel != null) {
                QualifiedNameReferenceNode moduleRef = (QualifiedNameReferenceNode) expressionNode;
                Optional<Symbol> refSymbol = semanticModel.symbol(moduleRef);
                if (refSymbol.isPresent() && (refSymbol.get().kind() == SymbolKind.CONSTANT) && ((ConstantSymbol) refSymbol.get()).resolvedValue().isPresent()) {
                    String mediaType = ((ConstantSymbol) refSymbol.get()).resolvedValue().get();
                    mediaTypes.add(mediaType.replaceAll(""\"""", """"));
                }
            } else {
                mediaTypes.add(expressionNode.toString().trim().replaceAll(""\"""", """"));
            }
        }
    }
    return mediaTypes;
}",java:S3776,39
"private static void extractServiceNodes(String serviceName, List<String> availableService, Map<String, ServiceDeclarationNode> servicesToGenerate, ModulePartNode modulePartNode, SemanticModel semanticModel){
    for (Node node : modulePartNode.members()) {
        SyntaxKind syntaxKind = node.kind();
        if (syntaxKind.equals(SyntaxKind.SERVICE_DECLARATION)) {
            ServiceDeclarationNode serviceNode = (ServiceDeclarationNode) node;
            if (isHttpService(serviceNode, semanticModel)) {
                Optional<Symbol> serviceSymbol = semanticModel.symbol(serviceNode);
                if (serviceSymbol.isPresent() && serviceSymbol.get() instanceof ServiceDeclarationSymbol) {
                    String service = OpenAPIEndpointMapper.ENDPOINT_MAPPER.getServiceBasePath(serviceNode);
                    String updateServiceName = service;
                    if (servicesToGenerate.containsKey(service)) {
                        updateServiceName = service + HYPHEN + serviceSymbol.get().hashCode();
                    }
                    if (serviceName != null) {
                        availableService.add(service);
                        if (serviceName.equals(service)) {
                            servicesToGenerate.put(updateServiceName, serviceNode);
                        }
                    } else {
                        servicesToGenerate.put(updateServiceName, serviceNode);
                    }
                }
            }
        }
    }
}",java:S3776,39
"private static OASResult normalizeInfoSection(String openapiFileName, String currentServiceName, String version, OASResult oasResult){
    if (oasResult.getOpenAPI().isPresent()) {
        OpenAPI openAPI = oasResult.getOpenAPI().get();
        if (openAPI.getInfo() == null) {
            String title = normalizeTitle(currentServiceName);
            if (currentServiceName.equals(SLASH)) {
                title = normalizeTitle(openapiFileName);
            }
            openAPI.setInfo(new Info().title(title).version(version));
        } else {
            if (openAPI.getInfo().getTitle() == null) {
                openAPI.getInfo().setTitle(normalizeTitle(currentServiceName));
            } else if (openAPI.getInfo().getTitle() != null && openAPI.getInfo().getTitle().equals(SLASH)) {
                openAPI.getInfo().setTitle(normalizeTitle(openapiFileName));
            } else if (openAPI.getInfo().getTitle().isBlank()) {
                openAPI.getInfo().setTitle(normalizeTitle(currentServiceName));
            } else if (openAPI.getInfo().getTitle() == null && currentServiceName.equals(SLASH)) {
                openAPI.getInfo().setTitle(normalizeTitle(openapiFileName));
            }
            if (openAPI.getInfo().getVersion() == null || openAPI.getInfo().getVersion().isBlank()) {
                openAPI.getInfo().setVersion(version);
            }
        }
        return new OASResult(openAPI, oasResult.getDiagnostics());
    } else {
        return oasResult;
    }
}",java:S3776,39
"public static LinkedHashSet<ListenerDeclarationNode> collectListeners(Project project){
    ModuleMemberVisitor balNodeVisitor = new ModuleMemberVisitor();
    LinkedHashSet<ListenerDeclarationNode> listeners = new LinkedHashSet<>();
    project.currentPackage().moduleIds().forEach(moduleId -> {
        Module module = project.currentPackage().module(moduleId);
        module.documentIds().forEach(documentId -> {
            SyntaxTree syntaxTreeDoc = module.document(documentId).syntaxTree();
            syntaxTreeDoc.rootNode().accept(balNodeVisitor);
            listeners.addAll(balNodeVisitor.getListenerDeclarationNodes());
        });
    });
    return listeners;
}",java:S1319,22
"private void importSaveFiles(final File saveFileDir, final List<String> allowedSaveFileExtensions, final Uri zipFileUri, final ContentResolver contentResolver){
    final Status status = Objects.requireNonNull(liveStatus.getValue());
    assert !status.isBackgroundTaskExecuting;
    liveStatus.setValue(status.setIsBackgroundTaskExecuting(true));
    new Thread(() -> {
        Exception caughtException = null;
        final Predicate<String> checkExtension = (String name) -> {
            final String lowercaseName = name.toLowerCase(Locale.ROOT);
            for (final String extension : allowedSaveFileExtensions) {
                if (lowercaseName.endsWith(extension)) {
                    return true;
                }
            }
            return false;
        };
        boolean atLeastOneSaveFileImported = false;
        try (final InputStream in = contentResolver.openInputStream(zipFileUri);
            final ZipInputStream zin = new ZipInputStream(in)) {
            Files.createDirectories(saveFileDir.toPath());
            for (ZipEntry zEntry = zin.getNextEntry(); zEntry != null; zEntry = zin.getNextEntry()) {
                if (zEntry.isDirectory()) {
                    continue;
                }
                final String zEntryFileName = new File(zEntry.getName()).getName();
                if (!checkExtension.test(zEntryFileName)) {
                    continue;
                }
                try (final OutputStream out = Files.newOutputStream((new File(saveFileDir, zEntryFileName)).toPath())) {
                    IOUtils.copy(zin, out);
                }
                atLeastOneSaveFileImported = true;
            }
        } catch (final Exception ex) {
            Log.e(""fheroes2"", ""Failed to import save files."", ex);
            caughtException = ex;
        } finally {
            try {
                if (caughtException != null) {
                    liveStatus.postValue(new Status(false, BackgroundTaskResult.RESULT_ERROR, String.format(""%s"", caughtException), getSaveFileList(saveFileDir, allowedSaveFileExtensions)));
                } else {
                    liveStatus.postValue(new Status(false, atLeastOneSaveFileImported ? BackgroundTaskResult.RESULT_SUCCESS : BackgroundTaskResult.RESULT_NO_SAVE_FILES, """", getSaveFileList(saveFileDir, allowedSaveFileExtensions)));
                }
            } catch (final Exception ex) {
                Log.e(""fheroes2"", ""Failed to get a list of save files."", ex);
                liveStatus.postValue(new Status(false, BackgroundTaskResult.RESULT_ERROR, String.format(""%s"", ex), new ArrayList<>()));
            }
        }
    }).start();
}",java:S3776,39
"public void generateClientAndService(String definitionPath, String serviceName, String outPath, Filter filter, boolean nullable, boolean isResource, boolean generateServiceType, boolean generateWithoutDataBinding) throws IOException, FormatterException, io.ballerina.openapi.core.exception.BallerinaOpenApiException{
    Path srcPath = Paths.get(outPath);
    Path implPath = CodegenUtils.getImplPath(srcPackage, srcPath);
    List<GenSrcFile> sourceFiles = new ArrayList<>();
    Path openAPIPath = Path.of(definitionPath);
    OpenAPI openAPIDef = GeneratorUtils.normalizeOpenAPI(openAPIPath, !isResource);
    String concatTitle = serviceName.toLowerCase(Locale.ENGLISH);
    String srcFile = concatTitle + ""_service.bal"";
    OASServiceMetadata oasServiceMetadata = new OASServiceMetadata.Builder().withOpenAPI(openAPIDef).withFilters(filter).withNullable(nullable).withGenerateServiceType(generateServiceType).withGenerateWithoutDataBinding(generateWithoutDataBinding).build();
    BallerinaServiceGenerator serviceGenerator = new BallerinaServiceGenerator(oasServiceMetadata);
    String serviceContent = Formatter.format(serviceGenerator.generateSyntaxTree()).toSourceCode();
    sourceFiles.add(new GenSrcFile(GenSrcFile.GenFileType.GEN_SRC, srcPackage, srcFile, (licenseHeader.isBlank() ? DEFAULT_FILE_HEADER : licenseHeader) + serviceContent));
    if (generateServiceType) {
        BallerinaServiceObjectGenerator ballerinaServiceObjectGenerator = new BallerinaServiceObjectGenerator(serviceGenerator.getFunctionList());
        String serviceType = Formatter.format(ballerinaServiceObjectGenerator.generateSyntaxTree()).toSourceCode();
        sourceFiles.add(new GenSrcFile(GenSrcFile.GenFileType.GEN_SRC, srcPackage, ""service_type.bal"", (licenseHeader.isBlank() ? DO_NOT_MODIFY_FILE_HEADER : licenseHeader) + serviceType));
    }
    OASClientConfig.Builder clientMetaDataBuilder = new OASClientConfig.Builder();
    OASClientConfig oasClientConfig = clientMetaDataBuilder.withFilters(filter).withNullable(nullable).withPlugin(false).withOpenAPI(openAPIDef).withResourceMode(isResource).build();
    BallerinaClientGenerator clientGenerator = new BallerinaClientGenerator(oasClientConfig);
    String clientContent = Formatter.format(clientGenerator.generateSyntaxTree()).toSourceCode();
    sourceFiles.add(new GenSrcFile(GenSrcFile.GenFileType.GEN_SRC, srcPackage, CLIENT_FILE_NAME, (licenseHeader.isBlank() ? DO_NOT_MODIFY_FILE_HEADER : licenseHeader) + clientContent));
    String utilContent = Formatter.format(clientGenerator.getBallerinaUtilGenerator().generateUtilSyntaxTree()).toString();
    if (!utilContent.isBlank()) {
        sourceFiles.add(new GenSrcFile(GenSrcFile.GenFileType.UTIL_SRC, srcPackage, UTIL_FILE_NAME, (licenseHeader.isBlank() ? DEFAULT_FILE_HEADER : licenseHeader) + utilContent));
    }
    List<TypeDefinitionNode> preGeneratedTypeDefNodes = new ArrayList<>(clientGenerator.getBallerinaAuthConfigGenerator().getAuthRelatedTypeDefinitionNodes());
    List<TypeDefinitionNode> typeInclusionRecords = serviceGenerator.getTypeInclusionRecords();
    List<TypeDefinitionNode> typeDefinitionNodeList = clientGenerator.getTypeDefinitionNodeList();
    preGeneratedTypeDefNodes.addAll(typeInclusionRecords);
    preGeneratedTypeDefNodes.addAll(typeDefinitionNodeList);
    BallerinaTypesGenerator ballerinaSchemaGenerator = new BallerinaTypesGenerator(openAPIDef, nullable, preGeneratedTypeDefNodes);
    SyntaxTree schemaSyntaxTree = ballerinaSchemaGenerator.generateSyntaxTree();
    String schemaContent = Formatter.format(schemaSyntaxTree).toSourceCode();
    if (filter.getTags().size() > 0) {
        schemaContent = GeneratorUtils.removeUnusedEntities(schemaSyntaxTree, clientContent, schemaContent, serviceContent);
    }
    if (!schemaContent.isBlank()) {
        sourceFiles.add(new GenSrcFile(GenSrcFile.GenFileType.MODEL_SRC, srcPackage, TYPE_FILE_NAME, (licenseHeader.isBlank() ? DEFAULT_FILE_HEADER : licenseHeader) + schemaContent));
    }
    if (this.includeTestFiles) {
        BallerinaTestGenerator ballerinaTestGenerator = new BallerinaTestGenerator(clientGenerator);
        String testContent = Formatter.format(ballerinaTestGenerator.generateSyntaxTree()).toSourceCode();
        sourceFiles.add(new GenSrcFile(GenSrcFile.GenFileType.GEN_SRC, srcPackage, TEST_FILE_NAME, (licenseHeader.isBlank() ? DEFAULT_FILE_HEADER : licenseHeader) + testContent));
        String configContent = ballerinaTestGenerator.getConfigTomlFile();
        if (!configContent.isBlank()) {
            sourceFiles.add(new GenSrcFile(GenSrcFile.GenFileType.GEN_SRC, srcPackage, CONFIG_FILE_NAME, configContent));
        }
    }
    List<GenSrcFile> newGenFiles = sourceFiles.stream().filter(distinctByKey(GenSrcFile::getFileName)).collect(Collectors.toList());
    writeGeneratedSources(newGenFiles, srcPath, implPath, GEN_BOTH);
}",java:S3776,39
"public void generateClientAndService(String definitionPath, String serviceName, String outPath, Filter filter, boolean nullable, boolean isResource, boolean generateServiceType, boolean generateWithoutDataBinding) throws IOException, FormatterException, io.ballerina.openapi.core.exception.BallerinaOpenApiException{
    Path srcPath = Paths.get(outPath);
    Path implPath = CodegenUtils.getImplPath(srcPackage, srcPath);
    List<GenSrcFile> sourceFiles = new ArrayList<>();
    Path openAPIPath = Path.of(definitionPath);
    OpenAPI openAPIDef = GeneratorUtils.normalizeOpenAPI(openAPIPath, !isResource);
    String concatTitle = serviceName.toLowerCase(Locale.ENGLISH);
    String srcFile = concatTitle + ""_service.bal"";
    OASServiceMetadata oasServiceMetadata = new OASServiceMetadata.Builder().withOpenAPI(openAPIDef).withFilters(filter).withNullable(nullable).withGenerateServiceType(generateServiceType).withGenerateWithoutDataBinding(generateWithoutDataBinding).build();
    BallerinaServiceGenerator serviceGenerator = new BallerinaServiceGenerator(oasServiceMetadata);
    String serviceContent = Formatter.format(serviceGenerator.generateSyntaxTree()).toSourceCode();
    sourceFiles.add(new GenSrcFile(GenSrcFile.GenFileType.GEN_SRC, srcPackage, srcFile, (licenseHeader.isBlank() ? DEFAULT_FILE_HEADER : licenseHeader) + serviceContent));
    if (generateServiceType) {
        BallerinaServiceObjectGenerator ballerinaServiceObjectGenerator = new BallerinaServiceObjectGenerator(serviceGenerator.getFunctionList());
        String serviceType = Formatter.format(ballerinaServiceObjectGenerator.generateSyntaxTree()).toSourceCode();
        sourceFiles.add(new GenSrcFile(GenSrcFile.GenFileType.GEN_SRC, srcPackage, ""service_type.bal"", (licenseHeader.isBlank() ? DO_NOT_MODIFY_FILE_HEADER : licenseHeader) + serviceType));
    }
    OASClientConfig.Builder clientMetaDataBuilder = new OASClientConfig.Builder();
    OASClientConfig oasClientConfig = clientMetaDataBuilder.withFilters(filter).withNullable(nullable).withPlugin(false).withOpenAPI(openAPIDef).withResourceMode(isResource).build();
    BallerinaClientGenerator clientGenerator = new BallerinaClientGenerator(oasClientConfig);
    String clientContent = Formatter.format(clientGenerator.generateSyntaxTree()).toSourceCode();
    sourceFiles.add(new GenSrcFile(GenSrcFile.GenFileType.GEN_SRC, srcPackage, CLIENT_FILE_NAME, (licenseHeader.isBlank() ? DO_NOT_MODIFY_FILE_HEADER : licenseHeader) + clientContent));
    String utilContent = Formatter.format(clientGenerator.getBallerinaUtilGenerator().generateUtilSyntaxTree()).toString();
    if (!utilContent.isBlank()) {
        sourceFiles.add(new GenSrcFile(GenSrcFile.GenFileType.UTIL_SRC, srcPackage, UTIL_FILE_NAME, (licenseHeader.isBlank() ? DEFAULT_FILE_HEADER : licenseHeader) + utilContent));
    }
    List<TypeDefinitionNode> preGeneratedTypeDefNodes = new ArrayList<>(clientGenerator.getBallerinaAuthConfigGenerator().getAuthRelatedTypeDefinitionNodes());
    List<TypeDefinitionNode> typeInclusionRecords = serviceGenerator.getTypeInclusionRecords();
    List<TypeDefinitionNode> typeDefinitionNodeList = clientGenerator.getTypeDefinitionNodeList();
    preGeneratedTypeDefNodes.addAll(typeInclusionRecords);
    preGeneratedTypeDefNodes.addAll(typeDefinitionNodeList);
    BallerinaTypesGenerator ballerinaSchemaGenerator = new BallerinaTypesGenerator(openAPIDef, nullable, preGeneratedTypeDefNodes);
    SyntaxTree schemaSyntaxTree = ballerinaSchemaGenerator.generateSyntaxTree();
    String schemaContent = Formatter.format(schemaSyntaxTree).toSourceCode();
    if (filter.getTags().size() > 0) {
        schemaContent = GeneratorUtils.removeUnusedEntities(schemaSyntaxTree, clientContent, schemaContent, serviceContent);
    }
    if (!schemaContent.isBlank()) {
        sourceFiles.add(new GenSrcFile(GenSrcFile.GenFileType.MODEL_SRC, srcPackage, TYPE_FILE_NAME, (licenseHeader.isBlank() ? DEFAULT_FILE_HEADER : licenseHeader) + schemaContent));
    }
    if (this.includeTestFiles) {
        BallerinaTestGenerator ballerinaTestGenerator = new BallerinaTestGenerator(clientGenerator);
        String testContent = Formatter.format(ballerinaTestGenerator.generateSyntaxTree()).toSourceCode();
        sourceFiles.add(new GenSrcFile(GenSrcFile.GenFileType.GEN_SRC, srcPackage, TEST_FILE_NAME, (licenseHeader.isBlank() ? DEFAULT_FILE_HEADER : licenseHeader) + testContent));
        String configContent = ballerinaTestGenerator.getConfigTomlFile();
        if (!configContent.isBlank()) {
            sourceFiles.add(new GenSrcFile(GenSrcFile.GenFileType.GEN_SRC, srcPackage, CONFIG_FILE_NAME, configContent));
        }
    }
    List<GenSrcFile> newGenFiles = sourceFiles.stream().filter(distinctByKey(GenSrcFile::getFileName)).collect(Collectors.toList());
    writeGeneratedSources(newGenFiles, srcPath, implPath, GEN_BOTH);
}",java:S107,1
"private void writeGeneratedSources(List<GenSrcFile> sources, Path srcPath, Path implPath, CmdConstants.GenType type) throws IOException{
    List<File> listFiles = new ArrayList<>();
    if (Files.exists(srcPath)) {
        File[] files = new File(String.valueOf(srcPath)).listFiles();
        if (files != null) {
            listFiles.addAll(Arrays.asList(files));
            for (File file : files) {
                if (file.isDirectory() && file.getName().equals(""tests"")) {
                    File[] innerFiles = new File(srcPath + ""/tests"").listFiles();
                    if (innerFiles != null) {
                        listFiles.addAll(Arrays.asList(innerFiles));
                    }
                }
            }
        }
    }
    for (File file : listFiles) {
        for (GenSrcFile gFile : sources) {
            if (file.getName().equals(gFile.getFileName())) {
                if (System.console() != null) {
                    String userInput = System.console().readLine(""There is already a/an "" + file.getName() + "" in the location. Do you want to override the file? [y/N] "");
                    if (!Objects.equals(userInput.toLowerCase(Locale.ENGLISH), ""y"")) {
                        int duplicateCount = 0;
                        setGeneratedFileName(listFiles, gFile, duplicateCount);
                    }
                }
            }
        }
    }
    for (GenSrcFile file : sources) {
        Path filePath;
        if (!file.getType().isOverwritable()) {
            filePath = implPath.resolve(file.getFileName());
            if (Files.notExists(filePath)) {
                String fileContent = file.getContent();
                CodegenUtils.writeFile(filePath, fileContent);
            }
        } else {
            boolean isDuplicatedFileInTests = file.getFileName().matches(""test.+[0-9]+.bal"") || file.getFileName().matches(""Config.+[0-9]+.toml"");
            if (file.getFileName().equals(TEST_FILE_NAME) || file.getFileName().equals(CONFIG_FILE_NAME) || isDuplicatedFileInTests) {
                Files.createDirectories(Paths.get(srcPath + OAS_PATH_SEPARATOR + TEST_DIR));
                filePath = Paths.get(srcPath.resolve(TEST_DIR + OAS_PATH_SEPARATOR + file.getFileName()).toFile().getCanonicalPath());
            } else {
                filePath = Paths.get(srcPath.resolve(file.getFileName()).toFile().getCanonicalPath());
            }
            String fileContent = file.getContent();
            CodegenUtils.writeFile(filePath, fileContent);
        }
    }
    if (type.equals(GEN_SERVICE)) {
        outStream.println(""Service generated successfully and the OpenAPI contract is copied to path "" + srcPath + ""."");
    } else if (type.equals(GEN_CLIENT)) {
        outStream.println(""Client generated successfully."");
    }
    outStream.println(""Following files were created."");
    Iterator<GenSrcFile> iterator = sources.iterator();
    while (iterator.hasNext()) {
        outStream.println(""-- "" + iterator.next().getFileName());
    }
}",java:S3776,39
"private void writeGeneratedSources(List<GenSrcFile> sources, Path srcPath, Path implPath, CmdConstants.GenType type) throws IOException{
    List<File> listFiles = new ArrayList<>();
    if (Files.exists(srcPath)) {
        File[] files = new File(String.valueOf(srcPath)).listFiles();
        if (files != null) {
            listFiles.addAll(Arrays.asList(files));
            for (File file : files) {
                if (file.isDirectory() && file.getName().equals(""tests"")) {
                    File[] innerFiles = new File(srcPath + ""/tests"").listFiles();
                    if (innerFiles != null) {
                        listFiles.addAll(Arrays.asList(innerFiles));
                    }
                }
            }
        }
    }
    for (File file : listFiles) {
        for (GenSrcFile gFile : sources) {
            if (file.getName().equals(gFile.getFileName())) {
                if (System.console() != null) {
                    String userInput = System.console().readLine(""There is already a/an "" + file.getName() + "" in the location. Do you want to override the file? [y/N] "");
                    if (!Objects.equals(userInput.toLowerCase(Locale.ENGLISH), ""y"")) {
                        int duplicateCount = 0;
                        setGeneratedFileName(listFiles, gFile, duplicateCount);
                    }
                }
            }
        }
    }
    for (GenSrcFile file : sources) {
        Path filePath;
        if (!file.getType().isOverwritable()) {
            filePath = implPath.resolve(file.getFileName());
            if (Files.notExists(filePath)) {
                String fileContent = file.getContent();
                CodegenUtils.writeFile(filePath, fileContent);
            }
        } else {
            boolean isDuplicatedFileInTests = file.getFileName().matches(""test.+[0-9]+.bal"") || file.getFileName().matches(""Config.+[0-9]+.toml"");
            if (file.getFileName().equals(TEST_FILE_NAME) || file.getFileName().equals(CONFIG_FILE_NAME) || isDuplicatedFileInTests) {
                Files.createDirectories(Paths.get(srcPath + OAS_PATH_SEPARATOR + TEST_DIR));
                filePath = Paths.get(srcPath.resolve(TEST_DIR + OAS_PATH_SEPARATOR + file.getFileName()).toFile().getCanonicalPath());
            } else {
                filePath = Paths.get(srcPath.resolve(file.getFileName()).toFile().getCanonicalPath());
            }
            String fileContent = file.getContent();
            CodegenUtils.writeFile(filePath, fileContent);
        }
    }
    if (type.equals(GEN_SERVICE)) {
        outStream.println(""Service generated successfully and the OpenAPI contract is copied to path "" + srcPath + ""."");
    } else if (type.equals(GEN_CLIENT)) {
        outStream.println(""Client generated successfully."");
    }
    outStream.println(""Following files were created."");
    Iterator<GenSrcFile> iterator = sources.iterator();
    while (iterator.hasNext()) {
        outStream.println(""-- "" + iterator.next().getFileName());
    }
}",java:S6541,49
"public void generateOAS3DefinitionsAllService(Path servicePath, Path outPath, String serviceName, Boolean needJson){
    project = ProjectLoader.loadProject(servicePath);
    DiagnosticResult diagnosticsFromCodeGenAndModify = project.currentPackage().runCodeGenAndModifyPlugins();
    boolean hasErrorsFromCodeGenAndModify = diagnosticsFromCodeGenAndModify.diagnostics().stream().anyMatch(d -> DiagnosticSeverity.ERROR.equals(d.diagnosticInfo().severity()));
    DocumentId docId;
    Document doc;
    if (project.kind().equals(ProjectKind.BUILD_PROJECT)) {
        docId = project.documentId(servicePath);
        ModuleId moduleId = docId.moduleId();
        doc = project.currentPackage().module(moduleId).document(docId);
    } else {
        Module currentModule = project.currentPackage().getDefaultModule();
        Iterator<DocumentId> documentIterator = currentModule.documentIds().iterator();
        docId = documentIterator.next();
        doc = currentModule.document(docId);
    }
    Optional<Path> path = project.documentPath(docId);
    Path inputPath = path.orElse(null);
    syntaxTree = doc.syntaxTree();
    PackageCompilation compilation = project.currentPackage().getCompilation();
    boolean hasCompilationErrors = compilation.diagnosticResult().diagnostics().stream().anyMatch(d -> DiagnosticSeverity.ERROR.equals(d.diagnosticInfo().severity()));
    if (hasCompilationErrors || hasErrorsFromCodeGenAndModify) {
        return;
    }
    semanticModel = compilation.getSemanticModel(docId.moduleId());
    List<OASResult> openAPIDefinitions = ServiceToOpenAPIConverterUtils.generateOAS3Definition(project, syntaxTree, semanticModel, serviceName, needJson, inputPath);
    if (!openAPIDefinitions.isEmpty()) {
        List<String> fileNames = new ArrayList<>();
        for (OASResult definition : openAPIDefinitions) {
            try {
                this.errors.addAll(definition.getDiagnostics());
                if (definition.getOpenAPI().isPresent()) {
                    Optional<String> content;
                    if (needJson) {
                        content = definition.getJson();
                    } else {
                        content = definition.getYaml();
                    }
                    String fileName = resolveContractFileName(outPath, definition.getServiceName(), needJson);
                    CodegenUtils.writeFile(outPath.resolve(fileName), content.get());
                    fileNames.add(fileName);
                }
            } catch (IOException e) {
                DiagnosticMessages message = DiagnosticMessages.OAS_CONVERTOR_108;
                ExceptionDiagnostic error = new ExceptionDiagnostic(message.getCode(), message.getDescription() + e.getLocalizedMessage(), null);
                this.errors.add(error);
            }
        }
        if (fileNames.isEmpty()) {
            return;
        }
        outStream.println(""OpenAPI definition(s) generated successfully and copied to :"");
        Iterator<String> iterator = fileNames.iterator();
        while (iterator.hasNext()) {
            outStream.println(""-- "" + iterator.next());
        }
    } else {
        DiagnosticMessages message = DiagnosticMessages.OAS_CONVERTOR_115;
        ExceptionDiagnostic error = new ExceptionDiagnostic(message.getCode(), message.getDescription(), null);
        this.errors.add(error);
    }
}",java:S3776,39
"private static boolean isOpenAPI(Path oasPath, IDLSourceGeneratorContext context){
    try {
        if (!(oasPath.toString().endsWith(YAML_EXTENSION) || oasPath.toString().endsWith(JSON_EXTENSION) || oasPath.toString().endsWith(YML_EXTENSION))) {
            return false;
        }
        String content = Files.readString(oasPath);
        Pattern openapiPattern = Pattern.compile(OPENAPI_REGEX_PATTERN);
        Matcher openapiMatcher = openapiPattern.matcher(content);
        return openapiMatcher.find();
    } catch (IOException | NullPointerException e) {
        return false;
    }
}",java:S1172,13
"private void glyphChanged(@SuppressWarnings(""unused"") ObservableValue<? extends FontAwesome5Icon> observable, @SuppressWarnings(""unused"") FontAwesome5Icon oldValue, FontAwesome5Icon newValue){
    setText(newValue == null ? null : newValue.unicode());
}",java:S4968,42
"private static Image createImageFromResource(String resourceName) throws IOException{
    try (InputStream in = FxApplicationModule.class.getResourceAsStream(resourceName)) {
        return new Image(in);
    }
}",java:S1118,3
"private void appThemeChanged(@SuppressWarnings(""unused"") ObservableValue<? extends UiTheme> observable, @SuppressWarnings(""unused"") UiTheme oldValue, UiTheme newValue){
    if (appearanceProvider.isPresent() && oldValue == UiTheme.AUTOMATIC && newValue != UiTheme.AUTOMATIC) {
        try {
            appearanceProvider.get().removeListener(systemInterfaceThemeListener);
        } catch (UiAppearanceException e) {
            LOG.error(""Failed to disable automatic theme switching."");
        }
    }
    loadSelectedStyleSheet(newValue);
}",java:S4968,42
"public void showQuitWindow(QuitResponse response, boolean forced){
    CompletableFuture.runAsync(() -> quitWindowBuilder.build().showQuitWindow(response, forced), Platform::runLater);
}",java:S1117,2
"private void lock(boolean forced) throws InterruptedException, ExecutionException, IOException{
    try {
        vault.lock(forced);
    } catch (UnmountFailedException e) {
        LOG.info(""Locking {} failed (forced: {})."", vault.getDisplayName(), forced, e);
        retryOrCancel();
    }
}",java:S1135,9
"private void startResize(MouseEvent evt){
    origX = window.getX();
    origY = window.getY();
    origW = window.getWidth();
    origH = window.getHeight();
}",java:S1172,13
"public void initialize(){
    vaultList.setItems(vaults);
    vaultList.setCellFactory(cellFactory);
    selectedVault.bind(vaultList.getSelectionModel().selectedItemProperty());
    vaults.addListener((ListChangeListener.Change<? extends Vault> c) -> {
        while (c.next()) {
            if (c.wasAdded()) {
                Vault anyAddedVault = c.getAddedSubList().get(0);
                vaultList.getSelectionModel().select(anyAddedVault);
            }
        }
    });
    vaultList.addEventFilter(MouseEvent.MOUSE_RELEASED, this::deselect);
    vaultList.addEventFilter(ContextMenuEvent.CONTEXT_MENU_REQUESTED, request -> {
        if (selectedVault.get() == null) {
            request.consume();
        }
    });
    vaultList.addEventFilter(KeyEvent.KEY_PRESSED, keyEvent -> {
        if (keyEvent.getCode() == KeyCode.DELETE) {
            pressedShortcutToRemoveVault();
            keyEvent.consume();
        }
    });
    if (SystemUtils.IS_OS_MAC) {
        vaultList.addEventFilter(KeyEvent.KEY_PRESSED, keyEvent -> {
            if (keyEvent.getCode() == KeyCode.BACK_SPACE) {
                pressedShortcutToRemoveVault();
                keyEvent.consume();
            }
        });
    }
    mainWindow.addEventFilter(KeyEvent.KEY_RELEASED, keyEvent -> {
        if (keyEvent.isShortcutDown() && keyEvent.getCode().isDigitKey()) {
            vaultList.getSelectionModel().select(Integer.parseInt(keyEvent.getText()) - 1);
            keyEvent.consume();
        }
    });
    root.setOnDragEntered(this::handleDragEvent);
    root.setOnDragOver(this::handleDragEvent);
    root.setOnDragDropped(this::handleDragEvent);
    root.setOnDragExited(this::handleDragEvent);
}",java:S3776,39
"private void registrationKeyChanged(@SuppressWarnings(""unused"") ObservableValue<? extends String> observable, @SuppressWarnings(""unused"") String oldValue, String newValue){
    licenseHolder.validateAndStoreLicense(newValue);
    if (!licenseHolder.isValidLicense()) {
        settings.theme().set(UiTheme.LIGHT);
    }
}",java:S4968,42
"public TextFormatter getRecoveryKeyTextFormatter(){
    return new TextFormatter<>(this::filterTextChange);
}",java:S3740,38
"private static synchronized ActualMountService applyWorkaroundForProblematicFuse(MountService targetedService, boolean isDesired, AtomicReference<MountService> firstUsedProblematicFuseMountService){
    var targetIsProblematicFuse = isProblematicFuseService(targetedService);
    if (targetIsProblematicFuse && firstUsedProblematicFuseMountService.get() == null) {
        firstUsedProblematicFuseMountService.set(targetedService);
    }
    if (targetIsProblematicFuse && !firstUsedProblematicFuseMountService.get().equals(targetedService)) {
        return new ActualMountService(formerSelectedMountService.get(), false);
    } else {
        formerSelectedMountService.set(targetedService);
        return new ActualMountService(targetedService, isDesired);
    }
}",java:S1124,6
"public void log(){
    LOG.info(""user.home: {}"", System.getProperty(""user.home""));
    LOG.info(""java.library.path: {}"", System.getProperty(""java.library.path""));
    LOG.info(""user.language: {}"", System.getProperty(""user.language""));
    LOG.info(""user.region: {}"", System.getProperty(""user.region""));
    LOG.info(""logback.configurationFile: {}"", System.getProperty(""logback.configurationFile""));
    logCryptomatorSystemProperty(SETTINGS_PATH_PROP_NAME);
    logCryptomatorSystemProperty(IPC_SOCKET_PATH_PROP_NAME);
    logCryptomatorSystemProperty(KEYCHAIN_PATHS_PROP_NAME);
    logCryptomatorSystemProperty(LOG_DIR_PROP_NAME);
    logCryptomatorSystemProperty(LOOPBACK_ALIAS_PROP_NAME);
    logCryptomatorSystemProperty(PLUGIN_DIR_PROP_NAME);
    logCryptomatorSystemProperty(MOUNTPOINT_DIR_PROP_NAME);
    logCryptomatorSystemProperty(MIN_PW_LENGTH_PROP_NAME);
    logCryptomatorSystemProperty(APP_VERSION_PROP_NAME);
    logCryptomatorSystemProperty(BUILD_NUMBER_PROP_NAME);
    logCryptomatorSystemProperty(TRAY_ICON_PROP_NAME);
    logCryptomatorSystemProperty(P12_PATH_PROP_NAME);
}",java:S2629,31
"private void updateStats(Optional<CryptoFileSystemStats> stats){
    assert Platform.isFxApplicationThread();
    bytesPerSecondRead.set(stats.map(CryptoFileSystemStats::pollBytesRead).orElse(0L));
    bytesPerSecondWritten.set(stats.map(CryptoFileSystemStats::pollBytesWritten).orElse(0L));
    cacheHitRate.set(stats.map(this::getCacheHitRate).orElse(0.0));
    bytesPerSecondDecrypted.set(stats.map(CryptoFileSystemStats::pollBytesDecrypted).orElse(0L));
    bytesPerSecondEncrypted.set(stats.map(CryptoFileSystemStats::pollBytesEncrypted).orElse(0L));
    totalBytesRead.set(stats.map(CryptoFileSystemStats::pollTotalBytesRead).orElse(0L));
    totalBytesWritten.set(stats.map(CryptoFileSystemStats::pollTotalBytesWritten).orElse(0L));
    totalBytesEncrypted.set(stats.map(CryptoFileSystemStats::pollTotalBytesEncrypted).orElse(0L));
    totalBytesDecrypted.set(stats.map(CryptoFileSystemStats::pollTotalBytesDecrypted).orElse(0L));
    var oldAccessCount = filesRead.get() + filesWritten.get();
    filesRead.set(stats.map(CryptoFileSystemStats::pollAmountOfAccessesRead).orElse(0L));
    filesWritten.set(stats.map(CryptoFileSystemStats::pollAmountOfAccessesWritten).orElse(0L));
    filesAccessed.set(stats.map(CryptoFileSystemStats::pollAmountOfAccesses).orElse(0L));
    totalFilesAccessed.set(stats.map(CryptoFileSystemStats::pollTotalAmountOfAccesses).orElse(0L));
    var newAccessCount = filesRead.get() + filesWritten.get();
    if (newAccessCount > oldAccessCount) {
        lastActivity.set(Instant.now());
    }
}",java:S3398,35
"private void logLevelChanged(@SuppressWarnings(""unused"") ObservableValue<? extends Boolean> observable, @SuppressWarnings(""unused"") Boolean oldValue, Boolean newValue){
    setLogLevels(newValue);
}",java:S4968,42
"private static void stripTryDescr(String originalCode, StringBuilder consequence, JavaTryBlockDescr block, int offset){
    addWhiteSpaces(originalCode, consequence, consequence.length(), block.getTextStart() - offset);
    addWhiteSpaces(originalCode, consequence, consequence.length(), block.getEnd() - offset);
    for (JavaCatchBlockDescr catchBlock : block.getCatches()) {
        addWhiteSpaces(originalCode, consequence, consequence.length(), catchBlock.getTextStart() - offset);
        addWhiteSpaces(originalCode, consequence, consequence.length(), catchBlock.getEnd() - offset);
    }
    if (block.getFinal() != null) {
        addWhiteSpaces(originalCode, consequence, consequence.length(), block.getFinal().getTextStart() - offset);
        addWhiteSpaces(originalCode, consequence, consequence.length(), block.getFinal().getEnd() - offset);
    }
}",java:S1144,10
"private static void stripBlockDescr(String originalCode, StringBuilder consequence, JavaBlockDescr block, int offset){
    addWhiteSpaces(originalCode, consequence, consequence.length(), block.getEnd() - offset);
}",java:S1144,10
"private Object normalizeResult(Class<?> resultClass, Object val){
    if (resultClass == String.class) {
        String value = val.toString();
        if (annotationDescr.isStrict()) {
            if (value.charAt(0) == '""' && value.charAt(value.length() - 1) == '""') {
                return value.substring(1, value.length() - 1);
            } else {
                throw new RuntimeException(""Cannot convert "" + value + "" to an instance of type "" + resultClass.getName());
            }
        } else {
            return value;
        }
    }
    if (resultClass.isInstance(val)) {
        return val;
    }
    String value = val.toString();
    if (resultClass == Boolean.class || resultClass == boolean.class) {
        return Boolean.valueOf(value);
    }
    if (resultClass == Integer.class || resultClass == int.class) {
        return Integer.valueOf(value);
    }
    if (resultClass.isEnum()) {
        String annotationHead = resultClass.getSimpleName() + ""."";
        int typePos = value.indexOf(annotationHead);
        if (typePos >= 0) {
            value = value.substring(typePos + annotationHead.length());
        }
        try {
            return Enum.valueOf((Class<Enum>) resultClass, value);
        } catch (IllegalArgumentException e) {
            if (!annotationDescr.isStrict()) {
                value = ucFirst(value);
                try {
                    return Enum.valueOf((Class<Enum>) resultClass, value);
                } catch (IllegalArgumentException e2) {
                    return Enum.valueOf((Class<Enum>) resultClass, value.toUpperCase());
                }
            }
            throw e;
        }
    }
    throw new RuntimeException(""Cannot convert "" + value + "" to an instance of type "" + resultClass.getName());
}",java:S3776,39
"public static String[] addXsdModel(Resource resource, KnowledgeBuilderImpl kBuilder, Options xjcOpts, String systemId) throws IOException{
    InputSource source = new InputSource(new CachingRewindableReader(resource.getReader()));
    source.setSystemId(systemId.trim().startsWith(""."") ? systemId : ""."" + systemId);
    xjcOpts.addGrammar(source);
    try {
        xjcOpts.parseArguments(new String[] { ""-npa"" });
    } catch (BadCommandLineException e) {
        throw new IllegalArgumentException(""Unable to parse arguments"", e);
    }
    ErrorReceiver errorReceiver = new JaxbErrorReceiver4Drools();
    Model model = ModelLoader.load(xjcOpts, new JCodeModel(), errorReceiver);
    model.generateCode(xjcOpts, errorReceiver);
    MapVfsCodeWriter codeWriter = new MapVfsCodeWriter();
    model.codeModel.build(xjcOpts.createCodeWriter(codeWriter));
    MemoryResourceReader src = new MemoryResourceReader();
    boolean useProjectClassLoader = kBuilder.getRootClassLoader() instanceof ProjectClassLoader;
    List<String> classNames = new ArrayList<>();
    List<String> srcNames = new ArrayList<>();
    for (Entry<String, byte[]> entry : codeWriter.getMap().entrySet()) {
        String name = entry.getKey();
        int dotPos = name.lastIndexOf('.');
        String pkgName = name.substring(0, dotPos);
        if (!name.endsWith(""package-info.java"")) {
            classNames.add(pkgName);
        }
        dotPos = pkgName.lastIndexOf('.');
        if (dotPos != -1) {
            pkgName = pkgName.substring(0, dotPos);
        }
        PackageRegistry pkgReg = kBuilder.getPackageRegistry(pkgName);
        if (pkgReg == null) {
            kBuilder.addPackage(new PackageDescr(pkgName));
            pkgReg = kBuilder.getPackageRegistry(pkgName);
        }
        if (useProjectClassLoader) {
            String srcName = convertToResource(entry.getKey());
            src.add(srcName, entry.getValue());
            srcNames.add(srcName);
        } else {
            Dialect dialect = pkgReg.getDialectCompiletimeRegistry().getDialect(""java"");
            dialect.addSrc(convertToResource(entry.getKey()), entry.getValue());
        }
    }
    if (useProjectClassLoader) {
        ProjectJavaCompiler compiler = new ProjectJavaCompiler(kBuilder.getBuilderConfiguration());
        List<KnowledgeBuilderResult> results = compiler.compileAll((ProjectClassLoader) kBuilder.getRootClassLoader(), srcNames, src);
        for (String className : classNames) {
            Class<?> clazz;
            try {
                clazz = Class.forName(className, true, kBuilder.getRootClassLoader());
            } catch (ClassNotFoundException e) {
                continue;
            }
            String pkgName = className.substring(0, className.lastIndexOf('.'));
            PackageRegistry pkgReg = kBuilder.getPackageRegistry(pkgName);
            pkgReg.getPackage().addTypeDeclaration(TypeDeclaration.createTypeDeclarationForBean(clazz));
        }
        kBuilder.updateResults(results);
    } else {
        kBuilder.compileAll();
        kBuilder.updateResults();
    }
    return classNames.toArray(new String[classNames.size()]);
}",java:S3776,39
"public void close(){
}",java:S1161,11
"public void close(){
    try {
        reset();
    } catch (IOException e) {
        LOG.error(""Exception"", e);
    }
}",java:S1161,11
"public void matchCancelled(MatchCancelledEvent event){
}",java:S1186,16
"public void matchCreated(MatchCreatedEvent event){
}",java:S1186,16
"public void agendaGroupPopped(AgendaGroupPoppedEvent event){
}",java:S1186,16
"public void agendaGroupPushed(AgendaGroupPushedEvent event){
}",java:S1186,16
"public void beforeMatchFired(BeforeMatchFiredEvent event){
}",java:S1186,16
"public AgendaFilter getAgendaFilter(final HashSet<String> ruleNames, final boolean inclusive){
    return new AgendaFilter() {

        public boolean accept(Match match) {
            if (ruleNames.size() == 0)
                return true;
            String ruleName = match.getRule().getName();
            if (inclusive) {
                if (ruleNames.contains(ruleName)) {
                    return true;
                } else {
                    return false;
                }
            } else {
                if (!ruleNames.contains(ruleName)) {
                    return true;
                } else {
                    return false;
                }
            }
        }
    };
}",java:S1319,22
"public void matchCancelled(MatchCancelledEvent event){
}",java:S1186,16
"public void matchCreated(MatchCreatedEvent event){
}",java:S1186,16
"public void agendaGroupPopped(AgendaGroupPoppedEvent event){
}",java:S1186,16
"public void agendaGroupPushed(AgendaGroupPushedEvent event){
}",java:S1186,16
"public void beforeMatchFired(BeforeMatchFiredEvent event){
}",java:S1186,16
"public void evaluate(KnowledgeHelper knowledgeHelper, ValueResolver valueResolver) throws Exception{
}",java:S1186,16
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1186,16
"public String toString(){
    return this.string;
}",java:S1161,11
"public String toString(){
    return this.string;
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
}",java:S1185,15
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
}",java:S1185,15
" void _setBottomTypeCode(BitSet bottomTypeCode){
    ((TraitTypeMap) _getTraitMap()).setBottomCode(bottomTypeCode);
}",java:S100,0
"public void setOption(KieBaseOption option){
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
}",java:S1161,11
" boolean isEvent(){
    return true;
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeBoolean(mutabilityEnabled);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    mutabilityEnabled = in.readBoolean();
}",java:S1161,11
"public void remove(){
    this.iterator.remove();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeBoolean(sequential);
    out.writeObject(sequentialAgenda);
    out.writeBoolean(maintainTms);
    out.writeBoolean(removeIdentities);
    out.writeBoolean(shareAlphaNodes);
    out.writeBoolean(shareBetaNodes);
    out.writeInt(permGenThreshold);
    out.writeInt(jittingThreshold);
    out.writeInt(alphaNodeHashingThreshold);
    out.writeInt(alphaNodeRangeIndexThreshold);
    out.writeBoolean(betaNodeRangeIndexEnabled);
    out.writeInt(compositeKeyDepth);
    out.writeBoolean(indexLeftBetaMemory);
    out.writeBoolean(indexRightBetaMemory);
    out.writeObject(indexPrecedenceOption);
    out.writeObject(assertBehaviour);
    out.writeObject(consequenceExceptionHandler);
    out.writeObject(ruleBaseUpdateHandler);
    out.writeObject(conflictResolver);
    out.writeObject(parallelExecution);
    out.writeInt(maxThreads);
    out.writeObject(eventProcessingMode);
    out.writeBoolean(declarativeAgenda);
    out.writeInt(sessionPoolSize);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    sequential = in.readBoolean();
    sequentialAgenda = (SequentialAgenda) in.readObject();
    maintainTms = in.readBoolean();
    removeIdentities = in.readBoolean();
    shareAlphaNodes = in.readBoolean();
    shareBetaNodes = in.readBoolean();
    permGenThreshold = in.readInt();
    jittingThreshold = in.readInt();
    alphaNodeHashingThreshold = in.readInt();
    alphaNodeRangeIndexThreshold = in.readInt();
    betaNodeRangeIndexEnabled = in.readBoolean();
    compositeKeyDepth = in.readInt();
    indexLeftBetaMemory = in.readBoolean();
    indexRightBetaMemory = in.readBoolean();
    indexPrecedenceOption = (IndexPrecedenceOption) in.readObject();
    assertBehaviour = (AssertBehaviour) in.readObject();
    consequenceExceptionHandler = (String) in.readObject();
    ruleBaseUpdateHandler = (String) in.readObject();
    conflictResolver = (ConflictResolver) in.readObject();
    parallelExecution = (ParallelExecutionOption) in.readObject();
    maxThreads = in.readInt();
    eventProcessingMode = (EventProcessingOption) in.readObject();
    declarativeAgenda = in.readBoolean();
    sessionPoolSize = in.readInt();
}",java:S1161,11
"public boolean setInternalProperty(String name, String value){
    switch(name) {
        case SequentialAgendaOption.PROPERTY_NAME:
            {
                setSequentialAgenda(SequentialAgenda.determineSequentialAgenda(StringUtils.isEmpty(value) ? ""sequential"" : value));
                break;
            }
        case SequentialOption.PROPERTY_NAME:
            {
                setSequential(StringUtils.isEmpty(value) ? false : Boolean.valueOf(value));
                break;
            }
        case RemoveIdentitiesOption.PROPERTY_NAME:
            {
                setRemoveIdentities(StringUtils.isEmpty(value) ? false : Boolean.valueOf(value));
                break;
            }
        case ShareAlphaNodesOption.PROPERTY_NAME:
            {
                setShareAlphaNodes(StringUtils.isEmpty(value) ? false : Boolean.valueOf(value));
                break;
            }
        case ShareBetaNodesOption.PROPERTY_NAME:
            {
                setShareBetaNodes(StringUtils.isEmpty(value) ? false : Boolean.valueOf(value));
                break;
            }
        case ConstraintJittingThresholdOption.PROPERTY_NAME:
            {
                setJittingThreshold(StringUtils.isEmpty(value) ? ConstraintJittingThresholdOption.DEFAULT_VALUE : Integer.parseInt(value));
                break;
            }
        case AlphaThresholdOption.PROPERTY_NAME:
            {
                setAlphaNodeHashingThreshold(StringUtils.isEmpty(value) ? 3 : Integer.parseInt(value));
                break;
            }
        case AlphaRangeIndexThresholdOption.PROPERTY_NAME:
            {
                setAlphaNodeRangeIndexThreshold(StringUtils.isEmpty(value) ? AlphaRangeIndexThresholdOption.DEFAULT_VALUE : Integer.parseInt(value));
                break;
            }
        case BetaRangeIndexOption.PROPERTY_NAME:
            {
                setBetaNodeRangeIndexEnabled(StringUtils.isEmpty(value) ? false : Boolean.valueOf(value));
                break;
            }
        case SessionsPoolOption.PROPERTY_NAME:
            {
                setSessionPoolSize(StringUtils.isEmpty(value) ? -1 : Integer.parseInt(value));
                break;
            }
        case CompositeKeyDepthOption.PROPERTY_NAME:
            {
                setCompositeKeyDepth(StringUtils.isEmpty(value) ? 3 : Integer.parseInt(value));
                break;
            }
        case IndexLeftBetaMemoryOption.PROPERTY_NAME:
            {
                setIndexLeftBetaMemory(StringUtils.isEmpty(value) ? true : Boolean.valueOf(value));
                break;
            }
        case IndexRightBetaMemoryOption.PROPERTY_NAME:
            {
                setIndexRightBetaMemory(StringUtils.isEmpty(value) ? true : Boolean.valueOf(value));
                break;
            }
        case IndexPrecedenceOption.PROPERTY_NAME:
            {
                setIndexPrecedenceOption(StringUtils.isEmpty(value) ? IndexPrecedenceOption.EQUALITY_PRIORITY : IndexPrecedenceOption.determineIndexPrecedence(value));
                break;
            }
        case EqualityBehaviorOption.PROPERTY_NAME:
            {
                setAssertBehaviour(AssertBehaviour.determineAssertBehaviour(StringUtils.isEmpty(value) ? ""identity"" : value));
                break;
            }
        case ConsequenceExceptionHandlerOption.PROPERTY_NAME:
            {
                setConsequenceExceptionHandler(StringUtils.isEmpty(value) ? DefaultConsequenceExceptionHandler.class.getName() : value);
                break;
            }
        case ""drools.ruleBaseUpdateHandler"":
            {
                setRuleBaseUpdateHandler(StringUtils.isEmpty(value) ? """" : value);
                break;
            }
        case ParallelExecutionOption.PROPERTY_NAME:
            {
                setParallelExecution(ParallelExecutionOption.determineParallelExecution(StringUtils.isEmpty(value) ? ""sequential"" : value));
                break;
            }
        case MaxThreadsOption.PROPERTY_NAME:
            {
                setMaxThreads(StringUtils.isEmpty(value) ? 3 : Integer.parseInt(value));
                break;
            }
        case EventProcessingOption.PROPERTY_NAME:
            {
                setEventProcessingMode(EventProcessingOption.determineEventProcessingMode(StringUtils.isEmpty(value) ? ""cloud"" : value));
                break;
            }
        default:
            {
                return false;
            }
    }
    return true;
}",java:S3776,39
"public boolean equals(Object obj){
    if (obj == this)
        return true;
    else if (obj instanceof AssertBehaviour) {
        AssertBehaviour that = (AssertBehaviour) obj;
        return value == that.value;
    }
    return false;
}",java:S1206,19
"private Object readResolve() throws java.io.ObjectStreamException{
    switch(this.value) {
        case 0:
            return IDENTITY;
        case 1:
            return EQUALITY;
        default:
            throw new IllegalArgumentException(""Illegal enum value '"" + this.value + ""' for AssertBehaviour"");
    }
}",java:S2062,26
"private Object readResolve() throws java.io.ObjectStreamException{
    switch(this.value) {
        case 0:
            return SEQUENTIAL;
        case 1:
            return DYNAMIC;
        default:
            throw new IllegalArgumentException(""Illegal enum value '"" + this.value + ""' for SequentialAgenda"");
    }
}",java:S2062,26
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(queryListener);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    queryListener = (QueryListenerOption) in.readObject();
}",java:S1161,11
"public final T getOption(OptionKey<T> option, String subKey){
    return compConfig.getOption(option, subKey);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeBoolean(keepReference);
    out.writeObject(clockType);
    out.writeObject(timerJobFactoryType);
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1186,16
"public GlobalResolver clone(){
    Map<String, Object> clone = new HashMap<>();
    for (Entry<String, Object> entry : getGlobals()) {
        clone.put(entry.getKey(), entry.getValue());
    }
    return new MapGlobalResolver(clone);
}",java:S2975,34
"public GlobalResolver clone(){
    Map<String, Object> clone = new HashMap<>();
    for (Entry<String, Object> entry : getGlobals()) {
        clone.put(entry.getKey(), entry.getValue());
    }
    return new MapGlobalResolver(clone);
}",java:S1182,14
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1186,16
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1186,16
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1186,16
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1186,16
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1186,16
"public void reverse(MinData data, Object value){
}",java:S1186,16
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1186,16
"public void reverse(MinData data, Object value){
}",java:S1186,16
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1186,16
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1186,16
"public void reverse(MaxData data, Object value){
}",java:S1186,16
"public void setPartitionId(BuildContext context, RuleBasePartitionId partitionId){
    this.partitionId = partitionId;
}",java:S1172,13
"public void addAssociation(BuildContext context, Rule rule){
    addAssociation(rule);
}",java:S1172,13
"public boolean removeAssociation(Rule rule, RuleRemovalContext context){
    return this.associations.remove(rule);
}",java:S1172,13
"protected String getFormatVersion(){
    return EVENT_FORMAT_VERSION;
}",java:S1161,11
"public String toString(){
    return toExternalForm();
}",java:S1161,11
"public boolean isEvent(){
    return true;
}",java:S1161,11
"public boolean isPendingRemoveFromStore(){
    if (linkedFactHandle != null) {
        return linkedFactHandle.isPendingRemoveFromStore();
    } else {
        return pendingRemoveFromStore;
    }
}",java:S1161,11
"public DefaultEventHandle clone(){
    DefaultEventHandle clone = new DefaultEventHandle(getId(), getIdentityHashCode(), getObject(), getRecency(), getStartTimestamp(), getDuration(), getEntryPointId());
    clone.setActivationsCount(getActivationsCount());
    clone.setOtnCount(getOtnCount());
    clone.setExpired(isExpired());
    clone.setEqualityKey(getEqualityKey());
    clone.linkedTuples = this.linkedTuples.clone();
    clone.setObjectHashCode(getObjectHashCode());
    clone.wmEntryPoint = this.wmEntryPoint;
    return clone;
}",java:S2975,34
"public DefaultEventHandle clone(){
    DefaultEventHandle clone = new DefaultEventHandle(getId(), getIdentityHashCode(), getObject(), getRecency(), getStartTimestamp(), getDuration(), getEntryPointId());
    clone.setActivationsCount(getActivationsCount());
    clone.setOtnCount(getOtnCount());
    clone.setExpired(isExpired());
    clone.setEqualityKey(getEqualityKey());
    clone.linkedTuples = this.linkedTuples.clone();
    clone.setObjectHashCode(getObjectHashCode());
    clone.wmEntryPoint = this.wmEntryPoint;
    return clone;
}",java:S1161,11
"public DefaultEventHandle clone(){
    DefaultEventHandle clone = new DefaultEventHandle(getId(), getIdentityHashCode(), getObject(), getRecency(), getStartTimestamp(), getDuration(), getEntryPointId());
    clone.setActivationsCount(getActivationsCount());
    clone.setOtnCount(getOtnCount());
    clone.setExpired(isExpired());
    clone.setEqualityKey(getEqualityKey());
    clone.linkedTuples = this.linkedTuples.clone();
    clone.setObjectHashCode(getObjectHashCode());
    clone.wmEntryPoint = this.wmEntryPoint;
    return clone;
}",java:S1182,14
"public int compareTo(DefaultEventHandle e){
    return (getStartTimestamp() < e.getStartTimestamp()) ? -1 : (getStartTimestamp() == e.getStartTimestamp() ? 0 : 1);
}",java:S1210,20
"protected void setTraitType(TraitTypeEnum traitType){
}",java:S1186,16
"public ReteEvaluator getReteEvaluator(){
    return wmEntryPoint.getReteEvaluator();
}",java:S1161,11
"public DefaultFactHandle clone(){
    DefaultFactHandle clone = new DefaultFactHandle(this.id, this.identityHashCode, this.object, this.recency, this.entryPointId);
    clone.key = this.key;
    clone.linkedTuples = this.linkedTuples.clone();
    clone.objectHashCode = this.objectHashCode;
    clone.disconnected = this.disconnected;
    clone.negated = this.negated;
    clone.wmEntryPoint = this.wmEntryPoint;
    return clone;
}",java:S2975,34
"public DefaultFactHandle clone(){
    DefaultFactHandle clone = new DefaultFactHandle(this.id, this.identityHashCode, this.object, this.recency, this.entryPointId);
    clone.key = this.key;
    clone.linkedTuples = this.linkedTuples.clone();
    clone.objectHashCode = this.objectHashCode;
    clone.disconnected = this.disconnected;
    clone.negated = this.negated;
    clone.wmEntryPoint = this.wmEntryPoint;
    return clone;
}",java:S1182,14
"public SingleLinkedTuples clone(){
    SingleLinkedTuples clone = new SingleLinkedTuples();
    clone.firstLeftTuple = this.firstLeftTuple;
    clone.lastLeftTuple = this.lastLeftTuple;
    clone.firstRightTuple = this.firstRightTuple;
    clone.lastRightTuple = this.lastRightTuple;
    return clone;
}",java:S2975,34
"public SingleLinkedTuples clone(){
    SingleLinkedTuples clone = new SingleLinkedTuples();
    clone.firstLeftTuple = this.firstLeftTuple;
    clone.lastLeftTuple = this.lastLeftTuple;
    clone.firstRightTuple = this.firstRightTuple;
    clone.lastRightTuple = this.lastRightTuple;
    return clone;
}",java:S1182,14
"public void registerEvaluationContext(BuildContext buildContext){
    this.constraints[0].registerEvaluationContext(buildContext);
    this.constraints[1].registerEvaluationContext(buildContext);
}",java:S1161,11
"public int hashCode(){
    return this.hashCode;
}",java:S1161,11
"public boolean equals(final Object object){
    if (object == null) {
        return false;
    }
    if (object instanceof EqualityKey) {
        return this == object;
    }
    return this.getFirst().getObject().equals(object);
}",java:S1161,11
" FactHandleClassStore getStoreForClass(Class<?> clazz){
    return getObjectStore().getStoreForClass(clazz);
}",java:S1161,11
" boolean isThreadSafe(){
    return getRuleSessionConfiguration().isThreadSafe();
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1186,16
" Object getGlobal(String identifier){
    return getGlobalResolver().resolveGlobal(identifier);
}",java:S1161,11
"protected void startEvaluation(InternalAgendaGroup group){
    haltEvaluation = false;
}",java:S1172,13
"protected void startEvaluation(InternalAgendaGroup group){
    super.startEvaluation(group);
    parallelPreEvaluation(group);
}",java:S1161,11
"public static final int doCompare(InternalMatch existing, InternalMatch adding){
    if (existing == adding) {
        return 0;
    }
    final int s1 = existing.getSalience();
    final int s2 = adding.getSalience();
    if (s1 != s2) {
        return s1 > s2 ? 1 : -1;
    }
    Rule r1 = existing.getRule();
    Rule r2 = adding.getRule();
    if (r1.getLoadOrder() == r2.getLoadOrder()) {
        return existing.getActivationNumber() > adding.getActivationNumber() ? 1 : -1;
    }
    return r2.getLoadOrder() - r1.getLoadOrder();
}",java:S1124,6
"public static final int doCompare(final RuleAgendaItem existing, final RuleAgendaItem adding){
    if (existing == adding) {
        return 0;
    }
    final int s1 = existing.getSalience();
    final int s2 = adding.getSalience();
    if (s1 != s2) {
        return s1 > s2 ? 1 : -1;
    }
    Rule r1 = existing.getRule();
    Rule r2 = adding.getRule();
    if (r1.getLoadOrder() == r2.getLoadOrder()) {
        return adding.getTerminalNode().getId() - existing.getTerminalNode().getId();
    }
    return r2.getLoadOrder() - r1.getLoadOrder();
}",java:S1124,6
"public String toString(){
    return ""<==[ActivationCancelled("" + getActivation().getActivationNumber() + ""): rule="" + getActivation().getRule().getName() + ""; tuple="" + getActivation().getTuple() + ""]"";
}",java:S1161,11
"public String toString(){
    return ""[AfterActivationFired("" + getActivation().getActivationNumber() + ""): rule="" + getActivation().getRule().getName() + ""; tuple="" + getActivation().getTuple() + ""]"";
}",java:S1161,11
"public String toString(){
    return ""<==[AgendaGroupPoppedEvent("" + getAgendaGroup().getName() + ""]"";
}",java:S1161,11
"public String toString(){
    return "">==[AgendaGroupPushedEvent("" + getAgendaGroup().getName() + ""]"";
}",java:S1161,11
"public String toString(){
    return ""[BeforeActivationFired("" + getActivation().getActivationNumber() + ""): rule="" + getActivation().getRule().getName() + ""; tuple="" + getActivation().getTuple() + ""]"";
}",java:S1161,11
"public void afterNodeLeft(ProcessNodeLeftEvent event){
}",java:S1186,16
"public void afterNodeTriggered(ProcessNodeTriggeredEvent event){
}",java:S1186,16
"public void afterProcessCompleted(ProcessCompletedEvent event){
}",java:S1186,16
"public void afterProcessStarted(ProcessStartedEvent event){
}",java:S1186,16
"public void afterVariableChanged(ProcessVariableChangedEvent event){
}",java:S1186,16
"public void beforeNodeLeft(ProcessNodeLeftEvent event){
}",java:S1186,16
"public void beforeNodeTriggered(ProcessNodeTriggeredEvent event){
}",java:S1186,16
"public void beforeProcessCompleted(ProcessCompletedEvent event){
}",java:S1186,16
"public void beforeProcessStarted(ProcessStartedEvent event){
}",java:S1186,16
"public void beforeVariableChanged(ProcessVariableChangedEvent event){
}",java:S1186,16
"public String toString(){
    return ""==>[RuleFlowGroupActivated(name="" + getRuleFlowGroup().getName() + ""; size="" + getRuleFlowGroup().size() + "")]"";
}",java:S1161,11
"public String toString(){
    return ""==>[RuleFlowGroupDeactivated(name="" + getRuleFlowGroup().getName() + ""; size="" + getRuleFlowGroup().size() + "")]"";
}",java:S1161,11
"public void kBaseInternal_removePackage(InternalKnowledgePackage pkg, Collection<InternalWorkingMemory> workingMemories){
    final Set<String> referencedGlobals = new HashSet<>();
    for (InternalKnowledgePackage pkgref : this.pkgs.values()) {
        if (pkgref != pkg) {
            referencedGlobals.addAll(pkgref.getGlobals().keySet());
        }
    }
    for (String globalName : pkg.getGlobals().keySet()) {
        if (!referencedGlobals.contains(globalName)) {
            this.globals.remove(globalName);
        }
    }
    for (String processName : new ArrayList<>(pkg.getRuleFlows().keySet())) {
        removeProcess(processName);
    }
    this.pkgs.remove(pkg.getName());
    pkg.getDialectRuntimeRegistry().onRemove();
    pkg.clear();
}",java:S1172,13
"public void kBaseInternal_removePackage(InternalKnowledgePackage pkg, Collection<InternalWorkingMemory> workingMemories){
    final Set<String> referencedGlobals = new HashSet<>();
    for (InternalKnowledgePackage pkgref : this.pkgs.values()) {
        if (pkgref != pkg) {
            referencedGlobals.addAll(pkgref.getGlobals().keySet());
        }
    }
    for (String globalName : pkg.getGlobals().keySet()) {
        if (!referencedGlobals.contains(globalName)) {
            this.globals.remove(globalName);
        }
    }
    for (String processName : new ArrayList<>(pkg.getRuleFlows().keySet())) {
        removeProcess(processName);
    }
    this.pkgs.remove(pkg.getName());
    pkg.getDialectRuntimeRegistry().onRemove();
    pkg.clear();
}",java:S100,0
"public void kBaseInternal_lock(){
    this.lock.writeLock().lock();
}",java:S100,0
"public void kBaseInternal_unlock(){
    this.lock.writeLock().unlock();
}",java:S100,0
"public ReentrantReadWriteLock kBaseInternal_getLock(){
    return lock;
}",java:S100,0
"public void kBaseInternal_writeLock(){
    this.lock.writeLock().lock();
}",java:S100,0
"public boolean kBaseInternal_tryWriteLock(){
    return this.lock.writeLock().tryLock();
}",java:S100,0
"public void kBaseInternal_addPackages(Collection<InternalKnowledgePackage> clonedPkgs, Collection<InternalWorkingMemory> workingMemories){
    for (InternalKnowledgePackage newPkg : clonedPkgs) {
        newPkg.checkValidity();
        newPkg.mergeTraitRegistry(this);
        InternalKnowledgePackage pkg = this.pkgs.get(newPkg.getName());
        if (pkg == null) {
            pkg = CoreComponentFactory.get().createKnowledgePackage(newPkg.getName());
            pkg.setClassFieldAccessorCache(this.classFieldAccessorCache);
            pkgs.put(pkg.getName(), pkg);
        }
        pkg.getDialectRuntimeRegistry().merge(newPkg.getDialectRuntimeRegistry(), this.rootClassLoader, true);
    }
    processAllTypesDeclaration(clonedPkgs);
    for (InternalKnowledgePackage newPkg : clonedPkgs) {
        JavaDialectRuntimeData runtime = ((JavaDialectRuntimeData) newPkg.getDialectRuntimeRegistry().getDialectData(""java""));
        for (Function function : newPkg.getFunctions().values()) {
            String functionClassName = function.getClassName();
            try {
                registerFunctionClassAndInnerClasses(functionClassName, runtime, this::registerAndLoadTypeDefinition);
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(""Unable to compile function '"" + function.getName() + ""'"", e);
            }
        }
    }
    for (InternalKnowledgePackage newPkg : clonedPkgs) {
        InternalKnowledgePackage pkg = this.pkgs.get(newPkg.getName());
        if (newPkg.getFunctions() != null) {
            for (Map.Entry<String, Function> entry : newPkg.getFunctions().entrySet()) {
                pkg.addFunction(entry.getValue());
            }
        }
        pkg.getDialectRuntimeRegistry().onBeforeExecute();
        pkg.mergeStore(newPkg);
    }
    for (InternalKnowledgePackage newPkg : clonedPkgs) {
        InternalKnowledgePackage pkg = this.pkgs.get(newPkg.getName());
        mergePackage(pkg, newPkg, workingMemories);
        for (WindowDeclaration window : newPkg.getWindowDeclarations().values()) {
            this.reteooBuilder.addNamedWindow(window, workingMemories);
        }
        for (String entryPointId : newPkg.getEntryPointIds()) {
            this.reteooBuilder.addEntryPoint(entryPointId, workingMemories);
        }
        kBaseInternal_addRules(newPkg.getRules(), workingMemories);
        if (newPkg.getRuleFlows() != null) {
            final Map<String, Process> flows = newPkg.getRuleFlows();
            for (Process process : flows.values()) {
                kBaseInternal_addProcess(process);
            }
        }
        if (!newPkg.getResourceTypePackages().isEmpty()) {
            KieWeavers weavers = KieService.load(KieWeavers.class);
            for (ResourceTypePackage rtkKpg : newPkg.getResourceTypePackages().values()) {
                weavers.weave(newPkg, rtkKpg);
            }
        }
        ruleUnitDescriptionRegistry.add(newPkg.getRuleUnitDescriptionLoader());
    }
    if (ruleBaseConfig.isParallelEvaluation()) {
        setupParallelEvaluation();
    }
}",java:S3776,39
"public void kBaseInternal_addPackages(Collection<InternalKnowledgePackage> clonedPkgs, Collection<InternalWorkingMemory> workingMemories){
    for (InternalKnowledgePackage newPkg : clonedPkgs) {
        newPkg.checkValidity();
        newPkg.mergeTraitRegistry(this);
        InternalKnowledgePackage pkg = this.pkgs.get(newPkg.getName());
        if (pkg == null) {
            pkg = CoreComponentFactory.get().createKnowledgePackage(newPkg.getName());
            pkg.setClassFieldAccessorCache(this.classFieldAccessorCache);
            pkgs.put(pkg.getName(), pkg);
        }
        pkg.getDialectRuntimeRegistry().merge(newPkg.getDialectRuntimeRegistry(), this.rootClassLoader, true);
    }
    processAllTypesDeclaration(clonedPkgs);
    for (InternalKnowledgePackage newPkg : clonedPkgs) {
        JavaDialectRuntimeData runtime = ((JavaDialectRuntimeData) newPkg.getDialectRuntimeRegistry().getDialectData(""java""));
        for (Function function : newPkg.getFunctions().values()) {
            String functionClassName = function.getClassName();
            try {
                registerFunctionClassAndInnerClasses(functionClassName, runtime, this::registerAndLoadTypeDefinition);
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(""Unable to compile function '"" + function.getName() + ""'"", e);
            }
        }
    }
    for (InternalKnowledgePackage newPkg : clonedPkgs) {
        InternalKnowledgePackage pkg = this.pkgs.get(newPkg.getName());
        if (newPkg.getFunctions() != null) {
            for (Map.Entry<String, Function> entry : newPkg.getFunctions().entrySet()) {
                pkg.addFunction(entry.getValue());
            }
        }
        pkg.getDialectRuntimeRegistry().onBeforeExecute();
        pkg.mergeStore(newPkg);
    }
    for (InternalKnowledgePackage newPkg : clonedPkgs) {
        InternalKnowledgePackage pkg = this.pkgs.get(newPkg.getName());
        mergePackage(pkg, newPkg, workingMemories);
        for (WindowDeclaration window : newPkg.getWindowDeclarations().values()) {
            this.reteooBuilder.addNamedWindow(window, workingMemories);
        }
        for (String entryPointId : newPkg.getEntryPointIds()) {
            this.reteooBuilder.addEntryPoint(entryPointId, workingMemories);
        }
        kBaseInternal_addRules(newPkg.getRules(), workingMemories);
        if (newPkg.getRuleFlows() != null) {
            final Map<String, Process> flows = newPkg.getRuleFlows();
            for (Process process : flows.values()) {
                kBaseInternal_addProcess(process);
            }
        }
        if (!newPkg.getResourceTypePackages().isEmpty()) {
            KieWeavers weavers = KieService.load(KieWeavers.class);
            for (ResourceTypePackage rtkKpg : newPkg.getResourceTypePackages().values()) {
                weavers.weave(newPkg, rtkKpg);
            }
        }
        ruleUnitDescriptionRegistry.add(newPkg.getRuleUnitDescriptionLoader());
    }
    if (ruleBaseConfig.isParallelEvaluation()) {
        setupParallelEvaluation();
    }
}",java:S100,0
"private void mergeTypeDeclarations(TypeDeclaration existingDecl, TypeDeclaration newDecl){
    if (!Objects.equals(existingDecl.getFormat(), newDecl.getFormat()) || !Objects.equals(existingDecl.getObjectType(), newDecl.getObjectType()) || !Objects.equals(existingDecl.getTypeClassName(), newDecl.getTypeClassName()) || !Objects.equals(existingDecl.getTypeName(), newDecl.getTypeName())) {
        throw new RuntimeException(""Unable to merge Type Declaration for class '"" + existingDecl.getTypeName() + ""'"");
    }
    existingDecl.setDurationAttribute(mergeLeft(existingDecl.getTypeName(), ""Unable to merge @duration attribute for type declaration of class:"", existingDecl.getDurationAttribute(), newDecl.getDurationAttribute(), false));
    existingDecl.setDynamic(mergeLeft(existingDecl.getTypeName(), ""Unable to merge @propertyChangeSupport  (a.k.a. dynamic) attribute for type declaration of class:"", existingDecl.isDynamic(), newDecl.isDynamic(), false));
    existingDecl.setPropertyReactive(mergeLeft(existingDecl.getTypeName(), ""Unable to merge @propertyReactive attribute for type declaration of class:"", existingDecl.isPropertyReactive(), newDecl.isPropertyReactive(), false));
    if (newDecl.getExpirationPolicy() == Policy.TIME_HARD) {
        if (existingDecl.getExpirationPolicy() == Policy.TIME_SOFT || newDecl.getExpirationOffset() > existingDecl.getExpirationOffset()) {
            existingDecl.setExpirationOffset(newDecl.getExpirationOffset());
            existingDecl.setExpirationType(Policy.TIME_HARD);
        }
    } else {
        if (existingDecl.getExpirationPolicy() == Policy.TIME_SOFT && newDecl.getExpirationOffset() > existingDecl.getExpirationOffset()) {
            existingDecl.setExpirationOffset(newDecl.getExpirationOffset());
        }
    }
    if (newDecl.getNature().equals(TypeDeclaration.Nature.DEFINITION) && newDecl.isNovel()) {
        existingDecl.setNovel(mergeLeft(existingDecl.getTypeName(), ""Unable to merge @novel attribute for type declaration of class:"", existingDecl.isNovel(), newDecl.isNovel(), false));
    }
    if (newDecl.getNature().equals(TypeDeclaration.Nature.DEFINITION) || existingDecl.getResource() == null) {
        existingDecl.setResource(mergeLeft(existingDecl.getTypeName(), ""Unable to merge resource attribute for type declaration of class:"", existingDecl.getResource(), newDecl.getResource(), true));
    }
    existingDecl.setRole(mergeLeft(existingDecl.getTypeName(), ""Unable to merge @role attribute for type declaration of class:"", isSet(existingDecl.getSetMask(), TypeDeclaration.ROLE_BIT) && newDecl.getRole() != Role.Type.FACT ? existingDecl.getRole() : null, newDecl.getRole(), false));
    existingDecl.setTimestampAttribute(mergeLeft(existingDecl.getTypeName(), ""Unable to merge @timestamp attribute for type declaration of class:"", existingDecl.getTimestampAttribute(), newDecl.getTimestampAttribute(), false));
    existingDecl.setTypesafe(mergeLeft(existingDecl.getTypeName(), ""Unable to merge @typesafe attribute for type declaration of class:"", existingDecl.isTypesafe(), newDecl.isTypesafe(), false));
}",java:S3776,39
"private void mergePackage(InternalKnowledgePackage pkg, InternalKnowledgePackage newPkg, Collection<InternalWorkingMemory> workingMemories){
    final Map<String, ImportDeclaration> imports = pkg.getImports();
    imports.putAll(newPkg.getImports());
    for (String staticImport : newPkg.getStaticImports()) {
        pkg.addStaticImport(staticImport);
    }
    if (newPkg.getGlobals() != null && !newPkg.getGlobals().isEmpty()) {
        Map<String, Type> pkgGlobals = pkg.getGlobals();
        for (final Map.Entry<String, Type> entry : newPkg.getGlobals().entrySet()) {
            final String identifier = entry.getKey();
            final Type type = entry.getValue();
            if (pkgGlobals.containsKey(identifier) && !pkgGlobals.get(identifier).equals(type)) {
                throw new RuntimeException(pkg.getName() + "" cannot be integrated"");
            } else {
                pkg.addGlobal(identifier, type);
                addGlobal(identifier, type);
            }
        }
    }
    if (newPkg.getEntryPointIds() != null) {
        for (String ep : newPkg.getEntryPointIds()) {
            pkg.addEntryPointId(ep);
        }
    }
    if (newPkg.getTypeDeclarations() != null) {
        for (TypeDeclaration type : newPkg.getTypeDeclarations().values()) {
            if (!pkg.getTypeDeclarations().containsKey(type.getTypeName())) {
                pkg.addTypeDeclaration(type);
            }
        }
    }
    if (newPkg.getWindowDeclarations() != null) {
        for (WindowDeclaration window : newPkg.getWindowDeclarations().values()) {
            if (!pkg.getWindowDeclarations().containsKey(window.getName()) || pkg.getWindowDeclarations().get(window.getName()).equals(window)) {
                pkg.addWindowDeclaration(window);
            } else {
                throw new RuntimeException(""Unable to merge two conflicting window declarations for window named: "" + window.getName());
            }
        }
    }
    List<RuleImpl> rulesToBeRemoved = new ArrayList<>();
    for (Rule newRule : newPkg.getRules()) {
        RuleImpl oldRule = pkg.getRule(newRule.getName());
        if (oldRule != null) {
            rulesToBeRemoved.add(oldRule);
        }
    }
    if (!rulesToBeRemoved.isEmpty()) {
        kBaseInternal_removeRules(rulesToBeRemoved, workingMemories);
    }
    for (Rule newRule : newPkg.getRules()) {
        pkg.addRule((RuleImpl) newRule);
    }
    if (newPkg.getRuleFlows() != null) {
        for (Process flow : newPkg.getRuleFlows().values()) {
            pkg.addProcess(flow);
        }
    }
    if (!newPkg.getResourceTypePackages().isEmpty()) {
        KieWeavers weavers = KieService.load(KieWeavers.class);
        if (weavers == null) {
            throw new IllegalStateException(""Unable to find KieWeavers implementation"");
        }
        for (ResourceTypePackage rtkKpg : newPkg.getResourceTypePackages().values()) {
            weavers.merge(pkg, rtkKpg);
        }
    }
}",java:S3776,39
"public void kBaseInternal_addRules(Collection<? extends Rule> rules, Collection<InternalWorkingMemory> wms){
    List<TerminalNode> terminalNodes = new ArrayList<>(rules.size() * 2);
    for (Rule r : rules) {
        RuleImpl rule = (RuleImpl) r;
        checkParallelEvaluation(rule);
        this.hasMultipleAgendaGroups |= !rule.isMainAgendaGroup();
        terminalNodes.addAll(this.reteooBuilder.addRule(rule, wms));
    }
    if (PhreakBuilder.isEagerSegmentCreation() && !hasSegmentPrototypes()) {
        for (TerminalNode tn : terminalNodes) {
            tn.getPathMemSpec();
            BuildtimeSegmentUtilities.createPathProtoMemories(tn, null, this);
        }
        Set<Integer> visited = new HashSet<>();
        for (TerminalNode tn : terminalNodes) {
            wms.stream().forEach(wm -> {
                Add.insertLiaFacts(tn.getPathNodes()[0], wm, visited, true);
                Add.insertFacts(tn, wm, visited, true);
            });
        }
    }
}",java:S100,0
"public void kBaseInternal_removeRule(InternalKnowledgePackage pkg, RuleImpl rule, Collection<InternalWorkingMemory> workingMemories){
    this.reteooBuilder.removeRules(Collections.singletonList(rule), workingMemories);
    pkg.removeRule(rule);
    addReloadDialectDatas(pkg.getDialectRuntimeRegistry());
}",java:S100,0
"public void kBaseInternal_removeRules(Collection<? extends Rule> rules, Collection<InternalWorkingMemory> workingMemories){
    this.reteooBuilder.removeRules(rules, workingMemories);
}",java:S100,0
"public void kBaseInternal_removeFunction(InternalKnowledgePackage pkg, String functionName){
    Function function = pkg.getFunctions().get(functionName);
    if (function == null) {
        throw new IllegalArgumentException(""function name '"" + functionName + ""' does not exist in the Package '"" + pkg.getName() + ""'."");
    }
    pkg.removeFunction(functionName);
    if (rootClassLoader instanceof ProjectClassLoader) {
        ((ProjectClassLoader) rootClassLoader).undefineClass(function.getClassName());
    }
    addReloadDialectDatas(pkg.getDialectRuntimeRegistry());
}",java:S100,0
"public void kBaseInternal_addProcess(Process process){
    this.processes.put(process.getId(), process);
}",java:S100,0
"public void kBaseInternal_removeProcess(String id, Process process){
    this.processes.remove(id);
    this.pkgs.get(process.getPackageName()).removeRuleFlow(id);
}",java:S100,0
"private GenericKieSessionMonitoringImpl getKnowledgeSessionBean(CBSKey cbsKey, KieRuntimeEventManager ksession){
    if (mbeansRefs.get(cbsKey) != null) {
        return (GenericKieSessionMonitoringImpl) mbeansRefs.get(cbsKey);
    } else {
        if (ksession instanceof StatelessKieSession) {
            synchronized (mbeansRefs) {
                if (mbeansRefs.get(cbsKey) != null) {
                    return (GenericKieSessionMonitoringImpl) mbeansRefs.get(cbsKey);
                } else {
                    try {
                        GenericKieSessionMonitoringImpl mbean = RuntimeComponentFactory.get().createStatelessSessionMonitor(cbsKey);
                        registerMBean(cbsKey, mbean, mbean.getName());
                        mbeansRefs.put(cbsKey, mbean);
                        return mbean;
                    } catch (Exception e) {
                        logger.error(""Unable to instantiate and register StatelessKieSessionMonitoringMBean"");
                    }
                    return null;
                }
            }
        } else {
            synchronized (mbeansRefs) {
                if (mbeansRefs.get(cbsKey) != null) {
                    return (GenericKieSessionMonitoringImpl) mbeansRefs.get(cbsKey);
                } else {
                    try {
                        GenericKieSessionMonitoringImpl mbean = RuntimeComponentFactory.get().createStatefulSessionMonitor(cbsKey);
                        registerMBean(cbsKey, mbean, mbean.getName());
                        mbeansRefs.put(cbsKey, mbean);
                        return mbean;
                    } catch (Exception e) {
                        logger.error(""Unable to instantiate and register (stateful) KieSessionMonitoringMBean"");
                    }
                    return null;
                }
            }
        }
    }
}",java:S3776,39
"public void agendaGroupPopped(org.kie.api.event.rule.AgendaGroupPoppedEvent event){
}",java:S1186,16
"public void agendaGroupPushed(org.kie.api.event.rule.AgendaGroupPushedEvent event){
}",java:S1186,16
"public void beforeRuleFlowGroupActivated(org.kie.api.event.rule.RuleFlowGroupActivatedEvent event){
}",java:S1186,16
"public void afterRuleFlowGroupActivated(org.kie.api.event.rule.RuleFlowGroupActivatedEvent event){
}",java:S1186,16
"public void beforeRuleFlowGroupDeactivated(org.kie.api.event.rule.RuleFlowGroupDeactivatedEvent event){
}",java:S1186,16
"public void afterRuleFlowGroupDeactivated(org.kie.api.event.rule.RuleFlowGroupDeactivatedEvent event){
}",java:S1186,16
"public void reset(){
    super.reset();
    this.processNodesTriggered.set(0);
}",java:S1161,11
"private String getBinaryName(){
    return BINARY_PACKAGE_NAME + ""/"" + generatedClassSimpleName + "".class"";
}",java:S1144,10
"private static BitMask calculatePatternMask(String modifiedTypeName, Collection<String> listenedProperties, List<String> accessibleProperties, boolean isPositive){
    if (listenedProperties.isEmpty()) {
        return EmptyBitMask.get();
    }
    BitMask mask = getEmptyPropertyReactiveMask(accessibleProperties.size());
    if (listenedProperties.contains(TraitConstants.TRAITSET_FIELD_NAME)) {
        if (isPositive && listenedProperties.contains(TraitConstants.TRAITSET_FIELD_NAME)) {
            mask = mask.set(TRAITABLE_BIT);
        }
    }
    for (String propertyName : listenedProperties) {
        if (propertyName.equals(isPositive ? ""*"" : ""!*"")) {
            return isPositive ? AllSetBitMask.get() : allSetButTraitBitMask();
        }
        if (propertyName.startsWith(""!"") ^ !isPositive) {
            continue;
        }
        if (!isPositive) {
            propertyName = propertyName.substring(1);
        }
        mask = setPropertyOnMask(modifiedTypeName, mask, accessibleProperties, propertyName);
    }
    return mask;
}",java:S3776,39
"public String toString(){
    return super.toString() + "" processNodesTriggered="" + processNodesTriggered.get();
}",java:S1161,11
"private static long processBetaNode(BetaNode betaNode, SegmentPrototype smem, List<MemoryPrototype> memories, List<LeftTupleNode> nodes, long nodePosMask, long allLinkedTestMask, boolean updateNodeBit, TerminalNode removingTn, InternalRuleBase rbase){
    RightInputAdapterNode riaNode = null;
    if (betaNode.isRightInputIsRiaNode()) {
        riaNode = (RightInputAdapterNode) betaNode.getRightInput();
        SegmentPrototype[] smems = createLeftTupleNodeProtoMemories(riaNode, removingTn, rbase);
        setSegments(riaNode, smems);
        if (updateNodeBit && canBeDisabled(betaNode) && riaNode.getPathMemSpec().allLinkedTestMask() > 0) {
            allLinkedTestMask = allLinkedTestMask | nodePosMask;
        }
    } else if (updateNodeBit && canBeDisabled(betaNode)) {
        allLinkedTestMask = allLinkedTestMask | nodePosMask;
    }
    if (NodeTypeEnums.NotNode == betaNode.getType()) {
        smem.linkNode(nodePosMask);
    }
    BetaMemoryPrototype bm = new BetaMemoryPrototype(nodePosMask, riaNode);
    if (NodeTypeEnums.AccumulateNode == betaNode.getType()) {
        AccumulateMemoryPrototype am = new AccumulateMemoryPrototype(bm);
        memories.add(am);
    } else {
        memories.add(bm);
    }
    nodes.add(betaNode);
    return allLinkedTestMask;
}",java:S107,1
"private static void processLeftTuples(LeftTupleNode node, boolean insert, TerminalNode tn, Collection<InternalWorkingMemory> wms){
    for (InternalWorkingMemory wm : wms) {
        if (node instanceof AlphaTerminalNode) {
            processLeftTuplesOnLian(wm, insert, tn, (LeftInputAdapterNode) node);
            return;
        }
        Memory memory = wm.getNodeMemories().peekNodeMemory(node);
        if (memory == null || memory.getSegmentMemory() == null) {
            return;
        }
        Set<LeftTupleNode> visited = new HashSet<>();
        while (NodeTypeEnums.LeftInputAdapterNode != node.getType()) {
            if (!visited.add(node)) {
                return;
            }
            if (NodeTypeEnums.isBetaNode(node)) {
                BetaMemory bm;
                if (NodeTypeEnums.AccumulateNode == node.getType()) {
                    AccumulateMemory am = (AccumulateMemory) memory;
                    bm = am.getBetaMemory();
                    FastIterator it = bm.getLeftTupleMemory().fullFastIterator();
                    Tuple lt = BetaNode.getFirstTuple(bm.getLeftTupleMemory(), it);
                    for (; lt != null; lt = (LeftTuple) it.next(lt)) {
                        AccumulateContext accctx = (AccumulateContext) lt.getContextObject();
                        visitChild((LeftTuple) accctx.getResultLeftTuple(), insert, wm, tn);
                    }
                } else if (NodeTypeEnums.ExistsNode == node.getType() && !((BetaNode) node).isRightInputIsRiaNode()) {
                    bm = (BetaMemory) wm.getNodeMemories().peekNodeMemory(node);
                    if (bm != null) {
                        FastIterator it = bm.getRightTupleMemory().fullFastIterator();
                        RightTuple rt = (RightTuple) BetaNode.getFirstTuple(bm.getRightTupleMemory(), it);
                        for (; rt != null; rt = (RightTuple) it.next(rt)) {
                            for (LeftTuple lt = rt.getBlocked(); lt != null; lt = lt.getBlockedNext()) {
                                visitChild(wm, insert, tn, it, lt);
                            }
                        }
                    }
                } else {
                    bm = (BetaMemory) wm.getNodeMemories().peekNodeMemory(node);
                    if (bm != null) {
                        FastIterator it = bm.getLeftTupleMemory().fullFastIterator();
                        Tuple lt = BetaNode.getFirstTuple(bm.getLeftTupleMemory(), it);
                        visitChild(wm, insert, tn, it, lt);
                    }
                }
                return;
            } else if (NodeTypeEnums.FromNode == node.getType()) {
                FromMemory fm = (FromMemory) wm.getNodeMemories().peekNodeMemory(node);
                if (fm != null) {
                    TupleMemory ltm = fm.getBetaMemory().getLeftTupleMemory();
                    FastIterator it = ltm.fullFastIterator();
                    for (LeftTuple lt = (LeftTuple) ltm.getFirst(null); lt != null; lt = (LeftTuple) it.next(lt)) {
                        visitChild(lt, insert, wm, tn);
                    }
                }
                return;
            }
            node = node.getLeftTupleSource();
        }
        processLeftTuplesOnLian(wm, insert, tn, (LeftInputAdapterNode) node);
    }
}",java:S3776,39
"private static void visitChild(LeftTuple lt, boolean insert, InternalWorkingMemory wm, TerminalNode tn){
    LeftTuple prevLt = null;
    LeftTupleSinkNode sink = (LeftTupleSinkNode) lt.getTupleSink();
    for (; sink != null; sink = sink.getNextLeftTupleSinkNode()) {
        if (lt != null) {
            if (isAssociatedWith(lt.getTupleSink(), tn)) {
                if (lt.getTupleSink().getAssociatedTerminalsSize() > 1) {
                    if (lt.getFirstChild() != null) {
                        for (LeftTuple child = lt.getFirstChild(); child != null; child = child.getHandleNext()) {
                            visitChild(child, insert, wm, tn);
                        }
                    } else if (lt.getTupleSink().getType() == NodeTypeEnums.RightInputAdapterNode) {
                        insertPeerRightTuple(lt, wm, tn, insert);
                    }
                } else if (!insert) {
                    iterateLeftTuple(lt, wm);
                    LeftTuple lt2 = null;
                    for (LeftTuple peerLt = lt.getPeer(); peerLt != null && isAssociatedWith(peerLt.getTupleSink(), tn) && peerLt.getTupleSink().getAssociatedTerminalsSize() == 1; peerLt = peerLt.getPeer()) {
                        iterateLeftTuple(peerLt, wm);
                        lt2 = peerLt;
                    }
                    deleteLeftTuple(lt, lt2, prevLt);
                    break;
                }
            }
            prevLt = lt;
            lt = lt.getPeer();
        } else {
            prevLt = insertPeerLeftTuple(prevLt, sink, wm, insert);
        }
    }
}",java:S3776,39
"private static void iterateLeftTuple(LeftTuple lt, InternalWorkingMemory wm){
    if (NodeTypeEnums.isTerminalNode(lt.getTupleSink())) {
        PathMemory pmem = (PathMemory) wm.getNodeMemories().peekNodeMemory(lt.getTupleSink());
        if (pmem != null) {
            PhreakRuleTerminalNode.doLeftDelete(pmem.getActualActivationsManager(wm), pmem.getRuleAgendaItem().getRuleExecutor(), lt);
        }
    } else {
        if (lt.getContextObject() instanceof AccumulateContext) {
            LeftTuple resultLt = (LeftTuple) ((AccumulateContext) lt.getContextObject()).getResultLeftTuple();
            if (resultLt != null) {
                iterateLeftTuple(resultLt, wm);
            }
        }
        for (LeftTuple child = lt.getFirstChild(); child != null; child = child.getHandleNext()) {
            for (LeftTuple peer = child; peer != null; peer = peer.getPeer()) {
                if (peer.getPeer() == null) {
                    iterateLeftTuple(peer, wm);
                }
            }
        }
    }
}",java:S3776,39
" static void deleteLeftTuple(LeftTuple removingLt, LeftTuple removingLt2, LeftTuple prevLt){
    boolean isFirstLt = prevLt == null;
    LeftTuple nextPeerLt = (removingLt2 == null) ? removingLt.getPeer() : removingLt2.getPeer();
    if (!isFirstLt) {
        prevLt.setPeer(nextPeerLt);
    } else {
        if (nextPeerLt == null) {
            removingLt.unlinkFromLeftParent();
            removingLt.unlinkFromRightParent();
            return;
        }
        InternalFactHandle fh = (InternalFactHandle) removingLt.getFactHandle();
        LeftTuple leftPrevious = removingLt.getHandlePrevious();
        LeftTuple leftNext = removingLt.getHandleNext();
        LeftTuple rightPrevious = removingLt.getRightParentPrevious();
        LeftTuple rightNext = removingLt.getRightParentNext();
        LeftTuple leftParent = removingLt.getLeftParent();
        RightTuple rightParent = removingLt.getRightParent();
        nextPeerLt.setFactHandle(removingLt.getFactHandle());
        if (leftPrevious != null) {
            nextPeerLt.setHandlePrevious(leftPrevious);
            leftPrevious.setHandleNext(nextPeerLt);
        }
        if (leftNext != null) {
            nextPeerLt.setHandleNext(leftNext);
            leftNext.setHandlePrevious(nextPeerLt);
        }
        if (rightPrevious != null) {
            nextPeerLt.setRightParentPrevious(rightPrevious);
            rightPrevious.setRightParentNext(nextPeerLt);
        }
        if (rightNext != null) {
            nextPeerLt.setRightParentNext(rightNext);
            rightNext.setRightParentPrevious(nextPeerLt);
        }
        if (leftParent != null) {
            nextPeerLt.setLeftParent(leftParent);
            if (leftParent.getFirstChild() == removingLt) {
                leftParent.setFirstChild(nextPeerLt);
            }
            if (leftParent.getLastChild() == removingLt) {
                leftParent.setLastChild(nextPeerLt);
            }
        } else {
            fh.removeLeftTuple(removingLt);
            if (leftPrevious == null) {
                fh.addFirstLeftTuple(nextPeerLt);
            }
        }
        if (rightParent != null) {
            nextPeerLt.setRightParent(rightParent);
            if (rightParent.getFirstChild() == removingLt) {
                rightParent.setFirstChild(nextPeerLt);
            }
            if (rightParent.getLastChild() == removingLt) {
                rightParent.setLastChild(nextPeerLt);
            }
        }
    }
}",java:S3776,39
"private static void updatePaths(SegmentPrototype proto, Collection<InternalWorkingMemory> wms, PathEndNode endNode, SegmentPrototype[] newList){
    PathMemSpec spec = endNode.getPathMemSpec();
    spec.update(BuildtimeSegmentUtilities.getPathAllLinkedMaskTest(endNode.getSegmentPrototypes(), endNode), endNode.getSegmentPrototypes().length);
    for (WorkingMemory wm : wms) {
        PathMemory pmem = (PathMemory) wm.getNodeMemories().peekNodeMemory(endNode);
        if (pmem != null) {
            pmem.setAllLinkedMaskTest(spec.allLinkedTestMask());
            SegmentMemory[] newSmems = new SegmentMemory[newList.length];
            for (int i = 0; i < newList.length; i++) {
                SegmentPrototype smproto = newList[i];
                if (!isInsideSubnetwork(endNode, smproto)) {
                    continue;
                }
                Memory mem = wm.getNodeMemories().peekNodeMemory(smproto.getRootNode());
                if (mem != null && mem.getSegmentMemory() != null) {
                    SegmentMemory sm = mem.getSegmentMemory();
                    newSmems[i] = sm;
                    if (i > proto.getPos()) {
                        long currentLinkedNodeMask = sm.getLinkedNodeMask();
                        smproto.shallowUpdateSegmentMemory(sm);
                        sm.setLinkedNodeMask(currentLinkedNodeMask);
                    }
                    if (i >= proto.getPos()) {
                        if (sm.getAllLinkedMaskTest() > 0 && sm.isSegmentLinked()) {
                            pmem.setLinkedSegmentMask(pmem.getLinkedSegmentMask() | sm.getSegmentPosMaskBit());
                        } else {
                            pmem.setLinkedSegmentMask(pmem.getLinkedSegmentMask() & ~sm.getSegmentPosMaskBit());
                        }
                    }
                } else {
                    pmem.setLinkedSegmentMask(pmem.getLinkedSegmentMask() & ~(1 << i));
                }
            }
            pmem.setSegmentMemories(newSmems);
        }
    }
}",java:S3776,39
"private static void notifyImpactedSegments(Collection<InternalWorkingMemory> wms, SegmentPrototype proto1, Set<SegmentMemoryPair> smemsToNotify){
    for (InternalWorkingMemory wm : wms) {
        Memory mem1 = wm.getNodeMemories().peekNodeMemory(proto1.getRootNode());
        if (mem1 != null && mem1.getSegmentMemory() != null) {
            notifyImpactedSegments(mem1.getSegmentMemory(), wm, smemsToNotify);
        }
    }
}",java:S3398,35
"private static Set<SegmentMemory> handleExistingPaths(TerminalNode tn, Map<PathMemory, SegmentMemory[]> prevSmemsLookup, List<PathMemory> pmems, InternalWorkingMemory wm, ExistingPathStrategy strategy){
    Set<SegmentMemory> smemsToNotify = new HashSet<>();
    Set<SegmentMemory> visitedSegments = new HashSet<>();
    Set<LeftTupleNode> visitedNodes = new HashSet<>();
    Map<LeftTupleNode, SegmentMemory> nodeToSegmentMap = new HashMap<>();
    for (PathMemory pmem : pmems) {
        LeftTupleNode[] nodes = pmem.getPathEndNode().getPathNodes();
        SegmentMemory[] prevSmems = prevSmemsLookup.get(pmem);
        SegmentMemory[] smems = strategy.getSegmenMemories(pmem);
        LeftTupleNode node;
        int prevSmemIndex = 0;
        int smemIndex = 0;
        int smemSplitAdjustAmount = 0;
        int nodeIndex = 0;
        int nodeTypesInSegment = 0;
        smems[smemIndex] = prevSmems[prevSmemIndex];
        do {
            node = nodes[nodeIndex++];
            LeftTupleSource parentNode = node.getLeftTupleSource();
            nodeTypesInSegment = BuildtimeSegmentUtilities.updateNodeTypesMask(parentNode, nodeTypesInSegment);
            if (isSplit(parentNode)) {
                smemIndex = strategy.incSmemIndex1(smemIndex);
                prevSmemIndex = strategy.incPrevSmemIndex1(prevSmemIndex);
                if (isSplit(parentNode, tn)) {
                    smemIndex = strategy.incSmemIndex2(smemIndex);
                    prevSmemIndex = strategy.incPrevSmemIndex2(prevSmemIndex);
                    smems[smemIndex] = prevSmems[prevSmemIndex];
                    if (smems[smemIndex] != null && smemSplitAdjustAmount > 0 && visitedSegments.add(smems[smemIndex])) {
                        strategy.adjustSegment(wm, smemsToNotify, smems[smemIndex], smemSplitAdjustAmount);
                    }
                } else {
                    strategy.handleSplit(pmem, prevSmems, smems, smemIndex, prevSmemIndex, parentNode, node, tn, visitedNodes, smemsToNotify, nodeToSegmentMap, wm);
                    smemSplitAdjustAmount++;
                }
                checkEagerSegmentCreation(parentNode, wm, nodeTypesInSegment);
                nodeTypesInSegment = 0;
            }
        } while (!NodeTypeEnums.isEndNode(node));
        strategy.processSegmentMemories(smems, pmem);
    }
    return smemsToNotify;
}",java:S3776,39
"private static void addNewPaths(InternalWorkingMemory wm, Set<SegmentMemory> smemsToNotify, List<PathMemory> pmems){
    Set<LeftTupleNode> visited = new HashSet<>();
    for (PathMemory pmem : pmems) {
        LeftTupleSink tipNode = pmem.getPathEndNode();
        LeftTupleNode child = tipNode;
        LeftTupleNode parent = tipNode.getLeftTupleSource();
        while (true) {
            if (visited.add(child)) {
                if (parent != null && parent.getAssociatedTerminalsSize() != 1 && child.getAssociatedTerminalsSize() == 1) {
                    Memory mem = wm.getNodeMemories().peekNodeMemory(parent);
                    if (mem != null && mem.getSegmentMemory() != null) {
                        SegmentMemory sm = mem.getSegmentMemory();
                        if (sm.getFirst() != null && sm.size() < parent.getSinkPropagator().size()) {
                            LeftTupleSink[] sinks = parent.getSinkPropagator().getSinks();
                            for (int i = sm.size(); i < sinks.length; i++) {
                                SegmentMemory childSmem = createChildSegment(wm, sinks[i]);
                                sm.add(childSmem);
                                pmem.setSegmentMemory(childSmem.getPos(), childSmem);
                                smemsToNotify.add(childSmem);
                            }
                        }
                        correctMemoryOnSplitsChanged(parent, null, wm);
                    }
                } else {
                    Memory mem = wm.getNodeMemories().peekNodeMemory(child);
                    if (mem != null) {
                        SegmentMemory sm = mem.getSegmentMemory();
                        if (sm != null && !sm.getPathMemories().contains(pmem)) {
                            RuntimeSegmentUtilities.addSegmentToPathMemory(pmem, sm);
                            sm.notifyRuleLinkSegment(wm, pmem);
                        }
                    }
                }
            } else {
                Memory mem = wm.getNodeMemories().peekNodeMemory(child);
                if (mem != null) {
                    mem.getSegmentMemory().notifyRuleLinkSegment(wm, pmem);
                }
            }
            if (parent == null) {
                break;
            }
            child = parent;
            parent = parent.getLeftTupleSource();
        }
    }
}",java:S3776,39
"private static void removeNewPaths(InternalWorkingMemory wm, List<PathMemory> pmems){
    Set<Integer> visitedNodes = new HashSet<>();
    for (PathMemory pmem : pmems) {
        LeftTupleSink tipNode = pmem.getPathEndNode();
        LeftTupleNode child = tipNode;
        LeftTupleNode parent = tipNode.getLeftTupleSource();
        while (true) {
            if (child.getAssociatedTerminalsSize() == 1 && NodeTypeEnums.isBetaNode(child)) {
                deleteRightInputData((LeftTupleSink) child, wm);
            }
            if (parent != null && parent.getAssociatedTerminalsSize() != 1 && child.getAssociatedTerminalsSize() == 1) {
                if (!visitedNodes.contains(child.getId())) {
                    Memory mem = wm.getNodeMemories().peekNodeMemory(parent);
                    if (mem != null && mem.getSegmentMemory() != null) {
                        SegmentMemory sm = mem.getSegmentMemory();
                        if (sm.getFirst() != null) {
                            SegmentMemory childSm = wm.getNodeMemories().peekNodeMemory(child).getSegmentMemory();
                            sm.remove(childSm);
                        }
                    }
                }
            } else {
                Memory mem = wm.getNodeMemories().peekNodeMemory(child);
                if (mem != null) {
                    SegmentMemory sm = mem.getSegmentMemory();
                    if (sm != null && sm.getPathMemories().contains(pmem)) {
                        mem.getSegmentMemory().removePathMemory(pmem);
                    }
                }
            }
            if (parent == null) {
                break;
            }
            visitedNodes.add(child.getId());
            child = parent;
            parent = parent.getLeftTupleSource();
        }
    }
}",java:S3776,39
"public static void flushStagedTuples(TerminalNode tn, PathMemory pmem, List<LeftTupleNode> splits, InternalWorkingMemory wm){
    if (pmem.isInitialized()) {
        RuleNetworkEvaluator.INSTANCE.evaluateNetwork(pmem, pmem.getRuleAgendaItem().getRuleExecutor(), wm);
    }
    List<Flushed> flushed = new ArrayList<>();
    for (LeftTupleNode node : splits) {
        if (!isSplit(node, tn)) {
            Memory mem = wm.getNodeMemories().peekNodeMemory(node);
            if (mem != null) {
                SegmentMemory smem = mem.getSegmentMemory();
                if (!smem.isEmpty()) {
                    for (SegmentMemory childSmem = smem.getFirst(); childSmem != null; childSmem = childSmem.getNext()) {
                        if (!childSmem.getStagedLeftTuples().isEmpty()) {
                            PathMemory childPmem = childSmem.getPathMemories().get(0);
                            flushed.add(new Flushed(childSmem, childPmem));
                            forceFlushLeftTuple(childPmem, childSmem, wm, childSmem.getStagedLeftTuples().takeAll());
                        }
                    }
                }
            }
        }
    }
    int flushCount = 1;
    while (!flushed.isEmpty() && flushCount != 0) {
        flushCount = 0;
        for (Flushed path : flushed) {
            if (!path.segmentMemory.getStagedLeftTuples().isEmpty()) {
                flushCount++;
                forceFlushLeftTuple(pmem, path.segmentMemory, wm, path.segmentMemory.getStagedLeftTuples().takeAll());
            }
        }
    }
}",java:S3776,39
"private static void insertFacts(PathEndNodes endNodes, Collection<InternalWorkingMemory> wms){
    Set<LeftTupleNode> visited = new HashSet<>();
    for (PathEndNode endNode : endNodes.subjectEndNodes) {
        LeftTupleNode[] nodes = endNode.getPathNodes();
        for (int i = 0; i < nodes.length; i++) {
            LeftTupleNode node = nodes[i];
            if (NodeTypeEnums.isBetaNode(node) && node.getAssociatedTerminalsSize() == 1) {
                if (!visited.add(node)) {
                    continue;
                }
                BetaNode bn = (BetaNode) node;
                if (!bn.isRightInputIsRiaNode()) {
                    for (InternalWorkingMemory wm : wms) {
                        PropagationContextFactory pctxFactory = RuntimeComponentFactory.get().getPropagationContextFactory();
                        final PropagationContext pctx = pctxFactory.createPropagationContext(wm.getNextPropagationIdCounter(), PropagationContext.Type.RULE_ADDITION, null, null, null);
                        bn.getRightInput().updateSink(bn, pctx, wm);
                    }
                }
            }
        }
    }
}",java:S3776,39
"private static void processLeftTuples(LeftTupleNode node, InternalWorkingMemory wm, boolean insert, Rule rule){
    if (node instanceof AlphaTerminalNode) {
        processLeftTuplesOnLian(wm, insert, rule, (LeftInputAdapterNode) node);
        return;
    }
    Memory memory = wm.getNodeMemories().peekNodeMemory(node);
    if (memory == null || memory.getSegmentMemory() == null) {
        return;
    }
    SegmentMemory sm = memory.getSegmentMemory();
    while (NodeTypeEnums.LeftInputAdapterNode != node.getType()) {
        if (NodeTypeEnums.isBetaNode(node)) {
            BetaMemory bm;
            if (NodeTypeEnums.AccumulateNode == node.getType()) {
                AccumulateMemory am = (AccumulateMemory) memory;
                bm = am.getBetaMemory();
                FastIterator it = bm.getLeftTupleMemory().fullFastIterator();
                Tuple lt = BetaNode.getFirstTuple(bm.getLeftTupleMemory(), it);
                for (; lt != null; lt = (LeftTuple) it.next(lt)) {
                    AccumulateContext accctx = (AccumulateContext) lt.getContextObject();
                    visitChild((LeftTuple) accctx.getResultLeftTuple(), insert, wm, rule);
                }
            } else if (NodeTypeEnums.ExistsNode == node.getType() && !node.isRightInputIsRiaNode()) {
                bm = (BetaMemory) wm.getNodeMemory((MemoryFactory) node);
                FastIterator it = bm.getRightTupleMemory().fullFastIterator();
                for (RightTuple rt = (RightTuple) BetaNode.getFirstTuple(bm.getRightTupleMemory(), it); rt != null; rt = (RightTuple) it.next(rt)) {
                    for (LeftTuple lt = rt.getBlocked(); lt != null; lt = lt.getBlockedNext()) {
                        visitLeftTuple(wm, insert, rule, lt);
                    }
                }
            } else {
                bm = (BetaMemory) wm.getNodeMemory((MemoryFactory) node);
                FastIterator it = bm.getLeftTupleMemory().fullFastIterator();
                for (LeftTuple lt = (LeftTuple) BetaNode.getFirstTuple(bm.getLeftTupleMemory(), it); lt != null; lt = (LeftTuple) it.next(lt)) {
                    visitLeftTuple(wm, insert, rule, lt);
                }
            }
            return;
        } else if (NodeTypeEnums.FromNode == node.getType()) {
            FromMemory fm = (FromMemory) wm.getNodeMemory((MemoryFactory) node);
            TupleMemory ltm = fm.getBetaMemory().getLeftTupleMemory();
            FastIterator it = ltm.fullFastIterator();
            for (LeftTuple lt = (LeftTuple) ltm.getFirst(null); lt != null; lt = (LeftTuple) it.next(lt)) {
                visitChild(lt, insert, wm, rule);
            }
            return;
        }
        if (sm.getRootNode() == node) {
            sm = wm.getNodeMemory((MemoryFactory<Memory>) node.getLeftTupleSource()).getSegmentMemory();
        }
        node = node.getLeftTupleSource();
    }
    processLeftTuplesOnLian(wm, insert, rule, (LeftInputAdapterNode) node);
}",java:S3776,39
"private static void visitChild(LeftTuple lt, boolean insert, InternalWorkingMemory wm, Rule rule){
    LeftTuple prevLt = null;
    LeftTupleSinkNode sink = (LeftTupleSinkNode) lt.getTupleSink();
    for (; sink != null; sink = sink.getNextLeftTupleSinkNode()) {
        if (lt != null) {
            if (lt.getTupleSink().isAssociatedWith(rule)) {
                if (lt.getTupleSink().getAssociatedTerminalsSize() > 1) {
                    if (lt.getFirstChild() != null) {
                        for (LeftTuple child = lt.getFirstChild(); child != null; child = child.getHandleNext()) {
                            visitChild(child, insert, wm, rule);
                        }
                    } else if (lt.getTupleSink().getType() == NodeTypeEnums.RightInputAdapterNode) {
                        insertPeerRightTuple(lt, wm, rule, insert);
                    }
                } else if (!insert) {
                    iterateLeftTuple(lt, wm);
                    LeftTuple lt2 = null;
                    for (LeftTuple peerLt = lt.getPeer(); peerLt != null && peerLt.getTupleSink().isAssociatedWith(rule) && peerLt.getTupleSink().getAssociatedTerminalsSize() == 1; peerLt = peerLt.getPeer()) {
                        iterateLeftTuple(peerLt, wm);
                        lt2 = peerLt;
                    }
                    deleteLeftTuple(lt, lt2, prevLt);
                    break;
                }
            }
            prevLt = lt;
            lt = lt.getPeer();
        } else {
            prevLt = insertPeerLeftTuple(prevLt, sink, wm, insert);
        }
    }
}",java:S3776,39
"private static void iterateLeftTuple(LeftTuple lt, InternalWorkingMemory wm){
    if (NodeTypeEnums.isTerminalNode(lt.getTupleSink())) {
        PathMemory pmem = (PathMemory) wm.getNodeMemories().peekNodeMemory(lt.getTupleSink());
        if (pmem != null) {
            PhreakRuleTerminalNode.doLeftDelete(pmem.getActualActivationsManager(wm), pmem.getRuleAgendaItem().getRuleExecutor(), lt);
        }
    } else {
        if (lt.getContextObject() instanceof AccumulateContext) {
            LeftTuple resultLt = (LeftTuple) ((AccumulateContext) lt.getContextObject()).getResultLeftTuple();
            if (resultLt != null) {
                iterateLeftTuple(resultLt, wm);
            }
        }
        for (LeftTuple child = lt.getFirstChild(); child != null; child = child.getHandleNext()) {
            for (LeftTuple peer = child; peer != null; peer = peer.getPeer()) {
                if (peer.getPeer() == null) {
                    iterateLeftTuple(peer, wm);
                }
            }
        }
    }
}",java:S3776,39
"private static void mergeSegment(SegmentMemory sm1, SegmentMemory sm2){
    if (sm1.getTipNode().getType() == NodeTypeEnums.LeftInputAdapterNode && !sm2.getStagedLeftTuples().isEmpty()) {
        sm1.getStagedLeftTuples().addAll(sm2.getStagedLeftTuples());
    }
    if (sm1.contains(sm2)) {
        sm1.remove(sm2);
    }
    if (sm2.getFirst() != null) {
        for (SegmentMemory sm = sm2.getFirst(); sm != null; ) {
            SegmentMemory next = sm.getNext();
            sm2.remove(sm);
            sm1.add(sm);
            sm = next;
        }
    }
    sm1.setTipNode(sm2.getTipNode());
    mergeNodeMemories(sm1, sm2);
    mergeBitMasks(sm1, sm2);
}",java:S3398,35
"private static PathEndNodeMemories getPathEndMemories(InternalWorkingMemory wm, PathEndNodes pathEndNodes){
    PathEndNodeMemories tnMems = new PathEndNodeMemories();
    for (LeftTupleNode node : pathEndNodes.otherEndNodes) {
        if (node.getType() == NodeTypeEnums.RightInputAdapterNode) {
            RiaPathMemory riaMem = (RiaPathMemory) wm.getNodeMemories().peekNodeMemory(node);
            if (riaMem != null) {
                tnMems.otherPmems.add(riaMem);
            }
        } else {
            PathMemory pmem = (PathMemory) wm.getNodeMemories().peekNodeMemory(node);
            if (pmem != null) {
                tnMems.otherPmems.add(pmem);
            }
        }
    }
    tnMems.subjectPmem = (PathMemory) wm.getNodeMemories().peekNodeMemory(pathEndNodes.subjectEndNode);
    if (tnMems.subjectPmem == null && !tnMems.otherPmems.isEmpty()) {
        tnMems.subjectPmem = wm.getNodeMemory(pathEndNodes.subjectEndNode);
    }
    for (LeftTupleNode node : pathEndNodes.subjectEndNodes) {
        if (node.getType() == NodeTypeEnums.RightInputAdapterNode) {
            RiaPathMemory riaMem = (RiaPathMemory) wm.getNodeMemories().peekNodeMemory(node);
            if (riaMem == null && !tnMems.otherPmems.isEmpty()) {
                riaMem = (RiaPathMemory) wm.getNodeMemory((MemoryFactory<Memory>) node);
            }
            if (riaMem != null) {
                tnMems.subjectPmems.add(riaMem);
            }
        } else {
            PathMemory pmem = (PathMemory) wm.getNodeMemories().peekNodeMemory(node);
            if (pmem != null) {
                tnMems.subjectPmems.add(pmem);
            }
        }
    }
    return tnMems;
}",java:S3776,39
"private static void collectPathEndNodes(InternalRuleBase kBase, LeftTupleNode lt, PathEndNodes endNodes, TerminalNode tn, Rule processedRule, boolean hasProtos, boolean hasWms, boolean isBelowNewSplit){
    for (LeftTupleSinkNode sink = lt.getSinkPropagator().getLastLeftTupleSink(); sink != null; sink = sink.getPreviousLeftTupleSinkNode()) {
        if (sink == tn) {
            continue;
        }
        if (hasProtos) {
            if (isBelowNewSplit) {
                if (isRootNode(sink, null)) {
                    kBase.invalidateSegmentPrototype(sink);
                }
            } else {
                isBelowNewSplit = isSplit(sink);
                if (isBelowNewSplit) {
                    invalidateRootNode(kBase, sink);
                }
            }
        }
        if (NodeTypeEnums.isLeftTupleSource(sink)) {
            if (hasWms && BuildtimeSegmentUtilities.isTipNode(sink, null)) {
                if (!BuildtimeSegmentUtilities.isTipNode(sink, tn)) {
                    endNodes.subjectSplits.add(sink);
                }
            }
            collectPathEndNodes(kBase, sink, endNodes, tn, processedRule, hasProtos, hasWms, isBelowNewSplit);
        } else if (NodeTypeEnums.isTerminalNode(sink)) {
            endNodes.otherEndNodes.add((PathEndNode) sink);
        } else if (NodeTypeEnums.RightInputAdapterNode == sink.getType()) {
            if (sink.isAssociatedWith(processedRule)) {
                endNodes.subjectEndNodes.add((PathEndNode) sink);
            }
            if (sink.getAssociatedTerminalsSize() > 1 || !sink.isAssociatedWith(processedRule)) {
                endNodes.otherEndNodes.add((PathEndNode) sink);
            }
        } else {
            throw new RuntimeException(""Error: Unknown Node. Defensive programming test.."");
        }
    }
}",java:S3776,39
"private static void collectPathEndNodes(InternalRuleBase kBase, LeftTupleNode lt, PathEndNodes endNodes, TerminalNode tn, Rule processedRule, boolean hasProtos, boolean hasWms, boolean isBelowNewSplit){
    for (LeftTupleSinkNode sink = lt.getSinkPropagator().getLastLeftTupleSink(); sink != null; sink = sink.getPreviousLeftTupleSinkNode()) {
        if (sink == tn) {
            continue;
        }
        if (hasProtos) {
            if (isBelowNewSplit) {
                if (isRootNode(sink, null)) {
                    kBase.invalidateSegmentPrototype(sink);
                }
            } else {
                isBelowNewSplit = isSplit(sink);
                if (isBelowNewSplit) {
                    invalidateRootNode(kBase, sink);
                }
            }
        }
        if (NodeTypeEnums.isLeftTupleSource(sink)) {
            if (hasWms && BuildtimeSegmentUtilities.isTipNode(sink, null)) {
                if (!BuildtimeSegmentUtilities.isTipNode(sink, tn)) {
                    endNodes.subjectSplits.add(sink);
                }
            }
            collectPathEndNodes(kBase, sink, endNodes, tn, processedRule, hasProtos, hasWms, isBelowNewSplit);
        } else if (NodeTypeEnums.isTerminalNode(sink)) {
            endNodes.otherEndNodes.add((PathEndNode) sink);
        } else if (NodeTypeEnums.RightInputAdapterNode == sink.getType()) {
            if (sink.isAssociatedWith(processedRule)) {
                endNodes.subjectEndNodes.add((PathEndNode) sink);
            }
            if (sink.getAssociatedTerminalsSize() > 1 || !sink.isAssociatedWith(processedRule)) {
                endNodes.otherEndNodes.add((PathEndNode) sink);
            }
        } else {
            throw new RuntimeException(""Error: Unknown Node. Defensive programming test.."");
        }
    }
}",java:S107,1
"private static SegmentMemory createSegmentMemory(LeftTupleSource segmentRoot, ReteEvaluator reteEvaluator){
    LeftTupleSource tupleSource = segmentRoot;
    SegmentMemory smem = new SegmentMemory(segmentRoot);
    long nodePosMask = 1;
    long allLinkedTestMask = 0;
    boolean updateNodeBit = true;
    int nodeTypesInSegment = 0;
    List<Memory> memories = new ArrayList<>();
    while (true) {
        nodeTypesInSegment = updateNodeTypesMask(tupleSource, nodeTypesInSegment);
        if (NodeTypeEnums.isBetaNode(tupleSource)) {
            allLinkedTestMask = processBetaNode((BetaNode) tupleSource, reteEvaluator, smem, memories, nodePosMask, allLinkedTestMask, updateNodeBit);
        } else {
            switch(tupleSource.getType()) {
                case NodeTypeEnums.LeftInputAdapterNode:
                    allLinkedTestMask = processLiaNode((LeftInputAdapterNode) tupleSource, reteEvaluator, smem, memories, nodePosMask, allLinkedTestMask);
                    break;
                case NodeTypeEnums.EvalConditionNode:
                    processEvalNode((EvalConditionNode) tupleSource, reteEvaluator, smem, memories);
                    break;
                case NodeTypeEnums.ConditionalBranchNode:
                    updateNodeBit = processBranchNode((ConditionalBranchNode) tupleSource, reteEvaluator, smem, memories);
                    break;
                case NodeTypeEnums.FromNode:
                    processFromNode((FromNode) tupleSource, reteEvaluator, smem, memories);
                    break;
                case NodeTypeEnums.ReactiveFromNode:
                    processReactiveFromNode((MemoryFactory) tupleSource, reteEvaluator, smem, memories, nodePosMask);
                    break;
                case NodeTypeEnums.TimerConditionNode:
                    processTimerNode((TimerNode) tupleSource, reteEvaluator, smem, memories, nodePosMask);
                    break;
                case NodeTypeEnums.AsyncSendNode:
                    processAsyncSendNode((AsyncSendNode) tupleSource, reteEvaluator, smem, memories);
                    break;
                case NodeTypeEnums.AsyncReceiveNode:
                    processAsyncReceiveNode((AsyncReceiveNode) tupleSource, reteEvaluator, smem, memories, nodePosMask);
                    break;
                case NodeTypeEnums.QueryElementNode:
                    updateNodeBit = processQueryNode((QueryElementNode) tupleSource, reteEvaluator, segmentRoot, smem, memories, nodePosMask);
                    break;
            }
        }
        nodePosMask = nextNodePosMask(nodePosMask);
        if (tupleSource.getSinkPropagator().size() == 1) {
            LeftTupleSinkNode sink = tupleSource.getSinkPropagator().getFirstLeftTupleSink();
            if (NodeTypeEnums.isLeftTupleSource(sink)) {
                tupleSource = (LeftTupleSource) sink;
            } else {
                Memory memory = reteEvaluator.getNodeMemory((MemoryFactory) sink);
                if (sink.getType() == NodeTypeEnums.RightInputAdapterNode) {
                    PathMemory riaPmem = (RightInputAdapterNode.RiaPathMemory) memory;
                    memories.add(riaPmem);
                    RightInputAdapterNode rian = (RightInputAdapterNode) sink;
                    ObjectSink[] nodes = rian.getObjectSinkPropagator().getSinks();
                    for (ObjectSink node : nodes) {
                        if (NodeTypeEnums.isLeftTupleSource(node)) {
                            getOrCreateSegmentMemory((LeftTupleSource) node, reteEvaluator);
                        }
                    }
                } else if (NodeTypeEnums.isTerminalNode(sink)) {
                    memories.add(memory);
                }
                memory.setSegmentMemory(smem);
                smem.setTipNode(sink);
                break;
            }
        } else {
            smem.setTipNode(tupleSource);
            break;
        }
    }
    smem.setAllLinkedMaskTest(allLinkedTestMask);
    smem.setNodeMemories(memories.toArray(new Memory[memories.size()]));
    Memory lastMem = null;
    for (Memory mem : memories) {
        if (lastMem != null) {
            mem.setPrevious(lastMem);
            lastMem.setNext(mem);
        }
        lastMem = mem;
    }
    LeftTupleSource pathRoot = segmentRoot;
    int ruleSegmentPosMask = 1;
    int counter = 0;
    while (pathRoot.getType() != NodeTypeEnums.LeftInputAdapterNode) {
        LeftTupleSource leftTupleSource = pathRoot.getLeftTupleSource();
        if (isNonTerminalTipNode(leftTupleSource, null)) {
            ruleSegmentPosMask = ruleSegmentPosMask << 1;
            counter++;
        }
        pathRoot = leftTupleSource;
    }
    smem.setSegmentPosMaskBit(ruleSegmentPosMask);
    smem.setPos(counter);
    updateRiaAndTerminalMemory(tupleSource, tupleSource, smem, reteEvaluator, false, nodeTypesInSegment);
    reteEvaluator.getKnowledgeBase().registerSegmentPrototype(segmentRoot, smem.getSegmentPrototype().initFromSegmentMemory(smem));
    return smem;
}",java:S3776,39
"private static boolean processQueryNode(QueryElementNode queryNode, ReteEvaluator reteEvaluator, LeftTupleSource segmentRoot, SegmentMemory smem, List<Memory> memories, long nodePosMask){
    SegmentMemory querySmem = getQuerySegmentMemory(reteEvaluator, queryNode);
    QueryElementNode.QueryElementNodeMemory queryNodeMem = smem.createNodeMemory(queryNode, reteEvaluator);
    queryNodeMem.setNodePosMaskBit(nodePosMask);
    queryNodeMem.setQuerySegmentMemory(querySmem);
    queryNodeMem.setSegmentMemory(smem);
    memories.add(queryNodeMem);
    return !queryNode.getQueryElement().isAbductive();
}",java:S1172,13
"private static int updateRiaAndTerminalMemory(LeftTupleSource lt, LeftTupleSource originalLt, SegmentMemory smem, ReteEvaluator reteEvaluator, boolean fromPrototype, int nodeTypesInSegment){
    nodeTypesInSegment = checkSegmentBoundary(lt, reteEvaluator, nodeTypesInSegment);
    PathMemory pmem = null;
    for (LeftTupleSink sink : lt.getSinkPropagator().getSinks()) {
        if (NodeTypeEnums.isLeftTupleSource(sink)) {
            nodeTypesInSegment = updateRiaAndTerminalMemory((LeftTupleSource) sink, originalLt, smem, reteEvaluator, fromPrototype, nodeTypesInSegment);
        } else if (sink.getType() == NodeTypeEnums.RightInputAdapterNode) {
            RightInputAdapterNode.RiaPathMemory riaMem = (RightInputAdapterNode.RiaPathMemory) reteEvaluator.getNodeMemory((MemoryFactory) sink);
            if (inSubNetwork((RightInputAdapterNode) sink, originalLt)) {
                pmem = riaMem;
                if (fromPrototype) {
                    ObjectSink[] nodes = ((RightInputAdapterNode) sink).getObjectSinkPropagator().getSinks();
                    for (ObjectSink node : nodes) {
                        if (NodeTypeEnums.isLeftTupleSource(node) && reteEvaluator.getNodeMemory((MemoryFactory) node).getSegmentMemory() == null) {
                            restoreSegmentFromPrototype(reteEvaluator, (LeftTupleSource) node, nodeTypesInSegment);
                        }
                    }
                } else if ((pmem.getAllLinkedMaskTest() & (1L << pmem.getSegmentMemories().length)) == 0) {
                    ObjectSink[] nodes = ((RightInputAdapterNode) sink).getObjectSinkPropagator().getSinks();
                    for (ObjectSink node : nodes) {
                        if (NodeTypeEnums.isLeftTupleSource(node)) {
                            getOrCreateSegmentMemory((LeftTupleSource) node, reteEvaluator);
                        }
                    }
                }
            }
        } else if (NodeTypeEnums.isTerminalNode(sink)) {
            pmem = (PathMemory) reteEvaluator.getNodeMemory((MemoryFactory) sink);
        }
        if (pmem != null && smem.getPos() < pmem.getSegmentMemories().length) {
            RuntimeSegmentUtilities.addSegmentToPathMemory(pmem, smem);
            if (smem.isSegmentLinked()) {
                smem.notifyRuleLinkSegment(reteEvaluator);
            }
            checkEagerSegmentCreation(sink.getLeftTupleSource(), reteEvaluator, nodeTypesInSegment);
            pmem = null;
        }
    }
    return nodeTypesInSegment;
}",java:S3776,39
"public void doNode(AccumulateNode accNode, LeftTupleSink sink, AccumulateMemory am, ReteEvaluator reteEvaluator, TupleSets<LeftTuple> srcLeftTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples){
    BetaMemory bm = am.getBetaMemory();
    TupleSets<RightTuple> srcRightTuples = bm.getStagedRightTuples().takeAll();
    if (srcLeftTuples.getDeleteFirst() != null) {
        doLeftDeletes(accNode, am, reteEvaluator, srcLeftTuples, trgLeftTuples, stagedLeftTuples);
    }
    TupleSets<LeftTuple> tempLeftTuples = new TupleSetsImpl<>();
    if (srcRightTuples.getDeleteFirst() != null) {
        doRightDeletes(accNode, am, reteEvaluator, srcRightTuples, tempLeftTuples);
    }
    if (srcRightTuples.getUpdateFirst() != null) {
        RuleNetworkEvaluator.doUpdatesReorderRightMemory(bm, srcRightTuples);
        doRightUpdates(accNode, am, reteEvaluator, srcRightTuples, tempLeftTuples);
    }
    if (srcLeftTuples.getUpdateFirst() != null) {
        RuleNetworkEvaluator.doUpdatesReorderLeftMemory(bm, srcLeftTuples);
        doLeftUpdates(accNode, am, reteEvaluator, srcLeftTuples, tempLeftTuples);
    }
    if (!accNode.isRightInputIsRiaNode()) {
        if (srcRightTuples.getInsertFirst() != null) {
            doRightInserts(accNode, am, reteEvaluator, srcRightTuples, tempLeftTuples);
        }
        if (srcLeftTuples.getInsertFirst() != null) {
            doLeftInserts(accNode, am, reteEvaluator, srcLeftTuples, tempLeftTuples);
        }
    } else {
        if (srcLeftTuples.getInsertFirst() != null) {
            doLeftInserts(accNode, am, reteEvaluator, srcLeftTuples, tempLeftTuples);
        }
        if (srcRightTuples.getInsertFirst() != null) {
            doRightInserts(accNode, am, reteEvaluator, srcRightTuples, tempLeftTuples);
        }
    }
    Accumulate accumulate = accNode.getAccumulate();
    for (LeftTuple leftTuple = tempLeftTuples.getInsertFirst(); leftTuple != null; ) {
        LeftTuple next = leftTuple.getStagedNext();
        evaluateResultConstraints(accNode, sink, accumulate, leftTuple, leftTuple.getPropagationContext(), reteEvaluator, am, (BaseAccumulation) leftTuple.getContextObject(), trgLeftTuples, stagedLeftTuples);
        leftTuple.clearStaged();
        leftTuple = next;
    }
    for (LeftTuple leftTuple = tempLeftTuples.getUpdateFirst(); leftTuple != null; ) {
        LeftTuple next = leftTuple.getStagedNext();
        evaluateResultConstraints(accNode, sink, accumulate, leftTuple, leftTuple.getPropagationContext(), reteEvaluator, am, (BaseAccumulation) leftTuple.getContextObject(), trgLeftTuples, stagedLeftTuples);
        leftTuple.clearStaged();
        leftTuple = next;
    }
    srcRightTuples.resetAll();
    srcLeftTuples.resetAll();
}",java:S3776,39
"private void doRightInserts(AccumulateNode accNode, AccumulateMemory am, ReteEvaluator reteEvaluator, TupleSets<RightTuple> srcRightTuples, TupleSets<LeftTuple> trgLeftTuples){
    Accumulate accumulate = accNode.getAccumulate();
    BetaMemory bm = am.getBetaMemory();
    TupleMemory ltm = bm.getLeftTupleMemory();
    TupleMemory rtm = bm.getRightTupleMemory();
    ContextEntry[] contextEntry = bm.getContext();
    BetaConstraints constraints = accNode.getRawConstraints();
    if (srcRightTuples.getInsertSize() > 32 && rtm instanceof AbstractHashTable) {
        ((AbstractHashTable) rtm).ensureCapacity(srcRightTuples.getInsertSize());
    }
    boolean tupleMemoryEnabled = accNode.isLeftTupleMemoryEnabled();
    for (RightTuple rightTuple = srcRightTuples.getInsertFirst(); rightTuple != null; ) {
        RightTuple next = rightTuple.getStagedNext();
        boolean useTupleMemory = tupleMemoryEnabled || RuleNetworkEvaluator.useLeftMemory(accNode, rightTuple);
        if (useTupleMemory || !accNode.isRightInputIsRiaNode()) {
            rtm.add(rightTuple);
        }
        if (accNode.isRightInputIsRiaNode() || (ltm != null && ltm.size() > 0)) {
            constraints.updateFromFactHandle(contextEntry, reteEvaluator, rightTuple.getFactHandleForEvaluation());
            FastIterator leftIt = accNode.getLeftIterator(ltm);
            for (LeftTuple leftTuple = accNode.getFirstLeftTuple(rightTuple, ltm, leftIt); leftTuple != null; leftTuple = (LeftTuple) leftIt.next(leftTuple)) {
                if (constraints.isAllowedCachedRight(contextEntry, leftTuple)) {
                    final BaseAccumulation accctx = (BaseAccumulation) leftTuple.getContextObject();
                    addMatch(accNode, accumulate, leftTuple, rightTuple, null, null, reteEvaluator, am, accctx, true, false);
                    if (leftTuple.getStagedType() == LeftTuple.NONE) {
                        trgLeftTuples.addUpdate(leftTuple);
                    }
                }
            }
        }
        rightTuple.clearStaged();
        rightTuple = next;
    }
    constraints.resetFactHandle(contextEntry);
}",java:S3776,39
"private void doLeftUpdatesProcessChildren(AccumulateNode accNode, AccumulateMemory am, ReteEvaluator reteEvaluator, BetaMemory bm, Accumulate accumulate, BetaConstraints constraints, FastIterator rightIt, LeftTuple leftTuple, final BaseAccumulation accctx, RightTuple rightTuple, LeftTuple match){
    if (match == null) {
        for (; rightTuple != null; rightTuple = (RightTuple) rightIt.next(rightTuple)) {
            if (constraints.isAllowedCachedLeft(bm.getContext(), rightTuple.getFactHandleForEvaluation())) {
                addMatch(accNode, accumulate, leftTuple, rightTuple, null, null, reteEvaluator, am, accctx, true, true);
            }
        }
    } else {
        boolean isDirty = false;
        for (; rightTuple != null; rightTuple = (RightTuple) rightIt.next(rightTuple)) {
            if (constraints.isAllowedCachedLeft(bm.getContext(), rightTuple.getFactHandleForEvaluation())) {
                if (match == null || match.getRightParent() != rightTuple) {
                    addMatch(accNode, accumulate, leftTuple, rightTuple, match, null, reteEvaluator, am, accctx, true, true);
                } else {
                    LeftTuple temp = match.getHandleNext();
                    match.reAddRight();
                    match = temp;
                    isDirty = accumulate.hasRequiredDeclarations();
                }
            } else if (match != null && match.getRightParent() == rightTuple) {
                LeftTuple temp = match.getHandleNext();
                boolean reversed = removeMatch(accNode, accumulate, rightTuple, match, reteEvaluator, am, accctx, false);
                match = temp;
                isDirty = !reversed;
            }
        }
        if (isDirty) {
            reaccumulateForLeftTuple(accNode, accumulate, leftTuple, null, null, reteEvaluator, am, accctx, true);
        }
    }
}",java:S3776,39
"private void doLeftUpdatesProcessChildren(AccumulateNode accNode, AccumulateMemory am, ReteEvaluator reteEvaluator, BetaMemory bm, Accumulate accumulate, BetaConstraints constraints, FastIterator rightIt, LeftTuple leftTuple, final BaseAccumulation accctx, RightTuple rightTuple, LeftTuple match){
    if (match == null) {
        for (; rightTuple != null; rightTuple = (RightTuple) rightIt.next(rightTuple)) {
            if (constraints.isAllowedCachedLeft(bm.getContext(), rightTuple.getFactHandleForEvaluation())) {
                addMatch(accNode, accumulate, leftTuple, rightTuple, null, null, reteEvaluator, am, accctx, true, true);
            }
        }
    } else {
        boolean isDirty = false;
        for (; rightTuple != null; rightTuple = (RightTuple) rightIt.next(rightTuple)) {
            if (constraints.isAllowedCachedLeft(bm.getContext(), rightTuple.getFactHandleForEvaluation())) {
                if (match == null || match.getRightParent() != rightTuple) {
                    addMatch(accNode, accumulate, leftTuple, rightTuple, match, null, reteEvaluator, am, accctx, true, true);
                } else {
                    LeftTuple temp = match.getHandleNext();
                    match.reAddRight();
                    match = temp;
                    isDirty = accumulate.hasRequiredDeclarations();
                }
            } else if (match != null && match.getRightParent() == rightTuple) {
                LeftTuple temp = match.getHandleNext();
                boolean reversed = removeMatch(accNode, accumulate, rightTuple, match, reteEvaluator, am, accctx, false);
                match = temp;
                isDirty = !reversed;
            }
        }
        if (isDirty) {
            reaccumulateForLeftTuple(accNode, accumulate, leftTuple, null, null, reteEvaluator, am, accctx, true);
        }
    }
}",java:S107,1
"private void doRightUpdatesProcessChildren(AccumulateNode accNode, AccumulateMemory am, ReteEvaluator reteEvaluator, BetaMemory bm, BetaConstraints constraints, Accumulate accumulate, FastIterator leftIt, RightTuple rightTuple, LeftTuple childLeftTuple, LeftTuple leftTuple, TupleSets<LeftTuple> trgLeftTuples){
    if (childLeftTuple == null) {
        for (; leftTuple != null; leftTuple = (LeftTuple) leftIt.next(leftTuple)) {
            if (constraints.isAllowedCachedRight(bm.getContext(), leftTuple)) {
                if (leftTuple.getStagedType() == LeftTuple.NONE) {
                    trgLeftTuples.addUpdate(leftTuple);
                }
                final BaseAccumulation accctx = (BaseAccumulation) leftTuple.getContextObject();
                addMatch(accNode, accumulate, leftTuple, rightTuple, null, null, reteEvaluator, am, accctx, true, false);
            }
        }
    } else {
        for (; leftTuple != null; leftTuple = (LeftTuple) leftIt.next(leftTuple)) {
            if (constraints.isAllowedCachedRight(bm.getContext(), leftTuple)) {
                if (leftTuple.getStagedType() == LeftTuple.NONE) {
                    trgLeftTuples.addUpdate(leftTuple);
                }
                final BaseAccumulation accctx = (BaseAccumulation) leftTuple.getContextObject();
                LeftTuple temp;
                if (childLeftTuple != null && childLeftTuple.getLeftParent() == leftTuple) {
                    temp = childLeftTuple.getRightParentNext();
                    childLeftTuple.reAddLeft();
                    removeMatch(accNode, accumulate, rightTuple, childLeftTuple, reteEvaluator, am, accctx, true);
                    childLeftTuple = temp;
                }
                addMatch(accNode, accumulate, leftTuple, rightTuple, null, childLeftTuple, reteEvaluator, am, accctx, true, false);
            } else if (childLeftTuple != null && childLeftTuple.getLeftParent() == leftTuple) {
                if (leftTuple.getStagedType() == LeftTuple.NONE) {
                    trgLeftTuples.addUpdate(leftTuple);
                }
                LeftTuple temp = childLeftTuple.getRightParentNext();
                final BaseAccumulation accctx = (BaseAccumulation) leftTuple.getContextObject();
                removeMatch(accNode, accumulate, rightTuple, childLeftTuple, reteEvaluator, am, accctx, true);
                childLeftTuple = temp;
            }
        }
    }
}",java:S3776,39
"private void doRightUpdatesProcessChildren(AccumulateNode accNode, AccumulateMemory am, ReteEvaluator reteEvaluator, BetaMemory bm, BetaConstraints constraints, Accumulate accumulate, FastIterator leftIt, RightTuple rightTuple, LeftTuple childLeftTuple, LeftTuple leftTuple, TupleSets<LeftTuple> trgLeftTuples){
    if (childLeftTuple == null) {
        for (; leftTuple != null; leftTuple = (LeftTuple) leftIt.next(leftTuple)) {
            if (constraints.isAllowedCachedRight(bm.getContext(), leftTuple)) {
                if (leftTuple.getStagedType() == LeftTuple.NONE) {
                    trgLeftTuples.addUpdate(leftTuple);
                }
                final BaseAccumulation accctx = (BaseAccumulation) leftTuple.getContextObject();
                addMatch(accNode, accumulate, leftTuple, rightTuple, null, null, reteEvaluator, am, accctx, true, false);
            }
        }
    } else {
        for (; leftTuple != null; leftTuple = (LeftTuple) leftIt.next(leftTuple)) {
            if (constraints.isAllowedCachedRight(bm.getContext(), leftTuple)) {
                if (leftTuple.getStagedType() == LeftTuple.NONE) {
                    trgLeftTuples.addUpdate(leftTuple);
                }
                final BaseAccumulation accctx = (BaseAccumulation) leftTuple.getContextObject();
                LeftTuple temp;
                if (childLeftTuple != null && childLeftTuple.getLeftParent() == leftTuple) {
                    temp = childLeftTuple.getRightParentNext();
                    childLeftTuple.reAddLeft();
                    removeMatch(accNode, accumulate, rightTuple, childLeftTuple, reteEvaluator, am, accctx, true);
                    childLeftTuple = temp;
                }
                addMatch(accNode, accumulate, leftTuple, rightTuple, null, childLeftTuple, reteEvaluator, am, accctx, true, false);
            } else if (childLeftTuple != null && childLeftTuple.getLeftParent() == leftTuple) {
                if (leftTuple.getStagedType() == LeftTuple.NONE) {
                    trgLeftTuples.addUpdate(leftTuple);
                }
                LeftTuple temp = childLeftTuple.getRightParentNext();
                final BaseAccumulation accctx = (BaseAccumulation) leftTuple.getContextObject();
                removeMatch(accNode, accumulate, rightTuple, childLeftTuple, reteEvaluator, am, accctx, true);
                childLeftTuple = temp;
            }
        }
    }
}",java:S107,1
"protected void evaluateResultConstraints(final AccumulateNode accNode, final LeftTupleSink sink, final Accumulate accumulate, final LeftTuple leftTuple, final PropagationContext context, final ReteEvaluator reteEvaluator, final AccumulateMemory memory, final BaseAccumulation accctx, final TupleSets<LeftTuple> trgLeftTuples, final TupleSets<LeftTuple> stagedLeftTuples){
    PropagationContext propagationContext = accctx.getPropagationContext();
    accctx.setPropagationContext(null);
    Object result = accumulate.getResult(memory.workingMemoryContext, accctx, leftTuple, reteEvaluator);
    propagateResult(accNode, sink, leftTuple, context, reteEvaluator, memory, trgLeftTuples, stagedLeftTuples, null, result, (AccumulateContextEntry) accctx, propagationContext, reteEvaluator.getRuleSessionConfiguration().isAccumulateNullPropagation());
}",java:S107,1
"protected final void propagateResult(AccumulateNode accNode, LeftTupleSink sink, LeftTuple leftTuple, PropagationContext context, ReteEvaluator reteEvaluator, AccumulateMemory memory, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples, Object key, Object result, AccumulateContextEntry accPropCtx, PropagationContext propagationContext, boolean allowNullPropagation){
    if (!allowNullPropagation && result == null) {
        if (accPropCtx.isPropagated()) {
            trgLeftTuples.addDelete((LeftTuple) accPropCtx.getResultLeftTuple());
            accPropCtx.setPropagated(false);
        }
        return;
    }
    if (accPropCtx.getResultFactHandle() == null) {
        InternalFactHandle handle = accNode.createResultFactHandle(context, reteEvaluator, leftTuple, createResult(accNode, key, result));
        accPropCtx.setResultFactHandle(handle);
        accPropCtx.setResultLeftTuple(sink.createLeftTuple(handle, leftTuple, sink));
    } else {
        ((InternalFactHandle) accPropCtx.getResultFactHandle()).setObject(createResult(accNode, key, result));
    }
    AlphaNodeFieldConstraint[] resultConstraints = accNode.getResultConstraints();
    BetaConstraints resultBinder = accNode.getResultBinder();
    boolean isAllowed = true;
    for (AlphaNodeFieldConstraint resultConstraint : resultConstraints) {
        if (!resultConstraint.isAllowed(accPropCtx.getResultFactHandle(), reteEvaluator)) {
            isAllowed = false;
            break;
        }
    }
    if (isAllowed) {
        resultBinder.updateFromTuple(memory.resultsContext, reteEvaluator, leftTuple);
        if (!resultBinder.isAllowedCachedLeft(memory.resultsContext, accPropCtx.getResultFactHandle())) {
            isAllowed = false;
        }
        resultBinder.resetTuple(memory.resultsContext);
    }
    LeftTuple childLeftTuple = (LeftTuple) accPropCtx.getResultLeftTuple();
    childLeftTuple.setPropagationContext(propagationContext != null ? propagationContext : leftTuple.getPropagationContext());
    if (accPropCtx.isPropagated()) {
        normalizeStagedTuples(stagedLeftTuples, childLeftTuple);
        if (isAllowed) {
            trgLeftTuples.addUpdate(childLeftTuple);
        } else {
            trgLeftTuples.addDelete(childLeftTuple);
            accPropCtx.setPropagated(false);
        }
    } else if (isAllowed) {
        trgLeftTuples.addInsert(childLeftTuple);
        accPropCtx.setPropagated(true);
    }
}",java:S3776,39
"protected final void propagateResult(AccumulateNode accNode, LeftTupleSink sink, LeftTuple leftTuple, PropagationContext context, ReteEvaluator reteEvaluator, AccumulateMemory memory, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples, Object key, Object result, AccumulateContextEntry accPropCtx, PropagationContext propagationContext, boolean allowNullPropagation){
    if (!allowNullPropagation && result == null) {
        if (accPropCtx.isPropagated()) {
            trgLeftTuples.addDelete((LeftTuple) accPropCtx.getResultLeftTuple());
            accPropCtx.setPropagated(false);
        }
        return;
    }
    if (accPropCtx.getResultFactHandle() == null) {
        InternalFactHandle handle = accNode.createResultFactHandle(context, reteEvaluator, leftTuple, createResult(accNode, key, result));
        accPropCtx.setResultFactHandle(handle);
        accPropCtx.setResultLeftTuple(sink.createLeftTuple(handle, leftTuple, sink));
    } else {
        ((InternalFactHandle) accPropCtx.getResultFactHandle()).setObject(createResult(accNode, key, result));
    }
    AlphaNodeFieldConstraint[] resultConstraints = accNode.getResultConstraints();
    BetaConstraints resultBinder = accNode.getResultBinder();
    boolean isAllowed = true;
    for (AlphaNodeFieldConstraint resultConstraint : resultConstraints) {
        if (!resultConstraint.isAllowed(accPropCtx.getResultFactHandle(), reteEvaluator)) {
            isAllowed = false;
            break;
        }
    }
    if (isAllowed) {
        resultBinder.updateFromTuple(memory.resultsContext, reteEvaluator, leftTuple);
        if (!resultBinder.isAllowedCachedLeft(memory.resultsContext, accPropCtx.getResultFactHandle())) {
            isAllowed = false;
        }
        resultBinder.resetTuple(memory.resultsContext);
    }
    LeftTuple childLeftTuple = (LeftTuple) accPropCtx.getResultLeftTuple();
    childLeftTuple.setPropagationContext(propagationContext != null ? propagationContext : leftTuple.getPropagationContext());
    if (accPropCtx.isPropagated()) {
        normalizeStagedTuples(stagedLeftTuples, childLeftTuple);
        if (isAllowed) {
            trgLeftTuples.addUpdate(childLeftTuple);
        } else {
            trgLeftTuples.addDelete(childLeftTuple);
            accPropCtx.setPropagated(false);
        }
    } else if (isAllowed) {
        trgLeftTuples.addInsert(childLeftTuple);
        accPropCtx.setPropagated(true);
    }
}",java:S107,1
"protected Object createResult(AccumulateNode accNode, Object key, Object result){
    return result;
}",java:S1172,13
"private void addMatch(final AccumulateNode accNode, final Accumulate accumulate, final LeftTuple leftTuple, final RightTuple rightTuple, final LeftTuple currentLeftChild, final LeftTuple currentRightChild, final ReteEvaluator reteEvaluator, final AccumulateMemory am, final BaseAccumulation accctx, final boolean useLeftMemory, final boolean leftPropagation){
    LeftTuple tuple = leftTuple;
    InternalFactHandle handle = (InternalFactHandle) rightTuple.getFactHandle();
    if (accNode.isRightInputIsRiaNode()) {
        tuple = (LeftTuple) rightTuple;
        handle = rightTuple.getFactHandleForEvaluation();
    }
    if (leftPropagation && handle.isExpired()) {
        return;
    }
    accctx.setPropagationContext(rightTuple.getPropagationContext());
    Object value = accumulate.accumulate(am.workingMemoryContext, accctx, tuple, handle, reteEvaluator);
    if (useLeftMemory) {
        LeftTuple match = accNode.createLeftTuple(leftTuple, rightTuple, currentLeftChild, currentRightChild, accNode, true);
        postAccumulate(accNode, accctx, match);
        match.setContextObject(value);
    }
}",java:S107,1
"private boolean removeMatch(final AccumulateNode accNode, final Accumulate accumulate, final RightTuple rightTuple, final LeftTuple match, final ReteEvaluator reteEvaluator, final AccumulateMemory am, final BaseAccumulation accctx, final boolean reaccumulate){
    LeftTuple leftParent = match.getLeftParent();
    RightTuple rightParent = match.getRightParent();
    match.unlinkFromLeftParent();
    match.unlinkFromRightParent();
    FactHandle handle = rightTuple.getFactHandle();
    LeftTuple tuple = leftParent;
    if (accNode.isRightInputIsRiaNode()) {
        tuple = (LeftTuple) rightTuple;
        handle = rightTuple.getFactHandleForEvaluation();
    }
    boolean reversed = accumulate.tryReverse(am.workingMemoryContext, accctx, tuple, handle, match, reteEvaluator);
    if (!reversed) {
        reaccumulateForLeftTuple(accNode, accumulate, leftParent, rightParent, match, reteEvaluator, am, accctx, reaccumulate);
    }
    return reversed;
}",java:S107,1
"protected void reaccumulateForLeftTuple(final AccumulateNode accNode, final Accumulate accumulate, final LeftTuple leftParent, final RightTuple unused1, final LeftTuple unused2, final ReteEvaluator reteEvaluator, final AccumulateMemory am, final BaseAccumulation accctx, final boolean reaccumulate){
    if (reaccumulate) {
        reinit(accumulate, leftParent, reteEvaluator, am, accctx);
        for (LeftTuple childMatch = leftParent.getFirstChild(); childMatch != null; childMatch = childMatch.getHandleNext()) {
            RightTuple rightTuple = childMatch.getRightParent();
            FactHandle childHandle = rightTuple.getFactHandle();
            LeftTuple tuple = leftParent;
            if (accNode.isRightInputIsRiaNode()) {
                tuple = (LeftTuple) rightTuple;
                childHandle = rightTuple.getFactHandleForEvaluation();
            }
            Object value = accumulate.accumulate(am.workingMemoryContext, accctx, tuple, childHandle, reteEvaluator);
            postAccumulate(accNode, accctx, childMatch);
            childMatch.setContextObject(value);
        }
    }
}",java:S107,1
"public ClassLoader getClassLoader(){
    throw new UnsupportedOperationException();
}",java:S1124,6
"private void fetchAndSendResults(AsyncSendNode node, AsyncSendMemory memory, ReteEvaluator reteEvaluator, ContextEntry[] context, BetaConstraints betaConstraints, AlphaNodeFieldConstraint[] alphaConstraints, DataProvider dataProvider, Class<?> resultClass, LeftTuple leftTuple, PropagationContext propagationContext){
    for (final java.util.Iterator<?> it = dataProvider.getResults(leftTuple, reteEvaluator, memory.providerContext); it.hasNext(); ) {
        final Object object = it.next();
        if ((object == null) || !resultClass.isAssignableFrom(object.getClass())) {
            continue;
        }
        InternalFactHandle factHandle = node.createFactHandle(leftTuple, propagationContext, reteEvaluator, object);
        if (isAllowed(factHandle, alphaConstraints, reteEvaluator)) {
            propagate(node, reteEvaluator, factHandle, betaConstraints, context);
        }
    }
}",java:S107,1
"public void doNode(ConditionalBranchNode branchNode, ConditionalBranchMemory cbm, LeftTupleSink sink, ActivationsManager activationsManager, TupleSets<LeftTuple> srcLeftTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples, RuleExecutor executor){
    if (srcLeftTuples.getDeleteFirst() != null) {
        doLeftDeletes(sink, activationsManager, srcLeftTuples, trgLeftTuples, stagedLeftTuples, executor);
    }
    if (srcLeftTuples.getUpdateFirst() != null) {
        doLeftUpdates(branchNode, cbm, sink, activationsManager, srcLeftTuples, trgLeftTuples, stagedLeftTuples, executor);
    }
    if (srcLeftTuples.getInsertFirst() != null) {
        doLeftInserts(branchNode, cbm, sink, activationsManager, srcLeftTuples, trgLeftTuples, executor);
    }
    srcLeftTuples.resetAll();
}",java:S107,1
"public void doLeftUpdates(ConditionalBranchNode branchNode, ConditionalBranchMemory cbm, LeftTupleSink sink, ActivationsManager activationsManager, TupleSets<LeftTuple> srcLeftTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples, RuleExecutor executor){
    ConditionalBranchEvaluator branchEvaluator = branchNode.getBranchEvaluator();
    RuleAgendaItem ruleAgendaItem = executor.getRuleAgendaItem();
    for (LeftTuple leftTuple = srcLeftTuples.getUpdateFirst(); leftTuple != null; ) {
        LeftTuple next = leftTuple.getStagedNext();
        BranchTuples branchTuples = getBranchTuples(sink, leftTuple);
        RuleTerminalNode oldRtn = null;
        if (branchTuples.rtnLeftTuple != null) {
            oldRtn = (RuleTerminalNode) branchTuples.rtnLeftTuple.getTupleSink();
        }
        ConditionalExecution conditionalExecution = branchEvaluator.evaluate(leftTuple, activationsManager.getReteEvaluator(), cbm.context);
        RuleTerminalNode newRtn = null;
        boolean breaking = false;
        if (conditionalExecution != null) {
            newRtn = (RuleTerminalNode) conditionalExecution.getSink().getFirstLeftTupleSink();
            breaking = conditionalExecution.isBreaking();
        }
        if (oldRtn != null) {
            if (newRtn == null) {
                if (branchTuples.rtnLeftTuple.getMemory() != null) {
                    executor.removeLeftTuple(branchTuples.rtnLeftTuple);
                }
                PhreakRuleTerminalNode.doLeftDelete(activationsManager, executor, branchTuples.rtnLeftTuple);
            } else if (newRtn == oldRtn) {
                PhreakRuleTerminalNode.doLeftTupleUpdate(newRtn, executor, activationsManager, branchTuples.rtnLeftTuple);
            } else {
                if (branchTuples.rtnLeftTuple.getMemory() != null) {
                    executor.removeLeftTuple(branchTuples.rtnLeftTuple);
                }
                PhreakRuleTerminalNode.doLeftDelete(activationsManager, executor, branchTuples.rtnLeftTuple);
                branchTuples.rtnLeftTuple = newRtn.createLeftTuple(leftTuple, newRtn, leftTuple.getPropagationContext(), true);
                PhreakRuleTerminalNode.doLeftTupleInsert(newRtn, executor, activationsManager, executor.getRuleAgendaItem(), branchTuples.rtnLeftTuple);
            }
        } else if (newRtn != null) {
            branchTuples.rtnLeftTuple = newRtn.createLeftTuple(leftTuple, newRtn, leftTuple.getPropagationContext(), true);
            PhreakRuleTerminalNode.doLeftTupleInsert(newRtn, executor, activationsManager, executor.getRuleAgendaItem(), branchTuples.rtnLeftTuple);
        }
        if (branchTuples.mainLeftTuple != null) {
            normalizeStagedTuples(stagedLeftTuples, branchTuples.mainLeftTuple);
            if (!breaking) {
                trgLeftTuples.addUpdate(branchTuples.mainLeftTuple);
            } else {
                trgLeftTuples.addDelete(branchTuples.mainLeftTuple);
            }
        } else if (!breaking) {
            trgLeftTuples.addInsert(sink.createLeftTuple(leftTuple, sink, leftTuple.getPropagationContext(), true));
        }
        leftTuple.clearStaged();
        leftTuple = next;
    }
}",java:S3776,39
"public void doLeftUpdates(ConditionalBranchNode branchNode, ConditionalBranchMemory cbm, LeftTupleSink sink, ActivationsManager activationsManager, TupleSets<LeftTuple> srcLeftTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples, RuleExecutor executor){
    ConditionalBranchEvaluator branchEvaluator = branchNode.getBranchEvaluator();
    RuleAgendaItem ruleAgendaItem = executor.getRuleAgendaItem();
    for (LeftTuple leftTuple = srcLeftTuples.getUpdateFirst(); leftTuple != null; ) {
        LeftTuple next = leftTuple.getStagedNext();
        BranchTuples branchTuples = getBranchTuples(sink, leftTuple);
        RuleTerminalNode oldRtn = null;
        if (branchTuples.rtnLeftTuple != null) {
            oldRtn = (RuleTerminalNode) branchTuples.rtnLeftTuple.getTupleSink();
        }
        ConditionalExecution conditionalExecution = branchEvaluator.evaluate(leftTuple, activationsManager.getReteEvaluator(), cbm.context);
        RuleTerminalNode newRtn = null;
        boolean breaking = false;
        if (conditionalExecution != null) {
            newRtn = (RuleTerminalNode) conditionalExecution.getSink().getFirstLeftTupleSink();
            breaking = conditionalExecution.isBreaking();
        }
        if (oldRtn != null) {
            if (newRtn == null) {
                if (branchTuples.rtnLeftTuple.getMemory() != null) {
                    executor.removeLeftTuple(branchTuples.rtnLeftTuple);
                }
                PhreakRuleTerminalNode.doLeftDelete(activationsManager, executor, branchTuples.rtnLeftTuple);
            } else if (newRtn == oldRtn) {
                PhreakRuleTerminalNode.doLeftTupleUpdate(newRtn, executor, activationsManager, branchTuples.rtnLeftTuple);
            } else {
                if (branchTuples.rtnLeftTuple.getMemory() != null) {
                    executor.removeLeftTuple(branchTuples.rtnLeftTuple);
                }
                PhreakRuleTerminalNode.doLeftDelete(activationsManager, executor, branchTuples.rtnLeftTuple);
                branchTuples.rtnLeftTuple = newRtn.createLeftTuple(leftTuple, newRtn, leftTuple.getPropagationContext(), true);
                PhreakRuleTerminalNode.doLeftTupleInsert(newRtn, executor, activationsManager, executor.getRuleAgendaItem(), branchTuples.rtnLeftTuple);
            }
        } else if (newRtn != null) {
            branchTuples.rtnLeftTuple = newRtn.createLeftTuple(leftTuple, newRtn, leftTuple.getPropagationContext(), true);
            PhreakRuleTerminalNode.doLeftTupleInsert(newRtn, executor, activationsManager, executor.getRuleAgendaItem(), branchTuples.rtnLeftTuple);
        }
        if (branchTuples.mainLeftTuple != null) {
            normalizeStagedTuples(stagedLeftTuples, branchTuples.mainLeftTuple);
            if (!breaking) {
                trgLeftTuples.addUpdate(branchTuples.mainLeftTuple);
            } else {
                trgLeftTuples.addDelete(branchTuples.mainLeftTuple);
            }
        } else if (!breaking) {
            trgLeftTuples.addInsert(sink.createLeftTuple(leftTuple, sink, leftTuple.getPropagationContext(), true));
        }
        leftTuple.clearStaged();
        leftTuple = next;
    }
}",java:S107,1
"public void doLeftUpdates(ExistsNode existsNode, LeftTupleSink sink, BetaMemory bm, ReteEvaluator reteEvaluator, TupleSets<LeftTuple> srcLeftTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples){
    TupleMemory ltm = bm.getLeftTupleMemory();
    TupleMemory rtm = bm.getRightTupleMemory();
    ContextEntry[] contextEntry = bm.getContext();
    BetaConstraints constraints = existsNode.getRawConstraints();
    boolean leftUpdateOptimizationAllowed = existsNode.isLeftUpdateOptimizationAllowed();
    for (LeftTuple leftTuple = srcLeftTuples.getUpdateFirst(); leftTuple != null; ) {
        LeftTuple next = leftTuple.getStagedNext();
        FastIterator rightIt = existsNode.getRightIterator(rtm);
        RightTuple firstRightTuple = existsNode.getFirstRightTuple(leftTuple, rtm, rightIt);
        RightTuple blocker = leftTuple.getBlocker();
        if (blocker == null) {
            if (leftTuple.getMemory() != null) {
                ltm.remove(leftTuple);
            }
        } else {
            if (rtm.isIndexed() && !rightIt.isFullIterator()) {
                if (firstRightTuple == null || firstRightTuple.getMemory() != blocker.getMemory()) {
                    blocker.removeBlocked(leftTuple);
                    blocker = null;
                }
            }
        }
        constraints.updateFromTuple(contextEntry, reteEvaluator, leftTuple);
        if (!leftUpdateOptimizationAllowed && blocker != null) {
            blocker.removeBlocked(leftTuple);
            blocker = null;
        }
        if (blocker == null || !constraints.isAllowedCachedLeft(contextEntry, blocker.getFactHandleForEvaluation())) {
            if (blocker != null) {
                blocker.removeBlocked(leftTuple);
            }
            for (RightTuple newBlocker = firstRightTuple; newBlocker != null; newBlocker = (RightTuple) rightIt.next(newBlocker)) {
                if (constraints.isAllowedCachedLeft(contextEntry, newBlocker.getFactHandleForEvaluation())) {
                    leftTuple.setBlocker(newBlocker);
                    newBlocker.addBlocked(leftTuple);
                    break;
                }
            }
        }
        if (leftTuple.getBlocker() == null) {
            ltm.add(leftTuple);
            if (leftTuple.getFirstChild() != null) {
                RuleNetworkEvaluator.unlinkAndDeleteChildLeftTuple(leftTuple.getFirstChild(), trgLeftTuples, stagedLeftTuples);
            }
        } else if (leftTuple.getFirstChild() == null) {
            insertChildLeftTuple(sink, trgLeftTuples, leftTuple, leftTuple.getBlocker().getPropagationContext(), true);
        } else {
            LeftTuple childLeftTuple = leftTuple.getFirstChild();
            while (childLeftTuple != null) {
                childLeftTuple.setPropagationContext(leftTuple.getBlocker().getPropagationContext());
                updateChildLeftTuple(childLeftTuple, stagedLeftTuples, trgLeftTuples);
                childLeftTuple.reAddRight();
                childLeftTuple = childLeftTuple.getHandleNext();
            }
        }
        leftTuple.clearStaged();
        leftTuple = next;
    }
    constraints.resetTuple(contextEntry);
}",java:S3776,39
"public void doRightUpdates(ExistsNode existsNode, LeftTupleSink sink, BetaMemory bm, ReteEvaluator reteEvaluator, TupleSets<RightTuple> srcRightTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples){
    TupleMemory ltm = bm.getLeftTupleMemory();
    TupleMemory rtm = bm.getRightTupleMemory();
    ContextEntry[] contextEntry = bm.getContext();
    BetaConstraints constraints = existsNode.getRawConstraints();
    boolean iterateFromStart = existsNode.isIndexedUnificationJoin() || rtm.getIndexType().isComparison();
    for (RightTuple rightTuple = srcRightTuples.getUpdateFirst(); rightTuple != null; ) {
        RightTuple next = rightTuple.getStagedNext();
        if (ltm != null && ltm.size() > 0) {
            FastIterator leftIt = existsNode.getLeftIterator(ltm);
            LeftTuple firstLeftTuple = existsNode.getFirstLeftTuple(rightTuple, ltm, leftIt);
            constraints.updateFromFactHandle(contextEntry, reteEvaluator, rightTuple.getFactHandleForEvaluation());
            for (LeftTuple leftTuple = firstLeftTuple; leftTuple != null; ) {
                LeftTuple temp = (LeftTuple) leftIt.next(leftTuple);
                if (leftTuple.getStagedType() == LeftTuple.UPDATE) {
                    leftTuple = temp;
                    continue;
                }
                if (constraints.isAllowedCachedRight(contextEntry, leftTuple)) {
                    leftTuple.setBlocker(rightTuple);
                    rightTuple.addBlocked(leftTuple);
                    ltm.remove(leftTuple);
                    insertChildLeftTuple(sink, trgLeftTuples, leftTuple, rightTuple.getPropagationContext(), true);
                }
                leftTuple = temp;
            }
        }
        LeftTuple firstBlocked = rightTuple.getTempBlocked();
        if (firstBlocked != null) {
            RightTuple rootBlocker = rightTuple.getTempNextRightTuple();
            if (rootBlocker == null) {
                iterateFromStart = true;
            }
            FastIterator rightIt = existsNode.getRightIterator(rtm);
            for (LeftTuple leftTuple = firstBlocked; leftTuple != null; ) {
                LeftTuple temp = leftTuple.getBlockedNext();
                leftTuple.clearBlocker();
                if (leftTuple.getStagedType() == LeftTuple.UPDATE) {
                    leftTuple.setBlocker(rightTuple);
                    rightTuple.addBlocked(leftTuple);
                    leftTuple = temp;
                    continue;
                }
                constraints.updateFromTuple(contextEntry, reteEvaluator, leftTuple);
                if (iterateFromStart) {
                    rootBlocker = existsNode.getFirstRightTuple(leftTuple, rtm, rightIt);
                }
                for (RightTuple newBlocker = rootBlocker; newBlocker != null; newBlocker = (RightTuple) rightIt.next(newBlocker)) {
                    if (leftTuple.getStagedType() != LeftTuple.DELETE && newBlocker.getStagedType() != LeftTuple.DELETE && constraints.isAllowedCachedLeft(contextEntry, newBlocker.getFactHandleForEvaluation())) {
                        leftTuple.setBlocker(newBlocker);
                        newBlocker.addBlocked(leftTuple);
                        break;
                    }
                }
                if (leftTuple.getBlocker() == null) {
                    if (ltm != null) {
                        ltm.add(leftTuple);
                    }
                    LeftTuple childLeftTuple = leftTuple.getFirstChild();
                    if (childLeftTuple != null) {
                        childLeftTuple.setPropagationContext(rightTuple.getPropagationContext());
                        RuleNetworkEvaluator.unlinkAndDeleteChildLeftTuple(childLeftTuple, trgLeftTuples, stagedLeftTuples);
                    }
                }
                leftTuple = temp;
            }
        }
        rightTuple.clearStaged();
        rightTuple = next;
    }
    constraints.resetFactHandle(contextEntry);
}",java:S3776,39
"public void doRightDeletes(ExistsNode existsNode, BetaMemory bm, ReteEvaluator reteEvaluator, TupleSets<RightTuple> srcRightTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples){
    TupleMemory rtm = bm.getRightTupleMemory();
    TupleMemory ltm = bm.getLeftTupleMemory();
    ContextEntry[] contextEntry = bm.getContext();
    BetaConstraints constraints = existsNode.getRawConstraints();
    for (RightTuple rightTuple = srcRightTuples.getDeleteFirst(); rightTuple != null; ) {
        RightTuple next = rightTuple.getStagedNext();
        if (rightTuple.getMemory() != null) {
            rtm.remove(rightTuple);
        }
        if (rightTuple.getBlocked() != null) {
            FastIterator it = existsNode.getRightIterator(rtm);
            for (LeftTuple leftTuple = rightTuple.getBlocked(); leftTuple != null; ) {
                LeftTuple temp = leftTuple.getBlockedNext();
                leftTuple.clearBlocker();
                if (leftTuple.getStagedType() == LeftTuple.UPDATE) {
                    leftTuple = temp;
                    continue;
                }
                constraints.updateFromTuple(contextEntry, reteEvaluator, leftTuple);
                RightTuple rootBlocker = (RightTuple) rtm.getFirst(leftTuple);
                for (RightTuple newBlocker = rootBlocker; newBlocker != null; newBlocker = (RightTuple) it.next(newBlocker)) {
                    if (!newBlocker.isDeleted() && constraints.isAllowedCachedLeft(contextEntry, newBlocker.getFactHandleForEvaluation())) {
                        leftTuple.setBlocker(newBlocker);
                        newBlocker.addBlocked(leftTuple);
                        break;
                    }
                }
                if (leftTuple.getBlocker() == null) {
                    ltm.add(leftTuple);
                    LeftTuple childLeftTuple = leftTuple.getFirstChild();
                    if (childLeftTuple != null) {
                        childLeftTuple.setPropagationContext(rightTuple.getPropagationContext());
                        RuleNetworkEvaluator.unlinkAndDeleteChildLeftTuple(childLeftTuple, trgLeftTuples, stagedLeftTuples);
                    }
                }
                leftTuple = temp;
            }
        }
        rightTuple.setBlocked(null);
        rightTuple.clearStaged();
        rightTuple = next;
    }
}",java:S3776,39
"public void doLeftUpdates(FromNode fromNode, FromMemory fm, LeftTupleSink sink, ReteEvaluator reteEvaluator, TupleSets<LeftTuple> srcLeftTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples){
    BetaMemory bm = fm.getBetaMemory();
    ContextEntry[] context = bm.getContext();
    BetaConstraints betaConstraints = fromNode.getBetaConstraints();
    AlphaNodeFieldConstraint[] alphaConstraints = fromNode.getAlphaConstraints();
    DataProvider dataProvider = fromNode.getDataProvider();
    Class<?> resultClass = fromNode.getResultClass();
    for (LeftTuple leftTuple = srcLeftTuples.getUpdateFirst(); leftTuple != null; ) {
        LeftTuple next = leftTuple.getStagedNext();
        PropagationContext propagationContext = leftTuple.getPropagationContext();
        final Map<Object, RightTuple> previousMatches = (Map<Object, RightTuple>) leftTuple.getContextObject();
        final Map<Object, RightTuple> newMatches = new HashMap<>();
        leftTuple.setContextObject(newMatches);
        betaConstraints.updateFromTuple(context, reteEvaluator, leftTuple);
        FastIterator rightIt = LinkedList.fastIterator;
        for (final java.util.Iterator<?> it = dataProvider.getResults(leftTuple, reteEvaluator, fm.providerContext); it.hasNext(); ) {
            final Object object = it.next();
            if ((object == null) || !resultClass.isAssignableFrom(object.getClass())) {
                continue;
            }
            RightTuple rightTuple = previousMatches.remove(object);
            if (rightTuple == null) {
                rightTuple = fromNode.createRightTuple(leftTuple, propagationContext, reteEvaluator, object);
            } else {
                if (rightIt.next(rightTuple) != null) {
                    previousMatches.put(object, (RightTuple) rightIt.next(rightTuple));
                    rightTuple.setNext(null);
                }
            }
            if (isAllowed(rightTuple.getFactHandle(), alphaConstraints, reteEvaluator, fm)) {
                propagate(sink, leftTuple, rightTuple, betaConstraints, propagationContext, context, true, trgLeftTuples, stagedLeftTuples);
                fromNode.addToCreatedHandlesMap(newMatches, rightTuple);
            } else {
                deleteChildLeftTuple(propagationContext, trgLeftTuples, stagedLeftTuples, rightTuple.getFirstChild());
            }
        }
        for (RightTuple rightTuple : previousMatches.values()) {
            for (RightTuple current = rightTuple; current != null; current = (RightTuple) rightIt.next(current)) {
                deleteChildLeftTuple(propagationContext, trgLeftTuples, stagedLeftTuples, current.getFirstChild());
            }
        }
        leftTuple.clearStaged();
        leftTuple = next;
    }
    betaConstraints.resetTuple(context);
}",java:S3776,39
"public static void propagate(LeftTupleSink sink, Tuple leftTuple, RightTuple rightTuple, BetaConstraints betaConstraints, PropagationContext propagationContext, ContextEntry[] context, boolean useLeftMemory, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples){
    if (betaConstraints.isAllowedCachedLeft(context, rightTuple.getFactHandleForEvaluation())) {
        if (rightTuple.getFirstChild() == null) {
            LeftTuple childLeftTuple = sink.createLeftTuple((LeftTuple) leftTuple, rightTuple, null, null, sink, useLeftMemory);
            childLeftTuple.setPropagationContext(propagationContext);
            trgLeftTuples.addInsert(childLeftTuple);
        } else {
            LeftTuple childLeftTuple = rightTuple.getFirstChild();
            childLeftTuple.setPropagationContext(propagationContext);
            updateChildLeftTuple(childLeftTuple, stagedLeftTuples, trgLeftTuples);
        }
    } else {
        deleteChildLeftTuple(propagationContext, trgLeftTuples, stagedLeftTuples, rightTuple.getFirstChild());
    }
}",java:S107,1
" void postAccumulate(AccumulateNode accNode, Object accctx, LeftTuple match){
    ((GroupByContext) accctx).addMatchOnLastTupleList(match);
}",java:S1161,11
"public void doRightInserts(JoinNode joinNode, LeftTupleSink sink, BetaMemory bm, ReteEvaluator reteEvaluator, TupleSets<RightTuple> srcRightTuples, TupleSets<LeftTuple> trgLeftTuples){
    TupleMemory ltm = bm.getLeftTupleMemory();
    TupleMemory rtm = bm.getRightTupleMemory();
    ContextEntry[] contextEntry = bm.getContext();
    BetaConstraints constraints = joinNode.getRawConstraints();
    if (srcRightTuples.getInsertSize() > 32 && rtm instanceof AbstractHashTable) {
        ((AbstractHashTable) rtm).ensureCapacity(srcRightTuples.getInsertSize());
    }
    for (RightTuple rightTuple = srcRightTuples.getInsertFirst(); rightTuple != null; ) {
        RightTuple next = rightTuple.getStagedNext();
        rtm.add(rightTuple);
        if (ltm != null && ltm.size() > 0) {
            FastIterator it = joinNode.getLeftIterator(ltm);
            constraints.updateFromFactHandle(contextEntry, reteEvaluator, rightTuple.getFactHandleForEvaluation());
            for (LeftTuple leftTuple = joinNode.getFirstLeftTuple(rightTuple, ltm, it); leftTuple != null; leftTuple = (LeftTuple) it.next(leftTuple)) {
                if (leftTuple.getStagedType() == LeftTuple.UPDATE) {
                    continue;
                }
                if (constraints.isAllowedCachedRight(contextEntry, leftTuple)) {
                    insertChildLeftTuple(trgLeftTuples, leftTuple, rightTuple, null, null, sink, true);
                }
            }
        }
        rightTuple.clearStaged();
        rightTuple = next;
    }
    constraints.resetFactHandle(contextEntry);
}",java:S3776,39
"public LeftTuple doLeftUpdatesProcessChildren(LeftTuple childLeftTuple, LeftTuple leftTuple, RightTuple rightTuple, TupleSets<LeftTuple> stagedLeftTuples, ContextEntry[] contextEntry, BetaConstraints constraints, LeftTupleSink sink, FastIterator it, TupleSets<LeftTuple> trgLeftTuples){
    if (childLeftTuple == null) {
        for (; rightTuple != null; rightTuple = (RightTuple) it.next(rightTuple)) {
            if (constraints.isAllowedCachedLeft(contextEntry, rightTuple.getFactHandle())) {
                insertChildLeftTuple(trgLeftTuples, leftTuple, rightTuple, null, null, sink, true);
            }
        }
    } else {
        for (; rightTuple != null; rightTuple = (RightTuple) it.next(rightTuple)) {
            if (constraints.isAllowedCachedLeft(contextEntry, rightTuple.getFactHandle())) {
                if (childLeftTuple == null || childLeftTuple.getRightParent() != rightTuple) {
                    insertChildLeftTuple(trgLeftTuples, leftTuple, rightTuple, childLeftTuple, null, sink, true);
                } else {
                    childLeftTuple.setPropagationContext(rightTuple.getPropagationContext());
                    updateChildLeftTuple(childLeftTuple, stagedLeftTuples, trgLeftTuples);
                    LeftTuple nextChildLeftTuple = childLeftTuple.getHandleNext();
                    childLeftTuple.reAddRight();
                    childLeftTuple = nextChildLeftTuple;
                }
            } else if (childLeftTuple != null && childLeftTuple.getRightParent() == rightTuple) {
                LeftTuple nextChild = childLeftTuple.getHandleNext();
                RuleNetworkEvaluator.unlinkAndDeleteChildLeftTuple(childLeftTuple, trgLeftTuples, stagedLeftTuples);
                childLeftTuple = nextChild;
            }
        }
    }
    return childLeftTuple;
}",java:S3776,39
"public LeftTuple doLeftUpdatesProcessChildren(LeftTuple childLeftTuple, LeftTuple leftTuple, RightTuple rightTuple, TupleSets<LeftTuple> stagedLeftTuples, ContextEntry[] contextEntry, BetaConstraints constraints, LeftTupleSink sink, FastIterator it, TupleSets<LeftTuple> trgLeftTuples){
    if (childLeftTuple == null) {
        for (; rightTuple != null; rightTuple = (RightTuple) it.next(rightTuple)) {
            if (constraints.isAllowedCachedLeft(contextEntry, rightTuple.getFactHandle())) {
                insertChildLeftTuple(trgLeftTuples, leftTuple, rightTuple, null, null, sink, true);
            }
        }
    } else {
        for (; rightTuple != null; rightTuple = (RightTuple) it.next(rightTuple)) {
            if (constraints.isAllowedCachedLeft(contextEntry, rightTuple.getFactHandle())) {
                if (childLeftTuple == null || childLeftTuple.getRightParent() != rightTuple) {
                    insertChildLeftTuple(trgLeftTuples, leftTuple, rightTuple, childLeftTuple, null, sink, true);
                } else {
                    childLeftTuple.setPropagationContext(rightTuple.getPropagationContext());
                    updateChildLeftTuple(childLeftTuple, stagedLeftTuples, trgLeftTuples);
                    LeftTuple nextChildLeftTuple = childLeftTuple.getHandleNext();
                    childLeftTuple.reAddRight();
                    childLeftTuple = nextChildLeftTuple;
                }
            } else if (childLeftTuple != null && childLeftTuple.getRightParent() == rightTuple) {
                LeftTuple nextChild = childLeftTuple.getHandleNext();
                RuleNetworkEvaluator.unlinkAndDeleteChildLeftTuple(childLeftTuple, trgLeftTuples, stagedLeftTuples);
                childLeftTuple = nextChild;
            }
        }
    }
    return childLeftTuple;
}",java:S107,1
"public void doRightUpdates(JoinNode joinNode, LeftTupleSink sink, BetaMemory bm, ReteEvaluator reteEvaluator, TupleSets<RightTuple> srcRightTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples){
    TupleMemory ltm = bm.getLeftTupleMemory();
    ContextEntry[] contextEntry = bm.getContext();
    BetaConstraints constraints = joinNode.getRawConstraints();
    for (RightTuple rightTuple = srcRightTuples.getUpdateFirst(); rightTuple != null; ) {
        RightTuple next = rightTuple.getStagedNext();
        if (ltm != null && ltm.size() > 0) {
            FastIterator it = joinNode.getLeftIterator(ltm);
            LeftTuple leftTuple = joinNode.getFirstLeftTuple(rightTuple, ltm, it);
            constraints.updateFromFactHandle(contextEntry, reteEvaluator, rightTuple.getFactHandleForEvaluation());
            LeftTuple childLeftTuple = rightTuple.getFirstChild();
            if (childLeftTuple != null && ltm.isIndexed() && !it.isFullIterator() && (leftTuple == null || (leftTuple.getMemory() != childLeftTuple.getLeftParent().getMemory()))) {
                while (childLeftTuple != null) {
                    childLeftTuple.setPropagationContext(rightTuple.getPropagationContext());
                    LeftTuple nextChild = childLeftTuple.getRightParentNext();
                    RuleNetworkEvaluator.unlinkAndDeleteChildLeftTuple(childLeftTuple, trgLeftTuples, stagedLeftTuples);
                    childLeftTuple = nextChild;
                }
            }
            if (leftTuple != null) {
                doRightUpdatesProcessChildren(childLeftTuple, leftTuple, rightTuple, stagedLeftTuples, contextEntry, constraints, sink, it, trgLeftTuples);
            }
        }
        rightTuple.clearStaged();
        rightTuple = next;
    }
    constraints.resetFactHandle(contextEntry);
}",java:S3776,39
"public LeftTuple doRightUpdatesProcessChildren(LeftTuple childLeftTuple, LeftTuple leftTuple, RightTuple rightTuple, TupleSets<LeftTuple> stagedLeftTuples, ContextEntry[] contextEntry, BetaConstraints constraints, LeftTupleSink sink, FastIterator it, TupleSets<LeftTuple> trgLeftTuples){
    if (childLeftTuple == null) {
        for (; leftTuple != null; leftTuple = (LeftTuple) it.next(leftTuple)) {
            if (leftTuple.getStagedType() == LeftTuple.UPDATE) {
                continue;
            }
            if (constraints.isAllowedCachedRight(contextEntry, leftTuple)) {
                insertChildLeftTuple(trgLeftTuples, leftTuple, rightTuple, null, null, sink, true);
            }
        }
    } else {
        for (; leftTuple != null; leftTuple = (LeftTuple) it.next(leftTuple)) {
            if (leftTuple.getStagedType() == LeftTuple.UPDATE) {
                continue;
            }
            if (constraints.isAllowedCachedRight(contextEntry, leftTuple)) {
                if (childLeftTuple == null || childLeftTuple.getLeftParent() != leftTuple) {
                    insertChildLeftTuple(trgLeftTuples, leftTuple, rightTuple, null, childLeftTuple, sink, true);
                } else {
                    childLeftTuple.setPropagationContext(rightTuple.getPropagationContext());
                    updateChildLeftTuple(childLeftTuple, stagedLeftTuples, trgLeftTuples);
                    LeftTuple nextChildLeftTuple = childLeftTuple.getRightParentNext();
                    childLeftTuple.reAddLeft();
                    childLeftTuple = nextChildLeftTuple;
                }
            } else if (childLeftTuple != null && childLeftTuple.getLeftParent() == leftTuple) {
                childLeftTuple.setPropagationContext(rightTuple.getPropagationContext());
                LeftTuple nextChild = childLeftTuple.getRightParentNext();
                RuleNetworkEvaluator.unlinkAndDeleteChildLeftTuple(childLeftTuple, trgLeftTuples, stagedLeftTuples);
                childLeftTuple = nextChild;
            }
        }
    }
    return childLeftTuple;
}",java:S3776,39
"public LeftTuple doRightUpdatesProcessChildren(LeftTuple childLeftTuple, LeftTuple leftTuple, RightTuple rightTuple, TupleSets<LeftTuple> stagedLeftTuples, ContextEntry[] contextEntry, BetaConstraints constraints, LeftTupleSink sink, FastIterator it, TupleSets<LeftTuple> trgLeftTuples){
    if (childLeftTuple == null) {
        for (; leftTuple != null; leftTuple = (LeftTuple) it.next(leftTuple)) {
            if (leftTuple.getStagedType() == LeftTuple.UPDATE) {
                continue;
            }
            if (constraints.isAllowedCachedRight(contextEntry, leftTuple)) {
                insertChildLeftTuple(trgLeftTuples, leftTuple, rightTuple, null, null, sink, true);
            }
        }
    } else {
        for (; leftTuple != null; leftTuple = (LeftTuple) it.next(leftTuple)) {
            if (leftTuple.getStagedType() == LeftTuple.UPDATE) {
                continue;
            }
            if (constraints.isAllowedCachedRight(contextEntry, leftTuple)) {
                if (childLeftTuple == null || childLeftTuple.getLeftParent() != leftTuple) {
                    insertChildLeftTuple(trgLeftTuples, leftTuple, rightTuple, null, childLeftTuple, sink, true);
                } else {
                    childLeftTuple.setPropagationContext(rightTuple.getPropagationContext());
                    updateChildLeftTuple(childLeftTuple, stagedLeftTuples, trgLeftTuples);
                    LeftTuple nextChildLeftTuple = childLeftTuple.getRightParentNext();
                    childLeftTuple.reAddLeft();
                    childLeftTuple = nextChildLeftTuple;
                }
            } else if (childLeftTuple != null && childLeftTuple.getLeftParent() == leftTuple) {
                childLeftTuple.setPropagationContext(rightTuple.getPropagationContext());
                LeftTuple nextChild = childLeftTuple.getRightParentNext();
                RuleNetworkEvaluator.unlinkAndDeleteChildLeftTuple(childLeftTuple, trgLeftTuples, stagedLeftTuples);
                childLeftTuple = nextChild;
            }
        }
    }
    return childLeftTuple;
}",java:S107,1
"public void doLeftUpdates(NotNode notNode, LeftTupleSink sink, BetaMemory bm, ReteEvaluator reteEvaluator, TupleSets<LeftTuple> srcLeftTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples){
    TupleMemory ltm = bm.getLeftTupleMemory();
    TupleMemory rtm = bm.getRightTupleMemory();
    ContextEntry[] contextEntry = bm.getContext();
    BetaConstraints constraints = notNode.getRawConstraints();
    boolean leftUpdateOptimizationAllowed = notNode.isLeftUpdateOptimizationAllowed();
    for (LeftTuple leftTuple = srcLeftTuples.getUpdateFirst(); leftTuple != null; ) {
        LeftTuple next = leftTuple.getStagedNext();
        FastIterator rightIt = notNode.getRightIterator(rtm);
        RightTuple firstRightTuple = notNode.getFirstRightTuple(leftTuple, rtm, rightIt);
        RightTuple blocker = leftTuple.getBlocker();
        if (blocker == null) {
            if (leftTuple.getMemory() != null) {
                ltm.remove(leftTuple);
            }
        } else {
            if (rtm.isIndexed() && !rightIt.isFullIterator()) {
                if (firstRightTuple == null || firstRightTuple.getMemory() != blocker.getMemory()) {
                    blocker.removeBlocked(leftTuple);
                    blocker = null;
                }
            }
        }
        constraints.updateFromTuple(contextEntry, reteEvaluator, leftTuple);
        if (!leftUpdateOptimizationAllowed && blocker != null) {
            blocker.removeBlocked(leftTuple);
            blocker = null;
        }
        if (blocker == null || !constraints.isAllowedCachedLeft(contextEntry, blocker.getFactHandleForEvaluation())) {
            if (blocker != null) {
                blocker.removeBlocked(leftTuple);
            }
            for (RightTuple newBlocker = firstRightTuple; newBlocker != null; newBlocker = (RightTuple) rightIt.next(newBlocker)) {
                if (constraints.isAllowedCachedLeft(contextEntry, newBlocker.getFactHandleForEvaluation())) {
                    leftTuple.setBlocker(newBlocker);
                    newBlocker.addBlocked(leftTuple);
                    break;
                }
            }
            LeftTuple childLeftTuple = leftTuple.getFirstChild();
            if (leftTuple.getBlocker() != null) {
                if (childLeftTuple != null) {
                    childLeftTuple.setPropagationContext(leftTuple.getBlocker().getPropagationContext());
                    RuleNetworkEvaluator.unlinkAndDeleteChildLeftTuple(childLeftTuple, trgLeftTuples, stagedLeftTuples);
                }
            } else if (childLeftTuple == null) {
                insertChildLeftTuple(sink, trgLeftTuples, ltm, leftTuple, leftTuple.getPropagationContext(), true);
            } else {
                updateChildLeftTuple(childLeftTuple, stagedLeftTuples, trgLeftTuples);
                ltm.add(leftTuple);
                childLeftTuple.reAddLeft();
            }
        }
        leftTuple.clearStaged();
        leftTuple = next;
    }
    constraints.resetTuple(contextEntry);
}",java:S3776,39
"public void doRightUpdates(NotNode notNode, LeftTupleSink sink, BetaMemory bm, ReteEvaluator reteEvaluator, TupleSets<RightTuple> srcRightTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples){
    TupleMemory ltm = bm.getLeftTupleMemory();
    TupleMemory rtm = bm.getRightTupleMemory();
    ContextEntry[] contextEntry = bm.getContext();
    BetaConstraints constraints = notNode.getRawConstraints();
    boolean iterateFromStart = notNode.isIndexedUnificationJoin() || rtm.getIndexType().isComparison();
    for (RightTuple rightTuple = srcRightTuples.getUpdateFirst(); rightTuple != null; ) {
        RightTuple next = rightTuple.getStagedNext();
        if (ltm != null && ltm.size() > 0) {
            constraints.updateFromFactHandle(contextEntry, reteEvaluator, rightTuple.getFactHandleForEvaluation());
            FastIterator leftIt = notNode.getLeftIterator(ltm);
            LeftTuple firstLeftTuple = notNode.getFirstLeftTuple(rightTuple, ltm, leftIt);
            for (LeftTuple leftTuple = firstLeftTuple; leftTuple != null; ) {
                LeftTuple temp = (LeftTuple) leftIt.next(leftTuple);
                if (leftTuple.getStagedType() == LeftTuple.UPDATE) {
                    leftTuple = temp;
                    continue;
                }
                if (constraints.isAllowedCachedRight(contextEntry, leftTuple)) {
                    leftTuple.setBlocker(rightTuple);
                    rightTuple.addBlocked(leftTuple);
                    ltm.remove(leftTuple);
                    LeftTuple childLeftTuple = leftTuple.getFirstChild();
                    if (childLeftTuple != null) {
                        childLeftTuple.setPropagationContext(rightTuple.getPropagationContext());
                        RuleNetworkEvaluator.unlinkAndDeleteChildLeftTuple(childLeftTuple, trgLeftTuples, stagedLeftTuples);
                    }
                }
                leftTuple = temp;
            }
        }
        iterateFromStart = updateBlockersAndPropagate(notNode, rightTuple, reteEvaluator, rtm, contextEntry, constraints, iterateFromStart, sink, trgLeftTuples, ltm);
        rightTuple.clearStaged();
        rightTuple = next;
    }
    constraints.resetFactHandle(contextEntry);
    constraints.resetTuple(contextEntry);
}",java:S3776,39
"public static boolean updateBlockersAndPropagate(NotNode notNode, RightTuple rightTuple, ReteEvaluator reteEvaluator, TupleMemory rtm, ContextEntry[] contextEntry, BetaConstraints constraints, boolean iterateFromStart, LeftTupleSink sink, TupleSets<LeftTuple> trgLeftTuples, TupleMemory ltm){
    LeftTuple firstBlocked = rightTuple.getTempBlocked();
    if (firstBlocked != null) {
        RightTuple rootBlocker = rightTuple.getTempNextRightTuple();
        if (rootBlocker == null) {
            iterateFromStart = true;
        }
        FastIterator rightIt = notNode.getRightIterator(rtm);
        for (LeftTuple leftTuple = firstBlocked; leftTuple != null; ) {
            LeftTuple temp = leftTuple.getBlockedNext();
            leftTuple.clearBlocker();
            if (leftTuple.getStagedType() == LeftTuple.UPDATE) {
                leftTuple.setBlocker(rightTuple);
                rightTuple.addBlocked(leftTuple);
                leftTuple = temp;
                continue;
            }
            constraints.updateFromTuple(contextEntry, reteEvaluator, leftTuple);
            if (iterateFromStart) {
                rootBlocker = notNode.getFirstRightTuple(leftTuple, rtm, rightIt);
            }
            for (RightTuple newBlocker = rootBlocker; newBlocker != null; newBlocker = (RightTuple) rightIt.next(newBlocker)) {
                if (leftTuple.getStagedType() != LeftTuple.DELETE && newBlocker.getStagedType() != LeftTuple.DELETE && constraints.isAllowedCachedLeft(contextEntry, newBlocker.getFactHandleForEvaluation())) {
                    leftTuple.setBlocker(newBlocker);
                    newBlocker.addBlocked(leftTuple);
                    break;
                }
            }
            if (trgLeftTuples != null && leftTuple.getBlocker() == null) {
                insertChildLeftTuple(sink, trgLeftTuples, ltm, leftTuple, rightTuple.getPropagationContext(), true);
            }
            leftTuple = temp;
        }
    }
    return iterateFromStart;
}",java:S3776,39
"public static boolean updateBlockersAndPropagate(NotNode notNode, RightTuple rightTuple, ReteEvaluator reteEvaluator, TupleMemory rtm, ContextEntry[] contextEntry, BetaConstraints constraints, boolean iterateFromStart, LeftTupleSink sink, TupleSets<LeftTuple> trgLeftTuples, TupleMemory ltm){
    LeftTuple firstBlocked = rightTuple.getTempBlocked();
    if (firstBlocked != null) {
        RightTuple rootBlocker = rightTuple.getTempNextRightTuple();
        if (rootBlocker == null) {
            iterateFromStart = true;
        }
        FastIterator rightIt = notNode.getRightIterator(rtm);
        for (LeftTuple leftTuple = firstBlocked; leftTuple != null; ) {
            LeftTuple temp = leftTuple.getBlockedNext();
            leftTuple.clearBlocker();
            if (leftTuple.getStagedType() == LeftTuple.UPDATE) {
                leftTuple.setBlocker(rightTuple);
                rightTuple.addBlocked(leftTuple);
                leftTuple = temp;
                continue;
            }
            constraints.updateFromTuple(contextEntry, reteEvaluator, leftTuple);
            if (iterateFromStart) {
                rootBlocker = notNode.getFirstRightTuple(leftTuple, rtm, rightIt);
            }
            for (RightTuple newBlocker = rootBlocker; newBlocker != null; newBlocker = (RightTuple) rightIt.next(newBlocker)) {
                if (leftTuple.getStagedType() != LeftTuple.DELETE && newBlocker.getStagedType() != LeftTuple.DELETE && constraints.isAllowedCachedLeft(contextEntry, newBlocker.getFactHandleForEvaluation())) {
                    leftTuple.setBlocker(newBlocker);
                    newBlocker.addBlocked(leftTuple);
                    break;
                }
            }
            if (trgLeftTuples != null && leftTuple.getBlocker() == null) {
                insertChildLeftTuple(sink, trgLeftTuples, ltm, leftTuple, rightTuple.getPropagationContext(), true);
            }
            leftTuple = temp;
        }
    }
    return iterateFromStart;
}",java:S107,1
"public void doRightDeletes(NotNode notNode, LeftTupleSink sink, BetaMemory bm, ReteEvaluator reteEvaluator, TupleSets<RightTuple> srcRightTuples, TupleSets<LeftTuple> trgLeftTuples){
    TupleMemory ltm = bm.getLeftTupleMemory();
    TupleMemory rtm = bm.getRightTupleMemory();
    ContextEntry[] contextEntry = bm.getContext();
    BetaConstraints constraints = notNode.getRawConstraints();
    for (RightTuple rightTuple = srcRightTuples.getDeleteFirst(); rightTuple != null; ) {
        RightTuple next = rightTuple.getStagedNext();
        if (rightTuple.getMemory() != null) {
            rtm.remove(rightTuple);
        }
        if (rightTuple.getBlocked() != null) {
            FastIterator it = notNode.getRightIterator(rtm);
            for (LeftTuple leftTuple = rightTuple.getBlocked(); leftTuple != null; ) {
                LeftTuple temp = leftTuple.getBlockedNext();
                leftTuple.clearBlocker();
                if (leftTuple.getStagedType() == LeftTuple.UPDATE) {
                    leftTuple = temp;
                    continue;
                }
                constraints.updateFromTuple(contextEntry, reteEvaluator, leftTuple);
                RightTuple rootBlocker = (RightTuple) rtm.getFirst(leftTuple);
                for (RightTuple newBlocker = rootBlocker; newBlocker != null; newBlocker = (RightTuple) it.next(newBlocker)) {
                    if (!newBlocker.isDeleted() && constraints.isAllowedCachedLeft(contextEntry, newBlocker.getFactHandleForEvaluation())) {
                        leftTuple.setBlocker(newBlocker);
                        newBlocker.addBlocked(leftTuple);
                        break;
                    }
                }
                if (leftTuple.getBlocker() == null) {
                    insertChildLeftTuple(sink, trgLeftTuples, ltm, leftTuple, rightTuple.getPropagationContext(), true);
                }
                leftTuple = temp;
            }
        }
        rightTuple.setBlocked(null);
        rightTuple.clearStaged();
        rightTuple = next;
    }
    constraints.resetTuple(contextEntry);
}",java:S3776,39
"public static void doLeftTupleUpdate(TerminalNode rtnNode, RuleExecutor executor, ActivationsManager activationsManager, LeftTuple leftTuple){
    RuleTerminalNodeLeftTuple rtnLeftTuple = (RuleTerminalNodeLeftTuple) leftTuple;
    ReteEvaluator reteEvaluator = activationsManager.getReteEvaluator();
    if (reteEvaluator.getRuleSessionConfiguration().isDirectFiring()) {
        if (!rtnLeftTuple.isQueued()) {
            executor.addLeftTuple(leftTuple);
            reteEvaluator.getRuleEventSupport().onUpdateMatch(rtnLeftTuple);
        }
        return;
    }
    PropagationContext pctx = leftTuple.findMostRecentPropagationContext();
    boolean blocked = false;
    if (executor.isDeclarativeAgendaEnabled()) {
        if (rtnLeftTuple.hasBlockers()) {
            blocked = true;
        }
    } else {
        blocked = rtnNode.getRule().isNoLoop() && rtnNode.equals(pctx.getTerminalNodeOrigin());
    }
    int salienceInt = getSalienceValue(rtnNode, executor.getRuleAgendaItem(), (InternalMatch) leftTuple, reteEvaluator);
    if (activationsManager.getActivationsFilter() != null && !activationsManager.getActivationsFilter().accept(rtnLeftTuple)) {
        return;
    }
    if (!blocked) {
        boolean addToExector = true;
        if (rtnNode.getRule().isLockOnActive() && pctx.getType() != PropagationContext.Type.RULE_ADDITION) {
            InternalAgendaGroup agendaGroup = executor.getRuleAgendaItem().getAgendaGroup();
            if (blockedByLockOnActive(rtnNode.getRule(), pctx, agendaGroup)) {
                addToExector = false;
            }
        }
        if (addToExector) {
            if (!rtnLeftTuple.isQueued()) {
                activationsManager.getAgendaEventSupport().fireActivationCreated(rtnLeftTuple, reteEvaluator);
                rtnLeftTuple.update(salienceInt, pctx);
                executor.addLeftTuple(leftTuple);
                reteEvaluator.getRuleEventSupport().onUpdateMatch(rtnLeftTuple);
            }
        }
    } else {
        rtnLeftTuple.update(salienceInt, pctx);
    }
    if (!rtnNode.isFireDirect() && executor.isDeclarativeAgendaEnabled()) {
        modifyActivation(reteEvaluator, rtnLeftTuple);
    }
}",java:S3776,39
"private static void updateLeft(TupleSets<LeftTuple> srcLeftTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples, TupleMemory ltm){
    for (LeftTuple leftTuple = srcLeftTuples.getUpdateFirst(); leftTuple != null; ) {
        LeftTuple next = leftTuple.getStagedNext();
        LeftTuple childLeftTuple = leftTuple.getFirstChild();
        if (!leftTuple.isExpired() && childLeftTuple != null && childLeftTuple.getStagedType() == Tuple.NONE) {
            childLeftTuple.setPropagationContext(leftTuple.getPropagationContext());
            updateChildLeftTuple(childLeftTuple, stagedLeftTuples, trgLeftTuples);
        }
        leftTuple.clearStaged();
        leftTuple = next;
    }
}",java:S1172,13
"private static void insertRight(BetaNode node, LeftTupleSink sink, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples, TupleSets<RightTuple> srcRightTuples, boolean tupleMemoryEnabled){
    if (srcRightTuples.getInsertFirst() != null) {
        for (RightTuple rightTuple = srcRightTuples.getInsertFirst(); rightTuple != null; ) {
            RightTuple next = rightTuple.getStagedNext();
            LeftTuple leftTuple = node.getStartTuple((SubnetworkTuple) rightTuple);
            TupleList<RightTuple> matches = (TupleList<RightTuple>) leftTuple.getContextObject();
            if (matches == null) {
                matches = new TupleList<>();
                leftTuple.setContextObject(matches);
            }
            matches.add(rightTuple);
            if (matches.size() == 1) {
                if (node.getType() == NodeTypeEnums.ExistsNode) {
                    if (!leftTuple.isExpired()) {
                        boolean useTupleMemory = tupleMemoryEnabled || RuleNetworkEvaluator.useLeftMemory(node, rightTuple);
                        trgLeftTuples.addInsert(sink.createLeftTuple(leftTuple, sink, leftTuple.getPropagationContext(), useTupleMemory));
                    }
                } else {
                    LeftTuple childLeftTuple = leftTuple.getFirstChild();
                    if (childLeftTuple != null) {
                        childLeftTuple.setPropagationContext(rightTuple.getPropagationContext());
                        RuleNetworkEvaluator.unlinkAndDeleteChildLeftTuple(childLeftTuple, trgLeftTuples, stagedLeftTuples);
                    }
                }
            }
            rightTuple.clearStaged();
            rightTuple = next;
        }
    }
}",java:S3776,39
"public void doNode(TimerNode timerNode, TimerNodeMemory tm, PathMemory pmem, SegmentMemory smem, LeftTupleSink sink, ActivationsManager activationsManager, TupleSets<LeftTuple> srcLeftTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples){
    if (srcLeftTuples.getDeleteFirst() != null) {
        doLeftDeletes(timerNode, tm, pmem, sink, activationsManager, srcLeftTuples, trgLeftTuples, stagedLeftTuples);
    }
    if (srcLeftTuples.getUpdateFirst() != null) {
        doLeftUpdates(timerNode, tm, pmem, smem, sink, activationsManager, srcLeftTuples, trgLeftTuples, stagedLeftTuples);
    }
    if (srcLeftTuples.getInsertFirst() != null) {
        doLeftInserts(timerNode, tm, pmem, smem, sink, activationsManager, srcLeftTuples, trgLeftTuples);
    }
    doPropagateChildLeftTuples(tm, sink, trgLeftTuples, stagedLeftTuples);
    srcLeftTuples.resetAll();
}",java:S107,1
"public void doLeftInserts(TimerNode timerNode, TimerNodeMemory tm, PathMemory pmem, SegmentMemory smem, LeftTupleSink sink, ActivationsManager activationsManager, TupleSets<LeftTuple> srcLeftTuples, TupleSets<LeftTuple> trgLeftTuples){
    Timer timer = timerNode.getTimer();
    TimerService timerService = activationsManager.getReteEvaluator().getTimerService();
    long timestamp = timerService.getCurrentTime();
    String[] calendarNames = timerNode.getCalendarNames();
    Calendars calendars = activationsManager.getReteEvaluator().getCalendars();
    for (LeftTuple leftTuple = srcLeftTuples.getInsertFirst(); leftTuple != null; ) {
        LeftTuple next = leftTuple.getStagedNext();
        scheduleLeftTuple(timerNode, tm, pmem, smem, sink, activationsManager, timer, timerService, timestamp, calendarNames, calendars, leftTuple, trgLeftTuples, null);
        leftTuple.clearStaged();
        leftTuple = next;
    }
}",java:S107,1
"public void doLeftUpdates(TimerNode timerNode, TimerNodeMemory tm, PathMemory pmem, SegmentMemory smem, LeftTupleSink sink, ActivationsManager activationsManager, TupleSets<LeftTuple> srcLeftTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples){
    Timer timer = timerNode.getTimer();
    TimerService timerService = activationsManager.getReteEvaluator().getTimerService();
    long timestamp = timerService.getCurrentTime();
    String[] calendarNames = timerNode.getCalendarNames();
    Calendars calendars = activationsManager.getReteEvaluator().getCalendars();
    for (LeftTuple leftTuple = srcLeftTuples.getUpdateFirst(); leftTuple != null; ) {
        LeftTuple next = leftTuple.getStagedNext();
        DefaultJobHandle jobHandle = (DefaultJobHandle) leftTuple.getContextObject();
        if (jobHandle != null) {
            timerService.removeJob(jobHandle);
        }
        scheduleLeftTuple(timerNode, tm, pmem, smem, sink, activationsManager, timer, timerService, timestamp, calendarNames, calendars, leftTuple, trgLeftTuples, stagedLeftTuples);
        leftTuple.clearStaged();
        leftTuple = next;
    }
}",java:S107,1
"public void doLeftDeletes(TimerNode timerNode, TimerNodeMemory tm, PathMemory pmem, LeftTupleSink sink, ActivationsManager activationsManager, TupleSets<LeftTuple> srcLeftTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples){
    TimerService timerService = activationsManager.getReteEvaluator().getTimerService();
    TupleList leftTuples = tm.getInsertOrUpdateLeftTuples();
    TupleList deletes = tm.getDeleteLeftTuples();
    if (!deletes.isEmpty()) {
        for (LeftTuple leftTuple = (LeftTuple) deletes.getFirst(); leftTuple != null; ) {
            LeftTuple next = (LeftTuple) leftTuple.getNext();
            srcLeftTuples.addDelete(leftTuple);
            if (log.isTraceEnabled()) {
                log.trace(""Timer Add Postponed Delete {}"", leftTuple);
            }
            leftTuple.clear();
            leftTuple = next;
        }
        deletes.clear();
    }
    for (LeftTuple leftTuple = srcLeftTuples.getDeleteFirst(); leftTuple != null; ) {
        LeftTuple next = leftTuple.getStagedNext();
        PropagationContext pctx = leftTuple.findMostRecentPropagationContext();
        Object obj = leftTuple.getContextObject();
        if (obj instanceof DefaultJobHandle) {
            timerService.removeJob((DefaultJobHandle) obj);
        } else if (obj instanceof TupleKey && pctx.getReaderContext() != null) {
            pctx.getReaderContext().removeTimerNodeScheduler(timerNode.getId(), (TupleKey) obj);
        }
        if (leftTuple.getMemory() != null) {
            leftTuples.remove(leftTuple);
            if (((InternalFactHandle) pctx.getFactHandle()).isExpired()) {
                doPropagateChildLeftTuple(sink, trgLeftTuples, stagedLeftTuples, leftTuple);
                tm.getDeleteLeftTuples().add(leftTuple);
                pmem.doLinkRule(activationsManager);
                if (log.isTraceEnabled()) {
                    log.trace(""Timer Postponed Delete {}"", leftTuple);
                }
            }
        }
        if (leftTuple.getMemory() == null) {
            LeftTuple childLeftTuple = leftTuple.getFirstChild();
            if (childLeftTuple != null) {
                childLeftTuple.setPropagationContext(leftTuple.getPropagationContext());
                RuleNetworkEvaluator.deleteChildLeftTuple(childLeftTuple, trgLeftTuples, stagedLeftTuples);
                if (log.isTraceEnabled()) {
                    log.trace(""Timer Delete {}"", leftTuple);
                }
            }
        }
        leftTuple.clearStaged();
        leftTuple = next;
    }
}",java:S3776,39
"public void doLeftDeletes(TimerNode timerNode, TimerNodeMemory tm, PathMemory pmem, LeftTupleSink sink, ActivationsManager activationsManager, TupleSets<LeftTuple> srcLeftTuples, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples){
    TimerService timerService = activationsManager.getReteEvaluator().getTimerService();
    TupleList leftTuples = tm.getInsertOrUpdateLeftTuples();
    TupleList deletes = tm.getDeleteLeftTuples();
    if (!deletes.isEmpty()) {
        for (LeftTuple leftTuple = (LeftTuple) deletes.getFirst(); leftTuple != null; ) {
            LeftTuple next = (LeftTuple) leftTuple.getNext();
            srcLeftTuples.addDelete(leftTuple);
            if (log.isTraceEnabled()) {
                log.trace(""Timer Add Postponed Delete {}"", leftTuple);
            }
            leftTuple.clear();
            leftTuple = next;
        }
        deletes.clear();
    }
    for (LeftTuple leftTuple = srcLeftTuples.getDeleteFirst(); leftTuple != null; ) {
        LeftTuple next = leftTuple.getStagedNext();
        PropagationContext pctx = leftTuple.findMostRecentPropagationContext();
        Object obj = leftTuple.getContextObject();
        if (obj instanceof DefaultJobHandle) {
            timerService.removeJob((DefaultJobHandle) obj);
        } else if (obj instanceof TupleKey && pctx.getReaderContext() != null) {
            pctx.getReaderContext().removeTimerNodeScheduler(timerNode.getId(), (TupleKey) obj);
        }
        if (leftTuple.getMemory() != null) {
            leftTuples.remove(leftTuple);
            if (((InternalFactHandle) pctx.getFactHandle()).isExpired()) {
                doPropagateChildLeftTuple(sink, trgLeftTuples, stagedLeftTuples, leftTuple);
                tm.getDeleteLeftTuples().add(leftTuple);
                pmem.doLinkRule(activationsManager);
                if (log.isTraceEnabled()) {
                    log.trace(""Timer Postponed Delete {}"", leftTuple);
                }
            }
        }
        if (leftTuple.getMemory() == null) {
            LeftTuple childLeftTuple = leftTuple.getFirstChild();
            if (childLeftTuple != null) {
                childLeftTuple.setPropagationContext(leftTuple.getPropagationContext());
                RuleNetworkEvaluator.deleteChildLeftTuple(childLeftTuple, trgLeftTuples, stagedLeftTuples);
                if (log.isTraceEnabled()) {
                    log.trace(""Timer Delete {}"", leftTuple);
                }
            }
        }
        leftTuple.clearStaged();
        leftTuple = next;
    }
}",java:S107,1
"private void scheduleLeftTuple(final TimerNode timerNode, final TimerNodeMemory tm, final PathMemory pmem, final SegmentMemory smem, final LeftTupleSink sink, final ActivationsManager activationsManager, final Timer timer, final TimerService timerService, final long timestamp, final String[] calendarNames, final Calendars calendars, final LeftTuple leftTuple, final TupleSets<LeftTuple> trgLeftTuples, final TupleSets<LeftTuple> stagedLeftTuples){
    ReteEvaluator reteEvaluator = activationsManager.getReteEvaluator();
    if (leftTuple.getPropagationContext().getReaderContext() == null) {
        final Trigger trigger = createTrigger(timerNode, reteEvaluator, timer, timestamp, calendarNames, calendars, leftTuple);
        scheduleTimer(timerNode, tm, smem, sink, reteEvaluator, timerService, timestamp, leftTuple, trgLeftTuples, stagedLeftTuples, trigger);
    } else {
        Scheduler scheduler = new Scheduler() {

            @Override
            public void schedule(Trigger t) {
                scheduleTimer(timerNode, tm, smem, sink, reteEvaluator, timerService, timestamp, leftTuple, trgLeftTuples, stagedLeftTuples, t);
                evaluate(pmem, activationsManager, sink, tm, trgLeftTuples);
            }

            @Override
            public Trigger getTrigger() {
                return createTrigger(timerNode, reteEvaluator, timer, timestamp, calendarNames, calendars, leftTuple);
            }
        };
        TupleKey key = TupleKey.createTupleKey(leftTuple);
        leftTuple.getPropagationContext().getReaderContext().addTimerNodeScheduler(timerNode.getId(), key, scheduler);
        leftTuple.setContextObject(key);
    }
}",java:S107,1
"private void scheduleTimer(TimerNode timerNode, TimerNodeMemory tm, SegmentMemory smem, LeftTupleSink sink, ReteEvaluator reteEvaluator, TimerService timerService, long timestamp, LeftTuple leftTuple, TupleSets<LeftTuple> trgLeftTuples, TupleSets<LeftTuple> stagedLeftTuples, Trigger trigger){
    if (trigger.hasNextFireTime() == null) {
        return;
    }
    if (trigger.hasNextFireTime().getTime() <= timestamp) {
        if (log.isTraceEnabled()) {
            log.trace(""Timer Fire Now {}"", leftTuple);
        }
        LeftTuple childLeftTuple = doPropagateChildLeftTuple(sink, trgLeftTuples, stagedLeftTuples, leftTuple);
        if (childLeftTuple.getStagedType() != LeftTuple.NONE) {
            childLeftTuple.setContextObject(Boolean.TRUE);
        }
        trigger.nextFireTime();
        Date nextFireTime = trigger.hasNextFireTime();
        if (nextFireTime != null && nextFireTime.getTime() <= timestamp) {
            throw new IllegalStateException(""Trigger.nextFireTime is not increasing"");
        }
    }
    if (trigger.hasNextFireTime() != null) {
        TimerNodeJob job = new TimerNodeJob();
        TimerNodeJobContext jobCtx = new TimerNodeJobContext(timerNode.getId(), trigger, leftTuple, tm, sink, smem.getPathMemories(), reteEvaluator);
        DefaultJobHandle jobHandle = (DefaultJobHandle) timerService.scheduleJob(job, jobCtx, trigger);
        leftTuple.setContextObject(jobHandle);
        if (log.isTraceEnabled()) {
            log.trace(""Timer Scheduled {}"", leftTuple);
        }
    }
}",java:S107,1
"public TupleSets<LeftTuple> evalNode(PathMemory pmem, NetworkNode node, long bit, Memory nodeMem, SegmentMemory[] smems, int smemIndex, ActivationsManager activationsManager, LinkedList<StackEntry> stack, boolean processRian, RuleExecutor executor, TupleSets<LeftTuple> srcTuples, SegmentMemory smem, TupleSets<LeftTuple> stagedLeftTuples, LeftTupleSinkNode sink){
    TupleSets<LeftTuple> trgTuples = new TupleSetsImpl<>();
    if (NodeTypeEnums.isBetaNode(node)) {
        boolean exitInnerEval = evalBetaNode(pmem, node, nodeMem, smems, smemIndex, trgTuples, activationsManager, stack, processRian, executor, srcTuples, stagedLeftTuples, sink);
        if (exitInnerEval) {
            return null;
        }
    } else {
        boolean exitInnerEval = false;
        switch(node.getType()) {
            case NodeTypeEnums.EvalConditionNode:
                {
                    pEvalNode.doNode((EvalConditionNode) node, (EvalMemory) nodeMem, sink, activationsManager.getReteEvaluator(), srcTuples, trgTuples, stagedLeftTuples);
                    break;
                }
            case NodeTypeEnums.FromNode:
                {
                    pFromNode.doNode((FromNode) node, (FromMemory) nodeMem, sink, activationsManager.getReteEvaluator(), srcTuples, trgTuples, stagedLeftTuples);
                    break;
                }
            case NodeTypeEnums.ReactiveFromNode:
                {
                    pReactiveFromNode.doNode((ReactiveFromNode) node, (ReactiveFromNode.ReactiveFromMemory) nodeMem, sink, activationsManager.getReteEvaluator(), srcTuples, trgTuples, stagedLeftTuples);
                    break;
                }
            case NodeTypeEnums.QueryElementNode:
                {
                    exitInnerEval = evalQueryNode(pmem, node, bit, nodeMem, smems, smemIndex, trgTuples, activationsManager.getReteEvaluator(), stack, srcTuples, sink, stagedLeftTuples);
                    break;
                }
            case NodeTypeEnums.TimerConditionNode:
                {
                    pTimerNode.doNode((TimerNode) node, (TimerNodeMemory) nodeMem, pmem, smem, sink, activationsManager, srcTuples, trgTuples, stagedLeftTuples);
                    break;
                }
            case NodeTypeEnums.ConditionalBranchNode:
                {
                    pBranchNode.doNode((ConditionalBranchNode) node, (ConditionalBranchMemory) nodeMem, sink, activationsManager, srcTuples, trgTuples, stagedLeftTuples, executor);
                    break;
                }
            case NodeTypeEnums.AsyncSendNode:
                {
                    pSendNode.doNode((AsyncSendNode) node, (AsyncSendMemory) nodeMem, activationsManager.getReteEvaluator(), srcTuples);
                    break;
                }
            case NodeTypeEnums.AsyncReceiveNode:
                {
                    pReceiveNode.doNode((AsyncReceiveNode) node, (AsyncReceiveMemory) nodeMem, sink, activationsManager.getReteEvaluator(), srcTuples, trgTuples);
                    break;
                }
        }
        if (exitInnerEval && trgTuples.isEmpty()) {
            return null;
        }
    }
    return trgTuples;
}",java:S107,1
"private boolean evalQueryNode(PathMemory pmem, NetworkNode node, long bit, Memory nodeMem, SegmentMemory[] smems, int smemIndex, TupleSets<LeftTuple> trgTuples, ReteEvaluator reteEvaluator, LinkedList<StackEntry> stack, TupleSets<LeftTuple> srcTuples, LeftTupleSinkNode sink, TupleSets<LeftTuple> stagedLeftTuples){
    QueryElementNodeMemory qmem = (QueryElementNodeMemory) nodeMem;
    if (srcTuples.isEmpty() && qmem.getResultLeftTuples().isEmpty()) {
        return false;
    }
    QueryElementNode qnode = (QueryElementNode) node;
    if (log.isTraceEnabled()) {
        int offset = getOffset(node);
        log.trace(""{} query result tuples {}"", indent(offset), qmem.getResultLeftTuples().toStringSizes());
    }
    qmem.getResultLeftTuples().addTo(trgTuples);
    qmem.setNodeCleanWithoutNotify();
    if (!srcTuples.isEmpty()) {
        StackEntry stackEntry = new StackEntry(node, bit, sink, pmem, nodeMem, smems, smemIndex, trgTuples, true, true);
        stack.add(stackEntry);
        pQueryNode.doNode(qnode, (QueryElementNodeMemory) nodeMem, stackEntry, reteEvaluator, srcTuples, trgTuples, stagedLeftTuples);
        SegmentMemory qsmem = ((QueryElementNodeMemory) nodeMem).getQuerySegmentMemory();
        List<PathMemory> qpmems = qsmem.getPathMemories();
        for (int i = 0; i < qpmems.size(); i++) {
            PathMemory qpmem = qpmems.get(i);
            pmem = qpmem;
            smems = qpmem.getSegmentMemories();
            smemIndex = 0;
            SegmentMemory smem = smems[smemIndex];
            LeftTupleNode liaNode = qpmem.getPathEndNode().getPathNodes()[0];
            if (liaNode == smem.getTipNode()) {
                smem = smems[++smemIndex];
                node = smem.getRootNode();
                nodeMem = smem.getNodeMemories()[0];
                bit = 1;
            } else {
                node = liaNode.getSinkPropagator().getFirstLeftTupleSink();
                nodeMem = smem.getNodeMemories()[1];
                bit = 2;
            }
            trgTuples = smem.getStagedLeftTuples().takeAll();
            stackEntry = new StackEntry(node, bit, null, pmem, nodeMem, smems, smemIndex, trgTuples, false, true);
            if (log.isTraceEnabled()) {
                int offset = getOffset(stackEntry.getNode());
                log.trace(""{} ORQueue branch={} {} {}"", indent(offset), i, stackEntry.getNode().toString(), trgTuples.toStringSizes());
            }
            stack.add(stackEntry);
        }
        return true;
    } else {
        return false;
    }
}",java:S107,1
"private boolean evalBetaNode(PathMemory pmem, NetworkNode node, Memory nodeMem, SegmentMemory[] smems, int smemIndex, TupleSets<LeftTuple> trgTuples, ActivationsManager activationsManager, LinkedList<StackEntry> stack, boolean processRian, RuleExecutor executor, TupleSets<LeftTuple> srcTuples, TupleSets<LeftTuple> stagedLeftTuples, LeftTupleSinkNode sink){
    BetaNode betaNode = (BetaNode) node;
    BetaMemory bm;
    AccumulateMemory am = null;
    if (NodeTypeEnums.AccumulateNode == node.getType()) {
        am = (AccumulateMemory) nodeMem;
        bm = am.getBetaMemory();
    } else {
        bm = (BetaMemory) nodeMem;
    }
    if (processRian && betaNode.isRightInputIsRiaNode()) {
        doRiaNode(activationsManager, pmem, srcTuples, betaNode, sink, smems, smemIndex, nodeMem, bm, stack, executor);
        return true;
    }
    switchOnDoBetaNode(node, trgTuples, activationsManager.getReteEvaluator(), srcTuples, stagedLeftTuples, sink, bm, am);
    return false;
}",java:S107,1
"private void switchOnDoBetaNode(NetworkNode node, TupleSets<LeftTuple> trgTuples, ReteEvaluator reteEvaluator, TupleSets<LeftTuple> srcTuples, TupleSets<LeftTuple> stagedLeftTuples, LeftTupleSinkNode sink, BetaMemory bm, AccumulateMemory am){
    if (log.isTraceEnabled()) {
        int offset = getOffset(node);
        log.trace(""{} rightTuples {}"", indent(offset), bm.getStagedRightTuples().toStringSizes());
    }
    switch(node.getType()) {
        case NodeTypeEnums.JoinNode:
            {
                pJoinNode.doNode((JoinNode) node, sink, bm, reteEvaluator, srcTuples, trgTuples, stagedLeftTuples);
                break;
            }
        case NodeTypeEnums.NotNode:
            {
                pNotNode.doNode((NotNode) node, sink, bm, reteEvaluator, srcTuples, trgTuples, stagedLeftTuples);
                break;
            }
        case NodeTypeEnums.ExistsNode:
            {
                pExistsNode.doNode((ExistsNode) node, sink, bm, reteEvaluator, srcTuples, trgTuples, stagedLeftTuples);
                break;
            }
        case NodeTypeEnums.AccumulateNode:
            {
                AccumulateNode accumulateNode = (AccumulateNode) node;
                if (accumulateNode.getAccumulate().isGroupBy()) {
                    pGroupByNode.doNode(accumulateNode, sink, am, reteEvaluator, srcTuples, trgTuples, stagedLeftTuples);
                } else {
                    pAccNode.doNode(accumulateNode, sink, am, reteEvaluator, srcTuples, trgTuples, stagedLeftTuples);
                }
                break;
            }
    }
}",java:S107,1
"private void doRiaNode(ActivationsManager activationsManager, PathMemory pmem, TupleSets<LeftTuple> srcTuples, BetaNode betaNode, LeftTupleSinkNode sink, SegmentMemory[] smems, int smemIndex, Memory nodeMem, BetaMemory bm, LinkedList<StackEntry> stack, RuleExecutor executor){
    RiaPathMemory pathMem = bm.getRiaRuleMemory();
    SegmentMemory[] subnetworkSmems = pathMem.getSegmentMemories();
    SegmentMemory subSmem = null;
    for (int i = 0; subSmem == null; i++) {
        subSmem = subnetworkSmems[i];
    }
    StackEntry stackEntry = new StackEntry(betaNode, bm.getNodePosMaskBit(), sink, pmem, nodeMem, smems, smemIndex, srcTuples, false, false);
    stack.add(stackEntry);
    if (log.isTraceEnabled()) {
        int offset = getOffset(betaNode);
        log.trace(""{} RiaQueue {} {}"", indent(offset), betaNode.toString(), srcTuples.toStringSizes());
    }
    TupleSets<LeftTuple> subLts = subSmem.getStagedLeftTuples().takeAll();
    innerEval(pathMem, subSmem.getRootNode(), 1, subSmem.getNodeMemories()[0], subnetworkSmems, subSmem.getPos(), subLts, activationsManager, stack, true, executor);
}",java:S107,1
"private void doRiaNode2(ReteEvaluator reteEvaluator, TupleSets<LeftTuple> srcTuples, RightInputAdapterNode riaNode){
    ObjectSink[] sinks = riaNode.getObjectSinkPropagator().getSinks();
    BetaNode betaNode = (BetaNode) sinks[0];
    BetaMemory bm;
    Memory nodeMem = reteEvaluator.getNodeMemory(betaNode);
    if (NodeTypeEnums.AccumulateNode == betaNode.getType()) {
        bm = ((AccumulateMemory) nodeMem).getBetaMemory();
    } else {
        bm = (BetaMemory) nodeMem;
    }
    TupleSets<RightTuple> rightTuples = bm.getStagedRightTuples();
    BetaNode[] bns = null;
    BetaMemory[] bms = null;
    int length = sinks.length;
    if (length > 1) {
        bns = new BetaNode[sinks.length - 1];
        bms = new BetaMemory[sinks.length - 1];
        for (int i = 1; i < length; i++) {
            bns[i - 1] = (BetaNode) sinks[i];
            Memory nodeMem2 = reteEvaluator.getNodeMemory(bns[i - 1]);
            if (NodeTypeEnums.AccumulateNode == betaNode.getType()) {
                bms[i - 1] = ((AccumulateMemory) nodeMem2).getBetaMemory();
            } else {
                bms[i - 1] = (BetaMemory) nodeMem2;
            }
        }
    }
    length--;
    for (SubnetworkTuple subnetworkTuple = (SubnetworkTuple) srcTuples.getInsertFirst(); subnetworkTuple != null; ) {
        SubnetworkTuple next = (SubnetworkTuple) subnetworkTuple.getStagedNext();
        if (bm.getStagedRightTuples().isEmpty()) {
            bm.setNodeDirtyWithoutNotify();
        }
        subnetworkTuple.prepareStagingOnRight();
        rightTuples.addInsert(subnetworkTuple);
        if (bns != null) {
            for (int i = 0; i < length; i++) {
                if (bms[i].getStagedRightTuples().isEmpty()) {
                    bms[i].setNodeDirtyWithoutNotify();
                }
                subnetworkTuple = riaNode.createPeer(subnetworkTuple);
                bms[i].getStagedRightTuples().addInsert(subnetworkTuple);
            }
        }
        subnetworkTuple = next;
    }
    for (SubnetworkTuple subnetworkTuple = (SubnetworkTuple) srcTuples.getDeleteFirst(); subnetworkTuple != null; ) {
        SubnetworkTuple next = (SubnetworkTuple) subnetworkTuple.getStagedNext();
        if (rightTuples.isEmpty()) {
            bm.setNodeDirtyWithoutNotify();
        }
        switch(subnetworkTuple.getStagedTypeOnRight()) {
            case Tuple.INSERT:
                rightTuples.removeInsert(subnetworkTuple.moveStagingFromLeftToRight());
                break;
            case Tuple.UPDATE:
                rightTuples.removeUpdate(subnetworkTuple.moveStagingFromLeftToRight());
                break;
        }
        subnetworkTuple.prepareStagingOnRight();
        rightTuples.addDelete(subnetworkTuple);
        if (bns != null) {
            for (int i = 0; i < length; i++) {
                subnetworkTuple = (SubnetworkTuple) subnetworkTuple.getPeer();
                if (bms[i].getStagedRightTuples().isEmpty()) {
                    bms[i].setNodeDirtyWithoutNotify();
                }
                bms[i].getStagedRightTuples().addDelete(subnetworkTuple);
                subnetworkTuple.setStagedOnRight();
            }
        }
        subnetworkTuple = next;
    }
    for (SubnetworkTuple subnetworkTuple = (SubnetworkTuple) srcTuples.getUpdateFirst(); subnetworkTuple != null; ) {
        SubnetworkTuple next = (SubnetworkTuple) subnetworkTuple.getStagedNext();
        if (rightTuples.isEmpty()) {
            bm.setNodeDirtyWithoutNotify();
        }
        subnetworkTuple.prepareStagingOnRight();
        rightTuples.addUpdate(subnetworkTuple);
        if (bns != null) {
            for (int i = 0; i < length; i++) {
                subnetworkTuple = (SubnetworkTuple) subnetworkTuple.getPeer();
                if (bms[i].getStagedRightTuples().isEmpty()) {
                    bms[i].setNodeDirtyWithoutNotify();
                }
                bms[i].getStagedRightTuples().addUpdate(subnetworkTuple);
                subnetworkTuple.setStagedOnRight();
            }
        }
        subnetworkTuple = next;
    }
    srcTuples.resetAll();
}",java:S3776,39
"private static void doRemoveExistentialRightMemoryForReorder(TupleMemory rtm, boolean resumeFromCurrent, RightTuple rightTuple){
    if (rightTuple.getMemory() != null) {
        if (resumeFromCurrent) {
            if (rightTuple.getBlocked() != null) {
                RightTuple tempRightTuple = (RightTuple) rightTuple.getNext();
                while (tempRightTuple != null && tempRightTuple.getStagedType() != LeftTuple.NONE) {
                    tempRightTuple = (RightTuple) tempRightTuple.getNext();
                }
                if (tempRightTuple == null) {
                    tempRightTuple = (RightTuple) rightTuple.getPrevious();
                    while (tempRightTuple != null && tempRightTuple.getStagedType() != LeftTuple.NONE) {
                        tempRightTuple = (RightTuple) tempRightTuple.getPrevious();
                    }
                }
                rightTuple.setTempNextRightTuple(tempRightTuple);
            }
        }
        rightTuple.setTempBlocked(rightTuple.getBlocked());
        rightTuple.setBlocked(null);
        rtm.remove(rightTuple);
    }
}",java:S3776,39
"public static List<PathMemory> findPathsToFlushFromRia(ReteEvaluator reteEvaluator, PathMemory pmem){
    List<PathMemory> paths = null;
    if (pmem.isDataDriven() && pmem.getNodeType() == NodeTypeEnums.RightInputAdapterNode) {
        for (PathEndNode pnode : pmem.getPathEndNode().getPathEndNodes()) {
            if (pnode instanceof TerminalNode) {
                PathMemory outPmem = reteEvaluator.getNodeMemory((TerminalNode) pnode);
                if (outPmem.isDataDriven()) {
                    if (paths == null) {
                        paths = new ArrayList<>();
                    }
                    paths.add(outPmem);
                }
            }
        }
    }
    return paths == null ? Collections.emptyList() : paths;
}",java:S3776,39
"public KieRuntime getKnowledgeRuntime(){
    return kruntime;
}",java:S4144,40
"public EvalCondition clone(){
    final EvalCondition clone = new EvalCondition(this.expression.clone(), this.requiredDeclarations.clone());
    if (this.cloned == Collections.EMPTY_LIST) {
        this.cloned = new ArrayList<>(1);
    }
    this.cloned.add(clone);
    return clone;
}",java:S2975,34
"protected int calculateHashCode(){
    return 0;
}",java:S1161,11
"public Memory createMemory(final RuleBaseConfiguration config, ReteEvaluator reteEvaluator){
    BetaMemory betaMemory = this.constraints.createBetaMemory(config, NodeTypeEnums.AccumulateNode);
    AccumulateMemory memory = this.accumulate.isMultiFunction() ? new MultiAccumulateMemory(betaMemory, this.accumulate.getAccumulators()) : new SingleAccumulateMemory(betaMemory, this.accumulate.getAccumulators()[0]);
    memory.workingMemoryContext = this.accumulate.createWorkingMemoryContext();
    memory.resultsContext = this.resultBinder.createContext();
    return memory;
}",java:S1161,11
"public String toString(){
    return ""[AsyncReceiveNode("" + this.id + ""): messageId="" + messageId + ""]"";
}",java:S1161,11
"public EvalCondition clone(){
    final EvalCondition clone = new EvalCondition(this.expression.clone(), this.requiredDeclarations.clone());
    if (this.cloned == Collections.EMPTY_LIST) {
        this.cloned = new ArrayList<>(1);
    }
    this.cloned.add(clone);
    return clone;
}",java:S1182,14
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    this.sinks = (LeftTupleSinkNodeList) in.readObject();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(this.sinks);
}",java:S1161,11
"public ObjectSinkPropagator addObjectSink(ObjectSink sink, int alphaNodeHashingThreshold, int alphaNodeRangeIndexThreshold){
    this.sinks = null;
    if (this.sinksMap != null) {
        this.sinksMap.put(sink, sink);
    }
    if (sink.getType() == NodeTypeEnums.AlphaNode) {
        final AlphaNode alphaNode = (AlphaNode) sink;
        final ReadAccessor readAccessor = getHashableAccessor(alphaNode);
        if (readAccessor != null) {
            final int index = readAccessor.getIndex();
            final FieldIndex fieldIndex = registerFieldIndex(index, readAccessor);
            final FieldValue value = ((IndexableConstraint) alphaNode.getConstraint()).getField();
            if (fieldIndex.getCount() >= this.alphaNodeHashingThreshold && this.alphaNodeHashingThreshold != 0 && !value.isNull()) {
                if (!fieldIndex.isHashed()) {
                    hashSinks(fieldIndex);
                }
                this.hashedSinkMap.put(new HashKey(index, value, fieldIndex.getFieldExtractor()), alphaNode);
            } else {
                if (this.hashableSinks == null) {
                    this.hashableSinks = new ArrayList<>();
                }
                this.hashableSinks.add(alphaNode);
            }
            return this;
        }
        if (isRangeIndexable(alphaNode)) {
            IndexableConstraint indexableConstraint = (IndexableConstraint) alphaNode.getConstraint();
            ReadAccessor ReadAccessor = indexableConstraint.getFieldExtractor();
            final int index = ReadAccessor.getIndex();
            final FieldIndex fieldIndex = registerFieldIndexForRange(index, ReadAccessor);
            final FieldValue value = indexableConstraint.getField();
            if (fieldIndex.getCount() >= this.alphaNodeRangeIndexThreshold && this.alphaNodeRangeIndexThreshold != 0 && !value.isNull()) {
                if (!fieldIndex.isRangeIndexed()) {
                    rangeIndexSinks(fieldIndex);
                }
                this.rangeIndexMap.get(fieldIndex).add(alphaNode);
            } else {
                if (rangeIndexableSinks == null) {
                    rangeIndexableSinks = new ArrayList<>();
                }
                rangeIndexableSinks.add(alphaNode);
            }
            return this;
        }
    }
    if (this.otherSinks == null) {
        this.otherSinks = new ArrayList<>();
    }
    this.otherSinks.add((ObjectSinkNode) sink);
    return this;
}",java:S3776,39
"public ObjectSinkPropagator removeObjectSink(final ObjectSink sink){
    this.sinks = null;
    if (this.sinksMap != null) {
        this.sinksMap.remove(sink);
    }
    if (sink.getType() == NodeTypeEnums.AlphaNode) {
        final AlphaNode alphaNode = (AlphaNode) sink;
        final AlphaNodeFieldConstraint fieldConstraint = alphaNode.getConstraint();
        if (fieldConstraint instanceof IndexableConstraint) {
            final IndexableConstraint indexableConstraint = (IndexableConstraint) fieldConstraint;
            final FieldValue value = indexableConstraint.getField();
            if (isHashable(indexableConstraint)) {
                final ReadAccessor fieldAccessor = indexableConstraint.getFieldExtractor();
                final int index = fieldAccessor.getIndex();
                final FieldIndex fieldIndex = unregisterFieldIndex(index);
                if (fieldIndex.isHashed()) {
                    HashKey hashKey = new HashKey(index, value, fieldAccessor);
                    this.hashedSinkMap.remove(hashKey);
                    if (fieldIndex.getCount() <= this.alphaNodeHashingThreshold - 1) {
                        unHashSinks(fieldIndex);
                    }
                } else {
                    this.hashableSinks.remove(alphaNode);
                }
                if (this.hashableSinks != null && this.hashableSinks.isEmpty()) {
                    this.hashableSinks = null;
                }
                return size() == 1 ? new SingleObjectSinkAdapter(getSinks()[0]) : this;
            }
            if (isRangeIndexable(alphaNode)) {
                final ReadAccessor fieldAccessor = indexableConstraint.getFieldExtractor();
                final int index = fieldAccessor.getIndex();
                final FieldIndex fieldIndex = unregisterFieldIndexForRange(index);
                if (fieldIndex.isRangeIndexed()) {
                    AlphaRangeIndex alphaRangeIndex = this.rangeIndexMap.get(fieldIndex);
                    alphaRangeIndex.remove(alphaNode);
                    if (fieldIndex.getCount() <= this.alphaNodeRangeIndexThreshold - 1) {
                        unRangeIndexSinks(fieldIndex, alphaRangeIndex);
                    }
                } else {
                    this.rangeIndexableSinks.remove(alphaNode);
                }
                if (this.rangeIndexableSinks != null && this.rangeIndexableSinks.isEmpty()) {
                    this.rangeIndexableSinks = null;
                }
                return size() == 1 ? new SingleObjectSinkAdapter(getSinks()[0]) : this;
            }
        }
    }
    this.otherSinks.remove((ObjectSinkNode) sink);
    if (this.otherSinks.isEmpty()) {
        this.otherSinks = null;
    }
    return size() == 1 ? new SingleObjectSinkAdapter(getSinks()[0]) : this;
}",java:S3776,39
"public void propagateAssertObject(final InternalFactHandle factHandle, final PropagationContext context, final ReteEvaluator reteEvaluator){
    final Object object = factHandle.getObject();
    if (this.hashedFieldIndexes != null) {
        for (FieldIndex fieldIndex : this.hashedFieldIndexes) {
            if (!fieldIndex.isHashed()) {
                continue;
            }
            final AlphaNode sink = this.hashedSinkMap.get(new HashKey(fieldIndex, object));
            if (sink != null) {
                sink.getObjectSinkPropagator().propagateAssertObject(factHandle, context, reteEvaluator);
            }
        }
    }
    if (this.rangeIndexMap != null) {
        for (Map.Entry<FieldIndex, AlphaRangeIndex> entry : this.rangeIndexMap.entrySet()) {
            if (!entry.getKey().isRangeIndexed()) {
                continue;
            }
            for (AlphaNode sink : entry.getValue().getMatchingAlphaNodes(object)) {
                sink.getObjectSinkPropagator().propagateAssertObject(factHandle, context, reteEvaluator);
            }
        }
    }
    if (this.hashableSinks != null) {
        for (ObjectSinkNode sink : this.hashableSinks) {
            doPropagateAssertObject(factHandle, context, reteEvaluator, sink);
        }
    }
    if (this.rangeIndexableSinks != null) {
        for (ObjectSinkNode sink : this.rangeIndexableSinks) {
            doPropagateAssertObject(factHandle, context, reteEvaluator, sink);
        }
    }
    if (this.otherSinks != null) {
        for (ObjectSinkNode sink : this.otherSinks) {
            doPropagateAssertObject(factHandle, context, reteEvaluator, sink);
        }
    }
}",java:S3776,39
"public void propagateModifyObject(final InternalFactHandle factHandle, final ModifyPreviousTuples modifyPreviousTuples, final PropagationContext context, final ReteEvaluator reteEvaluator){
    final Object object = factHandle.getObject();
    if (this.hashedFieldIndexes != null) {
        for (FieldIndex fieldIndex : this.hashedFieldIndexes) {
            if (!fieldIndex.isHashed()) {
                continue;
            }
            final AlphaNode sink = this.hashedSinkMap.get(new HashKey(fieldIndex, object));
            if (sink != null) {
                sink.getObjectSinkPropagator().propagateModifyObject(factHandle, modifyPreviousTuples, context, reteEvaluator);
            }
        }
    }
    if (this.rangeIndexMap != null) {
        for (Map.Entry<FieldIndex, AlphaRangeIndex> entry : this.rangeIndexMap.entrySet()) {
            if (!entry.getKey().isRangeIndexed()) {
                continue;
            }
            for (AlphaNode sink : entry.getValue().getMatchingAlphaNodes(object)) {
                sink.getObjectSinkPropagator().propagateModifyObject(factHandle, modifyPreviousTuples, context, reteEvaluator);
            }
        }
    }
    if (this.hashableSinks != null) {
        for (ObjectSinkNode sink : this.hashableSinks) {
            doPropagateModifyObject(factHandle, modifyPreviousTuples, context, reteEvaluator, sink);
        }
    }
    if (this.rangeIndexableSinks != null) {
        for (ObjectSinkNode sink : this.rangeIndexableSinks) {
            doPropagateModifyObject(factHandle, modifyPreviousTuples, context, reteEvaluator, sink);
        }
    }
    if (this.otherSinks != null) {
        for (ObjectSinkNode sink : this.otherSinks) {
            doPropagateModifyObject(factHandle, modifyPreviousTuples, context, reteEvaluator, sink);
        }
    }
}",java:S3776,39
"public void byPassModifyToBetaNode(final InternalFactHandle factHandle, final ModifyPreviousTuples modifyPreviousTuples, final PropagationContext context, final ReteEvaluator reteEvaluator){
    final Object object = factHandle.getObject();
    if (this.hashedFieldIndexes != null) {
        for (FieldIndex fieldIndex : this.hashedFieldIndexes) {
            if (!fieldIndex.isHashed()) {
                continue;
            }
            final AlphaNode sink = this.hashedSinkMap.get(new HashKey(fieldIndex, object));
            if (sink != null) {
                sink.getObjectSinkPropagator().byPassModifyToBetaNode(factHandle, modifyPreviousTuples, context, reteEvaluator);
            }
        }
    }
    if (this.rangeIndexMap != null) {
        for (Map.Entry<FieldIndex, AlphaRangeIndex> entry : this.rangeIndexMap.entrySet()) {
            if (!entry.getKey().isRangeIndexed()) {
                continue;
            }
            for (AlphaNode sink : entry.getValue().getMatchingAlphaNodes(object)) {
                sink.getObjectSinkPropagator().byPassModifyToBetaNode(factHandle, modifyPreviousTuples, context, reteEvaluator);
            }
        }
    }
    if (this.hashableSinks != null) {
        for (AlphaNode sink : this.hashableSinks) {
            sink.getObjectSinkPropagator().byPassModifyToBetaNode(factHandle, modifyPreviousTuples, context, reteEvaluator);
        }
    }
    if (this.rangeIndexableSinks != null) {
        for (AlphaNode sink : this.rangeIndexableSinks) {
            sink.getObjectSinkPropagator().byPassModifyToBetaNode(factHandle, modifyPreviousTuples, context, reteEvaluator);
        }
    }
    if (this.otherSinks != null) {
        for (ObjectSinkNode sink : this.otherSinks) {
            sink.byPassModifyToBetaNode(factHandle, modifyPreviousTuples, context, reteEvaluator);
        }
    }
}",java:S3776,39
"public ObjectSink[] getSinks(){
    if (this.sinks != null) {
        return sinks;
    }
    ObjectSink[] newSinks = new ObjectSink[size()];
    int at = 0;
    if (this.hashedFieldIndexes != null) {
        for (FieldIndex fieldIndex : this.hashedFieldIndexes) {
            if (!fieldIndex.isHashed()) {
                continue;
            }
            final int index = fieldIndex.getIndex();
            for (Map.Entry<HashKey, AlphaNode> entry : this.hashedSinkMap.entrySet()) {
                if (entry.getKey().getIndex() == index) {
                    newSinks[at++] = entry.getValue();
                }
            }
        }
    }
    if (this.rangeIndexedFieldIndexes != null) {
        for (FieldIndex fieldIndex : this.rangeIndexedFieldIndexes) {
            if (!fieldIndex.isRangeIndexed()) {
                continue;
            }
            Collection<AlphaNode> alphaNodes = this.rangeIndexMap.get(fieldIndex).getAllValues();
            for (AlphaNode sink : alphaNodes) {
                newSinks[at++] = sink;
            }
        }
    }
    if (this.hashableSinks != null) {
        for (ObjectSinkNode sink : this.hashableSinks) {
            newSinks[at++] = sink;
        }
    }
    if (this.rangeIndexableSinks != null) {
        for (ObjectSinkNode sink : this.rangeIndexableSinks) {
            newSinks[at++] = sink;
        }
    }
    if (this.otherSinks != null) {
        for (ObjectSinkNode sink : this.otherSinks) {
            newSinks[at++] = sink;
        }
    }
    this.sinks = newSinks;
    return newSinks;
}",java:S3776,39
"public String toString(){
    return ""[ConditionalBranchNode: cond="" + this.branchEvaluator + ""]"";
}",java:S1161,11
"public void reset(){
}",java:S1186,16
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1186,16
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1186,16
"public void propagateAssertObject(final InternalFactHandle factHandle, final PropagationContext context, final ReteEvaluator reteEvaluator){
}",java:S1186,16
"public void propagateModifyObject(InternalFactHandle factHandle, ModifyPreviousTuples modifyPreviousTuples, PropagationContext context, ReteEvaluator reteEvaluator){
}",java:S1186,16
"public void byPassModifyToBetaNode(final InternalFactHandle factHandle, final ModifyPreviousTuples modifyPreviousTuples, final PropagationContext context, final ReteEvaluator reteEvaluator){
}",java:S1186,16
"public boolean equals(Object obj){
    return obj instanceof EmptyObjectSinkAdapter;
}",java:S1206,19
"public void setupParallelExecution(InternalRuleBase kbase){
    parallelExecution = true;
}",java:S1172,13
"public Forall clone(){
    List<Pattern> clonedPatterns = new ArrayList<>();
    for (Pattern remainingPattern : remainingPatterns) {
        clonedPatterns.add(remainingPattern.clone());
    }
    return new Forall(basePattern.clone(), clonedPatterns);
}",java:S2975,34
"public void addObjectSink(final ObjectSink objectSink){
    final ObjectTypeNode node = (ObjectTypeNode) objectSink;
    this.objectTypeNodes.put(node.getObjectType(), node);
}",java:S1161,11
"public void removeObjectSink(final ObjectSink objectSink){
    final ObjectTypeNode node = (ObjectTypeNode) objectSink;
    this.objectTypeNodes.remove(node.getObjectType());
}",java:S1161,11
"public void doAttach(BuildContext context){
    super.doAttach(context);
    this.source.addObjectSink(this);
    if (context != null) {
        for (InternalWorkingMemory workingMemory : context.getWorkingMemories()) {
            workingMemory.updateEntryPointsCache();
        }
    }
}",java:S1161,11
"protected boolean doRemove(final RuleRemovalContext context, final ReteooBuilder builder){
    return false;
}",java:S1161,11
"public String toString(){
    return ""[EntryPointNode("" + this.id + "") "" + this.entryPoint + "" ]"";
}",java:S1161,11
"public Forall clone(){
    List<Pattern> clonedPatterns = new ArrayList<>();
    for (Pattern remainingPattern : remainingPatterns) {
        clonedPatterns.add(remainingPattern.clone());
    }
    return new Forall(basePattern.clone(), clonedPatterns);
}",java:S1182,14
"public void doAttach(BuildContext context){
    super.doAttach(context);
    this.leftInput.addTupleSink(this, context);
}",java:S1161,11
"public void remove(){
    if (this.currentNode != null) {
        LeftTupleSinkNodeList.this.remove(this.currentNode);
        this.currentNode = null;
    } else {
        throw new IllegalStateException(""No item to remove. Call next() before calling remove()."");
    }
}",java:S1161,11
"protected LeftTupleSinkPropagator addTupleSink(final LeftTupleSinkPropagator sinkPropagator, final LeftTupleSink tupleSink, final BuildContext context){
    if (sinkPropagator instanceof EmptyLeftTupleSinkAdapter) {
        return new SingleLeftTupleSinkAdapter(this.getPartitionId(), tupleSink);
    }
    if (sinkPropagator instanceof SingleLeftTupleSinkAdapter) {
        CompositeLeftTupleSinkAdapter sinkAdapter = new CompositeLeftTupleSinkAdapter(this.getPartitionId());
        sinkAdapter.addTupleSink(sinkPropagator.getSinks()[0]);
        sinkAdapter.addTupleSink(tupleSink);
        return sinkAdapter;
    }
    ((CompositeLeftTupleSinkAdapter) sinkPropagator).addTupleSink(tupleSink);
    return sinkPropagator;
}",java:S1172,13
"protected BitMask setNodeConstraintsPropertyReactiveMask(BitMask mask, ObjectType objectType, List<String> accessibleProperties){
    return mask;
}",java:S1172,13
"public void unlinkFromLeftParent(){
    super.unlinkFromLeftParent();
}",java:S1161,11
"public void unlinkFromLeftParent(){
    super.unlinkFromLeftParent();
}",java:S1185,15
"public void unlinkFromRightParent(){
    super.unlinkFromRightParent();
}",java:S1161,11
"public From clone(){
    return new From(this.dataProvider.clone());
}",java:S2975,34
"public void unlinkFromRightParent(){
    super.unlinkFromRightParent();
}",java:S1185,15
"public void clearBlocker(){
    this.blockedPrevious = null;
    this.blockedNext = null;
    this.blocker = null;
}",java:S1161,11
"public void setBlocker(RightTuple blocker){
    this.blocker = blocker;
}",java:S1161,11
"public RightTuple getBlocker(){
    return this.blocker;
}",java:S1161,11
"public LeftTuple getBlockedPrevious(){
    return this.blockedPrevious;
}",java:S1161,11
"public void setBlockedPrevious(LeftTuple blockerPrevious){
    this.blockedPrevious = blockerPrevious;
}",java:S1161,11
"public LeftTuple getBlockedNext(){
    return this.blockedNext;
}",java:S1161,11
"public void setBlockedNext(LeftTuple blockerNext){
    this.blockedNext = blockerNext;
}",java:S1161,11
"public From clone(){
    return new From(this.dataProvider.clone());
}",java:S1182,14
" PathMemSpec calculatePathMemSpec(LeftTupleSource startTupleSource, TerminalNode removingTN){
    int counter = 1;
    long allLinkedTestMask = 0;
    LeftTupleSource tupleSource = getLeftTupleSource();
    if (BuildtimeSegmentUtilities.isNonTerminalTipNode(tupleSource, removingTN)) {
        counter++;
    }
    boolean updateBitInNewSegment = true;
    boolean updateAllLinkedTest = !hasConditionalBranchNode(tupleSource);
    boolean subnetworkBoundaryCrossed = false;
    while (tupleSource.getType() != NodeTypeEnums.LeftInputAdapterNode) {
        if (!subnetworkBoundaryCrossed && tupleSource.getType() == NodeTypeEnums.ConditionalBranchNode) {
            updateAllLinkedTest = tupleSource.getType() == NodeTypeEnums.ConditionalBranchNode;
        }
        if (updateAllLinkedTest && updateBitInNewSegment && NodeTypeEnums.isBetaNode(tupleSource) && NodeTypeEnums.AccumulateNode != tupleSource.getType()) {
            BetaNode bn = (BetaNode) tupleSource;
            if (bn.isRightInputIsRiaNode()) {
                updateBitInNewSegment = false;
                RightInputAdapterNode rian = (RightInputAdapterNode) bn.getRightInput();
                if (rian.getPathMemSpec(removingTN).allLinkedTestMask != 0) {
                    allLinkedTestMask = allLinkedTestMask | 1;
                }
            } else if (NodeTypeEnums.NotNode != bn.getType() || ((NotNode) bn).isEmptyBetaConstraints()) {
                updateBitInNewSegment = false;
                allLinkedTestMask = allLinkedTestMask | 1;
            }
        }
        tupleSource = tupleSource.getLeftTupleSource();
        if (BuildtimeSegmentUtilities.isNonTerminalTipNode(tupleSource, removingTN)) {
            updateBitInNewSegment = true;
            allLinkedTestMask = nextNodePosMask(allLinkedTestMask);
            counter++;
        }
        if (tupleSource == startTupleSource.getLeftTupleSource()) {
            subnetworkBoundaryCrossed = true;
            updateAllLinkedTest = false;
        }
    }
    if (!subnetworkBoundaryCrossed) {
        allLinkedTestMask = allLinkedTestMask | 1;
    }
    return new PathMemSpec(allLinkedTestMask, counter);
}",java:S3776,39
"private void clear(LeftTuple leftTuple){
    setStagedType(leftTuple, Tuple.NONE);
    setPreviousTuple(leftTuple, null);
    setNextTuple(leftTuple, null);
}",java:S2177,28
"public LeftTuple createLeftTuple(InternalFactHandle factHandle, boolean leftTupleMemoryEnabled){
    return new ReactiveFromNodeLeftTuple(factHandle, this, leftTupleMemoryEnabled);
}",java:S1161,11
"public LeftTuple createLeftTuple(final InternalFactHandle factHandle, final LeftTuple leftTuple, final Sink sink){
    return new ReactiveFromNodeLeftTuple(factHandle, leftTuple, sink);
}",java:S1161,11
"public LeftTuple createLeftTuple(LeftTuple leftTuple, Sink sink, PropagationContext pctx, boolean leftTupleMemoryEnabled){
    throw new UnsupportedOperationException();
}",java:S1161,11
"public LeftTuple createLeftTuple(LeftTuple leftTuple, RightTuple rightTuple, Sink sink){
    throw new UnsupportedOperationException();
}",java:S1161,11
"public void addObjectSink(final ObjectSink objectSink){
    final EntryPointNode node = (EntryPointNode) objectSink;
    entryPoints.put(node.getEntryPoint(), node);
    kBase.registerAddedEntryNodeCache(node);
}",java:S1161,11
"public void removeObjectSink(final ObjectSink objectSink){
    final EntryPointNode node = (EntryPointNode) objectSink;
    entryPoints.remove(node.getEntryPoint());
    kBase.registeRremovedEntryNodeCache(node);
}",java:S1161,11
"public void doAttach(BuildContext context){
    throw new UnsupportedOperationException(""cannot call attach() from the root Rete node"");
}",java:S1161,11
"public void networkUpdated(UpdateContext updateContext){
}",java:S1161,11
"protected boolean doRemove(final RuleRemovalContext context, final ReteooBuilder builder){
    return false;
}",java:S1161,11
"private void updateLeafSet(BaseNode baseNode, NodeSet leafSet){
    if (baseNode.getType() == NodeTypeEnums.AlphaNode) {
        for (ObjectSink sink : ((AlphaNode) baseNode).getObjectSinkPropagator().getSinks()) {
            if (((BaseNode) sink).isInUse()) {
                updateLeafSet((BaseNode) sink, leafSet);
            }
        }
    } else if (baseNode.getType() == NodeTypeEnums.LeftInputAdapterNode) {
        for (LeftTupleSink sink : ((LeftInputAdapterNode) baseNode).getSinkPropagator().getSinks()) {
            if (sink.getType() == NodeTypeEnums.RuleTerminalNode) {
                leafSet.add((BaseNode) sink);
            } else if (((BaseNode) sink).isInUse()) {
                updateLeafSet((BaseNode) sink, leafSet);
            }
        }
    } else if (baseNode.getType() == NodeTypeEnums.EvalConditionNode) {
        for (LeftTupleSink sink : ((EvalConditionNode) baseNode).getSinkPropagator().getSinks()) {
            if (((BaseNode) sink).isInUse()) {
                updateLeafSet((BaseNode) sink, leafSet);
            }
        }
    } else if (NodeTypeEnums.isBetaNode(baseNode) && (baseNode.isInUse())) {
        leafSet.add(baseNode);
    }
}",java:S3776,39
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    this.sink = (LeftTupleSink) in.readObject();
    this.sinkArray = new LeftTupleSink[] { this.sink };
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(this.sink);
}",java:S1161,11
"public void doAttach(BuildContext context){
    super.doAttach(context);
    this.leftInput.addTupleSink(this, context);
}",java:S1161,11
"public String toString(){
    return ""[TimerNode("" + this.id + ""): cond="" + this.timer + "" calendars="" + ((calendarNames == null) ? ""null"" : Arrays.asList(calendarNames)) + ""]"";
}",java:S1161,11
"public static void traverse(LeftTuple rootLeftTuple, LeftTuple leftTuple, OnLeaf onLeaf){
    boolean down = true;
    while (leftTuple != null) {
        while (down) {
            if (leftTuple.getFirstChild() != null) {
                leftTuple = leftTuple.getFirstChild();
            } else {
                down = false;
            }
        }
        onLeaf.execute(leftTuple);
        if (leftTuple.getHandleNext() != null) {
            leftTuple = leftTuple.getHandleNext();
            if (leftTuple.getFirstChild() != null) {
                down = true;
            }
        } else {
            while (leftTuple != rootLeftTuple && leftTuple.getHandleNext() == null) {
                leftTuple = leftTuple.getLeftParent();
            }
            leftTuple = leftTuple.getHandleNext();
            down = true;
        }
    }
}",java:S3776,39
"public void doAttach(BuildContext context){
    this.source.addObjectSink(this);
}",java:S1161,11
"public String toString(){
    return ""[WindowNode("" + this.id + "") constraints="" + this.constraints + ""]"";
}",java:S1161,11
"public void reset(){
}",java:S1186,16
"public void unlinkFromRightParent(){
    super.unlinkFromRightParent();
    this.windowList.removeWindowTuple(this);
}",java:S1161,11
"public boolean equals(Object object){
    return equals((WindowTupleList) object);
}",java:S2097,27
"public T attachNode(BuildContext context, T candidate){
    BaseNode node = null;
    RuleBasePartitionId partition = null;
    if (candidate.getType() == NodeTypeEnums.EntryPointNode) {
        node = context.getRuleBase().getRete().getEntryPointNode(((EntryPointNode) candidate).getEntryPoint());
        partition = RuleBasePartitionId.MAIN_PARTITION;
    } else if (candidate.getType() == NodeTypeEnums.ObjectTypeNode) {
        Map<ObjectType, ObjectTypeNode> map = context.getRuleBase().getRete().getObjectTypeNodes(context.getCurrentEntryPoint());
        if (map != null) {
            ObjectTypeNode otn = map.get(((ObjectTypeNode) candidate).getObjectType());
            if (otn != null) {
                otn.mergeExpirationOffset((ObjectTypeNode) candidate);
                node = otn;
            }
        }
        partition = RuleBasePartitionId.MAIN_PARTITION;
    } else if (isSharingEnabledForNode(context, candidate)) {
        if ((context.getTupleSource() != null) && NodeTypeEnums.isLeftTupleSink(candidate)) {
            node = context.getTupleSource().getSinkPropagator().getMatchingNode(candidate);
        } else if ((context.getObjectSource() != null) && NodeTypeEnums.isObjectSink(candidate)) {
            node = context.getObjectSource().getObjectSinkPropagator().getMatchingNode(candidate);
        } else {
            throw new RuntimeException(""This is a bug on node sharing verification. Please report to development team."");
        }
    }
    if (node != null && !areNodesCompatibleForSharing(context, node)) {
        node = null;
    }
    if (node == null) {
        node = candidate;
        if (partition == null) {
            if (context.getPartitionId() == null) {
                context.setPartitionId(context.getRuleBase().createNewPartitionId());
            }
            partition = context.getPartitionId();
        }
        node.setPartitionId(context, partition);
        node.attach(context);
    } else {
        mergeNodes(node, candidate);
        context.releaseId(candidate);
        if (partition == null && context.getPartitionId() == null) {
            partition = node.getPartitionId();
            context.setPartitionId(partition);
        }
    }
    context.getNodes().add(node);
    node.addAssociation(context, context.getRule());
    return (T) node;
}",java:S3776,39
"public TemporalDependencyMatrix calculateTemporalDistance(GroupElement groupElement){
    List<Pattern> events = new ArrayList<>();
    selectAllEventPatterns(events, groupElement);
    final int size = events.size();
    if (size >= 1) {
        Interval[][] source = new Interval[size][];
        for (int row = 0; row < size; row++) {
            source[row] = new Interval[size];
            for (int col = 0; col < size; col++) {
                if (row == col) {
                    source[row][col] = new Interval(0, 0);
                } else {
                    source[row][col] = new Interval(Interval.MIN, Interval.MAX);
                }
            }
        }
        Interval[][] result;
        if (size > 1) {
            List<Declaration> declarations = new ArrayList<>();
            int eventIndex = 0;
            for (Pattern event : events) {
                declarations.add(event.getDeclaration());
                Map<Declaration, Interval> temporal = new HashMap<>();
                gatherTemporalRelationships(event.getConstraints(), temporal);
                for (Map.Entry<Declaration, Interval> entry : temporal.entrySet()) {
                    int targetIndex = declarations.indexOf(entry.getKey());
                    Interval interval = entry.getValue();
                    source[targetIndex][eventIndex].intersect(interval);
                    Interval reverse = new Interval(interval.getUpperBound() == Long.MAX_VALUE ? Long.MIN_VALUE : -interval.getUpperBound(), interval.getLowerBound() == Long.MIN_VALUE ? Long.MAX_VALUE : -interval.getLowerBound());
                    source[eventIndex][targetIndex].intersect(reverse);
                }
                eventIndex++;
            }
            result = TimeUtils.calculateTemporalDistance(source);
        } else {
            result = source;
        }
        return new TemporalDependencyMatrix(result, events);
    }
    return null;
}",java:S3776,39
"private void gatherTemporalRelationships(List<?> constraints, Map<Declaration, Interval> temporal){
    for (Object obj : constraints) {
        if (obj instanceof IntervalProviderConstraint) {
            IntervalProviderConstraint constr = (IntervalProviderConstraint) obj;
            if (constr.isTemporal()) {
                Declaration[] decs = constr.getRequiredDeclarations();
                if (decs.length > 0 && decs[0].isPatternDeclaration() && decs[0].getPattern().getObjectType().isEvent()) {
                    Declaration target = decs[0];
                    Interval interval = temporal.get(target);
                    if (interval == null) {
                        interval = constr.getInterval();
                        temporal.put(target, interval);
                    } else {
                        interval.intersect(constr.getInterval());
                    }
                }
            }
        }
    }
}",java:S3776,39
"public void pack(){
    final Object[] clone = this.children.toArray();
    for (Object aClone : clone) {
        if (aClone instanceof GroupElement) {
            final GroupElement childGroup = (GroupElement) aClone;
            childGroup.pack(this);
        }
    }
    if ((this.isAnd() || this.isOr()) && (this.children.size() == 1)) {
        final Object child = this.getChildren().get(0);
        if (child instanceof GroupElement) {
            mergeGroupElements(this, (GroupElement) child);
        }
    }
    if (this.isNot() && this.children.size() == 1 && this.getChildren().get(0) instanceof GroupElement) {
        final GroupElement child = (GroupElement) this.getChildren().get(0);
        if (child.isExists()) {
            this.children.clear();
            this.children.addAll(child.getChildren());
        }
    }
    if (this.isExists() && this.children.size() == 1 && this.getChildren().get(0) instanceof GroupElement) {
        final GroupElement child = (GroupElement) this.getChildren().get(0);
        if (child.isNot()) {
            this.setType(NOT);
            this.children.clear();
            this.children.addAll(child.getChildren());
        }
    }
}",java:S3776,39
"public void replaceDeclaration(Declaration oldDecl, Declaration newDecl){
}",java:S1186,16
"public InstanceNotEqualsConstraint clone(){
    return new InstanceNotEqualsConstraint(this.otherPattern);
}",java:S2975,34
"public InstanceNotEqualsConstraint clone(){
    return new InstanceNotEqualsConstraint(this.otherPattern);
}",java:S1182,14
"public void pack(final GroupElement parent){
    if (this.children.size() == 0) {
        parent.children.remove(this);
        return;
    }
    if (this.isAnd() || this.isOr() || this.isExists()) {
        if (parent.getType() == this.getType()) {
            int index = parent.getChildren().indexOf(this);
            parent.getChildren().remove(this);
            for (RuleConditionElement child : children) {
                parent.addChild(index++, child);
                if (child instanceof GroupElement) {
                    final int previousSize = parent.getChildren().size();
                    ((GroupElement) child).pack(parent);
                    index += (parent.getChildren().size() - previousSize);
                }
            }
        } else if ((!this.isExists()) && (this.children.size() == 1)) {
            final int index = parent.getChildren().indexOf(this);
            parent.getChildren().remove(this);
            final RuleConditionElement child = this.children.get(0);
            parent.addChild(index, child);
            if (child instanceof GroupElement) {
                ((GroupElement) child).pack(parent);
            }
        } else {
            this.pack();
        }
    } else {
        this.pack();
    }
}",java:S3776,39
"private void checkDelaying(final BuildContext context, final Constraint constraint){
    if (constraint instanceof IntervalProviderConstraint) {
        Declaration target = constraint.getRequiredDeclarations()[0];
        if (target.isPatternDeclaration() && target.getPattern().getObjectType().isEvent()) {
            long uplimit = ((IntervalProviderConstraint) constraint).getInterval().getUpperBound();
            if (uplimit >= 0 && uplimit < Long.MAX_VALUE) {
                Timer timer = context.getRule().getTimer();
                DurationTimer durationTimer = new DurationTimer(uplimit);
                durationTimer.setEventFactHandle(target);
                if (timer instanceof CompositeMaxDurationTimer) {
                    ((CompositeMaxDurationTimer) timer).addDurationTimer(durationTimer);
                } else {
                    if (timer == null) {
                        timer = durationTimer;
                    } else {
                        CompositeMaxDurationTimer temp = new CompositeMaxDurationTimer();
                        if (timer instanceof DurationTimer) {
                            temp.addDurationTimer((DurationTimer) timer);
                        } else {
                            temp.setTimer(context.getRule().getTimer());
                        }
                        temp.addDurationTimer(durationTimer);
                        timer = temp;
                    }
                    context.getRule().setTimer(timer);
                }
            }
        }
    }
}",java:S3776,39
"private static ExpirationSpec getExpirationForType(BuildContext context, ObjectType objectType){
    long offset = NEVER_EXPIRES;
    boolean hard = false;
    for (TypeDeclaration type : context.getRuleBase().getTypeDeclarations()) {
        if (type.getObjectType().isAssignableFrom(objectType)) {
            if (hard) {
                if (type.getExpirationPolicy() == Policy.TIME_HARD && type.getExpirationOffset() > offset) {
                    offset = type.getExpirationOffset();
                }
            } else {
                if (type.getExpirationPolicy() == Policy.TIME_HARD) {
                    offset = type.getExpirationOffset();
                    hard = true;
                } else if (type.getExpirationOffset() > offset) {
                    offset = type.getExpirationOffset();
                }
            }
        }
    }
    return new ExpirationSpec(offset == NEVER_EXPIRES ? NEVER_EXPIRES : offset + 1, hard);
}",java:S3776,39
"private void attachObjectTypeNode(final BuildContext context, final BuildUtils utils, final Pattern pattern){
    ObjectType objectType = pattern.getObjectType();
    if (pattern.getObjectType() instanceof ClassObjectType) {
        if (DroolsQuery.class == ((ClassObjectType) pattern.getObjectType()).getClassType()) {
            context.setTupleMemoryEnabled(false);
        }
    }
    ObjectTypeNode otn = CoreComponentFactory.get().getNodeFactoryService().buildObjectTypeNode(context.getNextNodeId(), (EntryPointNode) context.getObjectSource(), objectType, context);
    if (objectType.isEvent() && EventProcessingOption.STREAM.equals(context.getRuleBase().getRuleBaseConfiguration().getEventProcessingMode())) {
        ExpirationSpec expirationSpec = getExpirationForType(context, objectType);
        if (expirationSpec.offset != NEVER_EXPIRES && expirationSpec.hard) {
            otn.setExpirationOffset(expirationSpec.offset);
        } else {
            long offset = NEVER_EXPIRES;
            for (Behavior behavior : pattern.getBehaviors()) {
                if (behavior.getExpirationOffset() != NEVER_EXPIRES) {
                    offset = Math.max(behavior.getExpirationOffset(), offset);
                }
            }
            if (offset == NEVER_EXPIRES && !expirationSpec.hard) {
                offset = expirationSpec.offset;
            }
            long distance = context.getExpirationOffset(pattern);
            if (distance == NEVER_EXPIRES) {
                otn.setExpirationOffset(offset);
            } else {
                otn.setExpirationOffset(Math.max(distance, offset));
            }
        }
    }
    context.setObjectSource(utils.attachNode(context, otn));
}",java:S3776,39
"public boolean requiresLeftActivation(final BuildUtils utils, final RuleConditionElement rce){
    return false;
}",java:S1172,13
"public GroupElement clone(){
    return clone(true);
}",java:S2975,34
"public void onRemove(){
}",java:S1186,16
"private void wireInParallel(int wireListSize) throws Exception{
    final int parallelThread = Runtime.getRuntime().availableProcessors();
    CompletionService<Boolean> ecs = ExecutorProviderFactory.getExecutorProvider().getCompletionService();
    int size = wireListSize / parallelThread;
    for (int i = 1; i <= parallelThread; i++) {
        List<String> subList = wireList.subList((i - 1) * size, i == parallelThread ? wireListSize : i * size);
        ecs.submit(new WiringExecutor(classLoader, invokerLookups, subList));
    }
    for (int i = 1; i <= parallelThread; i++) {
        ecs.take().get();
    }
}",java:S112,4
"public ClassLoader getClassLoader(){
    return this.classLoader;
}",java:S1161,11
"public ClassLoader getRootClassLoader(){
    return rootClassLoader;
}",java:S1161,11
"public GroupElement clone(){
    return clone(true);
}",java:S1182,14
"public boolean remove(final String resourceName){
    invokerLookups.remove(resourceName);
    if (getStore().remove(convertClassToResourcePath(resourceName)) != null) {
        this.wireList.remove(resourceName);
        this.dirty = true;
        return true;
    }
    return false;
}",java:S1161,11
"private Map<String, Declaration> getDeclarations(List<RuleConditionElement> children, ScopeDelimiter scopeDelimiter, String consequenceName){
    if (scopeDelimiter == ScopeDelimiter.ALWAYS || children.isEmpty()) {
        return Collections.EMPTY_MAP;
    } else if (children.size() == 1) {
        return getOuterDeclarations(children.get(0), consequenceName);
    } else {
        Map<String, Declaration> declarations = new HashMap<>();
        if (scopeDelimiter == ScopeDelimiter.NEVER) {
            for (RuleConditionElement rce : children) {
                declarations.putAll(getOuterDeclarations(rce, consequenceName));
                if (isConsequenceInvoker(rce, consequenceName)) {
                    break;
                }
            }
        } else if (scopeDelimiter == ScopeDelimiter.CONSENSUS) {
            Iterator<RuleConditionElement> i = children.iterator();
            RuleConditionElement rce = i.next();
            Map<String, Declaration> elementDeclarations = getOuterDeclarations(rce, consequenceName);
            if (isConsequenceInvoker(rce, consequenceName)) {
                return elementDeclarations;
            }
            declarations.putAll(elementDeclarations);
            while (i.hasNext()) {
                rce = i.next();
                elementDeclarations = getOuterDeclarations(rce, consequenceName);
                if (isConsequenceInvoker(rce, consequenceName)) {
                    return elementDeclarations;
                }
                declarations.keySet().retainAll(elementDeclarations.keySet());
                findCommonDeclarationClasses(declarations, elementDeclarations);
            }
        }
        return declarations;
    }
}",java:S3776,39
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
}",java:S1186,16
"public void writeExternal(ObjectOutput out) throws IOException{
}",java:S1186,16
"public FactHandle getFactHandle(int i){
    if (factHandles == null) {
        this.factHandles = this.tuple.toFactHandles();
    }
    return null;
}",java:S1172,13
"protected Date getTimeBefore(Date endTime){
    return null;
}",java:S1172,13
"public Object clone(){
    CronExpression copy;
    try {
        copy = new CronExpression(getCronExpression());
        if (getTimeZone() != null)
            copy.setTimeZone((TimeZone) getTimeZone().clone());
    } catch (ParseException ex) {
        throw new IncompatibleClassChangeError(""Not Cloneable."");
    }
    return copy;
}",java:S2975,34
"public Object clone(){
    CronExpression copy;
    try {
        copy = new CronExpression(getCronExpression());
        if (getTimeZone() != null)
            copy.setTimeZone((TimeZone) getTimeZone().clone());
    } catch (ParseException ex) {
        throw new IncompatibleClassChangeError(""Not Cloneable."");
    }
    return copy;
}",java:S1182,14
"public int compareTo(DefaultTimerJobInstance o){
    return this.trigger.hasNextFireTime().compareTo(o.getTrigger().hasNextFireTime());
}",java:S1210,20
"protected void addToSet(int val, int end, int incr, int type) throws ParseException{
    TreeSet set = getSet(type);
    if (type == SECOND || type == MINUTE) {
        if ((val < 0 || val > 59 || end > 59) && (val != ALL_SPEC_INT)) {
            throw new ParseException(""Minute and Second values must be between 0 and 59"", -1);
        }
    } else if (type == HOUR) {
        if ((val < 0 || val > 23 || end > 23) && (val != ALL_SPEC_INT)) {
            throw new ParseException(""Hour values must be between 0 and 23"", -1);
        }
    } else if (type == DAY_OF_MONTH) {
        if ((val < 1 || val > 31 || end > 31) && (val != ALL_SPEC_INT) && (val != NO_SPEC_INT)) {
            throw new ParseException(""Day of month values must be between 1 and 31"", -1);
        }
    } else if (type == MONTH) {
        if ((val < 1 || val > 12 || end > 12) && (val != ALL_SPEC_INT)) {
            throw new ParseException(""Month values must be between 1 and 12"", -1);
        }
    } else if (type == DAY_OF_WEEK) {
        if ((val == 0 || val > 7 || end > 7) && (val != ALL_SPEC_INT) && (val != NO_SPEC_INT)) {
            throw new ParseException(""Day-of-Week values must be between 1 and 7"", -1);
        }
    }
    if ((incr == 0 || incr == -1) && val != ALL_SPEC_INT) {
        if (val != -1) {
            set.add(val);
        } else {
            set.add(NO_SPEC);
        }
        return;
    }
    int startAt = val;
    int stopAt = end;
    if (val == ALL_SPEC_INT && incr <= 0) {
        incr = 1;
        set.add(ALL_SPEC);
    }
    if (type == SECOND || type == MINUTE) {
        if (stopAt == -1) {
            stopAt = 59;
        }
        if (startAt == -1 || startAt == ALL_SPEC_INT) {
            startAt = 0;
        }
    } else if (type == HOUR) {
        if (stopAt == -1) {
            stopAt = 23;
        }
        if (startAt == -1 || startAt == ALL_SPEC_INT) {
            startAt = 0;
        }
    } else if (type == DAY_OF_MONTH) {
        if (stopAt == -1) {
            stopAt = 31;
        }
        if (startAt == -1 || startAt == ALL_SPEC_INT) {
            startAt = 1;
        }
    } else if (type == MONTH) {
        if (stopAt == -1) {
            stopAt = 12;
        }
        if (startAt == -1 || startAt == ALL_SPEC_INT) {
            startAt = 1;
        }
    } else if (type == DAY_OF_WEEK) {
        if (stopAt == -1) {
            stopAt = 7;
        }
        if (startAt == -1 || startAt == ALL_SPEC_INT) {
            startAt = 1;
        }
    } else if (type == YEAR) {
        if (stopAt == -1) {
            stopAt = YEAR_TO_GIVEUP_SCHEDULING_AT;
        }
        if (startAt == -1 || startAt == ALL_SPEC_INT) {
            startAt = 1969;
        }
    }
    int max = -1;
    if (stopAt < startAt) {
        switch(type) {
            case SECOND:
            case MINUTE:
                max = 60;
                break;
            case HOUR:
                max = 24;
                break;
            case MONTH:
                max = 12;
                break;
            case DAY_OF_WEEK:
                max = 7;
                break;
            case DAY_OF_MONTH:
                max = 31;
                break;
            case YEAR:
                throw new IllegalArgumentException(""Start year must be less than stop year"");
            default:
                throw new IllegalArgumentException(""Unexpected type encountered"");
        }
        stopAt += max;
    }
    for (int i = startAt; i <= stopAt; i += incr) {
        if (max == -1) {
            set.add(i);
        } else {
            int i2 = i % max;
            if (i2 == 0 && (type == MONTH || type == DAY_OF_WEEK || type == DAY_OF_MONTH)) {
                i2 = max;
            }
            set.add(i2);
        }
    }
}",java:S3776,39
"private void processElement(final DeclarationScopeResolver resolver, final Deque<RuleConditionElement> contextList, final RuleConditionElement element){
    if (element instanceof Pattern) {
        Pattern pattern = (Pattern) element;
        for (RuleConditionElement ruleConditionElement : pattern.getNestedElements()) {
            processElement(resolver, contextList, ruleConditionElement);
        }
        for (Constraint constraint : pattern.getConstraints()) {
            if (constraint instanceof Declaration) {
                continue;
            }
            replaceDeclarations(resolver, pattern, constraint);
        }
    } else if (element instanceof EvalCondition) {
        processEvalCondition(resolver, (EvalCondition) element);
    } else if (element instanceof Accumulate) {
        for (RuleConditionElement rce : element.getNestedElements()) {
            processElement(resolver, contextList, rce);
        }
        Accumulate accumulate = (Accumulate) element;
        replaceDeclarations(resolver, accumulate);
    } else if (element instanceof From) {
        DataProvider provider = ((From) element).getDataProvider();
        Declaration[] decl = provider.getRequiredDeclarations();
        for (Declaration aDecl : decl) {
            Declaration resolved = resolver.getDeclaration(aDecl.getIdentifier());
            if (resolved != null && resolved != aDecl) {
                provider.replaceDeclaration(aDecl, resolved);
            } else if (resolved == null) {
                Pattern old = aDecl.getPattern();
                Pattern current = resolver.findPatternById(old.getPatternId());
                if (current != null && old != current) {
                    resolved = aDecl.cloneWithPattern(current);
                    provider.replaceDeclaration(aDecl, resolved);
                }
            }
        }
    } else if (element instanceof QueryElement) {
        QueryElement qe = (QueryElement) element;
        Pattern pattern = qe.getResultPattern();
        for (Entry<String, Declaration> entry : pattern.getInnerDeclarations().entrySet()) {
            Declaration resolved = resolver.getDeclaration(entry.getValue().getIdentifier());
            if (resolved != null && resolved != entry.getValue() && resolved.getPattern() != pattern) {
                entry.setValue(resolved);
            }
        }
        List<Integer> varIndexes = asList(qe.getVariableIndexes());
        for (int i = 0; i < qe.getArguments().length; i++) {
            if (!(qe.getArguments()[i] instanceof QueryArgument.Declr)) {
                continue;
            }
            Declaration declr = ((QueryArgument.Declr) qe.getArguments()[i]).getDeclaration();
            Declaration resolved = resolver.getDeclaration(declr.getIdentifier());
            if (resolved != declr && resolved.getPattern() != pattern) {
                qe.getArguments()[i] = new QueryArgument.Declr(resolved);
            }
            if (ClassObjectType.DroolsQuery_ObjectType.isAssignableFrom(resolved.getPattern().getObjectType())) {
                declr = pattern.addDeclaration(declr.getIdentifier());
                ArrayElementReader reader = new ArrayElementReader(new SelfReferenceClassFieldReader(Object[].class), i, resolved.getDeclarationClass());
                declr.setReadAccessor(reader);
                varIndexes.add(i);
            }
        }
        qe.setVariableIndexes(toIntArray(varIndexes));
    } else if (element instanceof ConditionalBranch) {
        processBranch(resolver, (ConditionalBranch) element);
    } else {
        contextList.push(element);
        for (RuleConditionElement ruleConditionElement : element.getNestedElements()) {
            processElement(resolver, contextList, ruleConditionElement);
        }
        contextList.pop();
    }
}",java:S3776,39
"public HashEntry clone(){
    SingleHashEntry singleEntry = new SingleHashEntry();
    singleEntry.hashCode = hashCode;
    singleEntry.obj1 = obj1;
    return singleEntry;
}",java:S2975,34
"public HashEntry clone(){
    SingleHashEntry singleEntry = new SingleHashEntry();
    singleEntry.hashCode = hashCode;
    singleEntry.obj1 = obj1;
    return singleEntry;
}",java:S1182,14
"private void replaceDeclarations(DeclarationScopeResolver resolver, Pattern pattern, Constraint constraint){
    Declaration[] decl = constraint.getRequiredDeclarations();
    for (Declaration aDecl : decl) {
        Declaration resolved = resolver.getDeclaration(aDecl.getIdentifier());
        if (constraint instanceof IndexableConstraint && ((IndexableConstraint) constraint).isUnification()) {
            if (ClassObjectType.DroolsQuery_ObjectType.isAssignableFrom(resolved.getPattern().getObjectType())) {
                Declaration redeclaredDeclr = new Declaration(resolved.getIdentifier(), ((IndexableConstraint) constraint).getFieldExtractor(), pattern, false);
                pattern.addDeclaration(redeclaredDeclr);
            } else if (resolved.getPattern() != pattern) {
                ((IndexableConstraint) constraint).unsetUnification();
            }
        }
        if (resolved != null && resolved != aDecl && resolved.getPattern() != pattern) {
            constraint.replaceDeclaration(aDecl, resolved);
        } else if (resolved == null) {
            Pattern old = aDecl.getPattern();
            Pattern current = resolver.findPatternById(old.getPatternId());
            if (current != null && old != current) {
                resolved = aDecl.cloneWithPattern(current);
                constraint.replaceDeclaration(aDecl, resolved);
            }
        }
    }
}",java:S3776,39
"public HashEntry clone(){
    DoubleHashEntry doubleEntry = new DoubleHashEntry();
    doubleEntry.hashCode = hashCode;
    doubleEntry.obj1 = obj1;
    doubleEntry.obj2 = obj2;
    return doubleEntry;
}",java:S2975,34
"public HashEntry clone(){
    DoubleHashEntry doubleEntry = new DoubleHashEntry();
    doubleEntry.hashCode = hashCode;
    doubleEntry.obj1 = obj1;
    doubleEntry.obj2 = obj2;
    return doubleEntry;
}",java:S1182,14
"public HashEntry clone(){
    TripleHashEntry tripleEntry = new TripleHashEntry();
    tripleEntry.hashCode = hashCode;
    tripleEntry.obj1 = obj1;
    tripleEntry.obj2 = obj2;
    tripleEntry.obj3 = obj3;
    return tripleEntry;
}",java:S2975,34
"public HashEntry clone(){
    TripleHashEntry tripleEntry = new TripleHashEntry();
    tripleEntry.hashCode = hashCode;
    tripleEntry.obj1 = obj1;
    tripleEntry.obj2 = obj2;
    tripleEntry.obj3 = obj3;
    return tripleEntry;
}",java:S1182,14
"public static URL getURL(String confName, ClassLoader classLoader, Class cls){
    URL url;
    String userHome = PortablePath.of(System.getProperty(""user.home"")).asString();
    if (userHome.endsWith(""/"")) {
        url = getURLForFile(userHome + confName);
    } else {
        url = getURLForFile(userHome + ""/"" + confName);
    }
    if (url == null) {
        url = getURLForFile(confName);
    }
    if (cls != null) {
        URL urlResource = cls.getResource(confName);
        if (urlResource != null) {
            url = urlResource;
        }
    }
    if (url == null && classLoader != null) {
        url = classLoader.getResource(""META-INF/"" + confName);
    }
    if (url == null) {
        ClassLoader confClassLoader = ConfFileUtils.class.getClassLoader();
        if (confClassLoader != null && confClassLoader != classLoader) {
            url = confClassLoader.getResource(""META-INF/"" + confName);
        }
    }
    if (url == null && cls != null) {
        ClassLoader confClassLoader = cls.getClassLoader();
        if (confClassLoader != null && confClassLoader != classLoader) {
            url = confClassLoader.getResource(""META-INF/"" + confName);
        }
    }
    if (url == null) {
        ClassLoader confClassLoader = Thread.currentThread().getContextClassLoader();
        if (confClassLoader != null && confClassLoader != classLoader) {
            url = confClassLoader.getResource(""META-INF/"" + confName);
        }
    }
    if (url == null) {
        ClassLoader confClassLoader = ClassLoader.getSystemClassLoader();
        if (confClassLoader != null && confClassLoader != classLoader) {
            url = confClassLoader.getResource(""META-INF/"" + confName);
        }
    }
    return url;
}",java:S3776,39
"public static String URLContentsToString(URL url){
    StringBuilder builder = new StringBuilder();
    if (url == null) {
        return null;
    }
    try (BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), IoUtils.UTF8_CHARSET))) {
        String line;
        while ((line = reader.readLine()) != null) {
            builder.append(line);
            builder.append(""\n"");
        }
    } catch (IOException e) {
        throw new RuntimeException(""Unable to read "" + url.toExternalForm());
    }
    return builder.toString();
}",java:S100,0
"public void transform(final GroupElement parent) throws InvalidPatternException{
    final List<GroupElement> orsList = new ArrayList<>();
    final RuleConditionElement[] others = new RuleConditionElement[parent.getChildren().size()];
    int permutations = 1;
    int index = 0;
    for (final RuleConditionElement child : parent.getChildren()) {
        if ((child instanceof GroupElement) && ((GroupElement) child).isOr()) {
            permutations *= ((GroupElement) child).getChildren().size();
            orsList.add((GroupElement) child);
        } else {
            others[index] = child;
        }
        index++;
    }
    parent.setType(GroupElement.OR);
    parent.getChildren().clear();
    final int[] indexes = new int[orsList.size()];
    for (int i = 1; i <= permutations; i++) {
        final GroupElement and = GroupElementFactory.newAndInstance();
        int mod = 1;
        for (int j = orsList.size() - 1; j >= 0; j--) {
            GroupElement or = orsList.get(j);
            and.addChild(0, or.getChildren().get(indexes[j]).clone());
            if ((i % mod) == 0) {
                indexes[j] = (indexes[j] + 1) % or.getChildren().size();
            }
            mod *= or.getChildren().size();
        }
        for (int j = 0; j < others.length; j++) {
            if (others[j] != null) {
                and.addChild(j, others[j].clone());
            }
        }
        parent.addChild(and);
    }
    parent.pack();
}",java:S3776,39
"public void remove(){
    if (this.immutable) {
        throw new UnsupportedOperationException(""This  Iterator is immutable, you cannot call remove()"");
    }
    if (this.currentNode != null) {
        this.list.remove(this.currentNode);
        this.currentNode = null;
    } else {
        throw new IllegalStateException(""No item to remove. Call next() before calling remove()."");
    }
}",java:S1161,11
"public synchronized Class loadClass(final String name, final boolean resolve) throws ClassNotFoundException{
    Class clazz = fastFindClass(name);
    if (clazz == null) {
        final ClassLoader parent = getParent();
        if (parent != null) {
            clazz = Class.forName(name, true, parent);
        }
    }
    if (resolve) {
        resolveClass(clazz);
    }
    return clazz;
}",java:S1161,11
"protected Class findClass(final String name) throws ClassNotFoundException{
    return fastFindClass(name);
}",java:S1161,11
"public Node<K> findNearestNode(K key, boolean allowEqual, Boundary boundary){
    if (key == null) {
        return allowEqual ? nullNode : null;
    }
    Node<K> nearest = null;
    Node<K> n = root;
    while (n != null) {
        int compResult = key.compareTo(n.key);
        if (allowEqual && compResult == 0) {
            return n;
        }
        boolean accepted = acceptNode(compResult, boundary);
        if (acceptNode(compResult, boundary) && (nearest == null || acceptNode(n.key.compareTo(nearest.key), boundary))) {
            nearest = n;
        }
        if (compResult == 0) {
            n = boundary == Boundary.LOWER ? n.right : n.left;
        } else {
            n = accepted ^ boundary == Boundary.LOWER ? n.right : n.left;
        }
    }
    return nearest;
}",java:S3776,39
"public Node<K> insert(K key){
    if (key == null) {
        if (nullNode == null) {
            nullNode = new Node<>(key);
        }
        return nullNode;
    }
    Node<K> insertedNode;
    if (root == null) {
        insertedNode = new Node<>(key);
        root = insertedNode;
    } else {
        Node<K> n = root;
        while (true) {
            int compResult = key.compareTo(n.key);
            if (compResult == 0) {
                return n;
            } else if (compResult < 0) {
                if (n.left == null) {
                    insertedNode = new Node<>(key);
                    n.left = insertedNode;
                    break;
                } else {
                    n = n.left;
                }
            } else {
                if (n.right == null) {
                    insertedNode = new Node<>(key);
                    n.right = insertedNode;
                    break;
                } else {
                    n = n.right;
                }
            }
        }
        insertedNode.parent = n;
    }
    insertCase1(insertedNode);
    return insertedNode;
}",java:S3776,39
"public InputStream getResourceAsStream(final String name){
    byte[] bytes;
    synchronized (this.store) {
        bytes = this.store.get(convertResourcePathToClassName(name));
    }
    if (bytes != null) {
        return new ByteArrayInputStream(bytes);
    } else {
        InputStream input = this.getParent().getResourceAsStream(name);
        if (input == null) {
            input = super.getResourceAsStream(name);
        }
        return input;
    }
}",java:S1161,11
"private static Node<K> maximumNode(Node<K> n){
    while (n.right != null) {
        n = n.right;
    }
    return n;
}",java:S2326,30
"public String toString(){
    return ""Node key="" + key;
}",java:S1161,11
"public void setNext(TupleList next){
}",java:S1161,11
"public TupleList getNext(){
    return null;
}",java:S1161,11
"private Comparable extractKey(IndexableConstraint constraint){
    FieldValue field = constraint.getField();
    ValueType valueType = fieldIndex.getFieldExtractor().getValueType();
    if (valueType == ValueType.PCHAR_TYPE || valueType == ValueType.CHAR_TYPE) {
        return field.getCharValue();
    } else if (valueType == ValueType.PBYTE_TYPE || valueType == ValueType.BYTE_TYPE) {
        return field.getByteValue();
    } else if (valueType == ValueType.PSHORT_TYPE || valueType == ValueType.SHORT_TYPE) {
        return field.getShortValue();
    } else if (valueType == ValueType.PINTEGER_TYPE || valueType == ValueType.INTEGER_TYPE) {
        return field.getIntValue();
    } else if (valueType == ValueType.PLONG_TYPE || valueType == ValueType.LONG_TYPE) {
        return field.getLongValue();
    } else if (valueType == ValueType.PFLOAT_TYPE || valueType == ValueType.FLOAT_TYPE) {
        return field.getFloatValue();
    } else if (valueType == ValueType.PDOUBLE_TYPE || valueType == ValueType.DOUBLE_TYPE) {
        return field.getDoubleValue();
    } else if (valueType == ValueType.PBOOLEAN_TYPE || valueType == ValueType.BOOLEAN_TYPE) {
        return field.getBooleanValue();
    } else if (valueType == ValueType.STRING_TYPE) {
        return (Comparable) field.getValue();
    } else if (valueType.isDate()) {
        return (Comparable) field.getValue();
    } else if (valueType == ValueType.ARRAY_TYPE) {
        return (Comparable) field.getValue();
    } else if (valueType == ValueType.OBJECT_TYPE) {
        return (Comparable) field.getValue();
    } else if (valueType == ValueType.TRAIT_TYPE) {
        return (Comparable) field.getValue();
    } else if (valueType == ValueType.BIG_DECIMAL_TYPE) {
        return field.getBigDecimalValue();
    } else if (valueType == ValueType.BIG_INTEGER_TYPE) {
        return field.getBigIntegerValue();
    } else if (valueType == ValueType.CLASS_TYPE) {
        return (Comparable) field.getValue();
    } else {
        return (Comparable) field.getValue();
    }
}",java:S3776,39
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    arraySize = in.readInt();
    this.accumulators = new Accumulator[in.readInt()];
    for (int i = 0; i < this.accumulators.length; i++) {
        this.accumulators[i] = (Accumulator) in.readObject();
    }
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeInt(arraySize);
    out.writeInt(accumulators.length);
    for (Accumulator acc : accumulators) {
        if (CompiledInvoker.isCompiledInvoker(acc)) {
            out.writeObject(null);
        } else {
            out.writeObject(acc);
        }
    }
}",java:S1161,11
"public MultiAccumulate clone(){
    RuleConditionElement clonedSource = source instanceof GroupElement ? ((GroupElement) source).cloneOnlyGroup() : source.clone();
    MultiAccumulate clone = new MultiAccumulate(clonedSource, this.requiredDeclarations, this.accumulators, this.arraySize);
    registerClone(clone);
    return clone;
}",java:S2975,34
"public synchronized int read(byte[] b, int off, int len) throws IOException{
    if (in == null) {
        throw new IOException(""Stream Closed"");
    }
    while (slack == null) {
        char[] buf = new char[len];
        int n = in.read(buf);
        if (n == -1) {
            return -1;
        }
        if (n > 0) {
            slack = new String(buf, 0, n).getBytes(encoding);
            begin = 0;
        }
    }
    if (len > slack.length - begin) {
        len = slack.length - begin;
    }
    System.arraycopy(slack, begin, b, off, len);
    if ((begin += len) >= slack.length) {
        slack = null;
    }
    return len;
}",java:S1161,11
"public synchronized void mark(final int limit){
    try {
        in.mark(limit);
    } catch (IOException ioe) {
        throw new RuntimeException(ioe.getMessage());
    }
}",java:S1161,11
"public synchronized int available() throws IOException{
    if (in == null) {
        throw new IOException(""Stream Closed"");
    }
    if (slack != null) {
        return slack.length - begin;
    }
    if (in.ready()) {
        return 1;
    } else {
        return 0;
    }
}",java:S1161,11
"public boolean markSupported(){
    return false;
}",java:S1161,11
"public MultiAccumulate clone(){
    RuleConditionElement clonedSource = source instanceof GroupElement ? ((GroupElement) source).cloneOnlyGroup() : source.clone();
    MultiAccumulate clone = new MultiAccumulate(clonedSource, this.requiredDeclarations, this.accumulators, this.arraySize);
    registerClone(clone);
    return clone;
}",java:S1182,14
"public synchronized void reset() throws IOException{
    if (in == null) {
        throw new IOException(""Stream Closed"");
    }
    slack = null;
    in.reset();
}",java:S1161,11
"public synchronized void close() throws IOException{
    if (in != null) {
        in.close();
        slack = null;
        in = null;
    }
}",java:S1161,11
"public static EnumSet<Code> getAttributeCodeSet(){
    return ATTRIBUTE_CODE_SET;
}",java:S1319,22
"private Package buildRuleSet(){
    final String defaultPackageName = ""rule_table"";
    final String rulesetName = getProperties().getSingleProperty(RULESET_TAG, defaultPackageName);
    final Package ruleset = new Package((showPackage) ? rulesetName : null);
    for (Rule rule : this._ruleList) {
        ruleset.addRule(rule);
    }
    List<String> units = getProperties().getProperty(UNIT_TAG);
    if (units != null && !units.isEmpty()) {
        ruleset.setRuleUnit(units.get(0));
    }
    List<String> dialects = getProperties().getProperty(DIALECT_TAG);
    if (dialects != null && !dialects.isEmpty()) {
        ruleset.setDialect(dialects.get(0));
    }
    final List<Import> importList = RuleSheetParserUtil.getImportList(getProperties().getProperty(IMPORT_TAG));
    for (Import import1 : importList) {
        ruleset.addImport(import1);
    }
    final List<Global> variableList = RuleSheetParserUtil.getVariableList(getProperties().getProperty(VARIABLES_TAG));
    for (Global global : variableList) {
        ruleset.addVariable(global);
    }
    final List<String> functions = getProperties().getProperty(FUNCTIONS_TAG);
    if (functions != null) {
        for (String function : functions) {
            ruleset.addFunctions(function);
        }
    }
    final List<String> queries = getProperties().getProperty(QUERIES_TAG);
    if (queries != null) {
        for (String query : queries) {
            ruleset.addQueries(query);
        }
    }
    final List<String> declarations = getProperties().getProperty(DECLARES_TAG);
    if (declarations != null) {
        for (String declaration : declarations) {
            ruleset.addDeclaredType(declaration);
        }
    }
    for (Code code : ActionType.ATTRIBUTE_CODE_SET) {
        List<String> values = getProperties().getProperty(code.getColHeader());
        if (values != null) {
            if (values.size() > 1) {
                List<String> cells = getProperties().getPropertyCells(code.getColHeader());
                throw new DecisionTableParseException(""Multiple values for "" + code.getColHeader() + "" in cells "" + cells.toString());
            }
            String value = values.get(0);
            switch(code) {
                case SALIENCE:
                    try {
                        ruleset.setSalience(Integer.valueOf(value));
                    } catch (NumberFormatException nfe) {
                        throw new DecisionTableParseException(""Priority is not an integer literal, in cell "" + getProperties().getSinglePropertyCell(code.getColHeader()));
                    }
                    break;
                case DURATION:
                    try {
                        ruleset.setDuration(Long.valueOf(value));
                    } catch (NumberFormatException nfe) {
                        throw new DecisionTableParseException(""Duration is not an integer literal, in cell "" + getProperties().getSinglePropertyCell(code.getColHeader()));
                    }
                    break;
                case TIMER:
                    ruleset.setTimer(value);
                    break;
                case ENABLED:
                    ruleset.setEnabled(RuleSheetParserUtil.isStringMeaningTrue(value));
                    break;
                case CALENDARS:
                    ruleset.setCalendars(value);
                    break;
                case NOLOOP:
                    ruleset.setNoLoop(RuleSheetParserUtil.isStringMeaningTrue(value));
                    break;
                case LOCKONACTIVE:
                    ruleset.setLockOnActive(RuleSheetParserUtil.isStringMeaningTrue(value));
                    break;
                case AUTOFOCUS:
                    ruleset.setAutoFocus(RuleSheetParserUtil.isStringMeaningTrue(value));
                    break;
                case ACTIVATIONGROUP:
                    ruleset.setActivationGroup(value);
                    break;
                case AGENDAGROUP:
                    ruleset.setAgendaGroup(value);
                    break;
                case RULEFLOWGROUP:
                    ruleset.setRuleFlowGroup(value);
                    break;
                case DATEEFFECTIVE:
                    ruleset.setDateEffective(value);
                    break;
                case DATEEXPIRES:
                    ruleset.setDateExpires(value);
                    break;
            }
        }
    }
    return ruleset;
}",java:S3776,39
"protected void preInitRuleTable(int row, int column, String value){
}",java:S1186,16
"protected void postInitRuleTable(int row, int column, String value){
}",java:S1186,16
"private void nextDataCell(final int row, final int column, final String value){
    final ActionType actionType = getActionForColumn(row, column);
    if (row - this._ruleRow > 1) {
        finishRuleTable();
        processNonRuleCell(row, column, value);
        return;
    }
    if (row > this._ruleRow) {
        String headCell = RuleSheetParserUtil.rc2name(this._ruleStartRow, this._ruleStartColumn);
        String ruleCell = RuleSheetParserUtil.rc2name(row, this._ruleStartColumn);
        this._currentRule = createNewRuleForRow(row, headCell, ruleCell);
        this._ruleList.add(this._currentRule);
        this._ruleRow++;
    }
    switch(actionType.getCode()) {
        case CONDITION:
        case ACTION:
        case METADATA:
            if (actionType.getSourceBuilder() == null) {
                throw new DecisionTableParseException(""Data cell "" + RuleSheetParserUtil.rc2name(row, column) + "" has an empty column header."");
            }
            actionType.addCellValue(row, column, value, _currentEscapeQuotesFlag, trimCell);
            break;
        case SALIENCE:
            if (!this._currentSequentialFlag) {
                if (value.startsWith(""("") && value.endsWith("")"")) {
                    this._currentRule.setSalience(value);
                } else {
                    try {
                        this._currentRule.setSalience(Integer.valueOf(value));
                    } catch (NumberFormatException nfe) {
                        throw new DecisionTableParseException(""Priority is not an integer literal, in cell "" + RuleSheetParserUtil.rc2name(row, column));
                    }
                }
            }
            break;
        case NAME:
            this._currentRule.setName(value);
            break;
        case DESCRIPTION:
            this._currentRule.setDescription(value);
            break;
        case ACTIVATIONGROUP:
            this._currentRule.setActivationGroup(value);
            break;
        case AGENDAGROUP:
            this._currentRule.setAgendaGroup(value);
            break;
        case RULEFLOWGROUP:
            this._currentRule.setRuleFlowGroup(value);
            break;
        case NOLOOP:
            this._currentRule.setNoLoop(RuleSheetParserUtil.isStringMeaningTrue(value));
            break;
        case LOCKONACTIVE:
            this._currentRule.setLockOnActive(RuleSheetParserUtil.isStringMeaningTrue(value));
            break;
        case AUTOFOCUS:
            this._currentRule.setAutoFocus(RuleSheetParserUtil.isStringMeaningTrue(value));
            break;
        case DURATION:
            try {
                this._currentRule.setDuration(Long.valueOf(value));
            } catch (NumberFormatException nfe) {
                throw new DecisionTableParseException(""Duration is not an integer literal, in cell "" + RuleSheetParserUtil.rc2name(row, column));
            }
            break;
        case TIMER:
            this._currentRule.setTimer(value);
            break;
        case ENABLED:
            this._currentRule.setEnabled(RuleSheetParserUtil.isStringMeaningTrue(value));
            break;
        case CALENDARS:
            this._currentRule.setCalendars(value);
            break;
        case DATEEFFECTIVE:
            this._currentRule.setDateEffective(value);
            break;
        case DATEEXPIRES:
            this._currentRule.setDateExpires(value);
            break;
    }
}",java:S3776,39
"public void addCellValue(int row, int column, String value, boolean trim){
    this.hasValues = true;
    if (this.constraints.isEmpty()) {
        return;
    }
    Integer key = Integer.valueOf(column);
    String content = this.constraints.get(key);
    if (content == null) {
        throw new DecisionTableParseException(""No code snippet for CONDITION in cell "" + RuleSheetParserUtil.rc2name(this.headerRow + 2, this.headerCol));
    }
    SnippetBuilder snip = new SnippetBuilder(content, trim);
    String result = snip.build(fixValue(column, value));
    this.values.add(result);
}",java:S1161,11
"public void newCell(final int row, final int column, final String value, final int mergedColStart){
    if (!isInRuleTable) {
        super.newCell(row, column, value, mergedColStart);
        return;
    }
    if (StringUtils.isEmpty(value)) {
        return;
    }
    if (row == (ruleTableRow) && column > ruleTableColumn) {
        _horizontalConditions.add(createCondition(value, _horizontalCondition));
    } else if (row > (ruleTableRow) && column == ruleTableColumn) {
        _currentVerticalCondition = createCondition(value, _verticalCondition);
    } else if (row > (ruleTableRow) && column > ruleTableColumn) {
        createRule(row, column, value);
    }
}",java:S1161,11
"public void newRow(int rowNumber, int columns){
}",java:S1161,11
"public void finishSheet(){
}",java:S1161,11
"protected void postInitRuleTable(int row, int column, String value){
    this.firstRule = getCurrentRule();
}",java:S1161,11
"protected void preInitRuleTable(final int row, final int column, final String value){
    this.ruleTableColumn = column;
    this.ruleTableRow = row;
    this.isInRuleTable = true;
    this._currentAgendaGroup = getProperties().getSingleProperty(AGENDAGROUP_TAG);
    this._action = getProperties().getSingleProperty(ACTION_TAG);
    this._horizontalCondition = getProperties().getSingleProperty(HORIZONTALCONDITION_TAG);
    this._verticalCondition = getProperties().getSingleProperty(VERTICALCONDITION_TAG);
    String precondition = getProperties().getSingleProperty(PRECONDITION_TAG);
    if (precondition != null) {
        this._currentPrecondition = new Condition();
        this._currentPrecondition.setSnippet(precondition);
    }
}",java:S1161,11
"private static void invalidRuleTableDef(final String ruleRow){
    throw new IllegalArgumentException(""Invalid rule table header cell. Should be in the format of 'RuleTable YourRuleName'. "" + ""It was: \n ["" + ruleRow + ""] \n"");
}",java:S1144,10
"private void processSheet(Sheet sheet, List<? extends DataListener> listeners){
    int maxRows = sheet.getLastRowNum();
    CellRangeAddress[] mergedRanges = getMergedCells(sheet);
    DataFormatter formatter = new DataFormatter(Locale.ENGLISH);
    FormulaEvaluator formulaEvaluator = sheet.getWorkbook().getCreationHelper().createFormulaEvaluator();
    for (int i = 0; i <= maxRows; i++) {
        Row row = sheet.getRow(i);
        int lastCellNum = row != null ? row.getLastCellNum() : 0;
        newRow(listeners, i, lastCellNum);
        for (int cellNum = 0; cellNum < lastCellNum; cellNum++) {
            Cell cell = row.getCell(cellNum);
            if (cell == null) {
                continue;
            }
            double num = 0;
            CellRangeAddress merged = getRangeIfMerged(cell, mergedRanges);
            int mergedColStart = DataListener.NON_MERGED;
            if (merged != null) {
                cell = sheet.getRow(merged.getFirstRow()).getCell(merged.getFirstColumn());
                mergedColStart = cell.getColumnIndex();
            }
            switch(cell.getCellType()) {
                case BOOLEAN:
                    newCell(listeners, i, cellNum, cell.getBooleanCellValue() ? ""true"" : ""false"", mergedColStart);
                    break;
                case FORMULA:
                    try {
                        boolean ignoreNumericFormat = doesIgnoreNumericFormat(listeners) && !isGeneralFormat(cell);
                        newCell(listeners, i, cellNum, getFormulaValue(formatter, formulaEvaluator, cell, ignoreNumericFormat), mergedColStart);
                    } catch (RuntimeException e) {
                        log.warn(""Cannot resolve externally linked value: "" + formatter.formatCellValue(cell));
                        String cachedValue = tryToReadCachedValue(cell);
                        newCell(listeners, i, cellNum, cachedValue, mergedColStart);
                    }
                    break;
                case NUMERIC:
                    if (isNumericDisabled(listeners)) {
                    } else if (DateUtil.isCellDateFormatted(cell)) {
                        newCell(listeners, i, cellNum, ""\"""" + DateUtils.format(cell.getDateCellValue()) + ""\"""", mergedColStart);
                        break;
                    } else {
                        num = cell.getNumericCellValue();
                        if (doesIgnoreNumericFormat(listeners) && !isGeneralFormat(cell)) {
                            newCell(listeners, i, cellNum, String.valueOf(num), mergedColStart);
                            break;
                        }
                    }
                default:
                    if (num - Math.round(num) != 0) {
                        newCell(listeners, i, cellNum, String.valueOf(num), mergedColStart);
                    } else {
                        newCell(listeners, i, cellNum, formatter.formatCellValue(cell), mergedColStart);
                    }
            }
        }
    }
    finishSheet(listeners);
}",java:S3776,39
"public void startSheet(final String name){
}",java:S1186,16
"public void finishSheet(){
}",java:S1186,16
"public void newRow(final int rowNumber, final int columns){
}",java:S1186,16
"public void newCell(final int row, final int column, final String value, final int mergedColstart){
}",java:S1186,16
"public void startSheet(final String name){
}",java:S1186,16
"public void setText(String text){
    this.text = text;
}",java:S1161,11
"public void accept(DescrVisitor visitor){
    visitor.visit(this);
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(annotations);
}",java:S1161,11
"public String toString(){
    return ""&&"";
}",java:S1161,11
"public String toString(){
    return ""||"";
}",java:S1161,11
"public String toString(){
    return this.connective;
}",java:S1161,11
"public Pattern clone(){
    final String identifier = (this.declaration != null) ? this.declaration.getIdentifier() : null;
    final Pattern clone = new Pattern(this.patternId, this.tupleIndex, this.objectIndex, this.objectType, identifier, this.declaration != null && this.declaration.isInternalFact());
    clone.listenedProperties = listenedProperties;
    if (this.getSource() != null) {
        clone.setSource((PatternSource) this.getSource().clone());
        if (source instanceof From) {
            ((From) clone.getSource()).setResultPattern(clone);
        }
    }
    for (Declaration decl : this.declarations.values()) {
        Declaration addedDeclaration = clone.addDeclaration(decl.getIdentifier());
        addedDeclaration.setReadAccessor(decl.getExtractor());
        addedDeclaration.setBindingName(decl.getBindingName());
        addedDeclaration.setxPathOffset(decl.getxPathOffset());
    }
    for (Constraint oldConstr : this.constraints) {
        Constraint clonedConstr = oldConstr.clone();
        Declaration[] oldDecl = oldConstr.getRequiredDeclarations();
        Declaration[] newDecl = clonedConstr.getRequiredDeclarations();
        for (int i = 0; i < newDecl.length; i++) {
            if (newDecl[i].getPattern() == this) {
                newDecl[i].setPattern(clone);
                clonedConstr.replaceDeclaration(oldDecl[i], newDecl[i]);
            }
        }
        clone.addConstraint(clonedConstr);
    }
    if (behaviors != null) {
        for (Behavior behavior : this.behaviors) {
            clone.addBehavior(behavior);
        }
    }
    return clone;
}",java:S2975,34
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(id);
    out.writeObject(label);
    out.writeObject(arguments);
}",java:S1161,11
"public Pattern clone(){
    final String identifier = (this.declaration != null) ? this.declaration.getIdentifier() : null;
    final Pattern clone = new Pattern(this.patternId, this.tupleIndex, this.objectIndex, this.objectType, identifier, this.declaration != null && this.declaration.isInternalFact());
    clone.listenedProperties = listenedProperties;
    if (this.getSource() != null) {
        clone.setSource((PatternSource) this.getSource().clone());
        if (source instanceof From) {
            ((From) clone.getSource()).setResultPattern(clone);
        }
    }
    for (Declaration decl : this.declarations.values()) {
        Declaration addedDeclaration = clone.addDeclaration(decl.getIdentifier());
        addedDeclaration.setReadAccessor(decl.getExtractor());
        addedDeclaration.setBindingName(decl.getBindingName());
        addedDeclaration.setxPathOffset(decl.getxPathOffset());
    }
    for (Constraint oldConstr : this.constraints) {
        Constraint clonedConstr = oldConstr.clone();
        Declaration[] oldDecl = oldConstr.getRequiredDeclarations();
        Declaration[] newDecl = clonedConstr.getRequiredDeclarations();
        for (int i = 0; i < newDecl.length; i++) {
            if (newDecl[i].getPattern() == this) {
                newDecl[i].setPattern(clone);
                clonedConstr.replaceDeclaration(oldDecl[i], newDecl[i]);
            }
        }
        clone.addConstraint(clonedConstr);
    }
    if (behaviors != null) {
        for (Behavior behavior : this.behaviors) {
            clone.addBehavior(behavior);
        }
    }
    return clone;
}",java:S1182,14
"public void accept(DescrVisitor visitor){
    visitor.visit(this);
}",java:S1161,11
"public String toString(){
    return ""import function "" + this.getTarget();
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    groupingFunction = (String) in.readObject();
    groupingKey = (String) in.readObject();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(groupingFunction);
    out.writeObject(groupingKey);
}",java:S1161,11
"public String toString(){
    return super.toString() + "" "" + this.getText();
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    breaking = in.readBoolean();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeBoolean(breaking);
}",java:S1161,11
"public void accept(DescrVisitor visitor){
    visitor.visit(this);
}",java:S1161,11
"public List<? extends BaseDescr> getDescrs(){
    return this.constraint.getDescrs();
}",java:S1452,23
"public List<? extends BaseDescr> getPositionalConstraints(){
    return this.doGetConstraints(ExprConstraintDescr.Type.POSITIONAL);
}",java:S1452,23
"public List<? extends BaseDescr> getSlottedConstraints(){
    return this.doGetConstraints(ExprConstraintDescr.Type.NAMED);
}",java:S1452,23
"public PatternDescr clone(){
    PatternDescr clone = new PatternDescr(this.objectType, this.identifier);
    clone.setQuery(this.query);
    clone.setUnification(unification);
    clone.setLeftParentCharacter(this.leftParentCharacter);
    clone.setRightParentCharacter(this.rightParentCharacter);
    clone.setSource(this.source);
    clone.setStartCharacter(this.getStartCharacter());
    clone.setEndCharacter(this.getEndCharacter());
    clone.setLocation(this.getLine(), this.getColumn());
    clone.setEndLocation(this.getEndLine(), this.getEndColumn());
    clone.setText(this.getText());
    for (BaseDescr constraint : this.getDescrs()) {
        clone.addConstraint(constraint);
    }
    if (behaviors != null) {
        for (BehaviorDescr behavior : behaviors) {
            clone.addBehavior(behavior);
        }
    }
    return clone;
}",java:S2975,34
"public PatternDescr clone(){
    PatternDescr clone = new PatternDescr(this.objectType, this.identifier);
    clone.setQuery(this.query);
    clone.setUnification(unification);
    clone.setLeftParentCharacter(this.leftParentCharacter);
    clone.setRightParentCharacter(this.rightParentCharacter);
    clone.setSource(this.source);
    clone.setStartCharacter(this.getStartCharacter());
    clone.setEndCharacter(this.getEndCharacter());
    clone.setLocation(this.getLine(), this.getColumn());
    clone.setEndLocation(this.getEndLine(), this.getEndColumn());
    clone.setText(this.getText());
    for (BaseDescr constraint : this.getDescrs()) {
        clone.addConstraint(constraint);
    }
    if (behaviors != null) {
        for (BehaviorDescr behavior : behaviors) {
            clone.addBehavior(behavior);
        }
    }
    return clone;
}",java:S1182,14
"public void accept(DescrVisitor visitor){
    visitor.visit(this);
}",java:S1161,11
"public String toString(){
    return ""[Query name='"" + getName() + ""']"";
}",java:S1161,11
"public boolean isNegated(){
    return operator != null ? operator.isNegated() : false;
}",java:S1161,11
"public String getText(){
    return text;
}",java:S1161,11
"public void setText(String text){
    this.text = text;
}",java:S1161,11
"public int compareTo(TypeDeclarationDescr descr){
    if (!this.getSuperTypes().isEmpty() && !descr.getSuperTypes().isEmpty()) {
        for (QualifiedName q : descr.getSuperTypes()) {
            if (this.getSuperTypes().contains(q)) {
                return -1;
            }
        }
        for (QualifiedName q : this.getSuperTypes()) {
            if (descr.getSuperTypes().contains(q)) {
                return +1;
            }
        }
    }
    for (TypeFieldDescr field : this.getFields().values()) {
        if (descr.getTypeName().equals(field.getPattern().getObjectType())) {
            return -1;
        }
    }
    for (TypeFieldDescr field : descr.getFields().values()) {
        if (this.getTypeName().equals(field.getPattern().getObjectType())) {
            return +1;
        }
    }
    return 0;
}",java:S3776,39
"public int compareTo(TypeDeclarationDescr descr){
    if (!this.getSuperTypes().isEmpty() && !descr.getSuperTypes().isEmpty()) {
        for (QualifiedName q : descr.getSuperTypes()) {
            if (this.getSuperTypes().contains(q)) {
                return -1;
            }
        }
        for (QualifiedName q : this.getSuperTypes()) {
            if (descr.getSuperTypes().contains(q)) {
                return +1;
            }
        }
    }
    for (TypeFieldDescr field : this.getFields().values()) {
        if (descr.getTypeName().equals(field.getPattern().getObjectType())) {
            return -1;
        }
    }
    for (TypeFieldDescr field : descr.getFields().values()) {
        if (this.getTypeName().equals(field.getPattern().getObjectType())) {
            return +1;
        }
    }
    return 0;
}",java:S1210,20
"public int compareTo(TypeFieldDescr other){
    return (this.index - other.index);
}",java:S1210,20
"public PackageDescr parse(boolean isEditor, final Reader drl, final Reader dsl) throws DroolsParserException, IOException{
    final StringBuilder text = getDRLText(drl);
    return parse(text.toString(), dsl);
}",java:S1172,13
"public String getMessage(){
    if (null == errorCode) {
        return super.getMessage();
    }
    return ""["" + errorCode + ""] "" + super.getMessage();
}",java:S1161,11
"public String toString(){
    return ""["" + this.row + "","" + this.col + ""]: "" + this.message;
}",java:S1161,11
"private Object readResolve() throws java.io.ObjectStreamException{
    Operator op = determineOperator(this.operator, this.isNegated);
    return op != null ? op : this;
}",java:S2062,26
"public TypeDeclarationDescr typeDeclaration(DeclareDescrBuilder ddb, boolean isTrait) throws RecognitionException{
    TypeDeclarationDescrBuilder declare = null;
    try {
        declare = helper.start(ddb, TypeDeclarationDescrBuilder.class, null);
        declare.setTrait(isTrait);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.TYPE)) {
            match(input, DRL5Lexer.ID, DroolsSoftKeywords.TYPE, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
        }
        String type = qualifiedIdentifier();
        if (state.failed)
            return null;
        if (state.backtracking == 0)
            declare.name(type);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.EXTENDS)) {
            match(input, DRL5Lexer.ID, DroolsSoftKeywords.EXTENDS, null, DroolsEditorType.KEYWORD);
            if (!state.failed) {
                String superType = qualifiedIdentifier();
                declare.superType(superType);
                while (input.LA(1) == DRL5Lexer.COMMA) {
                    match(input, DRL5Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                    superType = qualifiedIdentifier();
                    declare.superType(superType);
                }
            }
        }
        while (input.LA(1) == DRL5Lexer.AT) {
            annotation(declare);
            if (state.failed)
                return null;
        }
        while (input.LA(1) == DRL5Lexer.ID && !helper.validateIdentifierKey(DroolsSoftKeywords.END)) {
            field(declare);
            if (state.failed)
                return null;
        }
        match(input, DRL5Lexer.ID, DroolsSoftKeywords.END, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
    } catch (RecognitionException re) {
        reportError(re);
    } finally {
        helper.end(TypeDeclarationDescrBuilder.class, declare);
    }
    return (declare != null) ? declare.getDescr() : null;
}",java:S3776,39
"private void enumerative(EnumDeclarationDescrBuilder declare){
    EnumLiteralDescrBuilder literal = null;
    String lit = null;
    try {
        Token enumLit = match(input, DRL5Lexer.ID, null, null, DroolsEditorType.IDENTIFIER);
        lit = enumLit.getText();
        if (state.failed)
            return;
    } catch (RecognitionException re) {
        reportError(re);
    }
    try {
        literal = helper.start(declare, EnumLiteralDescrBuilder.class, lit);
        if (input.LA(1) == DRL5Lexer.LEFT_PAREN) {
            match(input, DRL5Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
            boolean more;
            do {
                int first = input.index();
                exprParser.conditionalExpression();
                if (state.failed)
                    return;
                if (state.backtracking == 0 && input.index() > first) {
                    String arg = input.toString(first, input.LT(-1).getTokenIndex());
                    literal.constructorArg(arg);
                }
                more = input.LA(1) == DRL5Lexer.COMMA;
                if (more) {
                    match(input, DRL5Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                }
            } while (more);
            match(input, DRL5Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
        }
    } catch (RecognitionException re) {
        reportError(re);
    } finally {
        helper.end(FieldDescrBuilder.class, literal);
    }
}",java:S3776,39
"private void field(AbstractClassTypeDeclarationBuilder declare){
    FieldDescrBuilder field = null;
    String fname = null;
    try {
        fname = label(DroolsEditorType.IDENTIFIER);
        if (state.failed)
            return;
    } catch (RecognitionException re) {
        reportError(re);
    }
    try {
        field = helper.start(declare, FieldDescrBuilder.class, fname);
        String type = type();
        if (state.failed)
            return;
        if (state.backtracking == 0)
            field.type(type);
        if (input.LA(1) == DRL5Lexer.EQUALS_ASSIGN) {
            match(input, DRL5Lexer.EQUALS_ASSIGN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
            int first = input.index();
            exprParser.conditionalExpression();
            if (state.failed)
                return;
            if (state.backtracking == 0 && input.index() > first) {
                String value = input.toString(first, input.LT(-1).getTokenIndex());
                field.initialValue(value);
            }
        }
        while (input.LA(1) == DRL5Lexer.AT) {
            annotation(field);
            if (state.failed)
                return;
        }
        if (input.LA(1) == DRL5Lexer.SEMICOLON) {
            match(input, DRL5Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
        }
    } catch (RecognitionException re) {
        reportError(re);
    } finally {
        helper.end(FieldDescrBuilder.class, field);
    }
}",java:S3776,39
"public RuleDescr query(PackageDescrBuilder pkg) throws RecognitionException{
    QueryDescrBuilder query = null;
    try {
        query = helper.start(pkg, QueryDescrBuilder.class, null);
        match(input, DRL5Lexer.ID, DroolsSoftKeywords.QUERY, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (helper.validateIdentifierKey(DroolsSoftKeywords.WHEN) || helper.validateIdentifierKey(DroolsSoftKeywords.THEN) || helper.validateIdentifierKey(DroolsSoftKeywords.END)) {
            failMissingTokenException();
            return null;
        }
        String name = stringId();
        if (state.backtracking == 0)
            query.name(name);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            helper.emit(Location.LOCATION_RULE_HEADER);
        }
        if (speculateParameters(true)) {
            parameters(query, true);
            if (state.failed)
                return null;
            if (state.backtracking == 0) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
            }
        } else if (speculateParameters(false)) {
            parameters(query, false);
            if (state.failed)
                return null;
            if (state.backtracking == 0) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
            }
        }
        while (input.LA(1) == DRL5Lexer.AT) {
            annotation(query);
            if (state.failed)
                return null;
        }
        if (state.backtracking == 0 && input.LA(1) != DRL5Lexer.EOF) {
            helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
        }
        if (input.LA(1) != DRL5Lexer.EOF) {
            lhsExpression(query != null ? query.lhs() : null);
        }
        match(input, DRL5Lexer.ID, DroolsSoftKeywords.END, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        helper.emit(Location.LOCATION_RHS);
    } catch (RecognitionException re) {
        reportError(re);
    } finally {
        helper.end(QueryDescrBuilder.class, query);
    }
    return (query != null) ? query.getDescr() : null;
}",java:S3776,39
"public RuleDescr rule(PackageDescrBuilder pkg) throws RecognitionException{
    RuleDescrBuilder rule = null;
    try {
        rule = helper.start(pkg, RuleDescrBuilder.class, null);
        match(input, DRL5Lexer.ID, DroolsSoftKeywords.RULE, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (helper.validateIdentifierKey(DroolsSoftKeywords.WHEN) || helper.validateIdentifierKey(DroolsSoftKeywords.THEN) || helper.validateIdentifierKey(DroolsSoftKeywords.END)) {
            failMissingTokenException();
            return null;
        }
        String name = stringId();
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            rule.name(name);
            helper.setParaphrasesValue(DroolsParaphraseTypes.RULE, ""\"""" + name + ""\"""");
            helper.emit(Location.LOCATION_RULE_HEADER);
        }
        if (helper.validateIdentifierKey(DroolsSoftKeywords.EXTENDS)) {
            match(input, DRL5Lexer.ID, DroolsSoftKeywords.EXTENDS, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            String parent = stringId();
            if (state.backtracking == 0)
                rule.extendsRule(parent);
            if (state.failed)
                return null;
        }
        if (state.backtracking == 0 && input.LA(1) != DRL5Lexer.EOF) {
            helper.emit(Location.LOCATION_RULE_HEADER);
        }
        while (input.LA(1) == DRL5Lexer.AT) {
            annotation(rule);
            if (state.failed)
                return null;
        }
        attributes(rule);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.WHEN)) {
            lhs(rule);
        } else {
            rule.lhs();
        }
        rhs(rule);
        match(input, DRL5Lexer.ID, DroolsSoftKeywords.END, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
    } catch (RecognitionException re) {
        reportError(re);
    } finally {
        helper.end(RuleDescrBuilder.class, rule);
    }
    return (rule != null) ? rule.getDescr() : null;
}",java:S3776,39
"private void attributes(RuleDescrBuilder rule) throws RecognitionException{
    if (helper.validateIdentifierKey(DroolsSoftKeywords.ATTRIBUTES)) {
        match(input, DRL5Lexer.ID, DroolsSoftKeywords.ATTRIBUTES, null, DroolsEditorType.IDENTIFIER);
        if (state.failed)
            return;
        if (input.LA(1) == DRL5Lexer.COLON) {
            match(input, DRL5Lexer.COLON, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
        }
    }
    if (helper.validateAttribute(1)) {
        attribute(rule);
        if (state.failed)
            return;
        while (input.LA(1) == DRL5Lexer.COMMA || helper.validateAttribute(1)) {
            if (input.LA(1) == DRL5Lexer.COMMA) {
                match(input, DRL5Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return;
            }
            attribute(rule);
            if (state.failed)
                return;
        }
    }
}",java:S3776,39
"public AttributeDescr attribute(AttributeSupportBuilder<?> as){
    AttributeDescr attribute = null;
    try {
        if (state.backtracking == 0 && input.LA(1) != DRL5Lexer.EOF) {
            helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);
        }
        if (helper.validateIdentifierKey(DroolsSoftKeywords.SALIENCE)) {
            attribute = salience(as);
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.ENABLED)) {
            attribute = enabled(as);
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.NO) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.LOOP)) {
            attribute = booleanAttribute(as, new String[] { DroolsSoftKeywords.NO, ""-"", DroolsSoftKeywords.LOOP });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.AUTO) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.FOCUS)) {
            attribute = booleanAttribute(as, new String[] { DroolsSoftKeywords.AUTO, ""-"", DroolsSoftKeywords.FOCUS });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.LOCK) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.ON) && helper.validateLT(4, ""-"") && helper.validateLT(5, DroolsSoftKeywords.ACTIVE)) {
            attribute = booleanAttribute(as, new String[] { DroolsSoftKeywords.LOCK, ""-"", DroolsSoftKeywords.ON, ""-"", DroolsSoftKeywords.ACTIVE });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.REFRACT)) {
            attribute = booleanAttribute(as, new String[] { DroolsSoftKeywords.REFRACT });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.AGENDA) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.GROUP)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.AGENDA, ""-"", DroolsSoftKeywords.GROUP });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.ACTIVATION) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.GROUP)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.ACTIVATION, ""-"", DroolsSoftKeywords.GROUP });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.RULEFLOW) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.GROUP)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.RULEFLOW, ""-"", DroolsSoftKeywords.GROUP });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DATE) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.EFFECTIVE)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.DATE, ""-"", DroolsSoftKeywords.EFFECTIVE });
            if (attribute != null) {
                attribute.setType(AttributeDescr.Type.DATE);
            } else {
                throw new RecognitionException();
            }
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DATE) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.EXPIRES)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.DATE, ""-"", DroolsSoftKeywords.EXPIRES });
            if (attribute != null) {
                attribute.setType(AttributeDescr.Type.DATE);
            } else {
                throw new RecognitionException();
            }
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DIALECT)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.DIALECT });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.CALENDARS)) {
            attribute = stringListAttribute(as, new String[] { DroolsSoftKeywords.CALENDARS });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.TIMER)) {
            attribute = intOrChunkAttribute(as, new String[] { DroolsSoftKeywords.TIMER });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DURATION)) {
            attribute = intOrChunkAttribute(as, new String[] { DroolsSoftKeywords.DURATION });
        }
        if (state.backtracking == 0) {
            helper.emit(Location.LOCATION_RULE_HEADER);
        }
    } catch (RecognitionException re) {
        reportError(re);
    }
    return attribute;
}",java:S3776,39
"private AttributeDescr salience(AttributeSupportBuilder<?> as) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        match(input, DRL5Lexer.ID, DroolsSoftKeywords.SALIENCE, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, DroolsSoftKeywords.SALIENCE);
        }
        boolean hasParen = input.LA(1) == DRL5Lexer.LEFT_PAREN;
        int first = input.index();
        if (hasParen) {
            match(input, DRL5Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        }
        String value = conditionalExpression();
        if (state.failed)
            return null;
        if (hasParen) {
            match(input, DRL5Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        }
        if (state.backtracking == 0) {
            if (attribute != null) {
                if (hasParen) {
                    value = input.toString(first, input.LT(-1).getTokenIndex());
                }
                attribute.value(value);
                attribute.type(AttributeDescr.Type.EXPRESSION);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr enabled(AttributeSupportBuilder<?> as) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        match(input, DRL5Lexer.ID, DroolsSoftKeywords.ENABLED, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, DroolsSoftKeywords.ENABLED);
        }
        boolean hasParen = input.LA(1) == DRL5Lexer.LEFT_PAREN;
        int first = input.index();
        if (hasParen) {
            match(input, DRL5Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        }
        String value = conditionalExpression();
        if (state.failed)
            return null;
        if (hasParen) {
            match(input, DRL5Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        }
        if (state.backtracking == 0) {
            if (attribute != null) {
                if (hasParen) {
                    value = input.toString(first, input.LT(-1).getTokenIndex());
                }
                attribute.value(value);
                attribute.type(AttributeDescr.Type.EXPRESSION);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr booleanAttribute(AttributeSupportBuilder<?> as, String[] key) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        StringBuilder builder = new StringBuilder();
        for (String k : key) {
            if (""-"".equals(k)) {
                match(input, DRL5Lexer.MINUS, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            } else {
                match(input, DRL5Lexer.ID, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            }
            builder.append(k);
        }
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, builder.toString());
        }
        String value = ""true"";
        if (input.LA(1) == DRL5Lexer.BOOL) {
            Token bool = match(input, DRL5Lexer.BOOL, null, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            value = bool.getText();
        }
        if (state.backtracking == 0) {
            if (attribute != null) {
                attribute.value(value);
                attribute.type(AttributeDescr.Type.BOOLEAN);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr stringAttribute(AttributeSupportBuilder<?> as, String[] key) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        StringBuilder builder = new StringBuilder();
        for (String k : key) {
            if (""-"".equals(k)) {
                match(input, DRL5Lexer.MINUS, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            } else {
                match(input, DRL5Lexer.ID, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            }
            builder.append(k);
        }
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, builder.toString());
        }
        Token value = match(input, DRL5Lexer.STRING, null, null, DroolsEditorType.STRING_CONST);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            if (attribute != null) {
                attribute.value(StringUtils.unescapeJava(safeStripStringDelimiters(value.getText())));
                attribute.type(AttributeDescr.Type.STRING);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr stringListAttribute(AttributeSupportBuilder<?> as, String[] key) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        StringBuilder builder = new StringBuilder();
        for (String k : key) {
            if (""-"".equals(k)) {
                match(input, DRL5Lexer.MINUS, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            } else {
                match(input, DRL5Lexer.ID, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            }
            builder.append(k);
        }
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, builder.toString());
        }
        builder = new StringBuilder();
        builder.append(""[ "");
        Token value = match(input, DRL5Lexer.STRING, null, null, DroolsEditorType.STRING_CONST);
        if (state.failed)
            return null;
        builder.append(value.getText());
        while (input.LA(1) == DRL5Lexer.COMMA) {
            match(input, DRL5Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
            builder.append("", "");
            value = match(input, DRL5Lexer.STRING, null, null, DroolsEditorType.STRING_CONST);
            if (state.failed)
                return null;
            builder.append(value.getText());
        }
        builder.append("" ]"");
        if (state.backtracking == 0) {
            if (attribute != null) {
                attribute.value(builder.toString());
                attribute.type(AttributeDescr.Type.LIST);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr intOrChunkAttribute(AttributeSupportBuilder<?> as, String[] key) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        StringBuilder builder = new StringBuilder();
        for (String k : key) {
            if (""-"".equals(k)) {
                match(input, DRL5Lexer.MINUS, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            } else {
                match(input, DRL5Lexer.ID, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            }
            builder.append(k);
        }
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, builder.toString());
        }
        if (input.LA(1) == DRL5Lexer.LEFT_PAREN) {
            String value = chunk(DRL5Lexer.LEFT_PAREN, DRL5Lexer.RIGHT_PAREN, -1);
            if (state.failed)
                return null;
            if (state.backtracking == 0) {
                if (attribute != null) {
                    attribute.value(safeStripDelimiters(value, ""("", "")""));
                    attribute.type(AttributeDescr.Type.EXPRESSION);
                }
            }
        } else {
            String value = """";
            if (input.LA(1) == DRL5Lexer.PLUS) {
                Token sign = match(input, DRL5Lexer.PLUS, null, null, DroolsEditorType.NUMERIC_CONST);
                if (state.failed)
                    return null;
                value += sign.getText();
            } else if (input.LA(1) == DRL5Lexer.MINUS) {
                Token sign = match(input, DRL5Lexer.MINUS, null, null, DroolsEditorType.NUMERIC_CONST);
                if (state.failed)
                    return null;
                value += sign.getText();
            }
            Token nbr = match(input, DRL5Lexer.DECIMAL, null, null, DroolsEditorType.NUMERIC_CONST);
            if (state.failed)
                return null;
            value += nbr.getText();
            if (state.backtracking == 0) {
                if (attribute != null) {
                    attribute.value(value);
                    attribute.type(AttributeDescr.Type.NUMBER);
                }
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private BaseDescr lhsOr(final CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    BaseDescr result = null;
    if (allowOr && input.LA(1) == DRL5Lexer.LEFT_PAREN && helper.validateLT(2, DroolsSoftKeywords.OR)) {
        CEDescrBuilder<?, OrDescr> or = null;
        if (state.backtracking == 0) {
            or = ce.or();
            result = or.getDescr();
            helper.start(or, CEDescrBuilder.class, null);
        }
        try {
            match(input, DRL5Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
            match(input, DRL5Lexer.ID, DroolsSoftKeywords.OR, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            while (input.LA(1) == DRL5Lexer.AT) {
                annotation(or);
                if (state.failed)
                    return null;
            }
            if (state.backtracking == 0) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);
            }
            while (input.LA(1) != DRL5Lexer.RIGHT_PAREN) {
                lhsAnd(or, allowOr);
                if (state.failed)
                    return null;
            }
            match(input, DRL5Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        } finally {
            if (state.backtracking == 0) {
                helper.end(CEDescrBuilder.class, or);
            }
        }
    } else {
        CEDescrBuilder<?, OrDescr> or = null;
        if (state.backtracking == 0) {
            or = ce.or();
            result = or.getDescr();
            helper.start(or, CEDescrBuilder.class, null);
        }
        try {
            lhsAnd(or, allowOr);
            if (state.failed)
                return null;
            if (allowOr && (helper.validateIdentifierKey(DroolsSoftKeywords.OR) || input.LA(1) == DRL5Lexer.DOUBLE_PIPE)) {
                while (helper.validateIdentifierKey(DroolsSoftKeywords.OR) || input.LA(1) == DRL5Lexer.DOUBLE_PIPE) {
                    if (input.LA(1) == DRL5Lexer.DOUBLE_PIPE) {
                        match(input, DRL5Lexer.DOUBLE_PIPE, null, null, DroolsEditorType.SYMBOL);
                    } else {
                        match(input, DRL5Lexer.ID, DroolsSoftKeywords.OR, null, DroolsEditorType.KEYWORD);
                    }
                    if (state.failed)
                        return null;
                    while (input.LA(1) == DRL5Lexer.AT) {
                        annotation(or);
                        if (state.failed)
                            return null;
                    }
                    if (state.backtracking == 0) {
                        helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);
                    }
                    lhsAnd(or, allowOr);
                    if (state.failed)
                        return null;
                }
            } else if (allowOr) {
                if (state.backtracking == 0) {
                    ((ConditionalElementDescr) ce.getDescr()).getDescrs().remove(or.getDescr());
                    for (BaseDescr base : or.getDescr().getDescrs()) {
                        ((ConditionalElementDescr) ce.getDescr()).addDescr(base);
                    }
                    result = ce.getDescr();
                }
            }
        } finally {
            if (state.backtracking == 0) {
                helper.end(CEDescrBuilder.class, or);
            }
        }
    }
    return result;
}",java:S3776,39
"private BaseDescr lhsAnd(final CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    BaseDescr result = null;
    if (input.LA(1) == DRL5Lexer.LEFT_PAREN && helper.validateLT(2, DroolsSoftKeywords.AND)) {
        CEDescrBuilder<?, AndDescr> and = null;
        if (state.backtracking == 0) {
            and = ce.and();
            result = ce.getDescr();
            helper.start(and, CEDescrBuilder.class, null);
        }
        try {
            match(input, DRL5Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
            match(input, DRL5Lexer.ID, DroolsSoftKeywords.AND, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            while (input.LA(1) == DRL5Lexer.AT) {
                annotation(and);
                if (state.failed)
                    return null;
            }
            if (state.backtracking == 0) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);
            }
            while (input.LA(1) != DRL5Lexer.RIGHT_PAREN) {
                lhsUnary(and, allowOr);
                if (state.failed)
                    return null;
            }
            match(input, DRL5Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        } finally {
            if (state.backtracking == 0) {
                helper.end(CEDescrBuilder.class, and);
            }
        }
    } else {
        CEDescrBuilder<?, AndDescr> and = null;
        if (state.backtracking == 0) {
            and = ce.and();
            result = and.getDescr();
            helper.start(and, CEDescrBuilder.class, null);
        }
        try {
            lhsUnary(and, allowOr);
            if (state.failed)
                return null;
            if (helper.validateIdentifierKey(DroolsSoftKeywords.AND) || input.LA(1) == DRL5Lexer.DOUBLE_AMPER) {
                while (helper.validateIdentifierKey(DroolsSoftKeywords.AND) || input.LA(1) == DRL5Lexer.DOUBLE_AMPER) {
                    if (input.LA(1) == DRL5Lexer.DOUBLE_AMPER) {
                        match(input, DRL5Lexer.DOUBLE_AMPER, null, null, DroolsEditorType.SYMBOL);
                    } else {
                        match(input, DRL5Lexer.ID, DroolsSoftKeywords.AND, null, DroolsEditorType.KEYWORD);
                    }
                    if (state.failed)
                        return null;
                    while (input.LA(1) == DRL5Lexer.AT) {
                        annotation(and);
                        if (state.failed)
                            return null;
                    }
                    if (state.backtracking == 0) {
                        helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);
                    }
                    lhsUnary(and, allowOr);
                    if (state.failed)
                        return null;
                }
            } else {
                if (state.backtracking == 0 && and.getDescr().getDescrs().size() < 2) {
                    ((ConditionalElementDescr) ce.getDescr()).getDescrs().remove(and.getDescr());
                    for (BaseDescr base : and.getDescr().getDescrs()) {
                        ((ConditionalElementDescr) ce.getDescr()).addDescr(base);
                    }
                    result = ce.getDescr();
                }
            }
        } finally {
            if (state.backtracking == 0) {
                helper.end(CEDescrBuilder.class, and);
            }
        }
    }
    return result;
}",java:S3776,39
"private BaseDescr lhsUnary(final CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    BaseDescr result = null;
    if (helper.validateIdentifierKey(DroolsSoftKeywords.EXISTS)) {
        result = lhsExists(ce, allowOr);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
            namedConsequence(ce, null);
        }
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.NOT)) {
        result = lhsNot(ce, allowOr);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
            namedConsequence(ce, null);
        }
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.EVAL)) {
        result = lhsEval(ce);
        for (BaseDescr i = consequenceInvocation(ce); i != null; i = consequenceInvocation(ce)) ;
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.FORALL)) {
        result = lhsForall(ce);
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.ACCUMULATE)) {
        result = lhsAccumulate(ce);
    } else if (input.LA(1) == DRL5Lexer.LEFT_PAREN) {
        result = lhsParen(ce, allowOr);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
            namedConsequence(ce, null);
        }
    } else if (input.LA(1) == DRL5Lexer.ID || input.LA(1) == DRL5Lexer.QUESTION) {
        result = lhsPatternBind(ce, allowOr);
        for (BaseDescr i = consequenceInvocation(ce); i != null; i = consequenceInvocation(ce)) ;
    } else {
        failMismatchedTokenException();
    }
    if (input.LA(1) == DRL5Lexer.SEMICOLON) {
        match(input, DRL5Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return null;
    }
    return result;
}",java:S3776,39
"private BaseDescr conditionalBranch(CEDescrBuilder<?, ?> ce, ConditionalBranchDescrBuilder<?> conditionalBranch) throws RecognitionException{
    if (conditionalBranch == null) {
        conditionalBranch = helper.start(ce, ConditionalBranchDescrBuilder.class, null);
    }
    try {
        match(input, DRL5Lexer.ID, DroolsSoftKeywords.IF, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        EvalDescrBuilder<?> eval = conditionalBranch.condition();
        if (!parseEvalExpression(eval))
            return null;
        if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
            if (namedConsequence(null, conditionalBranch.consequence()) == null)
                return null;
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.BREAK)) {
            if (breakingNamedConsequence(null, conditionalBranch.consequence()) == null)
                return null;
        } else {
            return null;
        }
        if (helper.validateIdentifierKey(DroolsSoftKeywords.ELSE)) {
            match(input, DRL5Lexer.ID, DroolsSoftKeywords.ELSE, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            ConditionalBranchDescrBuilder<?> elseBranch = conditionalBranch.otherwise();
            if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
                if (namedConsequence(null, elseBranch.consequence()) == null)
                    return null;
            } else if (helper.validateIdentifierKey(DroolsSoftKeywords.BREAK)) {
                if (breakingNamedConsequence(null, elseBranch.consequence()) == null)
                    return null;
            } else if (helper.validateIdentifierKey(DroolsSoftKeywords.IF)) {
                if (conditionalBranch(null, elseBranch) == null)
                    return null;
            } else {
                return null;
            }
        }
    } finally {
        helper.end(ConditionalBranchDescrBuilder.class, conditionalBranch);
    }
    return conditionalBranch.getDescr();
}",java:S3776,39
"private BaseDescr lhsExists(CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    CEDescrBuilder<?, ExistsDescr> exists = null;
    if (state.backtracking == 0) {
        exists = ce.exists();
        helper.start(exists, CEDescrBuilder.class, null);
    }
    try {
        match(input, DRL5Lexer.ID, DroolsSoftKeywords.EXISTS, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_EXISTS);
        }
        if (input.LA(1) == DRL5Lexer.LEFT_PAREN) {
            boolean prefixed = helper.validateLT(2, DroolsSoftKeywords.AND) || helper.validateLT(2, DroolsSoftKeywords.OR);
            if (!prefixed) {
                match(input, DRL5Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
            lhsOr(exists, allowOr);
            if (state.failed)
                return null;
            if (!prefixed) {
                match(input, DRL5Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
        } else {
            lhsPatternBind(exists, true);
            if (state.failed)
                return null;
        }
    } finally {
        if (state.backtracking == 0) {
            helper.end(CEDescrBuilder.class, exists);
        }
    }
    return exists != null ? exists.getDescr() : null;
}",java:S3776,39
"private BaseDescr lhsNot(CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    CEDescrBuilder<?, NotDescr> not = null;
    if (state.backtracking == 0) {
        not = ce.not();
        helper.start(not, CEDescrBuilder.class, null);
    }
    try {
        match(input, DRL5Lexer.ID, DroolsSoftKeywords.NOT, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_NOT);
        }
        if (input.LA(1) == DRL5Lexer.LEFT_PAREN) {
            boolean prefixed = helper.validateLT(2, DroolsSoftKeywords.AND) || helper.validateLT(2, DroolsSoftKeywords.OR);
            if (!prefixed) {
                match(input, DRL5Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
            if (state.backtracking == 0 && input.LA(1) != DRL5Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
            }
            lhsOr(not, allowOr);
            if (state.failed)
                return null;
            if (!prefixed) {
                match(input, DRL5Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
        } else if (input.LA(1) != DRL5Lexer.EOF) {
            lhsPatternBind(not, true);
            if (state.failed)
                return null;
        }
    } finally {
        if (state.backtracking == 0) {
            helper.end(CEDescrBuilder.class, not);
        }
    }
    return not != null ? not.getDescr() : null;
}",java:S3776,39
"private BaseDescr lhsAccumulate(PatternContainerDescrBuilder<?, ?> ce) throws RecognitionException{
    PatternDescrBuilder<?> pattern;
    BaseDescr result = null;
    pattern = helper.start((DescrBuilder<?, ?>) ce, PatternDescrBuilder.class, null);
    if (pattern != null) {
        result = pattern.getDescr();
    }
    try {
        if (state.backtracking == 0) {
            pattern.type(""Object[]"");
            pattern.isQuery(false);
        }
        AccumulateDescrBuilder<?> accumulate = helper.start(pattern, AccumulateDescrBuilder.class, null);
        try {
            match(input, DRL5Lexer.ID, DroolsSoftKeywords.ACCUMULATE, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            if (state.backtracking == 0 && input.LA(1) != DRL5Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE);
            }
            match(input, DRL5Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
            CEDescrBuilder<?, AndDescr> source = accumulate.source();
            try {
                helper.start(source, CEDescrBuilder.class, null);
                lhsAnd(source, false);
                if (state.failed)
                    return null;
                if (source.getDescr() != null && source.getDescr() instanceof ConditionalElementDescr) {
                    ConditionalElementDescr root = source.getDescr();
                    BaseDescr[] descrs = root.getDescrs().toArray(new BaseDescr[root.getDescrs().size()]);
                    root.getDescrs().clear();
                    for (int i = 0; i < descrs.length; i++) {
                        root.addOrMerge(descrs[i]);
                    }
                }
            } finally {
                helper.end(CEDescrBuilder.class, source);
            }
            if (input.LA(1) == DRL5Lexer.COMMA) {
                match(input, DRL5Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            } else if (input.LA(-1) != DRL5Lexer.SEMICOLON) {
                match(input, DRL5Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
            accumulateFunctionBinding(accumulate);
            if (state.failed)
                return null;
            while (input.LA(1) == DRL5Lexer.COMMA) {
                match(input, DRL5Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
                accumulateFunctionBinding(accumulate);
                if (state.failed)
                    return null;
            }
            if (input.LA(1) == DRL5Lexer.SEMICOLON) {
                match(input, DRL5Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
                constraints(pattern);
            }
            match(input, DRL5Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        } finally {
            helper.end(AccumulateDescrBuilder.class, accumulate);
            if (state.backtracking == 0 && input.LA(1) != DRL5Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
            }
        }
    } finally {
        helper.end(PatternDescrBuilder.class, pattern);
    }
    if (input.LA(1) == DRL5Lexer.SEMICOLON) {
        match(input, DRL5Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return null;
    }
    return result;
}",java:S3776,39
"private void lhsPattern(PatternDescrBuilder<?> pattern, String label, boolean isUnification) throws RecognitionException{
    boolean query = false;
    if (input.LA(1) == DRL5Lexer.QUESTION) {
        match(input, DRL5Lexer.QUESTION, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return;
        query = true;
    }
    String type = this.qualifiedIdentifier();
    if (state.failed)
        return;
    if (state.backtracking == 0) {
        pattern.type(type);
        pattern.isQuery(query);
        if (label != null) {
            pattern.id(label, isUnification);
        }
    }
    match(input, DRL5Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
    if (state.failed)
        return;
    if (input.LA(1) != DRL5Lexer.RIGHT_PAREN && speculatePositionalConstraints()) {
        positionalConstraints(pattern);
    }
    if (input.LA(1) != DRL5Lexer.RIGHT_PAREN) {
        constraints(pattern);
    }
    match(input, DRL5Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
    if (state.failed)
        return;
    while (input.LA(1) == DRL5Lexer.AT) {
        annotation(pattern);
        if (state.failed)
            return;
    }
    if (helper.validateIdentifierKey(DroolsSoftKeywords.OVER)) {
        patternFilter(pattern);
    }
    if (helper.validateIdentifierKey(DroolsSoftKeywords.FROM)) {
        patternSource(pattern);
    }
    if (state.backtracking == 0) {
        helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
    }
}",java:S3776,39
"private void constraint(PatternDescrBuilder<?> pattern, boolean positional, String prefix) throws RecognitionException{
    if (speculateNestedConstraint()) {
        nestedConstraint(pattern, prefix);
        return;
    }
    if (state.backtracking == 0) {
        helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_START);
    }
    int first = input.index();
    exprParser.getHelper().setHasOperator(false);
    try {
        exprParser.conditionalOrExpression();
    } finally {
        if (state.backtracking == 0) {
            if (input.LA(1) == DRL5Lexer.ID && input.LA(2) == DRL5Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_ARGUMENT);
            } else if (input.LA(1) != DRL5Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_END);
            } else if (!lastTokenWasWhiteSpace()) {
                int location = getCurrentLocation();
                if (location == Location.LOCATION_LHS_INSIDE_CONDITION_END) {
                    helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_ARGUMENT);
                } else if (input.get(input.index()).getType() != DRL5Lexer.EOF) {
                    helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_START);
                }
            } else if (getCurrentLocation() == Location.LOCATION_LHS_INSIDE_CONDITION_START && !exprParser.getHelper().getHasOperator() && lastTokenWasWhiteSpace() && input.LA(1) == DRL5Lexer.EOF && input.LA(-1) == DRL5Lexer.ID) {
                helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_OPERATOR);
            }
        }
    }
    if (state.failed)
        return;
    if (state.backtracking == 0 && input.index() > first) {
        int last = input.LT(-1).getTokenIndex();
        String expr = toExpression(prefix, first, last);
        pattern.constraint(expr, positional);
        BaseDescr constrDescr = pattern.getDescr().getDescrs().get(pattern.getDescr().getDescrs().size() - 1);
        constrDescr.setLocation(input.get(first).getLine(), input.get(first).getCharPositionInLine());
        constrDescr.setEndLocation(input.get(last).getLine(), input.get(last).getCharPositionInLine());
        constrDescr.setStartCharacter(((CommonToken) input.get(first)).getStartIndex());
        constrDescr.setEndCharacter(((CommonToken) input.get(last)).getStopIndex());
    }
}",java:S3776,39
"private boolean speculateNestedConstraint() throws RecognitionException{
    return getNestedConstraintPrefixLenght() > 0;
}",java:S1130,7
"private void patternSource(PatternDescrBuilder<?> pattern) throws RecognitionException{
    match(input, DRL5Lexer.ID, DroolsSoftKeywords.FROM, null, DroolsEditorType.KEYWORD);
    if (state.failed)
        return;
    if (state.backtracking == 0) {
        helper.emit(Location.LOCATION_LHS_FROM);
    }
    if (helper.validateIdentifierKey(DroolsSoftKeywords.ACCUMULATE)) {
        fromAccumulate(pattern);
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.COLLECT)) {
        fromCollect(pattern);
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.ENTRY) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.POINT)) {
        fromEntryPoint(pattern);
        if (state.failed)
            return;
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.WINDOW)) {
        fromWindow(pattern);
    } else {
        fromExpression(pattern);
        if (!lastTokenWasWhiteSpace() && input.LA(1) == DRL5Lexer.EOF) {
            helper.emit(Location.LOCATION_LHS_FROM);
            throw new RecognitionException();
        }
        if (state.failed)
            return;
    }
    if (input.LA(1) == DRL5Lexer.SEMICOLON) {
        match(input, DRL5Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return;
    }
}",java:S3776,39
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    if (CompiledInvoker.isCompiledInvoker(this.expression)) {
        out.writeObject(null);
    } else {
        out.writeObject(this.expression);
    }
    out.writeObject(this.requiredDeclarations);
    out.writeObject(this.previousDeclarations);
    out.writeObject(this.localDeclarations);
    out.writeObject(this.cloned);
}",java:S1161,11
"private void fromAccumulate(PatternDescrBuilder<?> pattern) throws RecognitionException{
    AccumulateDescrBuilder<?> accumulate = helper.start(pattern, AccumulateDescrBuilder.class, null);
    try {
        match(input, DRL5Lexer.ID, DroolsSoftKeywords.ACCUMULATE, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return;
        if (state.backtracking == 0 && input.LA(1) != DRL5Lexer.EOF) {
            helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE);
        }
        match(input, DRL5Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return;
        CEDescrBuilder<?, AndDescr> source = accumulate.source();
        try {
            helper.start(source, CEDescrBuilder.class, null);
            lhsAnd(source, false);
            if (state.failed)
                return;
            if (source.getDescr() != null && source.getDescr() instanceof ConditionalElementDescr) {
                ConditionalElementDescr root = source.getDescr();
                BaseDescr[] descrs = root.getDescrs().toArray(new BaseDescr[root.getDescrs().size()]);
                root.getDescrs().clear();
                for (int i = 0; i < descrs.length; i++) {
                    root.addOrMerge(descrs[i]);
                }
            }
        } finally {
            helper.end(CEDescrBuilder.class, source);
        }
        if (input.LA(1) == DRL5Lexer.COMMA) {
            match(input, DRL5Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
        }
        if (helper.validateIdentifierKey(DroolsSoftKeywords.INIT)) {
            match(input, DRL5Lexer.ID, DroolsSoftKeywords.INIT, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return;
            if (state.backtracking == 0 && input.LA(1) != DRL5Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_INIT);
            }
            String init = chunk(DRL5Lexer.LEFT_PAREN, DRL5Lexer.RIGHT_PAREN, Location.LOCATION_LHS_FROM_ACCUMULATE_INIT_INSIDE);
            if (state.failed)
                return;
            if (state.backtracking == 0)
                accumulate.init(init);
            if (input.LA(1) == DRL5Lexer.COMMA) {
                match(input, DRL5Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return;
            }
            match(input, DRL5Lexer.ID, DroolsSoftKeywords.ACTION, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return;
            if (state.backtracking == 0 && input.LA(1) != DRL5Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_ACTION);
            }
            String action = chunk(DRL5Lexer.LEFT_PAREN, DRL5Lexer.RIGHT_PAREN, Location.LOCATION_LHS_FROM_ACCUMULATE_ACTION_INSIDE);
            if (state.failed)
                return;
            if (state.backtracking == 0)
                accumulate.action(action);
            if (input.LA(1) == DRL5Lexer.COMMA) {
                match(input, DRL5Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return;
            }
            if (helper.validateIdentifierKey(DroolsSoftKeywords.REVERSE)) {
                match(input, DRL5Lexer.ID, DroolsSoftKeywords.REVERSE, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return;
                if (state.backtracking == 0 && input.LA(1) != DRL5Lexer.EOF) {
                    helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_REVERSE);
                }
                String reverse = chunk(DRL5Lexer.LEFT_PAREN, DRL5Lexer.RIGHT_PAREN, Location.LOCATION_LHS_FROM_ACCUMULATE_REVERSE_INSIDE);
                if (state.failed)
                    return;
                if (state.backtracking == 0)
                    accumulate.reverse(reverse);
                if (input.LA(1) == DRL5Lexer.COMMA) {
                    match(input, DRL5Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                    if (state.failed)
                        return;
                }
            }
            match(input, DRL5Lexer.ID, DroolsSoftKeywords.RESULT, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return;
            if (state.backtracking == 0 && input.LA(1) != DRL5Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_RESULT);
            }
            String result = chunk(DRL5Lexer.LEFT_PAREN, DRL5Lexer.RIGHT_PAREN, Location.LOCATION_LHS_FROM_ACCUMULATE_RESULT_INSIDE);
            if (state.failed)
                return;
            if (state.backtracking == 0)
                accumulate.result(result);
        } else {
            accumulateFunction(accumulate, false, null);
            if (state.failed)
                return;
        }
        match(input, DRL5Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return;
    } finally {
        helper.end(AccumulateDescrBuilder.class, accumulate);
        if (state.backtracking == 0 && input.LA(1) != DRL5Lexer.EOF) {
            helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
        }
    }
}",java:S3776,39
"private void annotation(AnnotatedDescrBuilder<?> adb){
    AnnotationDescrBuilder<?> annotation = null;
    try {
        if (speculateFullAnnotation()) {
            boolean buildState = exprParser.isBuildDescr();
            exprParser.setBuildDescr(true);
            exprParser.fullAnnotation(adb);
            exprParser.setBuildDescr(buildState);
        } else {
            Token at = match(input, DRL5Lexer.AT, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
            String fqn = qualifiedIdentifier();
            if (state.failed)
                return;
            if (state.backtracking == 0) {
                annotation = adb.newAnnotation(fqn);
                helper.setStart(annotation, at);
            }
            try {
                if (input.LA(1) == DRL5Lexer.LEFT_PAREN) {
                    String value = chunk(DRL5Lexer.LEFT_PAREN, DRL5Lexer.RIGHT_PAREN, -1).trim();
                    if (state.failed)
                        return;
                    if (state.backtracking == 0) {
                        if (annotation != null) {
                            annotation.value(value);
                        } else {
                            throw new RecognitionException();
                        }
                    }
                }
            } finally {
                if (state.backtracking == 0) {
                    helper.setEnd(annotation);
                }
            }
        }
    } catch (RecognitionException re) {
        reportError(re);
    }
}",java:S3776,39
"public String type() throws RecognitionException{
    String type = """";
    try {
        int first = input.index(), last;
        match(input, DRL5Lexer.ID, null, new int[] { DRL5Lexer.DOT, DRL5Lexer.LESS }, DroolsEditorType.IDENTIFIER);
        if (state.failed)
            return type;
        if (input.LA(1) == DRL5Lexer.LESS) {
            typeArguments();
            if (state.failed)
                return type;
        }
        while (input.LA(1) == DRL5Lexer.DOT && input.LA(2) == DRL5Lexer.ID) {
            match(input, DRL5Lexer.DOT, null, new int[] { DRL5Lexer.ID }, DroolsEditorType.IDENTIFIER);
            if (state.failed)
                return type;
            match(input, DRL5Lexer.ID, null, new int[] { DRL5Lexer.DOT }, DroolsEditorType.IDENTIFIER);
            if (state.failed)
                return type;
            if (input.LA(1) == DRL5Lexer.LESS) {
                typeArguments();
                if (state.failed)
                    return type;
            }
        }
        while (input.LA(1) == DRL5Lexer.LEFT_SQUARE && input.LA(2) == DRL5Lexer.RIGHT_SQUARE) {
            match(input, DRL5Lexer.LEFT_SQUARE, null, new int[] { DRL5Lexer.RIGHT_SQUARE }, DroolsEditorType.IDENTIFIER);
            if (state.failed)
                return type;
            match(input, DRL5Lexer.RIGHT_SQUARE, null, null, DroolsEditorType.IDENTIFIER);
            if (state.failed)
                return type;
        }
        last = input.LT(-1).getTokenIndex();
        type = input.toString(first, last);
        type = type.replace("" "", """");
    } catch (RecognitionException re) {
        reportError(re);
    }
    return type;
}",java:S3776,39
"public String typeArgument() throws RecognitionException{
    String typeArgument = """";
    try {
        int first = input.index(), last = first;
        int next = input.LA(1);
        switch(next) {
            case DRL5Lexer.QUESTION:
                match(input, DRL5Lexer.QUESTION, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return typeArgument;
                if (helper.validateIdentifierKey(DroolsSoftKeywords.EXTENDS)) {
                    match(input, DRL5Lexer.ID, DroolsSoftKeywords.EXTENDS, null, DroolsEditorType.SYMBOL);
                    if (state.failed)
                        return typeArgument;
                    type();
                    if (state.failed)
                        return typeArgument;
                } else if (helper.validateIdentifierKey(DroolsSoftKeywords.SUPER)) {
                    match(input, DRL5Lexer.ID, DroolsSoftKeywords.SUPER, null, DroolsEditorType.SYMBOL);
                    if (state.failed)
                        return typeArgument;
                    type();
                    if (state.failed)
                        return typeArgument;
                }
                break;
            case DRL5Lexer.ID:
                type();
                if (state.failed)
                    return typeArgument;
                break;
            default:
        }
        last = input.LT(-1).getTokenIndex();
        typeArgument = input.toString(first, last);
    } catch (RecognitionException re) {
        reportError(re);
    }
    return typeArgument;
}",java:S3776,39
"public boolean mismatchIsMissingToken(TokenStream input, int[] follow){
    if (follow == null) {
        return false;
    }
    return false;
}",java:S3516,37
"public boolean mismatchIsMissingToken(TokenStream input, int[] follow){
    if (follow == null) {
        return false;
    }
    return false;
}",java:S1172,13
"public RuleDescr query(PackageDescrBuilder pkg) throws RecognitionException{
    QueryDescrBuilder query = null;
    try {
        query = helper.start(pkg, QueryDescrBuilder.class, null);
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.QUERY, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (helper.validateIdentifierKey(DroolsSoftKeywords.WHEN) || helper.validateIdentifierKey(DroolsSoftKeywords.THEN) || helper.validateIdentifierKey(DroolsSoftKeywords.END)) {
            failMissingTokenException();
            return null;
        }
        String name = stringId();
        if (state.backtracking == 0)
            query.name(name);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            helper.emit(Location.LOCATION_RULE_HEADER);
        }
        if (speculateParameters(true)) {
            parameters(query, true);
            if (state.failed)
                return null;
            if (state.backtracking == 0) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
            }
        } else if (speculateParameters(false)) {
            parameters(query, false);
            if (state.failed)
                return null;
            if (state.backtracking == 0) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
            }
        }
        while (input.LA(1) == DRL6Lexer.AT) {
            annotation(query);
            if (state.failed)
                return null;
        }
        if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
            helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
        }
        if (input.LA(1) != DRL6Lexer.EOF) {
            lhsExpression(query != null ? query.lhs() : null);
        }
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.END, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        helper.emit(Location.LOCATION_RHS);
    } catch (RecognitionException re) {
        reportError(re);
    } finally {
        helper.end(QueryDescrBuilder.class, query);
    }
    return (query != null) ? query.getDescr() : null;
}",java:S3776,39
"public RuleDescr rule(PackageDescrBuilder pkg) throws RecognitionException{
    RuleDescrBuilder rule = null;
    try {
        rule = helper.start(pkg, RuleDescrBuilder.class, null);
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.RULE, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (helper.validateIdentifierKey(DroolsSoftKeywords.WHEN) || helper.validateIdentifierKey(DroolsSoftKeywords.THEN) || helper.validateIdentifierKey(DroolsSoftKeywords.END)) {
            failMissingTokenException();
            return null;
        }
        String name = stringId();
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            rule.name(name);
            helper.setParaphrasesValue(DroolsParaphraseTypes.RULE, ""\"""" + name + ""\"""");
            helper.emit(Location.LOCATION_RULE_HEADER);
        }
        if (helper.validateIdentifierKey(DroolsSoftKeywords.EXTENDS)) {
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.EXTENDS, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            String parent = stringId();
            if (state.backtracking == 0)
                rule.extendsRule(parent);
            if (state.failed)
                return null;
        }
        if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
            helper.emit(Location.LOCATION_RULE_HEADER);
        }
        while (input.LA(1) == DRL6Lexer.AT) {
            annotation(rule);
            if (state.failed)
                return null;
        }
        attributes(rule);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.WHEN)) {
            lhs(rule);
        } else {
            rule.lhs();
        }
        rhs(rule);
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.END, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
    } catch (RecognitionException re) {
        reportError(re);
    } finally {
        helper.end(RuleDescrBuilder.class, rule);
    }
    return (rule != null) ? rule.getDescr() : null;
}",java:S3776,39
" void attributes(RuleDescrBuilder rule) throws RecognitionException{
    if (helper.validateIdentifierKey(DroolsSoftKeywords.ATTRIBUTES)) {
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.ATTRIBUTES, null, DroolsEditorType.IDENTIFIER);
        if (state.failed)
            return;
        if (input.LA(1) == DRL6Lexer.COLON) {
            match(input, DRL6Lexer.COLON, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
        }
    }
    if (helper.validateAttribute(1)) {
        attribute(rule);
        if (state.failed)
            return;
        while (input.LA(1) == DRL6Lexer.COMMA || helper.validateAttribute(1)) {
            if (input.LA(1) == DRL6Lexer.COMMA) {
                match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return;
            }
            attribute(rule);
            if (state.failed)
                return;
        }
    }
}",java:S3776,39
"public AttributeDescr attribute(AttributeSupportBuilder<?> as){
    AttributeDescr attribute = null;
    try {
        if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
            helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);
        }
        if (helper.validateIdentifierKey(DroolsSoftKeywords.SALIENCE)) {
            attribute = salience(as);
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.ENABLED)) {
            attribute = enabled(as);
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.NO) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.LOOP)) {
            attribute = booleanAttribute(as, new String[] { DroolsSoftKeywords.NO, ""-"", DroolsSoftKeywords.LOOP });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.AUTO) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.FOCUS)) {
            attribute = booleanAttribute(as, new String[] { DroolsSoftKeywords.AUTO, ""-"", DroolsSoftKeywords.FOCUS });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.LOCK) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.ON) && helper.validateLT(4, ""-"") && helper.validateLT(5, DroolsSoftKeywords.ACTIVE)) {
            attribute = booleanAttribute(as, new String[] { DroolsSoftKeywords.LOCK, ""-"", DroolsSoftKeywords.ON, ""-"", DroolsSoftKeywords.ACTIVE });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.REFRACT)) {
            attribute = booleanAttribute(as, new String[] { DroolsSoftKeywords.REFRACT });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DIRECT)) {
            attribute = booleanAttribute(as, new String[] { DroolsSoftKeywords.DIRECT });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.AGENDA) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.GROUP)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.AGENDA, ""-"", DroolsSoftKeywords.GROUP });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.ACTIVATION) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.GROUP)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.ACTIVATION, ""-"", DroolsSoftKeywords.GROUP });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.RULEFLOW) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.GROUP)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.RULEFLOW, ""-"", DroolsSoftKeywords.GROUP });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DATE) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.EFFECTIVE)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.DATE, ""-"", DroolsSoftKeywords.EFFECTIVE });
            if (attribute != null) {
                attribute.setType(AttributeDescr.Type.DATE);
            } else {
                throw new RecognitionException();
            }
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DATE) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.EXPIRES)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.DATE, ""-"", DroolsSoftKeywords.EXPIRES });
            if (attribute != null) {
                attribute.setType(AttributeDescr.Type.DATE);
            } else {
                throw new RecognitionException();
            }
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DIALECT)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.DIALECT });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.CALENDARS)) {
            attribute = stringListAttribute(as, new String[] { DroolsSoftKeywords.CALENDARS });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.TIMER)) {
            attribute = intOrChunkAttribute(as, new String[] { DroolsSoftKeywords.TIMER });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DURATION)) {
            attribute = intOrChunkAttribute(as, new String[] { DroolsSoftKeywords.DURATION });
        }
        if (state.backtracking == 0) {
            helper.emit(Location.LOCATION_RULE_HEADER);
        }
    } catch (RecognitionException re) {
        reportError(re);
    }
    return attribute;
}",java:S3776,39
"private AttributeDescr salience(AttributeSupportBuilder<?> as) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.SALIENCE, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, DroolsSoftKeywords.SALIENCE);
        }
        boolean hasParen = input.LA(1) == DRL6Lexer.LEFT_PAREN;
        int first = input.index();
        if (hasParen) {
            match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        }
        String value = conditionalExpression();
        if (state.failed)
            return null;
        if (hasParen) {
            match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        }
        if (state.backtracking == 0) {
            if (attribute != null) {
                if (hasParen) {
                    value = input.toString(first, input.LT(-1).getTokenIndex());
                }
                attribute.value(value);
                attribute.type(AttributeDescr.Type.EXPRESSION);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr enabled(AttributeSupportBuilder<?> as) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.ENABLED, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, DroolsSoftKeywords.ENABLED);
        }
        boolean hasParen = input.LA(1) == DRL6Lexer.LEFT_PAREN;
        int first = input.index();
        if (hasParen) {
            match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        }
        String value = conditionalExpression();
        if (state.failed)
            return null;
        if (hasParen) {
            match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        }
        if (state.backtracking == 0) {
            if (attribute != null) {
                if (hasParen) {
                    value = input.toString(first, input.LT(-1).getTokenIndex());
                }
                attribute.value(value);
                attribute.type(AttributeDescr.Type.EXPRESSION);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr booleanAttribute(AttributeSupportBuilder<?> as, String[] key) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        StringBuilder builder = new StringBuilder();
        for (String k : key) {
            if (""-"".equals(k)) {
                match(input, DRL6Lexer.MINUS, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            } else {
                match(input, DRL6Lexer.ID, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            }
            builder.append(k);
        }
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, builder.toString());
        }
        String value = ""true"";
        if (input.LA(1) == DRL6Lexer.BOOL) {
            Token bool = match(input, DRL6Lexer.BOOL, null, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            value = bool.getText();
        }
        if (state.backtracking == 0) {
            if (attribute != null) {
                attribute.value(value);
                attribute.type(AttributeDescr.Type.BOOLEAN);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr stringAttribute(AttributeSupportBuilder<?> as, String[] key) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        StringBuilder builder = new StringBuilder();
        for (String k : key) {
            if (""-"".equals(k)) {
                match(input, DRL6Lexer.MINUS, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            } else {
                match(input, DRL6Lexer.ID, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            }
            builder.append(k);
        }
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, builder.toString());
        }
        Token value = match(input, DRL6Lexer.STRING, null, null, DroolsEditorType.STRING_CONST);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            if (attribute != null) {
                attribute.value(StringUtils.unescapeJava(safeStripStringDelimiters(value.getText())));
                attribute.type(AttributeDescr.Type.STRING);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr stringListAttribute(AttributeSupportBuilder<?> as, String[] key) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        StringBuilder builder = new StringBuilder();
        for (String k : key) {
            if (""-"".equals(k)) {
                match(input, DRL6Lexer.MINUS, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            } else {
                match(input, DRL6Lexer.ID, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            }
            builder.append(k);
        }
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, builder.toString());
        }
        builder = new StringBuilder();
        builder.append(""[ "");
        Token value = match(input, DRL6Lexer.STRING, null, null, DroolsEditorType.STRING_CONST);
        if (state.failed)
            return null;
        builder.append(value.getText());
        while (input.LA(1) == DRL6Lexer.COMMA) {
            match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
            builder.append("", "");
            value = match(input, DRL6Lexer.STRING, null, null, DroolsEditorType.STRING_CONST);
            if (state.failed)
                return null;
            builder.append(value.getText());
        }
        builder.append("" ]"");
        if (state.backtracking == 0) {
            if (attribute != null) {
                attribute.value(builder.toString());
                attribute.type(AttributeDescr.Type.LIST);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr intOrChunkAttribute(AttributeSupportBuilder<?> as, String[] key) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        StringBuilder builder = new StringBuilder();
        for (String k : key) {
            if (""-"".equals(k)) {
                match(input, DRL6Lexer.MINUS, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            } else {
                match(input, DRL6Lexer.ID, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            }
            builder.append(k);
        }
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, builder.toString());
        }
        if (input.LA(1) == DRL6Lexer.LEFT_PAREN) {
            String value = chunk(DRL6Lexer.LEFT_PAREN, DRL6Lexer.RIGHT_PAREN, -1);
            if (state.failed)
                return null;
            if (state.backtracking == 0) {
                if (attribute != null) {
                    attribute.value(safeStripDelimiters(value, ""("", "")""));
                    attribute.type(AttributeDescr.Type.EXPRESSION);
                }
            }
        } else {
            String value = """";
            if (input.LA(1) == DRL6Lexer.PLUS) {
                Token sign = match(input, DRL6Lexer.PLUS, null, null, DroolsEditorType.NUMERIC_CONST);
                if (state.failed)
                    return null;
                value += sign.getText();
            } else if (input.LA(1) == DRL6Lexer.MINUS) {
                Token sign = match(input, DRL6Lexer.MINUS, null, null, DroolsEditorType.NUMERIC_CONST);
                if (state.failed)
                    return null;
                value += sign.getText();
            }
            Token nbr = match(input, DRL6Lexer.DECIMAL, null, null, DroolsEditorType.NUMERIC_CONST);
            if (state.failed)
                return null;
            value += nbr.getText();
            if (state.backtracking == 0) {
                if (attribute != null) {
                    attribute.value(value);
                    attribute.type(AttributeDescr.Type.NUMBER);
                }
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private BaseDescr lhsOr(final CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    BaseDescr result = null;
    if (allowOr && input.LA(1) == DRL6Lexer.LEFT_PAREN && helper.validateLT(2, DroolsSoftKeywords.OR)) {
        CEDescrBuilder<?, OrDescr> or = null;
        if (state.backtracking == 0) {
            or = ce.or();
            result = or.getDescr();
            helper.start(or, CEDescrBuilder.class, null);
        }
        try {
            match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.OR, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            while (input.LA(1) == DRL6Lexer.AT) {
                annotation(or);
                if (state.failed)
                    return null;
            }
            if (state.backtracking == 0) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);
            }
            while (input.LA(1) != DRL6Lexer.RIGHT_PAREN) {
                lhsAnd(or, allowOr);
                if (state.failed)
                    return null;
            }
            match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        } finally {
            if (state.backtracking == 0) {
                helper.end(CEDescrBuilder.class, or);
            }
        }
    } else {
        CEDescrBuilder<?, OrDescr> or = null;
        if (state.backtracking == 0) {
            or = ce.or();
            result = or.getDescr();
            helper.start(or, CEDescrBuilder.class, null);
        }
        try {
            lhsAnd(or, allowOr);
            if (state.failed)
                return null;
            if (allowOr && (helper.validateIdentifierKey(DroolsSoftKeywords.OR) || input.LA(1) == DRL6Lexer.DOUBLE_PIPE)) {
                while (helper.validateIdentifierKey(DroolsSoftKeywords.OR) || input.LA(1) == DRL6Lexer.DOUBLE_PIPE) {
                    if (input.LA(1) == DRL6Lexer.DOUBLE_PIPE) {
                        match(input, DRL6Lexer.DOUBLE_PIPE, null, null, DroolsEditorType.SYMBOL);
                    } else {
                        match(input, DRL6Lexer.ID, DroolsSoftKeywords.OR, null, DroolsEditorType.KEYWORD);
                    }
                    if (state.failed)
                        return null;
                    while (input.LA(1) == DRL6Lexer.AT) {
                        annotation(or);
                        if (state.failed)
                            return null;
                    }
                    if (state.backtracking == 0) {
                        helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);
                    }
                    lhsAnd(or, allowOr);
                    if (state.failed)
                        return null;
                }
            } else if (allowOr) {
                if (state.backtracking == 0) {
                    ((ConditionalElementDescr) ce.getDescr()).getDescrs().remove(or.getDescr());
                    for (BaseDescr base : or.getDescr().getDescrs()) {
                        ((ConditionalElementDescr) ce.getDescr()).addDescr(base);
                    }
                    result = ce.getDescr();
                }
            }
        } finally {
            if (state.backtracking == 0) {
                helper.end(CEDescrBuilder.class, or);
            }
        }
    }
    return result;
}",java:S3776,39
"private BaseDescr lhsAnd(final CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    BaseDescr result = null;
    if (input.LA(1) == DRL6Lexer.LEFT_PAREN && helper.validateLT(2, DroolsSoftKeywords.AND)) {
        CEDescrBuilder<?, AndDescr> and = null;
        if (state.backtracking == 0) {
            and = ce.and();
            result = ce.getDescr();
            helper.start(and, CEDescrBuilder.class, null);
        }
        try {
            match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.AND, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            while (input.LA(1) == DRL6Lexer.AT) {
                annotation(and);
                if (state.failed)
                    return null;
            }
            if (state.backtracking == 0) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);
            }
            while (input.LA(1) != DRL6Lexer.RIGHT_PAREN) {
                lhsUnary(and, allowOr);
                if (state.failed)
                    return null;
            }
            match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        } finally {
            if (state.backtracking == 0) {
                helper.end(CEDescrBuilder.class, and);
            }
        }
    } else {
        CEDescrBuilder<?, AndDescr> and = null;
        if (state.backtracking == 0) {
            and = ce.and();
            result = and.getDescr();
            helper.start(and, CEDescrBuilder.class, null);
        }
        try {
            lhsUnary(and, allowOr);
            if (state.failed)
                return null;
            if (helper.validateIdentifierKey(DroolsSoftKeywords.AND) || input.LA(1) == DRL6Lexer.DOUBLE_AMPER) {
                while (helper.validateIdentifierKey(DroolsSoftKeywords.AND) || input.LA(1) == DRL6Lexer.DOUBLE_AMPER) {
                    if (input.LA(1) == DRL6Lexer.DOUBLE_AMPER) {
                        match(input, DRL6Lexer.DOUBLE_AMPER, null, null, DroolsEditorType.SYMBOL);
                    } else {
                        match(input, DRL6Lexer.ID, DroolsSoftKeywords.AND, null, DroolsEditorType.KEYWORD);
                    }
                    if (state.failed)
                        return null;
                    while (input.LA(1) == DRL6Lexer.AT) {
                        annotation(and);
                        if (state.failed)
                            return null;
                    }
                    if (state.backtracking == 0) {
                        helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);
                    }
                    lhsUnary(and, allowOr);
                    if (state.failed)
                        return null;
                }
            } else {
                if (state.backtracking == 0 && and.getDescr().getDescrs().size() < 2) {
                    ((ConditionalElementDescr) ce.getDescr()).getDescrs().remove(and.getDescr());
                    for (BaseDescr base : and.getDescr().getDescrs()) {
                        ((ConditionalElementDescr) ce.getDescr()).addDescr(base);
                    }
                    result = ce.getDescr();
                }
            }
        } finally {
            if (state.backtracking == 0) {
                helper.end(CEDescrBuilder.class, and);
            }
        }
    }
    return result;
}",java:S3776,39
"private BaseDescr lhsUnary(final CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    BaseDescr result = null;
    if (helper.validateIdentifierKey(DroolsSoftKeywords.EXISTS)) {
        result = lhsExists(ce, allowOr);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
            namedConsequence(ce, null);
        }
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.NOT)) {
        result = lhsNot(ce, allowOr);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
            namedConsequence(ce, null);
        }
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.EVAL)) {
        result = lhsEval(ce);
        for (BaseDescr i = consequenceInvocation(ce); i != null; i = consequenceInvocation(ce)) ;
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.FORALL)) {
        result = lhsForall(ce);
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.ACCUMULATE) || helper.validateIdentifierKey(DroolsSoftKeywords.ACC)) {
        result = lhsAccumulate(ce);
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.GROUPBY)) {
        result = lhsGroupBy(ce);
    } else if (input.LA(1) == DRL6Lexer.LEFT_PAREN) {
        result = lhsParen(ce, allowOr);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
            namedConsequence(ce, null);
        }
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.IF)) {
        result = conditionalBranch(ce, null);
    } else if (input.LA(1) == DRL6Lexer.ID || input.LA(1) == DRL6Lexer.QUESTION || input.LA(1) == DRL6Lexer.DIV) {
        result = lhsPatternBind(ce, allowOr);
        for (BaseDescr i = consequenceInvocation(ce); i != null; i = consequenceInvocation(ce)) ;
    } else {
        failMismatchedTokenException();
    }
    if (input.LA(1) == DRL6Lexer.SEMICOLON) {
        match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return null;
    }
    return result;
}",java:S3776,39
"private BaseDescr conditionalBranch(CEDescrBuilder<?, ?> ce, ConditionalBranchDescrBuilder<?> conditionalBranch) throws RecognitionException{
    if (conditionalBranch == null) {
        conditionalBranch = helper.start(ce, ConditionalBranchDescrBuilder.class, null);
    }
    try {
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.IF, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        EvalDescrBuilder<?> eval = conditionalBranch.condition();
        if (!parseEvalExpression(eval))
            return null;
        if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
            if (namedConsequence(null, conditionalBranch.consequence()) == null)
                return null;
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.BREAK)) {
            if (breakingNamedConsequence(null, conditionalBranch.consequence()) == null)
                return null;
        } else {
            return null;
        }
        if (helper.validateIdentifierKey(DroolsSoftKeywords.ELSE)) {
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.ELSE, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            ConditionalBranchDescrBuilder<?> elseBranch = conditionalBranch.otherwise();
            if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
                if (namedConsequence(null, elseBranch.consequence()) == null)
                    return null;
            } else if (helper.validateIdentifierKey(DroolsSoftKeywords.BREAK)) {
                if (breakingNamedConsequence(null, elseBranch.consequence()) == null)
                    return null;
            } else if (helper.validateIdentifierKey(DroolsSoftKeywords.IF)) {
                if (conditionalBranch(null, elseBranch) == null)
                    return null;
            } else {
                return null;
            }
        }
    } finally {
        helper.end(ConditionalBranchDescrBuilder.class, conditionalBranch);
    }
    return conditionalBranch.getDescr();
}",java:S3776,39
"protected BaseDescr lhsExists(CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    CEDescrBuilder<?, ExistsDescr> exists = null;
    if (state.backtracking == 0) {
        exists = ce.exists();
        helper.start(exists, CEDescrBuilder.class, null);
    }
    try {
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.EXISTS, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_EXISTS);
        }
        if (input.LA(1) == DRL6Lexer.LEFT_PAREN) {
            boolean prefixed = helper.validateLT(2, DroolsSoftKeywords.AND) || helper.validateLT(2, DroolsSoftKeywords.OR);
            if (!prefixed) {
                match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
            lhsOr(exists, allowOr);
            if (state.failed)
                return null;
            if (!prefixed) {
                match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
        } else {
            lhsPatternBind(exists, true);
            if (state.failed)
                return null;
        }
    } finally {
        if (state.backtracking == 0) {
            helper.end(CEDescrBuilder.class, exists);
        }
    }
    return exists != null ? exists.getDescr() : null;
}",java:S3776,39
"protected BaseDescr lhsNot(CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    CEDescrBuilder<?, NotDescr> not = null;
    if (state.backtracking == 0) {
        not = ce.not();
        helper.start(not, CEDescrBuilder.class, null);
    }
    try {
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.NOT, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_NOT);
        }
        if (input.LA(1) == DRL6Lexer.LEFT_PAREN) {
            boolean prefixed = helper.validateLT(2, DroolsSoftKeywords.AND) || helper.validateLT(2, DroolsSoftKeywords.OR);
            if (!prefixed) {
                match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
            if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
            }
            lhsOr(not, allowOr);
            if (state.failed)
                return null;
            if (!prefixed) {
                match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
        } else if (input.LA(1) != DRL6Lexer.EOF) {
            lhsPatternBind(not, true);
            if (state.failed)
                return null;
        }
    } finally {
        if (state.backtracking == 0) {
            helper.end(CEDescrBuilder.class, not);
        }
    }
    return not != null ? not.getDescr() : null;
}",java:S3776,39
"public PredicateConstraint clone(){
    Declaration[] previous = new Declaration[this.previousDeclarations.length];
    for (int i = 0; i < previous.length; i++) {
        previous[i] = this.previousDeclarations[i].clone();
    }
    Declaration[] local = new Declaration[this.localDeclarations.length];
    for (int i = 0; i < local.length; i++) {
        local[i] = this.localDeclarations[i].clone();
    }
    PredicateConstraint clone = new PredicateConstraint(this.expression, previous, local);
    if (this.cloned == Collections.EMPTY_LIST) {
        this.cloned = new ArrayList<>(1);
    }
    this.cloned.add(clone);
    return clone;
}",java:S2975,34
"private BaseDescr lhsAccumulate(PatternContainerDescrBuilder<?, ?> ce) throws RecognitionException{
    PatternDescrBuilder<?> pattern;
    BaseDescr result = null;
    pattern = helper.start((DescrBuilder<?, ?>) ce, PatternDescrBuilder.class, null);
    if (pattern != null) {
        result = pattern.getDescr();
    }
    try {
        if (state.backtracking == 0) {
            pattern.type(""Object"");
            pattern.isQuery(false);
        }
        AccumulateDescrBuilder<?> accumulate = helper.start(pattern, AccumulateDescrBuilder.class, null);
        try {
            if (helper.validateIdentifierKey(DroolsSoftKeywords.ACCUMULATE)) {
                match(input, DRL6Lexer.ID, DroolsSoftKeywords.ACCUMULATE, null, DroolsEditorType.KEYWORD);
            } else {
                match(input, DRL6Lexer.ID, DroolsSoftKeywords.ACC, null, DroolsEditorType.KEYWORD);
            }
            if (state.failed)
                return null;
            if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE);
            }
            match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
            CEDescrBuilder<?, AndDescr> source = accumulate.source();
            try {
                helper.start(source, CEDescrBuilder.class, null);
                lhsAnd(source, true);
                if (state.failed)
                    return null;
                if (source.getDescr() != null && source.getDescr() instanceof ConditionalElementDescr) {
                    ConditionalElementDescr root = source.getDescr();
                    BaseDescr[] descrs = root.getDescrs().toArray(new BaseDescr[root.getDescrs().size()]);
                    root.getDescrs().clear();
                    for (int i = 0; i < descrs.length; i++) {
                        root.addOrMerge(descrs[i]);
                    }
                }
            } finally {
                helper.end(CEDescrBuilder.class, source);
            }
            if (input.LA(1) == DRL6Lexer.COMMA) {
                match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            } else if (input.LA(-1) != DRL6Lexer.SEMICOLON) {
                match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
            accumulateFunctionBinding(accumulate);
            if (state.failed)
                return null;
            while (input.LA(1) == DRL6Lexer.COMMA) {
                match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
                accumulateFunctionBinding(accumulate);
                if (state.failed)
                    return null;
            }
            if (input.LA(1) == DRL6Lexer.SEMICOLON) {
                match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
                constraints(pattern);
            }
            match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        } finally {
            helper.end(AccumulateDescrBuilder.class, accumulate);
            if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
            }
        }
    } finally {
        helper.end(PatternDescrBuilder.class, pattern);
    }
    if (input.LA(1) == DRL6Lexer.SEMICOLON) {
        match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return null;
    }
    return result;
}",java:S3776,39
"private BaseDescr lhsGroupBy(PatternContainerDescrBuilder<?, ?> ce) throws RecognitionException{
    PatternDescrBuilder<?> pattern;
    BaseDescr result = null;
    pattern = helper.start((DescrBuilder<?, ?>) ce, PatternDescrBuilder.class, null);
    if (pattern != null) {
        result = pattern.getDescr();
    }
    try {
        if (state.backtracking == 0) {
            pattern.type(""Object"");
            pattern.isQuery(false);
        }
        GroupByDescrBuilder<?> groupBy = helper.start(pattern, GroupByDescrBuilder.class, null);
        try {
            if (helper.validateIdentifierKey(DroolsSoftKeywords.GROUPBY)) {
                match(input, DRL6Lexer.ID, DroolsSoftKeywords.GROUPBY, null, DroolsEditorType.KEYWORD);
            }
            if (state.failed)
                return null;
            if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE);
            }
            match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
            CEDescrBuilder<?, AndDescr> source = groupBy.source();
            try {
                helper.start(source, CEDescrBuilder.class, null);
                lhsAnd(source, true);
                if (state.failed)
                    return null;
                if (source.getDescr() != null && source.getDescr() instanceof ConditionalElementDescr) {
                    ConditionalElementDescr root = source.getDescr();
                    BaseDescr[] descrs = root.getDescrs().toArray(new BaseDescr[root.getDescrs().size()]);
                    root.getDescrs().clear();
                    for (int i = 0; i < descrs.length; i++) {
                        root.addOrMerge(descrs[i]);
                    }
                }
            } finally {
                helper.end(CEDescrBuilder.class, source);
            }
            if (input.LA(1) == DRL6Lexer.COMMA) {
                match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            } else if (input.LA(-1) != DRL6Lexer.SEMICOLON) {
                match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
            groupByKeyFunction(groupBy);
            if (state.failed)
                return null;
            match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
            accumulateFunctionBinding(groupBy);
            while (input.LA(1) == DRL6Lexer.COMMA) {
                match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
                accumulateFunctionBinding(groupBy);
                if (state.failed)
                    return null;
            }
            if (input.LA(1) == DRL6Lexer.SEMICOLON) {
                match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
                constraints(pattern);
            }
            match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        } finally {
            helper.end(GroupByDescrBuilder.class, groupBy);
            if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
            }
        }
    } finally {
        helper.end(PatternDescrBuilder.class, pattern);
    }
    return result;
}",java:S3776,39
" void lhsPattern(PatternDescrBuilder<?> pattern, String label, boolean isUnification) throws RecognitionException{
    if (input.LA(1) == DRL6Lexer.DIV) {
        int first = input.index();
        exprParser.xpathPrimary();
        if (state.failed)
            return;
        int last = input.LT(-1).getTokenIndex();
        String expr = toExpression("""", first, last);
        pattern.constraint(expr);
        if (label != null) {
            pattern.id(label, isUnification);
        }
        if (helper.validateIdentifierKey(DroolsSoftKeywords.OVER)) {
            patternFilter(pattern);
        }
        return;
    }
    boolean query = false;
    if (input.LA(1) == DRL6Lexer.QUESTION) {
        match(input, DRL6Lexer.QUESTION, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return;
        query = true;
    }
    String type = this.qualifiedIdentifier();
    if (state.failed)
        return;
    if (state.backtracking == 0) {
        pattern.type(type);
        pattern.isQuery(query);
        if (label != null) {
            pattern.id(label, isUnification);
        }
    }
    match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
    if (state.failed)
        return;
    if (input.LA(1) != DRL6Lexer.RIGHT_PAREN && speculatePositionalConstraints()) {
        positionalConstraints(pattern);
    }
    if (input.LA(1) != DRL6Lexer.RIGHT_PAREN) {
        constraints(pattern);
    }
    match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
    if (state.failed)
        return;
    while (input.LA(1) == DRL6Lexer.AT) {
        annotation(pattern);
        if (state.failed)
            return;
    }
    if (helper.validateIdentifierKey(DroolsSoftKeywords.OVER)) {
        patternFilter(pattern);
    }
    if (helper.validateIdentifierKey(DroolsSoftKeywords.FROM)) {
        patternSource(pattern);
    }
    if (state.backtracking == 0) {
        helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
    }
}",java:S3776,39
"private void constraint(PatternDescrBuilder<?> pattern, boolean positional, String prefix) throws RecognitionException{
    if (speculateNestedConstraint()) {
        nestedConstraint(pattern, prefix);
        return;
    }
    if (state.backtracking == 0) {
        helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_START);
    }
    int first = input.index();
    exprParser.getHelper().setHasOperator(false);
    try {
        exprParser.conditionalOrExpression();
    } finally {
        if (state.backtracking == 0) {
            if (input.LA(1) == DRL6Lexer.ID && input.LA(2) == DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_ARGUMENT);
            } else if (input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_END);
            } else if (!lastTokenWasWhiteSpace()) {
                int location = getCurrentLocation();
                if (location == Location.LOCATION_LHS_INSIDE_CONDITION_END) {
                    helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_ARGUMENT);
                } else if (input.get(input.index()).getType() != DRL6Lexer.EOF) {
                    helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_START);
                }
            } else if (getCurrentLocation() == Location.LOCATION_LHS_INSIDE_CONDITION_START && !exprParser.getHelper().getHasOperator() && lastTokenWasWhiteSpace() && input.LA(1) == DRL6Lexer.EOF && input.LA(-1) == DRL6Lexer.ID) {
                helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_OPERATOR);
            }
        }
    }
    if (state.failed)
        return;
    if (state.backtracking == 0 && input.index() > first) {
        int last = input.LT(-1).getTokenIndex();
        String expr = toExpression(prefix, first, last);
        pattern.constraint(expr, positional);
        BaseDescr constrDescr = pattern.getDescr().getDescrs().get(pattern.getDescr().getDescrs().size() - 1);
        constrDescr.setLocation(input.get(first).getLine(), input.get(first).getCharPositionInLine());
        constrDescr.setEndLocation(input.get(last).getLine(), input.get(last).getCharPositionInLine());
        constrDescr.setStartCharacter(((CommonToken) input.get(first)).getStartIndex());
        constrDescr.setEndCharacter(((CommonToken) input.get(last)).getStopIndex());
    }
}",java:S3776,39
"private boolean speculateNestedConstraint() throws RecognitionException{
    return getNestedConstraintPrefixLenght() > 0;
}",java:S1130,7
"public PredicateConstraint clone(){
    Declaration[] previous = new Declaration[this.previousDeclarations.length];
    for (int i = 0; i < previous.length; i++) {
        previous[i] = this.previousDeclarations[i].clone();
    }
    Declaration[] local = new Declaration[this.localDeclarations.length];
    for (int i = 0; i < local.length; i++) {
        local[i] = this.localDeclarations[i].clone();
    }
    PredicateConstraint clone = new PredicateConstraint(this.expression, previous, local);
    if (this.cloned == Collections.EMPTY_LIST) {
        this.cloned = new ArrayList<>(1);
    }
    this.cloned.add(clone);
    return clone;
}",java:S1182,14
"private void patternSource(PatternDescrBuilder<?> pattern) throws RecognitionException{
    match(input, DRL6Lexer.ID, DroolsSoftKeywords.FROM, null, DroolsEditorType.KEYWORD);
    if (state.failed)
        return;
    if (state.backtracking == 0) {
        helper.emit(Location.LOCATION_LHS_FROM);
    }
    if (helper.validateIdentifierKey(DroolsSoftKeywords.ACCUMULATE) || helper.validateIdentifierKey(DroolsSoftKeywords.ACC)) {
        fromAccumulate(pattern);
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.COLLECT)) {
        fromCollect(pattern);
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.ENTRY) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.POINT)) {
        fromEntryPoint(pattern);
        if (state.failed)
            return;
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.WINDOW)) {
        fromWindow(pattern);
    } else {
        fromExpression(pattern);
        if (!lastTokenWasWhiteSpace() && input.LA(1) == DRL6Lexer.EOF) {
            helper.emit(Location.LOCATION_LHS_FROM);
            throw new RecognitionException();
        }
        if (state.failed)
            return;
    }
    if (input.LA(1) == DRL6Lexer.SEMICOLON) {
        match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return;
    }
}",java:S3776,39
"private void fromAccumulate(PatternDescrBuilder<?> pattern) throws RecognitionException{
    AccumulateDescrBuilder<?> accumulate = helper.start(pattern, AccumulateDescrBuilder.class, null);
    try {
        if (helper.validateIdentifierKey(DroolsSoftKeywords.ACCUMULATE)) {
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.ACCUMULATE, null, DroolsEditorType.KEYWORD);
        } else {
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.ACC, null, DroolsEditorType.KEYWORD);
        }
        if (state.failed)
            return;
        if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
            helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE);
        }
        match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return;
        CEDescrBuilder<?, AndDescr> source = accumulate.source();
        try {
            helper.start(source, CEDescrBuilder.class, null);
            lhsAnd(source, false);
            if (state.failed)
                return;
            if (source.getDescr() != null && source.getDescr() instanceof ConditionalElementDescr) {
                ConditionalElementDescr root = source.getDescr();
                BaseDescr[] descrs = root.getDescrs().toArray(new BaseDescr[root.getDescrs().size()]);
                root.getDescrs().clear();
                for (int i = 0; i < descrs.length; i++) {
                    root.addOrMerge(descrs[i]);
                }
            }
        } finally {
            helper.end(CEDescrBuilder.class, source);
        }
        if (input.LA(1) == DRL6Lexer.COMMA) {
            match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
        } else if (input.LA(-1) != DRL6Lexer.SEMICOLON) {
            match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
        }
        if (helper.validateIdentifierKey(DroolsSoftKeywords.INIT)) {
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.INIT, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return;
            if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_INIT);
            }
            String init = chunk(DRL6Lexer.LEFT_PAREN, DRL6Lexer.RIGHT_PAREN, Location.LOCATION_LHS_FROM_ACCUMULATE_INIT_INSIDE);
            if (state.failed)
                return;
            if (state.backtracking == 0)
                accumulate.init(init);
            if (input.LA(1) == DRL6Lexer.COMMA) {
                match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return;
            }
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.ACTION, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return;
            if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_ACTION);
            }
            String action = chunk(DRL6Lexer.LEFT_PAREN, DRL6Lexer.RIGHT_PAREN, Location.LOCATION_LHS_FROM_ACCUMULATE_ACTION_INSIDE);
            if (state.failed)
                return;
            if (state.backtracking == 0)
                accumulate.action(action);
            if (input.LA(1) == DRL6Lexer.COMMA) {
                match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return;
            }
            if (helper.validateIdentifierKey(DroolsSoftKeywords.REVERSE)) {
                match(input, DRL6Lexer.ID, DroolsSoftKeywords.REVERSE, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return;
                if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                    helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_REVERSE);
                }
                String reverse = chunk(DRL6Lexer.LEFT_PAREN, DRL6Lexer.RIGHT_PAREN, Location.LOCATION_LHS_FROM_ACCUMULATE_REVERSE_INSIDE);
                if (state.failed)
                    return;
                if (state.backtracking == 0)
                    accumulate.reverse(reverse);
                if (input.LA(1) == DRL6Lexer.COMMA) {
                    match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                    if (state.failed)
                        return;
                }
            }
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.RESULT, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return;
            if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_RESULT);
            }
            String result = chunk(DRL6Lexer.LEFT_PAREN, DRL6Lexer.RIGHT_PAREN, Location.LOCATION_LHS_FROM_ACCUMULATE_RESULT_INSIDE);
            if (state.failed)
                return;
            if (state.backtracking == 0)
                accumulate.result(result);
        } else {
            accumulateFunction(accumulate, false, null);
            if (state.failed)
                return;
        }
        match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return;
    } finally {
        helper.end(AccumulateDescrBuilder.class, accumulate);
        if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
            helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
        }
    }
}",java:S3776,39
"protected String getConsequenceCode(int first){
    while (input.LA(1) != DRL6Lexer.EOF) {
        if (helper.validateIdentifierKey(DroolsSoftKeywords.END)) {
            int next = input.LA(2) == DRL6Lexer.SEMICOLON ? 3 : 2;
            if (input.LA(next) == DRL6Lexer.EOF || helper.validateStatement(next)) {
                break;
            }
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.THEN)) {
            if (isNextTokenThenCompatible(input.LA(2))) {
                break;
            }
        }
        helper.emit(input.LT(1), DroolsEditorType.CODE_CHUNK);
        input.consume();
    }
    int last = input.LT(1).getTokenIndex();
    if (last <= first) {
        return """";
    }
    String chunk = input.toString(first, last);
    if (chunk.endsWith(DroolsSoftKeywords.END)) {
        chunk = chunk.substring(0, chunk.length() - DroolsSoftKeywords.END.length());
    } else if (chunk.endsWith(DroolsSoftKeywords.THEN)) {
        chunk = chunk.substring(0, chunk.length() - DroolsSoftKeywords.THEN.length());
    }
    return chunk;
}",java:S3776,39
" void annotation(AnnotatedDescrBuilder<?> adb){
    AnnotationDescrBuilder<?> annotation = null;
    try {
        if (speculateFullAnnotation()) {
            boolean buildState = exprParser.isBuildDescr();
            exprParser.setBuildDescr(true);
            exprParser.fullAnnotation(adb);
            exprParser.setBuildDescr(buildState);
        } else {
            Token at = match(input, DRL6Lexer.AT, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
            String fqn = qualifiedIdentifier();
            if (state.failed)
                return;
            if (state.backtracking == 0) {
                annotation = adb.newAnnotation(fqn);
                helper.setStart(annotation, at);
            }
            try {
                if (input.LA(1) == DRL6Lexer.LEFT_PAREN) {
                    String value = chunk(DRL6Lexer.LEFT_PAREN, DRL6Lexer.RIGHT_PAREN, -1).trim();
                    if (state.failed)
                        return;
                    if (state.backtracking == 0) {
                        if (annotation != null) {
                            annotation.value(value);
                        } else {
                            throw new RecognitionException();
                        }
                    }
                }
            } finally {
                if (state.backtracking == 0) {
                    helper.setEnd(annotation);
                }
            }
        }
    } catch (RecognitionException re) {
        reportError(re);
    }
}",java:S3776,39
"public String type() throws RecognitionException{
    String type = """";
    try {
        int first = input.index(), last = first;
        match(input, DRL6Lexer.ID, null, new int[] { DRL6Lexer.DOT, DRL6Lexer.LESS }, DroolsEditorType.IDENTIFIER);
        if (state.failed)
            return type;
        if (input.LA(1) == DRL6Lexer.LESS) {
            typeArguments();
            if (state.failed)
                return type;
        }
        while (input.LA(1) == DRL6Lexer.DOT && input.LA(2) == DRL6Lexer.ID) {
            match(input, DRL6Lexer.DOT, null, new int[] { DRL6Lexer.ID }, DroolsEditorType.IDENTIFIER);
            if (state.failed)
                return type;
            match(input, DRL6Lexer.ID, null, new int[] { DRL6Lexer.DOT }, DroolsEditorType.IDENTIFIER);
            if (state.failed)
                return type;
            if (input.LA(1) == DRL6Lexer.LESS) {
                typeArguments();
                if (state.failed)
                    return type;
            }
        }
        while (input.LA(1) == DRL6Lexer.LEFT_SQUARE && input.LA(2) == DRL6Lexer.RIGHT_SQUARE) {
            match(input, DRL6Lexer.LEFT_SQUARE, null, new int[] { DRL6Lexer.RIGHT_SQUARE }, DroolsEditorType.IDENTIFIER);
            if (state.failed)
                return type;
            match(input, DRL6Lexer.RIGHT_SQUARE, null, null, DroolsEditorType.IDENTIFIER);
            if (state.failed)
                return type;
        }
        last = input.LT(-1).getTokenIndex();
        type = input.toString(first, last);
        type = type.replace("" "", """");
    } catch (RecognitionException re) {
        reportError(re);
    }
    return type;
}",java:S3776,39
"public String typeArgument() throws RecognitionException{
    String typeArgument = """";
    try {
        int first = input.index(), last = first;
        int next = input.LA(1);
        switch(next) {
            case DRL6Lexer.QUESTION:
                match(input, DRL6Lexer.QUESTION, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return typeArgument;
                if (helper.validateIdentifierKey(DroolsSoftKeywords.EXTENDS)) {
                    match(input, DRL6Lexer.ID, DroolsSoftKeywords.EXTENDS, null, DroolsEditorType.SYMBOL);
                    if (state.failed)
                        return typeArgument;
                    type();
                    if (state.failed)
                        return typeArgument;
                } else if (helper.validateIdentifierKey(DroolsSoftKeywords.SUPER)) {
                    match(input, DRL6Lexer.ID, DroolsSoftKeywords.SUPER, null, DroolsEditorType.SYMBOL);
                    if (state.failed)
                        return typeArgument;
                    type();
                    if (state.failed)
                        return typeArgument;
                }
                break;
            case DRL6Lexer.ID:
                type();
                if (state.failed)
                    return typeArgument;
                break;
            default:
        }
        last = input.LT(-1).getTokenIndex();
        typeArgument = input.toString(first, last);
    } catch (RecognitionException re) {
        reportError(re);
    }
    return typeArgument;
}",java:S3776,39
"public boolean mismatchIsMissingToken(TokenStream input, int[] follow){
    if (follow == null) {
        return false;
    }
    return false;
}",java:S3516,37
"public boolean mismatchIsMissingToken(TokenStream input, int[] follow){
    if (follow == null) {
        return false;
    }
    return false;
}",java:S1172,13
"public BaseDescr statement(PackageDescrBuilder pkg) throws RecognitionException{
    BaseDescr descr = null;
    try {
        if (helper.validateIdentifierKey(DroolsSoftKeywords.IMPORT)) {
            descr = importStatement(pkg);
            if (state.failed)
                return descr;
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.GLOBAL)) {
            descr = globalStatement(pkg);
            if (state.failed)
                return descr;
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DECLARE)) {
            descr = declare(pkg);
            if (state.failed)
                return descr;
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.RULE)) {
            descr = rule(pkg);
            if (state.failed)
                return descr;
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.QUERY)) {
            descr = query(pkg);
            if (state.failed)
                return descr;
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.FUNCTION)) {
            descr = function(pkg);
            if (state.failed)
                return descr;
        } else if (helper.validateAttribute(1)) {
            descr = attribute(pkg);
            if (state.failed)
                return descr;
        }
    } catch (RecognitionException e) {
        helper.reportError(e);
    } catch (Exception e) {
        helper.reportError(e);
    }
    return descr;
}",java:S3776,39
"public ImportDescr importStatement(PackageDescrBuilder pkg) throws RecognitionException{
    try {
        String kwd;
        if (helper.validateLT(2, kwd = DroolsSoftKeywords.ACC) || helper.validateLT(2, kwd = DroolsSoftKeywords.ACCUMULATE)) {
            AccumulateImportDescrBuilder imp = helper.start(pkg, AccumulateImportDescrBuilder.class, null);
            try {
                match(input, DRL6Lexer.ID, DroolsSoftKeywords.IMPORT, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
                match(input, DRL6Lexer.ID, kwd, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
                String target = qualifiedIdentifier();
                if (state.failed)
                    return null;
                Token id = match(input, DRL6Lexer.ID, null, null, DroolsEditorType.IDENTIFIER);
                if (state.failed)
                    return null;
                if (state.backtracking == 0) {
                    imp.target(target).functionName(id.getText());
                }
                return (imp != null) ? imp.getDescr() : null;
            } finally {
                helper.end(AccumulateImportDescrBuilder.class, imp);
            }
        } else {
            ImportDescrBuilder imp = helper.start(pkg, ImportDescrBuilder.class, null);
            try {
                match(input, DRL6Lexer.ID, DroolsSoftKeywords.IMPORT, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
                if (helper.validateIdentifierKey(kwd = DroolsSoftKeywords.FUNCTION) || helper.validateIdentifierKey(kwd = DroolsSoftKeywords.STATIC)) {
                    match(input, DRL6Lexer.ID, kwd, null, DroolsEditorType.KEYWORD);
                    if (state.failed)
                        return null;
                }
                String target = qualifiedIdentifier();
                if (state.failed)
                    return null;
                if (input.LA(1) == DRL6Lexer.DOT && input.LA(2) == DRL6Lexer.STAR) {
                    match(input, DRL6Lexer.DOT, null, null, DroolsEditorType.IDENTIFIER);
                    if (state.failed)
                        return null;
                    match(input, DRL6Lexer.STAR, null, null, DroolsEditorType.IDENTIFIER);
                    if (state.failed)
                        return null;
                    target += "".*"";
                }
                if (state.backtracking == 0)
                    imp.target(target);
                return (imp != null) ? imp.getDescr() : null;
            } finally {
                helper.end(ImportDescrBuilder.class, imp);
            }
        }
    } catch (RecognitionException re) {
        reportError(re);
    }
    return null;
}",java:S3776,39
"public EnumDeclarationDescr enumDeclaration(DeclareDescrBuilder ddb) throws RecognitionException{
    EnumDeclarationDescrBuilder declare = null;
    try {
        declare = helper.start(ddb, EnumDeclarationDescrBuilder.class, null);
        setAnnotationsOn(declare);
        String type = qualifiedIdentifier();
        if (state.failed)
            return null;
        if (state.backtracking == 0)
            declare.name(type);
        while (input.LA(1) == DRL6Lexer.ID) {
            int next = input.LA(2);
            if (next == DRL6Lexer.LEFT_PAREN || next == DRL6Lexer.COMMA || next == DRL6Lexer.SEMICOLON) {
                enumerative(declare);
                if (state.failed)
                    return null;
            }
            if (input.LA(1) == DRL6Lexer.COMMA) {
                match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
            } else {
                match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
                break;
            }
        }
        while (input.LA(1) == DRL6Lexer.ID && !helper.validateIdentifierKey(DroolsSoftKeywords.END)) {
            field(declare);
            if (state.failed)
                return null;
        }
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.END, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
    } catch (RecognitionException re) {
        reportError(re);
    } finally {
        helper.end(TypeDeclarationDescrBuilder.class, declare);
    }
    return (declare != null) ? declare.getDescr() : null;
}",java:S3776,39
"public TypeDeclarationDescr typeDeclaration(DeclareDescrBuilder ddb, boolean isTrait) throws RecognitionException{
    TypeDeclarationDescrBuilder declare = null;
    try {
        declare = helper.start(ddb, TypeDeclarationDescrBuilder.class, null);
        setAnnotationsOn(declare);
        declare.setTrait(isTrait);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.TYPE)) {
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.TYPE, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
        }
        String type = qualifiedIdentifier();
        if (state.failed)
            return null;
        if (state.backtracking == 0)
            declare.name(type);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.EXTENDS)) {
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.EXTENDS, null, DroolsEditorType.KEYWORD);
            if (!state.failed) {
                String superType = qualifiedIdentifier();
                declare.superType(superType);
                while (input.LA(1) == DRL6Lexer.COMMA) {
                    match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                    superType = qualifiedIdentifier();
                    declare.superType(superType);
                }
            }
        }
        while ((input.LA(1) == DRL6Lexer.ID || input.LA(1) == DRL6Lexer.AT) && !helper.validateIdentifierKey(DroolsSoftKeywords.END)) {
            field(declare);
            if (state.failed)
                return null;
        }
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.END, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
    } catch (RecognitionException re) {
        reportError(re);
    } finally {
        helper.end(TypeDeclarationDescrBuilder.class, declare);
    }
    return (declare != null) ? declare.getDescr() : null;
}",java:S3776,39
"private void enumerative(EnumDeclarationDescrBuilder declare){
    EnumLiteralDescrBuilder literal = null;
    String lit = null;
    try {
        Token enumLit = match(input, DRL6Lexer.ID, null, null, DroolsEditorType.IDENTIFIER);
        lit = enumLit.getText();
        if (state.failed)
            return;
    } catch (RecognitionException re) {
        reportError(re);
    }
    try {
        literal = helper.start(declare, EnumLiteralDescrBuilder.class, lit);
        if (input.LA(1) == DRL6Lexer.LEFT_PAREN) {
            match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
            boolean more;
            do {
                int first = input.index();
                exprParser.conditionalExpression();
                if (state.failed)
                    return;
                if (state.backtracking == 0 && input.index() > first) {
                    String arg = input.toString(first, input.LT(-1).getTokenIndex());
                    literal.constructorArg(arg);
                }
                more = input.LA(1) == DRL6Lexer.COMMA;
                if (more) {
                    match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                }
            } while (more);
            match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
        }
    } catch (RecognitionException re) {
        reportError(re);
    } finally {
        helper.end(FieldDescrBuilder.class, literal);
    }
}",java:S3776,39
"private void field(AbstractClassTypeDeclarationBuilder declare){
    annotations();
    FieldDescrBuilder field = null;
    String fname = null;
    try {
        fname = label(DroolsEditorType.IDENTIFIER);
        if (state.failed)
            return;
    } catch (RecognitionException re) {
        reportError(re);
    }
    try {
        field = helper.start(declare, FieldDescrBuilder.class, fname);
        setAnnotationsOn(field);
        String type = type();
        if (state.failed)
            return;
        if (state.backtracking == 0)
            field.type(type);
        if (input.LA(1) == DRL6Lexer.EQUALS_ASSIGN) {
            match(input, DRL6Lexer.EQUALS_ASSIGN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
            int first = input.index();
            exprParser.conditionalExpression();
            if (state.failed)
                return;
            if (state.backtracking == 0 && input.index() > first) {
                String value = input.toString(first, input.LT(-1).getTokenIndex());
                field.initialValue(value);
            }
        }
        if (input.LA(1) == DRL6Lexer.SEMICOLON) {
            match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
        }
    } catch (RecognitionException re) {
        reportError(re);
    } finally {
        helper.end(FieldDescrBuilder.class, field);
    }
}",java:S3776,39
"public RuleDescr query(PackageDescrBuilder pkg) throws RecognitionException{
    QueryDescrBuilder query = null;
    try {
        query = helper.start(pkg, QueryDescrBuilder.class, null);
        setAnnotationsOn(query);
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.QUERY, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (helper.validateIdentifierKey(DroolsSoftKeywords.WHEN) || helper.validateIdentifierKey(DroolsSoftKeywords.THEN) || helper.validateIdentifierKey(DroolsSoftKeywords.END)) {
            failMissingTokenException();
            return null;
        }
        String name = stringId();
        if (state.backtracking == 0)
            query.name(name);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            helper.emit(Location.LOCATION_RULE_HEADER);
        }
        if (speculateParameters(true)) {
            parameters(query, true);
            if (state.failed)
                return null;
            if (state.backtracking == 0) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
            }
        } else if (speculateParameters(false)) {
            parameters(query, false);
            if (state.failed)
                return null;
            if (state.backtracking == 0) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
            }
        }
        if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
            helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
        }
        if (input.LA(1) != DRL6Lexer.EOF) {
            lhsExpression(query != null ? query.lhs() : null);
        }
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.END, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        helper.emit(Location.LOCATION_RHS);
    } catch (RecognitionException re) {
        reportError(re);
    } finally {
        helper.end(QueryDescrBuilder.class, query);
    }
    return (query != null) ? query.getDescr() : null;
}",java:S3776,39
"public RuleDescr rule(PackageDescrBuilder pkg) throws RecognitionException{
    RuleDescrBuilder rule = null;
    try {
        rule = helper.start(pkg, RuleDescrBuilder.class, null);
        setAnnotationsOn(rule);
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.RULE, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (helper.validateIdentifierKey(DroolsSoftKeywords.WHEN) || helper.validateIdentifierKey(DroolsSoftKeywords.THEN) || helper.validateIdentifierKey(DroolsSoftKeywords.END)) {
            failMissingTokenException();
            return null;
        }
        String name = stringId();
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            rule.name(name);
            helper.setParaphrasesValue(DroolsParaphraseTypes.RULE, ""\"""" + name + ""\"""");
            helper.emit(Location.LOCATION_RULE_HEADER);
        }
        if (helper.validateIdentifierKey(DroolsSoftKeywords.EXTENDS)) {
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.EXTENDS, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            String parent = stringId();
            if (state.backtracking == 0)
                rule.extendsRule(parent);
            if (state.failed)
                return null;
        }
        if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
            helper.emit(Location.LOCATION_RULE_HEADER);
        }
        attributes(rule);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.WHEN)) {
            lhs(rule);
        } else {
            rule.lhs();
        }
        rhs(rule);
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.END, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
    } catch (RecognitionException re) {
        reportError(re);
    } finally {
        helper.end(RuleDescrBuilder.class, rule);
    }
    return (rule != null) ? rule.getDescr() : null;
}",java:S3776,39
" void attributes(RuleDescrBuilder rule) throws RecognitionException{
    if (helper.validateIdentifierKey(DroolsSoftKeywords.ATTRIBUTES)) {
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.ATTRIBUTES, null, DroolsEditorType.IDENTIFIER);
        if (state.failed)
            return;
        if (input.LA(1) == DRL6Lexer.COLON) {
            match(input, DRL6Lexer.COLON, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
        }
    }
    if (helper.validateAttribute(1)) {
        attribute(rule);
        if (state.failed)
            return;
        while (input.LA(1) == DRL6Lexer.COMMA || helper.validateAttribute(1)) {
            if (input.LA(1) == DRL6Lexer.COMMA) {
                match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return;
            }
            attribute(rule);
            if (state.failed)
                return;
        }
    }
}",java:S3776,39
"public AttributeDescr attribute(AttributeSupportBuilder<?> as){
    AttributeDescr attribute = null;
    try {
        if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
            helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);
        }
        if (helper.validateIdentifierKey(DroolsSoftKeywords.SALIENCE)) {
            attribute = salience(as);
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.ENABLED)) {
            attribute = enabled(as);
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.NO) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.LOOP)) {
            attribute = booleanAttribute(as, new String[] { DroolsSoftKeywords.NO, ""-"", DroolsSoftKeywords.LOOP });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.AUTO) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.FOCUS)) {
            attribute = booleanAttribute(as, new String[] { DroolsSoftKeywords.AUTO, ""-"", DroolsSoftKeywords.FOCUS });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.LOCK) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.ON) && helper.validateLT(4, ""-"") && helper.validateLT(5, DroolsSoftKeywords.ACTIVE)) {
            attribute = booleanAttribute(as, new String[] { DroolsSoftKeywords.LOCK, ""-"", DroolsSoftKeywords.ON, ""-"", DroolsSoftKeywords.ACTIVE });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.REFRACT)) {
            attribute = booleanAttribute(as, new String[] { DroolsSoftKeywords.REFRACT });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DIRECT)) {
            attribute = booleanAttribute(as, new String[] { DroolsSoftKeywords.DIRECT });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.AGENDA) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.GROUP)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.AGENDA, ""-"", DroolsSoftKeywords.GROUP });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.ACTIVATION) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.GROUP)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.ACTIVATION, ""-"", DroolsSoftKeywords.GROUP });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.RULEFLOW) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.GROUP)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.RULEFLOW, ""-"", DroolsSoftKeywords.GROUP });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DATE) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.EFFECTIVE)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.DATE, ""-"", DroolsSoftKeywords.EFFECTIVE });
            if (attribute != null) {
                attribute.setType(AttributeDescr.Type.DATE);
            } else {
                throw new RecognitionException();
            }
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DATE) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.EXPIRES)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.DATE, ""-"", DroolsSoftKeywords.EXPIRES });
            if (attribute != null) {
                attribute.setType(AttributeDescr.Type.DATE);
            } else {
                throw new RecognitionException();
            }
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DIALECT)) {
            attribute = stringAttribute(as, new String[] { DroolsSoftKeywords.DIALECT });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.CALENDARS)) {
            attribute = stringListAttribute(as, new String[] { DroolsSoftKeywords.CALENDARS });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.TIMER)) {
            attribute = intOrChunkAttribute(as, new String[] { DroolsSoftKeywords.TIMER });
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.DURATION)) {
            attribute = intOrChunkAttribute(as, new String[] { DroolsSoftKeywords.DURATION });
        }
        if (state.backtracking == 0) {
            helper.emit(Location.LOCATION_RULE_HEADER);
        }
    } catch (RecognitionException re) {
        reportError(re);
    }
    return attribute;
}",java:S3776,39
"private AttributeDescr salience(AttributeSupportBuilder<?> as) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.SALIENCE, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, DroolsSoftKeywords.SALIENCE);
        }
        boolean hasParen = input.LA(1) == DRL6Lexer.LEFT_PAREN;
        int first = input.index();
        if (hasParen) {
            match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        }
        String value = conditionalExpression();
        if (state.failed)
            return null;
        if (hasParen) {
            match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        }
        if (state.backtracking == 0) {
            if (attribute != null) {
                if (hasParen) {
                    value = input.toString(first, input.LT(-1).getTokenIndex());
                }
                attribute.value(value);
                attribute.type(AttributeDescr.Type.EXPRESSION);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr enabled(AttributeSupportBuilder<?> as) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.ENABLED, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, DroolsSoftKeywords.ENABLED);
        }
        boolean hasParen = input.LA(1) == DRL6Lexer.LEFT_PAREN;
        int first = input.index();
        if (hasParen) {
            match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        }
        String value = conditionalExpression();
        if (state.failed)
            return null;
        if (hasParen) {
            match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        }
        if (state.backtracking == 0) {
            if (attribute != null) {
                if (hasParen) {
                    value = input.toString(first, input.LT(-1).getTokenIndex());
                }
                attribute.value(value);
                attribute.type(AttributeDescr.Type.EXPRESSION);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr booleanAttribute(AttributeSupportBuilder<?> as, String[] key) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        StringBuilder builder = new StringBuilder();
        for (String k : key) {
            if (""-"".equals(k)) {
                match(input, DRL6Lexer.MINUS, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            } else {
                match(input, DRL6Lexer.ID, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            }
            builder.append(k);
        }
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, builder.toString());
        }
        String value = ""true"";
        if (input.LA(1) == DRL6Lexer.BOOL) {
            Token bool = match(input, DRL6Lexer.BOOL, null, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            value = bool.getText();
        }
        if (state.backtracking == 0) {
            if (attribute != null) {
                attribute.value(value);
                attribute.type(AttributeDescr.Type.BOOLEAN);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr stringAttribute(AttributeSupportBuilder<?> as, String[] key) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        StringBuilder builder = new StringBuilder();
        for (String k : key) {
            if (""-"".equals(k)) {
                match(input, DRL6Lexer.MINUS, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            } else {
                match(input, DRL6Lexer.ID, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            }
            builder.append(k);
        }
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, builder.toString());
        }
        Token value = match(input, DRL6Lexer.STRING, null, null, DroolsEditorType.STRING_CONST);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            if (attribute != null) {
                attribute.value(StringUtils.unescapeJava(safeStripStringDelimiters(value.getText())));
                attribute.type(AttributeDescr.Type.STRING);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr stringListAttribute(AttributeSupportBuilder<?> as, String[] key) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        StringBuilder builder = new StringBuilder();
        for (String k : key) {
            if (""-"".equals(k)) {
                match(input, DRL6Lexer.MINUS, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            } else {
                match(input, DRL6Lexer.ID, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            }
            builder.append(k);
        }
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, builder.toString());
        }
        builder = new StringBuilder();
        builder.append(""[ "");
        Token value = match(input, DRL6Lexer.STRING, null, null, DroolsEditorType.STRING_CONST);
        if (state.failed)
            return null;
        builder.append(value.getText());
        while (input.LA(1) == DRL6Lexer.COMMA) {
            match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
            builder.append("", "");
            value = match(input, DRL6Lexer.STRING, null, null, DroolsEditorType.STRING_CONST);
            if (state.failed)
                return null;
            builder.append(value.getText());
        }
        builder.append("" ]"");
        if (state.backtracking == 0) {
            if (attribute != null) {
                attribute.value(builder.toString());
                attribute.type(AttributeDescr.Type.LIST);
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private AttributeDescr intOrChunkAttribute(AttributeSupportBuilder<?> as, String[] key) throws RecognitionException{
    AttributeDescrBuilder<?> attribute = null;
    try {
        StringBuilder builder = new StringBuilder();
        for (String k : key) {
            if (""-"".equals(k)) {
                match(input, DRL6Lexer.MINUS, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            } else {
                match(input, DRL6Lexer.ID, k, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return null;
            }
            builder.append(k);
        }
        if (state.backtracking == 0) {
            attribute = helper.start((DescrBuilder<?, ?>) as, AttributeDescrBuilder.class, builder.toString());
        }
        if (input.LA(1) == DRL6Lexer.LEFT_PAREN) {
            String value = chunk(DRL6Lexer.LEFT_PAREN, DRL6Lexer.RIGHT_PAREN, -1);
            if (state.failed)
                return null;
            if (state.backtracking == 0) {
                if (attribute != null) {
                    attribute.value(safeStripDelimiters(value, ""("", "")""));
                    attribute.type(AttributeDescr.Type.EXPRESSION);
                }
            }
        } else {
            String value = """";
            if (input.LA(1) == DRL6Lexer.PLUS) {
                Token sign = match(input, DRL6Lexer.PLUS, null, null, DroolsEditorType.NUMERIC_CONST);
                if (state.failed)
                    return null;
                value += sign.getText();
            } else if (input.LA(1) == DRL6Lexer.MINUS) {
                Token sign = match(input, DRL6Lexer.MINUS, null, null, DroolsEditorType.NUMERIC_CONST);
                if (state.failed)
                    return null;
                value += sign.getText();
            }
            Token nbr = match(input, DRL6Lexer.DECIMAL, null, null, DroolsEditorType.NUMERIC_CONST);
            if (state.failed)
                return null;
            value += nbr.getText();
            if (state.backtracking == 0) {
                if (attribute != null) {
                    attribute.value(value);
                    attribute.type(AttributeDescr.Type.NUMBER);
                }
            }
        }
    } finally {
        if (attribute != null) {
            helper.end(AttributeDescrBuilder.class, attribute);
        }
    }
    return attribute != null ? attribute.getDescr() : null;
}",java:S3776,39
"private BaseDescr lhsOr(final CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    BaseDescr result = null;
    if (allowOr && input.LA(1) == DRL6Lexer.LEFT_PAREN && helper.validateLT(2, DroolsSoftKeywords.OR)) {
        CEDescrBuilder<?, OrDescr> or = null;
        if (state.backtracking == 0) {
            or = ce.or();
            result = or.getDescr();
            helper.start(or, CEDescrBuilder.class, null);
        }
        try {
            match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.OR, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            if (state.backtracking == 0) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);
            }
            while (input.LA(1) != DRL6Lexer.RIGHT_PAREN) {
                lhsAnd(or, allowOr);
                if (state.failed)
                    return null;
            }
            match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        } finally {
            if (state.backtracking == 0) {
                helper.end(CEDescrBuilder.class, or);
            }
        }
    } else {
        CEDescrBuilder<?, OrDescr> or = null;
        if (state.backtracking == 0) {
            or = ce.or();
            result = or.getDescr();
            helper.start(or, CEDescrBuilder.class, null);
        }
        try {
            lhsAnd(or, allowOr);
            if (state.failed)
                return null;
            if (allowOr && (helper.validateIdentifierKey(DroolsSoftKeywords.OR) || input.LA(1) == DRL6Lexer.DOUBLE_PIPE)) {
                while (helper.validateIdentifierKey(DroolsSoftKeywords.OR) || input.LA(1) == DRL6Lexer.DOUBLE_PIPE) {
                    if (input.LA(1) == DRL6Lexer.DOUBLE_PIPE) {
                        match(input, DRL6Lexer.DOUBLE_PIPE, null, null, DroolsEditorType.SYMBOL);
                    } else {
                        match(input, DRL6Lexer.ID, DroolsSoftKeywords.OR, null, DroolsEditorType.KEYWORD);
                    }
                    if (state.failed)
                        return null;
                    if (state.backtracking == 0) {
                        helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);
                    }
                    lhsAnd(or, allowOr);
                    if (state.failed)
                        return null;
                }
            } else if (allowOr) {
                if (state.backtracking == 0) {
                    ((ConditionalElementDescr) ce.getDescr()).getDescrs().remove(or.getDescr());
                    for (BaseDescr base : or.getDescr().getDescrs()) {
                        ((ConditionalElementDescr) ce.getDescr()).addDescr(base);
                    }
                    result = ce.getDescr();
                }
            }
        } finally {
            if (state.backtracking == 0) {
                helper.end(CEDescrBuilder.class, or);
            }
        }
    }
    return result;
}",java:S3776,39
"private BaseDescr lhsAnd(final CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    BaseDescr result = null;
    if (input.LA(1) == DRL6Lexer.LEFT_PAREN && helper.validateLT(2, DroolsSoftKeywords.AND)) {
        CEDescrBuilder<?, AndDescr> and = null;
        if (state.backtracking == 0) {
            and = ce.and();
            result = ce.getDescr();
            helper.start(and, CEDescrBuilder.class, null);
        }
        try {
            match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.AND, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            if (state.backtracking == 0) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);
            }
            while (input.LA(1) != DRL6Lexer.RIGHT_PAREN) {
                lhsUnary(and, allowOr);
                if (state.failed)
                    return null;
            }
            match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        } finally {
            if (state.backtracking == 0) {
                helper.end(CEDescrBuilder.class, and);
            }
        }
    } else {
        CEDescrBuilder<?, AndDescr> and = null;
        if (state.backtracking == 0) {
            and = ce.and();
            result = and.getDescr();
            helper.start(and, CEDescrBuilder.class, null);
        }
        try {
            lhsUnary(and, allowOr);
            if (state.failed)
                return null;
            if (helper.validateIdentifierKey(DroolsSoftKeywords.AND) || input.LA(1) == DRL6Lexer.DOUBLE_AMPER) {
                while (helper.validateIdentifierKey(DroolsSoftKeywords.AND) || input.LA(1) == DRL6Lexer.DOUBLE_AMPER) {
                    if (input.LA(1) == DRL6Lexer.DOUBLE_AMPER) {
                        match(input, DRL6Lexer.DOUBLE_AMPER, null, null, DroolsEditorType.SYMBOL);
                    } else {
                        match(input, DRL6Lexer.ID, DroolsSoftKeywords.AND, null, DroolsEditorType.KEYWORD);
                    }
                    if (state.failed)
                        return null;
                    if (state.backtracking == 0) {
                        helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);
                    }
                    lhsUnary(and, allowOr);
                    if (state.failed)
                        return null;
                }
            } else {
                if (state.backtracking == 0 && and.getDescr().getDescrs().size() < 2) {
                    ((ConditionalElementDescr) ce.getDescr()).getDescrs().remove(and.getDescr());
                    for (BaseDescr base : and.getDescr().getDescrs()) {
                        ((ConditionalElementDescr) ce.getDescr()).addDescr(base);
                    }
                    result = ce.getDescr();
                }
            }
        } finally {
            if (state.backtracking == 0) {
                helper.end(CEDescrBuilder.class, and);
            }
        }
    }
    return result;
}",java:S3776,39
"private BaseDescr lhsUnary(final CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    annotations();
    BaseDescr result = null;
    if (helper.validateIdentifierKey(DroolsSoftKeywords.EXISTS)) {
        result = lhsExists(ce, allowOr);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
            namedConsequence(ce, null);
        }
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.NOT)) {
        result = lhsNot(ce, allowOr);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
            namedConsequence(ce, null);
        }
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.EVAL)) {
        result = lhsEval(ce);
        for (BaseDescr i = consequenceInvocation(ce); i != null; i = consequenceInvocation(ce)) ;
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.FORALL)) {
        result = lhsForall(ce);
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.ACCUMULATE) || helper.validateIdentifierKey(DroolsSoftKeywords.ACC)) {
        result = lhsAccumulate(ce);
    } else if (input.LA(1) == DRL6Lexer.LEFT_PAREN) {
        result = lhsParen(ce, allowOr);
        if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
            namedConsequence(ce, null);
        }
    } else if (input.LA(1) == DRL6Lexer.ID || input.LA(1) == DRL6Lexer.QUESTION) {
        result = lhsPatternBind(ce, allowOr);
        for (BaseDescr i = consequenceInvocation(ce); i != null; i = consequenceInvocation(ce)) ;
    } else {
        failMismatchedTokenException();
    }
    if (input.LA(1) == DRL6Lexer.SEMICOLON) {
        match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return null;
    }
    setAnnotationsOn(result);
    return result;
}",java:S3776,39
"private BaseDescr conditionalBranch(CEDescrBuilder<?, ?> ce, ConditionalBranchDescrBuilder<?> conditionalBranch) throws RecognitionException{
    if (conditionalBranch == null) {
        conditionalBranch = helper.start(ce, ConditionalBranchDescrBuilder.class, null);
    }
    try {
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.IF, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        EvalDescrBuilder<?> eval = conditionalBranch.condition();
        if (!parseEvalExpression(eval))
            return null;
        if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
            if (namedConsequence(null, conditionalBranch.consequence()) == null)
                return null;
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.BREAK)) {
            if (breakingNamedConsequence(null, conditionalBranch.consequence()) == null)
                return null;
        } else {
            return null;
        }
        if (helper.validateIdentifierKey(DroolsSoftKeywords.ELSE)) {
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.ELSE, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return null;
            ConditionalBranchDescrBuilder<?> elseBranch = conditionalBranch.otherwise();
            if (helper.validateIdentifierKey(DroolsSoftKeywords.DO)) {
                if (namedConsequence(null, elseBranch.consequence()) == null)
                    return null;
            } else if (helper.validateIdentifierKey(DroolsSoftKeywords.BREAK)) {
                if (breakingNamedConsequence(null, elseBranch.consequence()) == null)
                    return null;
            } else if (helper.validateIdentifierKey(DroolsSoftKeywords.IF)) {
                if (conditionalBranch(null, elseBranch) == null)
                    return null;
            } else {
                return null;
            }
        }
    } finally {
        helper.end(ConditionalBranchDescrBuilder.class, conditionalBranch);
    }
    return conditionalBranch.getDescr();
}",java:S3776,39
"protected BaseDescr lhsExists(CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    CEDescrBuilder<?, ExistsDescr> exists = null;
    if (state.backtracking == 0) {
        exists = ce.exists();
        helper.start(exists, CEDescrBuilder.class, null);
    }
    try {
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.EXISTS, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_EXISTS);
        }
        if (input.LA(1) == DRL6Lexer.LEFT_PAREN) {
            boolean prefixed = helper.validateLT(2, DroolsSoftKeywords.AND) || helper.validateLT(2, DroolsSoftKeywords.OR);
            if (!prefixed) {
                match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
            lhsOr(exists, allowOr);
            if (state.failed)
                return null;
            if (!prefixed) {
                match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
        } else {
            lhsPatternBind(exists, true);
            if (state.failed)
                return null;
        }
    } finally {
        if (state.backtracking == 0) {
            helper.end(CEDescrBuilder.class, exists);
        }
    }
    return exists != null ? exists.getDescr() : null;
}",java:S3776,39
"protected BaseDescr lhsNot(CEDescrBuilder<?, ?> ce, boolean allowOr) throws RecognitionException{
    CEDescrBuilder<?, NotDescr> not = null;
    if (state.backtracking == 0) {
        not = ce.not();
        helper.start(not, CEDescrBuilder.class, null);
    }
    try {
        match(input, DRL6Lexer.ID, DroolsSoftKeywords.NOT, null, DroolsEditorType.KEYWORD);
        if (state.failed)
            return null;
        if (state.backtracking == 0) {
            helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_NOT);
        }
        if (input.LA(1) == DRL6Lexer.LEFT_PAREN) {
            boolean prefixed = helper.validateLT(2, DroolsSoftKeywords.AND) || helper.validateLT(2, DroolsSoftKeywords.OR);
            if (!prefixed) {
                match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
            if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
            }
            lhsOr(not, allowOr);
            if (state.failed)
                return null;
            if (!prefixed) {
                match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
        } else if (input.LA(1) != DRL6Lexer.EOF) {
            lhsPatternBind(not, true);
            if (state.failed)
                return null;
        }
    } finally {
        if (state.backtracking == 0) {
            helper.end(CEDescrBuilder.class, not);
        }
    }
    return not != null ? not.getDescr() : null;
}",java:S3776,39
"private BaseDescr lhsAccumulate(PatternContainerDescrBuilder<?, ?> ce) throws RecognitionException{
    PatternDescrBuilder<?> pattern;
    BaseDescr result = null;
    pattern = helper.start((DescrBuilder<?, ?>) ce, PatternDescrBuilder.class, null);
    if (pattern != null) {
        result = pattern.getDescr();
    }
    try {
        if (state.backtracking == 0) {
            pattern.type(""Object[]"");
            pattern.isQuery(false);
        }
        AccumulateDescrBuilder<?> accumulate = helper.start(pattern, AccumulateDescrBuilder.class, null);
        try {
            if (helper.validateIdentifierKey(DroolsSoftKeywords.ACCUMULATE)) {
                match(input, DRL6Lexer.ID, DroolsSoftKeywords.ACCUMULATE, null, DroolsEditorType.KEYWORD);
            } else {
                match(input, DRL6Lexer.ID, DroolsSoftKeywords.ACC, null, DroolsEditorType.KEYWORD);
            }
            if (state.failed)
                return null;
            if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE);
            }
            match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
            CEDescrBuilder<?, AndDescr> source = accumulate.source();
            try {
                helper.start(source, CEDescrBuilder.class, null);
                lhsAnd(source, false);
                if (state.failed)
                    return null;
                if (source.getDescr() != null && source.getDescr() instanceof ConditionalElementDescr) {
                    ConditionalElementDescr root = source.getDescr();
                    BaseDescr[] descrs = root.getDescrs().toArray(new BaseDescr[root.getDescrs().size()]);
                    root.getDescrs().clear();
                    for (int i = 0; i < descrs.length; i++) {
                        root.addOrMerge(descrs[i]);
                    }
                }
            } finally {
                helper.end(CEDescrBuilder.class, source);
            }
            if (input.LA(1) == DRL6Lexer.COMMA) {
                match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            } else if (input.LA(-1) != DRL6Lexer.SEMICOLON) {
                match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
            }
            accumulateFunctionBinding(accumulate);
            if (state.failed)
                return null;
            while (input.LA(1) == DRL6Lexer.COMMA) {
                match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
                accumulateFunctionBinding(accumulate);
                if (state.failed)
                    return null;
            }
            if (input.LA(1) == DRL6Lexer.SEMICOLON) {
                match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return null;
                constraints(pattern);
            }
            match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return null;
        } finally {
            helper.end(AccumulateDescrBuilder.class, accumulate);
            if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
            }
        }
    } finally {
        helper.end(PatternDescrBuilder.class, pattern);
    }
    if (input.LA(1) == DRL6Lexer.SEMICOLON) {
        match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return null;
    }
    return result;
}",java:S3776,39
" void lhsPattern(PatternDescrBuilder<?> pattern, String label, boolean isUnification) throws RecognitionException{
    if (label != null && input.LA(1) == DRL6Lexer.DIV) {
        int first = input.index();
        exprParser.xpathPrimary();
        if (state.failed)
            return;
        int last = input.LT(-1).getTokenIndex();
        String expr = toExpression("""", first, last);
        pattern.id(label, isUnification).constraint(expr);
        return;
    }
    boolean query = false;
    if (input.LA(1) == DRL6Lexer.QUESTION) {
        match(input, DRL6Lexer.QUESTION, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return;
        query = true;
    }
    String type = this.qualifiedIdentifier();
    if (state.failed)
        return;
    if (state.backtracking == 0) {
        pattern.type(type);
        pattern.isQuery(query);
        if (label != null) {
            pattern.id(label, isUnification);
        }
    }
    match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
    if (state.failed)
        return;
    if (input.LA(1) != DRL6Lexer.RIGHT_PAREN && speculatePositionalConstraints()) {
        positionalConstraints(pattern);
    }
    if (input.LA(1) != DRL6Lexer.RIGHT_PAREN) {
        constraints(pattern);
    }
    match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
    if (state.failed)
        return;
    if (helper.validateIdentifierKey(DroolsSoftKeywords.OVER)) {
        patternFilter(pattern);
    }
    if (helper.validateIdentifierKey(DroolsSoftKeywords.FROM)) {
        patternSource(pattern);
    }
    if (state.backtracking == 0) {
        helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
    }
}",java:S3776,39
"private void constraint(PatternDescrBuilder<?> pattern, boolean positional, String prefix) throws RecognitionException{
    if (speculateNestedConstraint()) {
        nestedConstraint(pattern, prefix);
        return;
    }
    if (state.backtracking == 0) {
        helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_START);
    }
    int first = input.index();
    exprParser.getHelper().setHasOperator(false);
    try {
        exprParser.conditionalOrExpression();
    } finally {
        if (state.backtracking == 0) {
            if (input.LA(1) == DRL6Lexer.ID && input.LA(2) == DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_ARGUMENT);
            } else if (input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_END);
            } else if (!lastTokenWasWhiteSpace()) {
                int location = getCurrentLocation();
                if (location == Location.LOCATION_LHS_INSIDE_CONDITION_END) {
                    helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_ARGUMENT);
                } else if (input.get(input.index()).getType() != DRL6Lexer.EOF) {
                    helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_START);
                }
            } else if (getCurrentLocation() == Location.LOCATION_LHS_INSIDE_CONDITION_START && !exprParser.getHelper().getHasOperator() && lastTokenWasWhiteSpace() && input.LA(1) == DRL6Lexer.EOF && input.LA(-1) == DRL6Lexer.ID) {
                helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_OPERATOR);
            }
        }
    }
    if (state.failed)
        return;
    if (state.backtracking == 0 && input.index() > first) {
        int last = input.LT(-1).getTokenIndex();
        String expr = toExpression(prefix, first, last);
        pattern.constraint(expr, positional);
        BaseDescr constrDescr = pattern.getDescr().getDescrs().get(pattern.getDescr().getDescrs().size() - 1);
        constrDescr.setLocation(input.get(first).getLine(), input.get(first).getCharPositionInLine());
        constrDescr.setEndLocation(input.get(last).getLine(), input.get(last).getCharPositionInLine());
        constrDescr.setStartCharacter(((CommonToken) input.get(first)).getStartIndex());
        constrDescr.setEndCharacter(((CommonToken) input.get(last)).getStopIndex());
    }
}",java:S3776,39
"private boolean speculateNestedConstraint() throws RecognitionException{
    return getNestedConstraintPrefixLenght() > 0;
}",java:S1130,7
"private void patternSource(PatternDescrBuilder<?> pattern) throws RecognitionException{
    match(input, DRL6Lexer.ID, DroolsSoftKeywords.FROM, null, DroolsEditorType.KEYWORD);
    if (state.failed)
        return;
    if (state.backtracking == 0) {
        helper.emit(Location.LOCATION_LHS_FROM);
    }
    if (helper.validateIdentifierKey(DroolsSoftKeywords.ACCUMULATE) || helper.validateIdentifierKey(DroolsSoftKeywords.ACC)) {
        fromAccumulate(pattern);
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.COLLECT)) {
        fromCollect(pattern);
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.ENTRY) && helper.validateLT(2, ""-"") && helper.validateLT(3, DroolsSoftKeywords.POINT)) {
        fromEntryPoint(pattern);
        if (state.failed)
            return;
    } else if (helper.validateIdentifierKey(DroolsSoftKeywords.WINDOW)) {
        fromWindow(pattern);
    } else {
        fromExpression(pattern);
        if (!lastTokenWasWhiteSpace() && input.LA(1) == DRL6Lexer.EOF) {
            helper.emit(Location.LOCATION_LHS_FROM);
            throw new RecognitionException();
        }
        if (state.failed)
            return;
    }
    if (input.LA(1) == DRL6Lexer.SEMICOLON) {
        match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return;
    }
}",java:S3776,39
"private void fromAccumulate(PatternDescrBuilder<?> pattern) throws RecognitionException{
    AccumulateDescrBuilder<?> accumulate = helper.start(pattern, AccumulateDescrBuilder.class, null);
    try {
        if (helper.validateIdentifierKey(DroolsSoftKeywords.ACCUMULATE)) {
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.ACCUMULATE, null, DroolsEditorType.KEYWORD);
        } else {
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.ACC, null, DroolsEditorType.KEYWORD);
        }
        if (state.failed)
            return;
        if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
            helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE);
        }
        match(input, DRL6Lexer.LEFT_PAREN, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return;
        CEDescrBuilder<?, AndDescr> source = accumulate.source();
        try {
            helper.start(source, CEDescrBuilder.class, null);
            lhsAnd(source, false);
            if (state.failed)
                return;
            if (source.getDescr() != null && source.getDescr() instanceof ConditionalElementDescr) {
                ConditionalElementDescr root = source.getDescr();
                BaseDescr[] descrs = root.getDescrs().toArray(new BaseDescr[root.getDescrs().size()]);
                root.getDescrs().clear();
                for (int i = 0; i < descrs.length; i++) {
                    root.addOrMerge(descrs[i]);
                }
            }
        } finally {
            helper.end(CEDescrBuilder.class, source);
        }
        if (input.LA(1) == DRL6Lexer.COMMA) {
            match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
        } else if (input.LA(-1) != DRL6Lexer.SEMICOLON) {
            match(input, DRL6Lexer.SEMICOLON, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
        }
        if (helper.validateIdentifierKey(DroolsSoftKeywords.INIT)) {
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.INIT, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return;
            if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_INIT);
            }
            String init = chunk(DRL6Lexer.LEFT_PAREN, DRL6Lexer.RIGHT_PAREN, Location.LOCATION_LHS_FROM_ACCUMULATE_INIT_INSIDE);
            if (state.failed)
                return;
            if (state.backtracking == 0)
                accumulate.init(init);
            if (input.LA(1) == DRL6Lexer.COMMA) {
                match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return;
            }
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.ACTION, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return;
            if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_ACTION);
            }
            String action = chunk(DRL6Lexer.LEFT_PAREN, DRL6Lexer.RIGHT_PAREN, Location.LOCATION_LHS_FROM_ACCUMULATE_ACTION_INSIDE);
            if (state.failed)
                return;
            if (state.backtracking == 0)
                accumulate.action(action);
            if (input.LA(1) == DRL6Lexer.COMMA) {
                match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return;
            }
            if (helper.validateIdentifierKey(DroolsSoftKeywords.REVERSE)) {
                match(input, DRL6Lexer.ID, DroolsSoftKeywords.REVERSE, null, DroolsEditorType.KEYWORD);
                if (state.failed)
                    return;
                if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                    helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_REVERSE);
                }
                String reverse = chunk(DRL6Lexer.LEFT_PAREN, DRL6Lexer.RIGHT_PAREN, Location.LOCATION_LHS_FROM_ACCUMULATE_REVERSE_INSIDE);
                if (state.failed)
                    return;
                if (state.backtracking == 0)
                    accumulate.reverse(reverse);
                if (input.LA(1) == DRL6Lexer.COMMA) {
                    match(input, DRL6Lexer.COMMA, null, null, DroolsEditorType.SYMBOL);
                    if (state.failed)
                        return;
                }
            }
            match(input, DRL6Lexer.ID, DroolsSoftKeywords.RESULT, null, DroolsEditorType.KEYWORD);
            if (state.failed)
                return;
            if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
                helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_RESULT);
            }
            String result = chunk(DRL6Lexer.LEFT_PAREN, DRL6Lexer.RIGHT_PAREN, Location.LOCATION_LHS_FROM_ACCUMULATE_RESULT_INSIDE);
            if (state.failed)
                return;
            if (state.backtracking == 0)
                accumulate.result(result);
        } else {
            accumulateFunction(accumulate, false, null);
            if (state.failed)
                return;
        }
        match(input, DRL6Lexer.RIGHT_PAREN, null, null, DroolsEditorType.SYMBOL);
        if (state.failed)
            return;
    } finally {
        helper.end(AccumulateDescrBuilder.class, accumulate);
        if (state.backtracking == 0 && input.LA(1) != DRL6Lexer.EOF) {
            helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
        }
    }
}",java:S3776,39
"protected String getConsequenceCode(int first){
    while (input.LA(1) != DRL6Lexer.EOF) {
        if (helper.validateIdentifierKey(DroolsSoftKeywords.END)) {
            int next = input.LA(2) == DRL6Lexer.SEMICOLON ? 3 : 2;
            if (input.LA(next) == DRL6Lexer.EOF || input.LA(next) == DRL6Lexer.AT || helper.validateStatement(next)) {
                break;
            }
        } else if (helper.validateIdentifierKey(DroolsSoftKeywords.THEN)) {
            if (isNextTokenThenCompatible(input.LA(2))) {
                break;
            }
        }
        helper.emit(input.LT(1), DroolsEditorType.CODE_CHUNK);
        input.consume();
    }
    int last = input.LT(1).getTokenIndex();
    if (last <= first) {
        return """";
    }
    String chunk = input.toString(first, last);
    if (chunk.endsWith(DroolsSoftKeywords.END)) {
        chunk = chunk.substring(0, chunk.length() - DroolsSoftKeywords.END.length());
    } else if (chunk.endsWith(DroolsSoftKeywords.THEN)) {
        chunk = chunk.substring(0, chunk.length() - DroolsSoftKeywords.THEN.length());
    }
    return chunk;
}",java:S3776,39
" void annotation(AnnotatedDescrBuilder<?> adb){
    AnnotationDescrBuilder<?> annotation = null;
    try {
        if (speculateFullAnnotation()) {
            boolean buildState = exprParser.isBuildDescr();
            exprParser.setBuildDescr(true);
            exprParser.fullAnnotation(adb);
            exprParser.setBuildDescr(buildState);
        } else {
            Token at = match(input, DRL6Lexer.AT, null, null, DroolsEditorType.SYMBOL);
            if (state.failed)
                return;
            String fqn = qualifiedIdentifier();
            if (state.failed)
                return;
            if (state.backtracking == 0) {
                annotation = adb.newAnnotation(fqn);
                helper.setStart(annotation, at);
            }
            try {
                if (input.LA(1) == DRL6Lexer.LEFT_PAREN) {
                    String value = chunk(DRL6Lexer.LEFT_PAREN, DRL6Lexer.RIGHT_PAREN, -1).trim();
                    if (state.failed)
                        return;
                    if (state.backtracking == 0) {
                        if (annotation != null) {
                            annotation.value(value);
                        } else {
                            throw new RecognitionException();
                        }
                    }
                }
            } finally {
                if (state.backtracking == 0) {
                    helper.setEnd(annotation);
                }
            }
        }
    } catch (RecognitionException re) {
        reportError(re);
    }
}",java:S3776,39
"public String type() throws RecognitionException{
    String type = """";
    try {
        int first = input.index(), last = first;
        match(input, DRL6Lexer.ID, null, new int[] { DRL6Lexer.DOT, DRL6Lexer.LESS }, DroolsEditorType.IDENTIFIER);
        if (state.failed)
            return type;
        if (input.LA(1) == DRL6Lexer.LESS) {
            typeArguments();
            if (state.failed)
                return type;
        }
        while (input.LA(1) == DRL6Lexer.DOT && input.LA(2) == DRL6Lexer.ID) {
            match(input, DRL6Lexer.DOT, null, new int[] { DRL6Lexer.ID }, DroolsEditorType.IDENTIFIER);
            if (state.failed)
                return type;
            match(input, DRL6Lexer.ID, null, new int[] { DRL6Lexer.DOT }, DroolsEditorType.IDENTIFIER);
            if (state.failed)
                return type;
            if (input.LA(1) == DRL6Lexer.LESS) {
                typeArguments();
                if (state.failed)
                    return type;
            }
        }
        while (input.LA(1) == DRL6Lexer.LEFT_SQUARE && input.LA(2) == DRL6Lexer.RIGHT_SQUARE) {
            match(input, DRL6Lexer.LEFT_SQUARE, null, new int[] { DRL6Lexer.RIGHT_SQUARE }, DroolsEditorType.IDENTIFIER);
            if (state.failed)
                return type;
            match(input, DRL6Lexer.RIGHT_SQUARE, null, null, DroolsEditorType.IDENTIFIER);
            if (state.failed)
                return type;
        }
        last = input.LT(-1).getTokenIndex();
        type = input.toString(first, last);
        type = type.replace("" "", """");
    } catch (RecognitionException re) {
        reportError(re);
    }
    return type;
}",java:S3776,39
"public String typeArgument() throws RecognitionException{
    String typeArgument = """";
    try {
        int first = input.index(), last = first;
        int next = input.LA(1);
        switch(next) {
            case DRL6Lexer.QUESTION:
                match(input, DRL6Lexer.QUESTION, null, null, DroolsEditorType.SYMBOL);
                if (state.failed)
                    return typeArgument;
                if (helper.validateIdentifierKey(DroolsSoftKeywords.EXTENDS)) {
                    match(input, DRL6Lexer.ID, DroolsSoftKeywords.EXTENDS, null, DroolsEditorType.SYMBOL);
                    if (state.failed)
                        return typeArgument;
                    type();
                    if (state.failed)
                        return typeArgument;
                } else if (helper.validateIdentifierKey(DroolsSoftKeywords.SUPER)) {
                    match(input, DRL6Lexer.ID, DroolsSoftKeywords.SUPER, null, DroolsEditorType.SYMBOL);
                    if (state.failed)
                        return typeArgument;
                    type();
                    if (state.failed)
                        return typeArgument;
                }
                break;
            case DRL6Lexer.ID:
                type();
                if (state.failed)
                    return typeArgument;
                break;
            default:
        }
        last = input.LT(-1).getTokenIndex();
        typeArgument = input.toString(first, last);
    } catch (RecognitionException re) {
        reportError(re);
    }
    return typeArgument;
}",java:S3776,39
"public boolean mismatchIsMissingToken(TokenStream input, int[] follow){
    if (follow == null) {
        return false;
    }
    return false;
}",java:S3516,37
"public boolean mismatchIsMissingToken(TokenStream input, int[] follow){
    if (follow == null) {
        return false;
    }
    return false;
}",java:S1172,13
"private List<String> createErrorMessage(RecognitionException e){
    List<String> codeAndMessage = new ArrayList<>(2);
    String message;
    if (e instanceof MismatchedTokenException) {
        MismatchedTokenException mte = (MismatchedTokenException) e;
        String expecting = mte instanceof DroolsMismatchedTokenException ? ((DroolsMismatchedTokenException) mte).getTokenText() : getBetterToken(mte.expecting);
        if (tokenNames != null && mte.expecting >= 0 && mte.expecting < tokenNames.length) {
            message = String.format(MISMATCHED_TOKEN_MESSAGE_COMPLETE, e.line, e.charPositionInLine, getBetterToken(e.token), expecting, formatParserLocation());
            codeAndMessage.add(message);
            codeAndMessage.add(""ERR 102"");
        } else {
            message = String.format(MISMATCHED_TOKEN_MESSAGE_PART, e.line, e.charPositionInLine, getBetterToken(e.token), formatParserLocation());
            codeAndMessage.add(message);
            codeAndMessage.add(""ERR 102"");
        }
    } else if (e instanceof MismatchedTreeNodeException) {
        MismatchedTreeNodeException mtne = (MismatchedTreeNodeException) e;
        if (mtne.expecting >= 0 && mtne.expecting < tokenNames.length) {
            message = String.format(MISMATCHED_TREE_NODE_MESSAGE_COMPLETE, e.line, e.charPositionInLine, getBetterToken(e.token), getBetterToken(mtne.expecting), formatParserLocation());
            codeAndMessage.add(message);
            codeAndMessage.add(""ERR 106"");
        } else {
            message = String.format(MISMATCHED_TREE_NODE_MESSAGE_PART, e.line, e.charPositionInLine, getBetterToken(e.token), formatParserLocation());
            codeAndMessage.add(message);
            codeAndMessage.add(""ERR 106"");
        }
    } else if (e instanceof NoViableAltException) {
        message = String.format(NO_VIABLE_ALT_MESSAGE, e.line, e.charPositionInLine, getBetterToken(e.token), formatParserLocation());
        codeAndMessage.add(message);
        codeAndMessage.add(""ERR 101"");
    } else if (e instanceof EarlyExitException) {
        message = String.format(EARLY_EXIT_MESSAGE, e.line, e.charPositionInLine, getBetterToken(e.token), formatParserLocation());
        codeAndMessage.add(message);
        codeAndMessage.add(""ERR 105"");
    } else if (e instanceof MismatchedSetException) {
        MismatchedSetException mse = (MismatchedSetException) e;
        String expected = expectedTokensAsString(mse.expecting);
        message = String.format(MISMATCHED_SET_MESSAGE, e.line, e.charPositionInLine, getBetterToken(e.token), expected, formatParserLocation());
        codeAndMessage.add(message);
        codeAndMessage.add(""ERR 107"");
    } else if (e instanceof DroolsMismatchedSetException) {
        DroolsMismatchedSetException mse = (DroolsMismatchedSetException) e;
        String expected = Arrays.asList(mse.getTokenText()).toString();
        message = String.format(MISMATCHED_SET_MESSAGE, e.line, e.charPositionInLine, getBetterToken(e.token), expected, formatParserLocation());
        codeAndMessage.add(message);
        codeAndMessage.add(""ERR 107"");
    } else if (e instanceof MismatchedNotSetException) {
        MismatchedNotSetException mse = (MismatchedNotSetException) e;
        String expected = expectedTokensAsString(mse.expecting);
        message = String.format(MISMATCHED_NOT_SET_MESSAGE, e.line, e.charPositionInLine, getBetterToken(e.token), expected, formatParserLocation());
        codeAndMessage.add(message);
        codeAndMessage.add(""ERR 108"");
    } else if (e instanceof FailedPredicateException) {
        FailedPredicateException fpe = (FailedPredicateException) e;
        message = String.format(FAILED_PREDICATE_MESSAGE, e.line, e.charPositionInLine, fpe.ruleName, fpe.predicateText, formatParserLocation());
        codeAndMessage.add(message);
        codeAndMessage.add(""ERR 103"");
    }
    if (codeAndMessage.get(0).length() == 0) {
        codeAndMessage.add(""?????"");
    }
    return codeAndMessage;
}",java:S3776,39
"private String formatParserLocation(){
    StringBuilder sb = new StringBuilder();
    if (paraphrases != null) {
        for (Map<DroolsParaphraseTypes, String> map : paraphrases) {
            for (Entry<DroolsParaphraseTypes, String> activeEntry : map.entrySet()) {
                if (activeEntry.getValue().length() == 0) {
                    String kStr = getLocationName(activeEntry.getKey());
                    if (kStr.length() > 0) {
                        sb.append(String.format(PARSER_LOCATION_MESSAGE_PART, kStr));
                    }
                } else {
                    sb.append(String.format(PARSER_LOCATION_MESSAGE_COMPLETE, getLocationName(activeEntry.getKey()), activeEntry.getValue()));
                }
            }
        }
    }
    return sb.toString();
}",java:S3776,39
"public LinkedList getContent(){
    return content;
}",java:S1319,22
"public Tree dupNode(){
    return new DroolsTree(this);
}",java:S1161,11
"public String toString(){
    return this.getMessage();
}",java:S1161,11
"public String getMessage(){
    return this.message;
}",java:S1161,11
"public LinkedList<DroolsSentence> getEditorInterface(){
    return editorInterface;
}",java:S1319,22
"public DroolsToken getLastTokenOnList(LinkedList<?> list){
    DroolsToken lastToken = null;
    for (Object object : list) {
        if (object instanceof DroolsToken) {
            lastToken = (DroolsToken) object;
        }
    }
    return lastToken;
}",java:S1319,22
"public String retrieveLT(int LTNumber){
    if (null == input)
        return null;
    if (null == input.LT(LTNumber))
        return null;
    if (null == input.LT(LTNumber).getText())
        return null;
    return input.LT(LTNumber).getText();
}",java:S117,12
"public boolean validateLT(int LTNumber, String text){
    String text2Validate = retrieveLT(LTNumber);
    return validateText(text, text2Validate);
}",java:S117,12
"public boolean validateAttribute(int index){
    String text2Validate = retrieveLT(index);
    return validateText(text2Validate, DroolsSoftKeywords.SALIENCE) || validateText(text2Validate, DroolsSoftKeywords.ENABLED) || (validateText(text2Validate, DroolsSoftKeywords.NO) && validateLT(index + 1, ""-"") && validateLT(index + 2, DroolsSoftKeywords.LOOP)) || (validateText(text2Validate, DroolsSoftKeywords.AUTO) && validateLT(index + 1, ""-"") && validateLT(index + 2, DroolsSoftKeywords.FOCUS)) || (validateText(text2Validate, DroolsSoftKeywords.LOCK) && validateLT(index + 1, ""-"") && validateLT(index + 2, DroolsSoftKeywords.ON) && validateLT(index + 3, ""-"") && validateLT(index + 4, DroolsSoftKeywords.ACTIVE)) || (validateText(text2Validate, DroolsSoftKeywords.AGENDA) && validateLT(index + 1, ""-"") && validateLT(index + 2, DroolsSoftKeywords.GROUP)) || (validateText(text2Validate, DroolsSoftKeywords.ACTIVATION) && validateLT(index + 1, ""-"") && validateLT(index + 2, DroolsSoftKeywords.GROUP)) || (validateText(text2Validate, DroolsSoftKeywords.RULEFLOW) && validateLT(index + 1, ""-"") && validateLT(index + 2, DroolsSoftKeywords.GROUP)) || (validateText(text2Validate, DroolsSoftKeywords.DATE) && validateLT(index + 1, ""-"") && validateLT(index + 2, DroolsSoftKeywords.EFFECTIVE)) || (validateText(text2Validate, DroolsSoftKeywords.DATE) && validateLT(index + 1, ""-"") && validateLT(index + 2, DroolsSoftKeywords.EXPIRES)) || validateText(text2Validate, DroolsSoftKeywords.DIALECT) || validateText(text2Validate, DroolsSoftKeywords.CALENDARS) || validateText(text2Validate, DroolsSoftKeywords.TIMER) || validateText(text2Validate, DroolsSoftKeywords.DURATION) || validateText(text2Validate, DroolsSoftKeywords.REFRACT) || validateText(text2Validate, DroolsSoftKeywords.DIRECT);
}",java:S3776,39
"public void setValuePattern(String value){
    if (value != null) {
        StringBuilder valuePatternBuffer = new StringBuilder();
        valuePatternBuffer.append(value);
        if (value.endsWith("" "")) {
            valuePatternBuffer.deleteCharAt(valuePatternBuffer.length() - 1);
        }
        String pat = valuePatternBuffer.toString().replaceAll(""\\\\(#|\\{|\\})"", ""$1"").replaceAll(""\\\\n"", ""\n"").replaceAll(""\\\\\\$"", ""\\$"");
        super.setValuePattern(pat);
    }
}",java:S1161,11
"private static int balancedCapture(char[] chars, int start, int end, char type){
    int depth = 1;
    char term = type;
    switch(type) {
        case '[':
            term = ']';
            break;
        case '{':
            term = '}';
            break;
        case '(':
            term = ')';
            break;
    }
    if (type == term) {
        for (start++; start < end; start++) {
            if (chars[start] == type) {
                return start;
            }
        }
    } else {
        for (start++; start < end; start++) {
            if (start < end && chars[start] == '/') {
                if (start + 1 == end)
                    return start;
                if (chars[start + 1] == '/') {
                    start++;
                    while (start < end && chars[start] != '\n') start++;
                } else if (chars[start + 1] == '*') {
                    start += 2;
                    SkipComment: while (start < end) {
                        switch(chars[start]) {
                            case '*':
                                if (start + 1 < end && chars[start + 1] == '/') {
                                    break SkipComment;
                                }
                            case '\r':
                            case '\n':
                                break;
                        }
                        start++;
                    }
                }
            }
            if (start == end)
                return start;
            if (chars[start] == '\'' || chars[start] == '""') {
                start = captureStringLiteral(chars[start], chars, start, end);
            } else if (chars[start] == type) {
                depth++;
            } else if (chars[start] == term && --depth == 0) {
                return start;
            }
        }
    }
    switch(type) {
        case '[':
            throw new RuntimeException(""unbalanced braces [ ... ]"");
        case '{':
            throw new RuntimeException(""unbalanced braces { ... }"");
        case '(':
            throw new RuntimeException(""unbalanced braces ( ... )"");
        default:
            throw new RuntimeException(""unterminated string literal"");
    }
}",java:S3776,39
"private String readFile(Reader reader) throws IOException{
    lineLengths = new ArrayList<>();
    lineLengths.add(null);
    LineNumberReader lnr = new LineNumberReader(reader);
    StringBuilder sb = new StringBuilder();
    int nlCount = 0;
    boolean inEntry = false;
    String line;
    while ((line = lnr.readLine()) != null) {
        lineLengths.add(line.length());
        Matcher commentMat = commentPat.matcher(line);
        if (commentMat.matches()) {
            if (inEntry) {
                nlCount++;
            } else {
                sb.append('\n');
            }
            if (""#/"".equals(commentMat.group(2))) {
                String[] options = commentMat.group(1).substring(2).trim().split(""\\s+"");
                Collections.addAll(optionSet, options);
            }
            continue;
        }
        if (entryPat.matcher(line).matches()) {
            if (inEntry) {
                for (int i = 0; i < nlCount; i++) sb.append('\n');
            }
            sb.append(line);
            nlCount = 1;
            inEntry = true;
            continue;
        }
        sb.append(' ').append(line);
        nlCount++;
    }
    if (inEntry)
        sb.append('\n');
    lnr.close();
    return sb.toString();
}",java:S3776,39
"private String applyFunc(String theFunc, String theValue){
    if (theFunc != null) {
        if (""uc"".equals(theFunc)) {
            theValue = theValue.toUpperCase();
        } else if (""lc"".equals(theFunc)) {
            theValue = theValue.toLowerCase();
        } else if (""ucfirst"".equals(theFunc)) {
            Matcher letterMat = letterPat.matcher(theValue);
            if (letterMat.find()) {
                int pos = letterMat.start();
                theValue = theValue.substring(0, pos) + theValue.substring(pos, pos + 1).toUpperCase() + theValue.substring(pos + 1).toLowerCase();
            }
        } else if (theFunc.startsWith(""num"")) {
            String numStr = theValue.replaceAll(""[^-\\d]+"", """");
            try {
                long numLong = Long.parseLong(numStr);
                if (theValue.matches(""^.*[.,]\\d\\d(?:\\D.*|$)"")) {
                    numStr = Long.toString(numLong);
                    theValue = numStr.substring(0, numStr.length() - 2) + '.' + numStr.substring(numStr.length() - 2);
                } else {
                    theValue = Long.toString(numLong);
                }
            } catch (NumberFormatException nfe) {
            }
        } else {
            StringTokenizer strTok = new StringTokenizer(theFunc, ""?/"", true);
            boolean compare = true;
            int toks = strTok.countTokens();
            while (toks >= 4) {
                String key = strTok.nextToken();
                String qmk = strTok.nextToken();
                String val = strTok.nextToken();
                String sep = strTok.nextToken();
                if (key.equals(theValue)) {
                    theValue = val;
                    break;
                }
                toks -= 4;
                if (toks < 4) {
                    theValue = strTok.nextToken();
                    break;
                }
            }
        }
    }
    return theValue;
}",java:S3776,39
"private String substitute(String exp, List<DSLMappingEntry> entries, int line, Map<String, Integer> use, boolean showSingleSteps){
    if (entries.size() == 0) {
        if (line > 0) {
            this.addError(new ExpanderException(""No mapping entries for expanding: "" + exp, line));
        }
        return exp;
    }
    if (showSingleSteps) {
        logger.info(""to expand: |"" + exp + ""|"");
    }
    Map<String, String> key2value = new HashMap<>();
    for (final DSLMappingEntry entry : entries) {
        Map<String, Integer> vars = entry.getVariables();
        String mappingKey = entry.getMappingKey();
        String vp = entry.getValuePattern();
        Pattern kp = entry.getKeyPattern();
        Matcher m = kp.matcher(exp);
        int startPos = 0;
        boolean match;
        Integer count;
        if (showUsage) {
            count = use.get(mappingKey);
            if (count == null)
                use.put(mappingKey, 0);
        }
        while (startPos < exp.length() && m.find(startPos)) {
            match = true;
            if (showSingleSteps) {
                logger.info(""  matches: "" + kp.toString());
            }
            if (showUsage) {
                use.put(mappingKey, use.get(mappingKey) + 1);
            }
            String target = m.group(0);
            if (!vars.keySet().isEmpty()) {
                StringBuilder sb = new StringBuilder();
                String del = ""\\{("";
                for (String key : vars.keySet()) {
                    sb.append(del).append(Pattern.quote(key));
                    del = ""|"";
                }
                sb.append("")"").append(funcPatStr).append(""\\}"");
                Pattern allkeyPat = Pattern.compile(sb.toString());
                vp = entry.getValuePattern();
                Matcher allkeyMat = allkeyPat.matcher(vp);
                while (allkeyMat.find()) {
                    String theKey = allkeyMat.group(1);
                    String theFunc = allkeyMat.group(2);
                    String foundValue = m.group(vars.get(theKey));
                    String theValue = applyFunc(theFunc, foundValue);
                    String newVp = vp.substring(0, allkeyMat.start()) + theValue + vp.substring(allkeyMat.end());
                    allkeyMat.reset(newVp);
                    key2value.put(theKey, foundValue);
                    if (newVp.equals(vp)) {
                        break;
                    } else {
                        vp = newVp;
                    }
                }
            }
            Matcher varRefMat = varRefPat.matcher(vp);
            while (varRefMat.find()) {
                String theKey = varRefMat.group(1);
                String theFunc = varRefMat.group(2);
                for (int ientry = substitutions.size() - 1; ientry >= 0; ientry--) {
                    String foundValue = substitutions.get(ientry).get(theKey);
                    if (foundValue != null) {
                        String theValue = applyFunc(theFunc, foundValue);
                        vp = vp.substring(0, varRefMat.start()) + theValue + vp.substring(varRefMat.end());
                        varRefMat.reset(vp);
                        break;
                    }
                }
            }
            if (key2value.size() > 0) {
                substitutions.add(key2value);
            }
            exp = exp.substring(0, m.start()) + vp + exp.substring(m.end());
            if (match && showSingleSteps) {
                logger.info(""   result: |"" + exp + ""|"");
            }
            startPos = m.start() + vp.length();
            m.reset(exp);
        }
    }
    return exp;
}",java:S3776,39
"protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException{
    return resolveClass(desc.getName());
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    this.accumulator = (Accumulator) in.readObject();
}",java:S1161,11
"private String expandLHS(final String lhs, int lineOffset){
    substitutions = new ArrayList<>();
    final StringBuilder buf = new StringBuilder();
    final String[] lines = lhs.split((lhs.indexOf(""\r\n"") >= 0 ? ""\r\n"" : ""\n""), -1);
    final String[] expanded = new String[lines.length];
    int lastExpanded = -1;
    int lastPattern = -1;
    for (int i = 0; i < lines.length - 1; i++) {
        final String trimmed = lines[i].trim();
        expanded[++lastExpanded] = lines[i];
        if (trimmed.length() == 0 || trimmed.startsWith(""#"") || trimmed.startsWith(""//"")) {
        } else if (trimmed.startsWith("">"")) {
            expanded[lastExpanded] = lines[i].replaceFirst("">"", "" "");
            lastPattern = lastExpanded;
        } else {
            expanded[lastExpanded] = substitute(expanded[lastExpanded], this.condition, i + lineOffset, useWhen, showSteps);
            if (lines[i].equals(expanded[lastExpanded])) {
                this.addError(new ExpanderException(""Unable to expand: "" + lines[i].replaceAll(""[\n\r]"", """").trim(), i + lineOffset));
            }
            if (trimmed.startsWith(""-"") && (!lines[i].equals(expanded[lastExpanded]))) {
                if (lastPattern >= 0) {
                    ConstraintInformation c = ConstraintInformation.findConstraintInformationInPattern(expanded[lastPattern]);
                    if (c.start > -1) {
                        expanded[lastPattern] = expanded[lastPattern].substring(0, c.start) + c.constraints + ((c.constraints.trim().length() == 0) ? """" : "", "") + expanded[lastExpanded].trim() + expanded[lastPattern].substring(c.end);
                    } else {
                        this.addError(new ExpanderException(""No pattern was found to add the constraint to: "" + lines[i].trim(), i + lineOffset));
                    }
                }
                lastExpanded--;
            } else {
                lastPattern = lastExpanded;
            }
        }
    }
    for (int i = 0; i <= lastExpanded; i++) {
        buf.append(expanded[i]);
        buf.append(nl);
    }
    return buf.toString();
}",java:S3776,39
"private String expandRHS(final String lhs, int lineOffset){
    final StringBuilder buf = new StringBuilder();
    final String[] lines = lhs.split((lhs.indexOf(""\r\n"") >= 0 ? ""\r\n"" : ""\n""), -1);
    final String[] expanded = new String[lines.length];
    int lastExpanded = -1;
    int lastPattern = -1;
    for (int i = 0; i < lines.length - 1; i++) {
        final String trimmed = lines[i].trim();
        expanded[++lastExpanded] = lines[i];
        if (trimmed.length() == 0 || trimmed.startsWith(""#"") || trimmed.startsWith(""//"")) {
            buf.append(lines[i]);
        } else if (trimmed.startsWith("">"")) {
            expanded[lastExpanded] = lines[i].replaceFirst("">"", "" "");
        } else {
            expanded[lastExpanded] = substitute(expanded[lastExpanded], this.consequence, i + lineOffset, useThen, showSteps);
            if (lines[i].equals(expanded[lastExpanded])) {
                this.addError(new ExpanderException(""Unable to expand: "" + lines[i], i + lineOffset));
            }
            if (trimmed.startsWith(""-"") && (!lines[i].equals(expanded[lastExpanded]))) {
                int lastMatchStart = -1;
                int lastMatchEnd = -1;
                String modifiers = """";
                if (lastPattern >= 0) {
                    final Matcher m2 = modifyFinder.matcher(expanded[lastPattern]);
                    while (m2.find()) {
                        lastMatchStart = m2.start();
                        lastMatchEnd = m2.end();
                        modifiers = m2.group(1).trim();
                    }
                }
                if (lastMatchStart > -1) {
                    expanded[lastPattern] = expanded[lastPattern].substring(0, lastMatchStart) + ""{ "" + modifiers + ((modifiers.length() == 0) ? """" : "", "") + expanded[lastExpanded].trim() + "" }"" + expanded[lastPattern].substring(lastMatchEnd);
                } else {
                    this.addError(new ExpanderException(""No modify was found to add the modifier to: "" + lines[i].trim(), i + lineOffset));
                }
                lastExpanded--;
            } else {
                lastPattern = lastExpanded;
            }
        }
    }
    for (int i = 0; i <= lastExpanded; i++) {
        buf.append(expanded[i]);
        buf.append(nl);
    }
    if (lines.length == 0) {
        buf.append(nl);
    }
    return buf.toString();
}",java:S3776,39
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    if (CompiledInvoker.isCompiledInvoker(accumulator)) {
        out.writeObject(null);
    } else {
        out.writeObject(accumulator);
    }
}",java:S1161,11
"public SingleAccumulate clone(){
    RuleConditionElement clonedSource = source instanceof GroupElement ? ((GroupElement) source).cloneOnlyGroup() : source.clone();
    SingleAccumulate clone = new SingleAccumulate(clonedSource, this.requiredDeclarations, this.accumulator);
    registerClone(clone);
    return clone;
}",java:S2975,34
"public SingleAccumulate clone(){
    RuleConditionElement clonedSource = source instanceof GroupElement ? ((GroupElement) source).cloneOnlyGroup() : source.clone();
    SingleAccumulate clone = new SingleAccumulate(clonedSource, this.requiredDeclarations, this.accumulator);
    registerClone(clone);
    return clone;
}",java:S1182,14
"public static String dumpDRL(DrlPackage drl) throws Exception{
    Template temp = CONFIGURATION.getTemplate(""drl.ftl"");
    Writer out = new StringWriter();
    temp.process(drl, out);
    String result = out.toString();
    out.close();
    return result;
}",java:S112,4
"public boolean ignoreOptionalProblems(){
    return true;
}",java:S1161,11
"public CompilationResult compile(final String[] pSourceFiles, final ResourceReader pReader, final ResourceStore pStore, final ClassLoader pClassLoader, final JavaCompilerSettings pSettings){
    final Collection problems = new ArrayList();
    final ICompilationUnit[] compilationUnits = new ICompilationUnit[pSourceFiles.length];
    for (int i = 0; i < compilationUnits.length; i++) {
        final PortablePath sourceFile = PortablePath.of(pSourceFiles[i]);
        if (pReader.isAvailable(sourceFile)) {
            compilationUnits[i] = new CompilationUnit(pReader, sourceFile.asString());
        } else {
            final CompilationProblem problem = new CompilationProblem() {

                public int getEndColumn() {
                    return 0;
                }

                public int getEndLine() {
                    return 0;
                }

                public String getFileName() {
                    return sourceFile.asString();
                }

                public String getMessage() {
                    return ""Source "" + sourceFile.asString() + "" could not be found"";
                }

                public int getStartColumn() {
                    return 0;
                }

                public int getStartLine() {
                    return 0;
                }

                public boolean isError() {
                    return true;
                }

                public String toString() {
                    return getMessage();
                }
            };
            problems.add(problem);
        }
    }
    if (problems.size() > 0) {
        final CompilationProblem[] result = new CompilationProblem[problems.size()];
        problems.toArray(result);
        return new CompilationResult(result);
    }
    final IErrorHandlingPolicy policy = DefaultErrorHandlingPolicies.proceedWithAllProblems();
    final IProblemFactory problemFactory = new DefaultProblemFactory(Locale.getDefault());
    final INameEnvironment nameEnvironment = new INameEnvironment() {

        public NameEnvironmentAnswer findType(final char[][] pCompoundTypeName) {
            final StringBuilder result = new StringBuilder();
            for (int i = 0; i < pCompoundTypeName.length; i++) {
                if (i != 0) {
                    result.append('.');
                }
                result.append(pCompoundTypeName[i]);
            }
            return findType(result.toString());
        }

        public NameEnvironmentAnswer findType(final char[] pTypeName, final char[][] pPackageName) {
            final StringBuilder result = new StringBuilder();
            for (char[] chars : pPackageName) {
                result.append(chars);
                result.append('.');
            }
            result.append(pTypeName);
            return findType(result.toString());
        }

        private NameEnvironmentAnswer findType(final String pClazzName) {
            final String resourceName = ClassUtils.convertClassToResourcePath(pClazzName);
            final byte[] clazzBytes = pStore.read(resourceName);
            if (clazzBytes != null) {
                try {
                    return createNameEnvironmentAnswer(pClazzName, clazzBytes);
                } catch (final ClassFormatException e) {
                    throw new RuntimeException(""ClassFormatException in loading class '"" + pClazzName + ""' with JCI."");
                }
            }
            try (InputStream is = pClassLoader.getResourceAsStream(resourceName)) {
                if (is == null) {
                    return null;
                }
                if (ClassUtils.isCaseSenstiveOS()) {
                    try {
                        pClassLoader.loadClass(pClazzName);
                    } catch (ClassNotFoundException | NoClassDefFoundError e) {
                        return null;
                    }
                }
                final byte[] buffer = new byte[8192];
                try (ByteArrayOutputStream baos = new ByteArrayOutputStream(buffer.length)) {
                    int count;
                    while ((count = is.read(buffer, 0, buffer.length)) > 0) {
                        baos.write(buffer, 0, count);
                    }
                    baos.flush();
                    return createNameEnvironmentAnswer(pClazzName, baos.toByteArray());
                }
            } catch (final IOException e) {
                throw new RuntimeException(""could not read class"", e);
            } catch (final ClassFormatException e) {
                throw new RuntimeException(""wrong class format"", e);
            }
        }

        private NameEnvironmentAnswer createNameEnvironmentAnswer(final String pClazzName, final byte[] clazzBytes) throws ClassFormatException {
            final char[] fileName = pClazzName.toCharArray();
            final ClassFileReader classFileReader = new ClassFileReader(clazzBytes, fileName, true);
            return new NameEnvironmentAnswer(classFileReader, null);
        }

        private boolean isSourceAvailable(final String pClazzName, final ResourceReader pReader) {
            final String javaSource = pClazzName.replace('.', '/') + "".java"";
            final String classSource = pClazzName.replace('.', '/') + "".class"";
            return pReader.isAvailable(sourceFolder + javaSource) || pReader.isAvailable(sourceFolder + classSource);
        }

        private boolean isPackage(final String pClazzName) {
            try (InputStream is = pClassLoader.getResourceAsStream(ClassUtils.convertClassToResourcePath(pClazzName))) {
                if (is != null) {
                    if (ClassUtils.isWindows() || ClassUtils.isOSX()) {
                        try {
                            Class cls = pClassLoader.loadClass(pClazzName);
                            if (cls != null) {
                                return false;
                            }
                        } catch (ClassNotFoundException | NoClassDefFoundError e) {
                            return true;
                        }
                    }
                }
                return is == null && !isSourceAvailable(pClazzName, pReader);
            } catch (IOException e) {
                throw new RuntimeException(""Cannot open or close resource stream!"", e);
            }
        }

        public boolean isPackage(char[][] parentPackageName, char[] pPackageName) {
            final StringBuilder result = new StringBuilder();
            if (parentPackageName != null) {
                for (int i = 0; i < parentPackageName.length; i++) {
                    if (i != 0) {
                        result.append('.');
                    }
                    result.append(parentPackageName[i]);
                }
            }
            if (parentPackageName != null && parentPackageName.length > 0) {
                result.append('.');
            }
            result.append(pPackageName);
            return isPackage(result.toString());
        }

        public void cleanup() {
        }
    };
    final ICompilerRequestor compilerRequestor = pResult -> {
        if (pResult.hasProblems()) {
            final IProblem[] iproblems = pResult.getProblems();
            for (final IProblem iproblem : iproblems) {
                final CompilationProblem problem = new EclipseCompilationProblem(iproblem);
                problems.add(problem);
            }
        }
        if (!pResult.hasErrors()) {
            final ClassFile[] clazzFiles = pResult.getClassFiles();
            for (final ClassFile clazzFile : clazzFiles) {
                final char[][] compoundName = clazzFile.getCompoundName();
                final StringBuilder clazzName = new StringBuilder();
                for (int j = 0; j < compoundName.length; j++) {
                    if (j != 0) {
                        clazzName.append('.');
                    }
                    clazzName.append(compoundName[j]);
                }
                pStore.write(clazzName.toString().replace('.', '/') + "".class"", clazzFile.getBytes());
            }
        }
    };
    final Map settingsMap = new EclipseJavaCompilerSettings(pSettings).toNativeSettings();
    CompilerOptions compilerOptions = new CompilerOptions(settingsMap);
    compilerOptions.parseLiteralExpressionsAsConstants = false;
    final Compiler compiler = new Compiler(nameEnvironment, policy, compilerOptions, compilerRequestor, problemFactory);
    if (true) {
        dumpUnits(compilationUnits, pReader);
    }
    compiler.compile(compilationUnits);
    final CompilationProblem[] result = new CompilationProblem[problems.size()];
    problems.toArray(result);
    return new CompilationResult(result);
}",java:S3776,39
"public void cleanup(){
}",java:S1186,16
"private static int get_y(int val){
    return val % MOD_NUM;
}",java:S100,0
"private static int get_x(int val){
    return val / MOD_NUM;
}",java:S100,0
"private static double get_angle(int p1, int p2){
    int delta_x, delta_y;
    double ret = 0.0;
    delta_x = get_x(p2) - get_x(p1);
    delta_y = get_y(p2) - get_y(p1);
    if (delta_x == 0) {
        if (delta_y > 0) {
            ret = PI / 2;
        } else if (delta_y < 0) {
            ret = -PI / 2;
        }
    } else if (delta_y == 0) {
        if (delta_x > 0) {
            ret = 0.0;
        } else if (delta_x < 0) {
            ret = PI;
        }
    } else {
        ret = Math.atan2(delta_y, delta_x);
    }
    return ret;
}",java:S100,0
"private static double inscribed_angle(int basepoint, int p1, int p2){
    double angle1, angle2, temp;
    angle1 = get_angle(basepoint, p1);
    angle2 = get_angle(basepoint, p2);
    temp = angle1 - angle2;
    if (temp < 0.0)
        temp = -temp;
    if (temp > PI)
        temp = 2 * PI - temp;
    if (temp < 0.0)
        return (-temp);
    return (temp);
}",java:S100,0
"public static Junction make_3_junction(int basepoint, int p1, int p2, int p3){
    int shaft, barb1, barb2;
    double angle12, angle13, angle23;
    double sum, sum1213, sum1223, sum1323;
    double delta;
    String j_type;
    angle12 = inscribed_angle(basepoint, p1, p2);
    angle13 = inscribed_angle(basepoint, p1, p3);
    angle23 = inscribed_angle(basepoint, p2, p3);
    sum1213 = angle12 + angle13;
    sum1223 = angle12 + angle23;
    sum1323 = angle13 + angle23;
    if (sum1213 < sum1223) {
        if (sum1213 < sum1323) {
            sum = sum1213;
            shaft = p1;
            barb1 = p2;
            barb2 = p3;
        } else {
            sum = sum1323;
            shaft = p3;
            barb1 = p1;
            barb2 = p2;
        }
    } else {
        if (sum1223 < sum1323) {
            sum = sum1223;
            shaft = p2;
            barb1 = p1;
            barb2 = p3;
        } else {
            sum = sum1323;
            shaft = p3;
            barb1 = p1;
            barb2 = p2;
        }
    }
    delta = sum - PI;
    if (delta < 0.0)
        delta = -delta;
    if (delta < 0.001) {
        j_type = Junction.TEE;
    } else if (sum > PI) {
        j_type = Junction.FORK;
    } else {
        j_type = Junction.ARROW;
    }
    return new Junction(barb1, shaft, barb2, basepoint, j_type);
}",java:S100,0
"public static void main(String[] args) throws Exception{
    KieContainer kc = KieServices.Factory.get().getKieClasspathContainer();
    KieSession ksession = kc.newKieSession(""HouseOfDoomKS"");
    ksession.insert(new Location(""Office"", ""House""));
    ksession.insert(new Location(""Kitchen"", ""House""));
    ksession.insert(new Location(""Knife"", ""Kitchen""));
    ksession.insert(new Location(""Cheese"", ""Kitchen""));
    ksession.insert(new Location(""Desk"", ""Office""));
    ksession.insert(new Location(""Chair"", ""Office""));
    ksession.insert(new Location(""Computer"", ""Desk""));
    ksession.insert(new Location(""Drawer"", ""Desk""));
    ksession.insert(""go1"");
    ksession.fireAllRules();
    System.out.println(""---"");
    ksession.insert(""go2"");
    ksession.fireAllRules();
    System.out.println(""---"");
    ksession.insert(""go3"");
    ksession.fireAllRules();
    System.out.println(""---"");
    ksession.insert(new Location(""Key"", ""Drawer""));
    ksession.fireAllRules();
    System.out.println(""---"");
    ksession.insert(""go4"");
    ksession.fireAllRules();
    System.out.println(""---"");
    ksession.insert(""go5"");
    ksession.fireAllRules();
}",java:S1130,7
"public String toString(){
    return ""AllocatedCashflow["" + ""account="" + account + "",date="" + getDate() + "",type="" + (getType() == CREDIT ? ""Credit"" : ""Debit"") + "",amount="" + getAmount() + ""]"";
}",java:S1161,11
"public String toString(){
    return ""TypedCashflow[date="" + getDate() + "",type="" + (type == CREDIT ? ""Credit"" : ""Debit"") + "",amount="" + getAmount() + ""]"";
}",java:S1161,11
"private static String createRules2(String dialect){
    return """" + ""rule \""r1\""\n"" + ""dialect \"""" + dialect + ""\""\n"" + ""when   t : TransactionC(CurrencyCode == \""USD\"") \n"" + ""then \n"" + ""mo.add(new Outcome(\""r1\"" , t.getTransactionNumber()));\n"" + ""end \n"" + ""rule \""r2\""\n"" + ""dialect \"""" + dialect + ""\""\n"" + ""when   t : TransactionC(CurrencyCode == \""USD\"") \n"" + ""then \n"" + ""mo.add(new Outcome(\""r2\"" , t.getTransactionNumber()));\n"" + ""end \n"" + ""rule \""r3\""\n"" + ""dialect \"""" + dialect + ""\""\n"" + ""when   t : TransactionC(CurrencyCode == \""CAD\"") \n"" + ""then \n"" + ""mo.add(new Outcome(\""r3\"", t.getTransactionNumber()));\n"" + ""end \n"" + ""rule \""r4\""\n"" + ""dialect \"""" + dialect + ""\""\n"" + ""when   t : TransactionC(CurrencyCode == \""USD\"") \n"" + ""then \n"" + ""mo.add(new Outcome(\""r4\"", t.getTransactionNumber()));\n"" + ""end \n"";
}",java:S1144,10
"public void mouseReleased(MouseEvent e){
    JList jlist = (JList) e.getSource();
    tableModel.addItem((Product) jlist.getSelectedValue());
}",java:S1161,11
"public void mouseReleased(MouseEvent e){
    JTable jtable = (JTable) e.getSource();
    TableModel tableModel = (TableModel) jtable.getModel();
    tableModel.removeItem(jtable.getSelectedRow());
}",java:S1161,11
"public void mouseReleased(MouseEvent e){
    JButton button = (JButton) e.getComponent();
    callback.checkout((JFrame) button.getTopLevelAncestor(), tableModel.getItems());
}",java:S1161,11
"public void mouseReleased(MouseEvent e){
    output.setText(null);
    tableModel.clear();
    System.out.println(""------ Reset ------"");
}",java:S1161,11
"public void setValue(Object object){
    Product item = (Product) object;
    setText(item.getName());
}",java:S1161,11
"public void setValue(Object object){
    Product item = (Product) object;
    setText(Double.toString(item.getPrice()));
}",java:S1161,11
"public String getColumnName(int col){
    return columnNames[col];
}",java:S1161,11
"public Class<?> getColumnClass(int c){
    return Product.class;
}",java:S1161,11
"public void consistencyCheck(){
    for (int iRow = 0; iRow < 9; iRow++) {
        for (int iCol = 0; iCol < 9; iCol++) {
            Cell cell = cells[iRow][iCol];
            Integer value = cell.getValue();
            if (value != null) {
                if (!cell.getFree().isEmpty()) {
                    throw new IllegalStateException(""free not empty"");
                }
                for (Cell other : cell.getExCells()) {
                    if (value.equals(other.getValue())) {
                        throw new IllegalStateException(""duplicate"");
                    }
                    if (other.getFree().contains(value)) {
                        throw new IllegalStateException(""not eliminated"");
                    }
                }
            }
        }
    }
    for (int i = 0; i < rows.length; i++) {
        Set<Integer> aSet = new HashSet<>();
        for (int j = 0; j < rows[i].getCells().size(); j++) {
            Cell cell = rows[i].getCells().get(j);
            Integer value = cell.getValue();
            if (value != null) {
                aSet.add(value);
            } else {
                aSet.addAll(cell.getFree());
            }
        }
        if (!aSet.equals(CellGroup.ALL_NINE)) {
            throw new IllegalStateException(""deficit in row"");
        }
    }
    for (int i = 0; i < cols.length; i++) {
        Set<Integer> aSet = new HashSet<>();
        for (int j = 0; j < cols[i].getCells().size(); j++) {
            Cell cell = cols[i].getCells().get(j);
            Integer value = cell.getValue();
            if (value != null) {
                aSet.add(value);
            } else {
                aSet.addAll(cell.getFree());
            }
        }
        if (!aSet.equals(CellGroup.ALL_NINE)) {
            throw new IllegalStateException(""deficit in column"");
        }
    }
    for (int ir = 0; ir < sqrs.length; ir++) {
        for (int ic = 0; ic < sqrs[ir].length; ic++) {
            Set<Integer> aSet = new HashSet<>();
            for (int j = 0; j < sqrs[ir][ic].getCells().size(); j++) {
                Cell cell = sqrs[ir][ic].getCells().get(j);
                Integer value = cell.getValue();
                if (value != null) {
                    aSet.add(value);
                } else {
                    aSet.addAll(cell.getFree());
                }
            }
            if (!aSet.equals(CellGroup.ALL_NINE)) {
                throw new IllegalStateException(""deficit in square"");
            }
        }
    }
    System.out.println(""+++ check OK +++"");
}",java:S3776,39
"public void objectDeleted(ObjectDeletedEvent ev){
}",java:S1186,16
"public void actionPerformed(ActionEvent ev){
    if (ev.getSource().equals(solveButton)) {
        sudoku.solve();
        buttonsActive(false);
        if (!sudoku.isSolved()) {
            sudoku.dumpGrid();
            System.out.println(""Sorry - can't solve this grid."");
        }
    } else if (ev.getSource().equals(stepButton)) {
        sudoku.step();
        if (sudoku.isSolved() || sudoku.isUnsolvable())
            buttonsActive(false);
        if (sudoku.isUnsolvable()) {
            sudoku.dumpGrid();
            System.out.println(""Sorry - can't solve this grid."");
        }
    } else if (ev.getSource().equals(dumpButton)) {
        sudoku.dumpGrid();
    } else if (ev.getSource().equals(openMenuItem)) {
        if (fileChooser == null) {
            fileChooser = new JFileChooser();
        }
        try {
            if (fileChooser.showOpenDialog(mainFrame) == JFileChooser.APPROVE_OPTION) {
                String path = fileChooser.getSelectedFile().getCanonicalPath();
                System.out.println(path);
                runFile(path);
                buttonsActive(true);
            }
        } catch (IOException ex) {
            LOG.error(""Exception"", ex);
        }
    } else if (ev.getSource().equals(exitMenuItem)) {
        if (mainFrame.getDefaultCloseOperation() == WindowConstants.EXIT_ON_CLOSE) {
            System.exit(0);
        } else {
            mainFrame.dispose();
        }
    } else if (ev.getSource() instanceof JMenuItem) {
        JMenuItem menuItem = (JMenuItem) ev.getSource();
        Integer[][] sample = SudokuGridSamples.getInstance().getSample(menuItem.getText());
        sudoku.setCellValues(sample);
        sudoku.validate();
        buttonsActive(true);
    }
}",java:S3776,39
"public Method getNativeReadMethod(){
    try {
        return this.getClass().getDeclaredMethod(""getValue"", ValueResolver.class, Object.class);
    } catch (final Exception e) {
        throw new RuntimeException(""This is a bug. Please report to development team: "" + e.getMessage(), e);
    }
}",java:S1161,11
"public void keyTyped(KeyEvent e){
}",java:S1161,11
"public void keyPressed(KeyEvent e){
    this.keyPressedEntryPoint.insert(e);
}",java:S1161,11
"public String getNativeReadMethodName(){
    return ""getValue"";
}",java:S1161,11
"public void keyReleased(KeyEvent e){
    this.keyReleasedEntryPoint.insert(e);
}",java:S1161,11
"public void mouseReleased(MouseEvent e){
}",java:S1186,16
"public void mousePressed(MouseEvent e){
}",java:S1186,16
"public void mouseExited(MouseEvent e){
}",java:S1186,16
"public void mouseEntered(MouseEvent e){
}",java:S1186,16
"public int hashCode(){
    return this.objectType.hashCode();
}",java:S1161,11
"public boolean equals(final Object obj){
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof GlobalExtractor)) {
        return false;
    }
    final GlobalExtractor other = (GlobalExtractor) obj;
    return this.objectType.equals(other.objectType);
}",java:S1161,11
"public void mouseReleased(MouseEvent e){
}",java:S1186,16
"public void mousePressed(MouseEvent e){
}",java:S1186,16
"public void mouseExited(MouseEvent e){
}",java:S1186,16
"public void mouseEntered(MouseEvent e){
}",java:S1186,16
"public void mouseReleased(MouseEvent e){
}",java:S1186,16
"public void mousePressed(MouseEvent e){
}",java:S1186,16
"public void mouseExited(MouseEvent e){
}",java:S1186,16
"public void mouseEntered(MouseEvent e){
}",java:S1186,16
"public boolean isGlobal(){
    return true;
}",java:S1161,11
"public void mousePressed(MouseEvent e){
    if (e.isPopupTrigger())
        react(e);
}",java:S1161,11
"public void mouseReleased(MouseEvent e){
    if (e.isPopupTrigger())
        react(e);
}",java:S1161,11
"public void react(MouseEvent e){
    JComponent c = (JComponent) e.getSource();
    LayoutManager lm = c.getParent().getLayout();
    if (lm instanceof MigLayout == false)
        lm = c.getLayout();
    if (lm instanceof MigLayout) {
        MigLayout layout = (MigLayout) lm;
        boolean isComp = layout.isManagingComponent(c);
        Object compConstr = isComp ? layout.getComponentConstraints(c) : null;
        if (isComp && compConstr == null)
            compConstr = """";
        Object rowsConstr = isComp ? null : layout.getRowConstraints();
        Object colsConstr = isComp ? null : layout.getColumnConstraints();
        Object layoutConstr = isComp ? null : layout.getLayoutConstraints();
        ConstraintsDialog cDlg = new ConstraintsDialog(AdventureFrame.this, (String) layoutConstr, (String) rowsConstr, (String) colsConstr, (String) compConstr);
        cDlg.pack();
        cDlg.setLocationRelativeTo(c);
        if (cDlg.showDialog()) {
            try {
                if (isComp) {
                    String constrStr = cDlg.componentConstrTF.getText().trim();
                    layout.setComponentConstraints(c, constrStr);
                    if (c instanceof JButton) {
                        c.setFont(BUTT_FONT);
                        ((JButton) c).setText(constrStr.length() == 0 ? ""<Empty>"" : constrStr);
                    }
                } else {
                    layout.setLayoutConstraints(cDlg.layoutConstrTF.getText());
                    layout.setRowConstraints(cDlg.rowsConstrTF.getText());
                    layout.setColumnConstraints(cDlg.colsConstrTF.getText());
                }
            } catch (Exception ex) {
                StringWriter sw = new StringWriter();
                ex.printStackTrace(new PrintWriter(sw));
                JOptionPane.showMessageDialog(SwingUtilities.getWindowAncestor(c), sw.toString(), ""Error parsing Constraint!"", JOptionPane.ERROR_MESSAGE);
                return;
            }
            c.invalidate();
            c.getParent().validate();
        }
    }
}",java:S3776,39
"public boolean isSelfReference(){
    return false;
}",java:S1161,11
"public void mouseMoved(MouseEvent e){
    JComponent c = (JComponent) e.getSource();
    LayoutManager lm = c.getParent().getLayout();
    if (lm instanceof MigLayout) {
        Object constr = ((MigLayout) lm).getComponentConstraints(c);
        if (constr instanceof String) {
            c.setToolTipText(""\"""" + constr + ""\"""");
        } else {
            c.setToolTipText(""null"");
        }
    }
}",java:S1161,11
"public void addNotify(){
    super.addNotify();
    KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(this);
}",java:S1161,11
"public void removeNotify(){
    KeyboardFocusManager.getCurrentKeyboardFocusManager().removeKeyEventDispatcher(this);
    super.removeNotify();
}",java:S1161,11
"public void keyPressed(KeyEvent e){
    if (e.getKeyCode() == KeyEvent.VK_ENTER) {
        okButt.doClick();
        return;
    }
    javax.swing.Timer timer = new Timer(50, new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            String constr = tf.getText();
            try {
                if (tf == layoutConstrTF) {
                    ConstraintParser.parseLayoutConstraint(constr);
                } else if (tf == rowsConstrTF) {
                    ConstraintParser.parseRowConstraints(constr);
                } else if (tf == colsConstrTF) {
                    ConstraintParser.parseColumnConstraints(constr);
                } else if (tf == componentConstrTF) {
                    ConstraintParser.parseComponentConstraint(constr);
                }
                tf.setBackground(Color.WHITE);
                okButt.setEnabled(true);
            } catch (Exception ex) {
                tf.setBackground(ERROR_COLOR);
                okButt.setEnabled(false);
            }
        }
    });
    timer.setRepeats(false);
    timer.start();
}",java:S1161,11
"public void internalFrameOpened(InternalFrameEvent e){
}",java:S1186,16
"public void internalFrameIconified(InternalFrameEvent e){
}",java:S1186,16
"public int getHashCode(Object object){
    throw new RuntimeException(""Can't extract a value from global "" + identifier + "" without a working memory reference"");
}",java:S1161,11
"public void internalFrameDeiconified(InternalFrameEvent e){
}",java:S1186,16
"public void internalFrameDeactivated(InternalFrameEvent e){
}",java:S1186,16
"public void internalFrameClosing(InternalFrameEvent e){
}",java:S1186,16
"public void internalFrameActivated(InternalFrameEvent e){
}",java:S1186,16
"public void setValue(Object value){
    if (value == null) {
        return;
    } else if (value instanceof Thing) {
        setText(((Thing) value).getName());
    } else {
        setText(value.toString());
    }
}",java:S1161,11
"public void addRows(List list){
    DefaultTableModel model = (DefaultTableModel) jTable.getModel();
    if (model.getRowCount() < list.size()) {
        Object[][] exits = new Object[list.size()][];
        for (int i = 0, length = model.getRowCount(); i < length; i++) {
            model.setValueAt(list.get(i), i, 0);
        }
        for (int i = model.getRowCount(), length = exits.length; i < length; i++) {
            if (list.get(i) == null) {
                continue;
            }
            model.addRow(new Object[] { list.get(i) });
        }
    } else {
        Object[][] exits = new Object[list.size()][];
        for (int i = 0; i < exits.length; i++) {
            if (list.get(i) == null) {
                continue;
            }
            model.setValueAt(list.get(i), i, 0);
        }
        int i = exits.length;
        while (model.getRowCount() > exits.length) {
            model.removeRow(i);
        }
    }
}",java:S3776,39
"public int getIndex(){
    return -1;
}",java:S1161,11
"public Object getValue(Object object){
    throw new RuntimeException(""Can't extract a value from global "" + identifier + "" without a working memory reference"");
}",java:S1161,11
"public void mousePressed(MouseEvent e){
    Reset reset = new Reset();
    reset.setResetScore(true);
    gameView.getKsession().insert(reset);
    gameView.getKsession().getAgenda().getAgendaGroup(""Reset"").setFocus();
    gameView.getKsession().fireAllRules();
}",java:S1161,11
"public void mousePressed(MouseEvent e){
    gameView.getKsession().insert(new ShootCommand());
    gameView.getKsession().fireAllRules();
}",java:S1161,11
"public void mousePressed(MouseEvent e){
    gameView.getKsession().insert(new GrabCommand());
    gameView.getKsession().fireAllRules();
}",java:S1161,11
"public void mousePressed(MouseEvent e){
    gameView.getKsession().insert(new ClimbCommand());
    gameView.getKsession().fireAllRules();
}",java:S1161,11
"public void mousePressed(MouseEvent e){
    if (cavePanel.isVisible()) {
        cavePanel.setVisible(false);
        showCaveButton.setText(""SHOW"");
    } else {
        cavePanel.setVisible(true);
        showCaveButton.setText(""HIDE"");
    }
}",java:S1161,11
"public void mousePressed(MouseEvent e){
    FactHandle fh = gameView.getKsession().getFactHandle(gameView);
    if (gameView.isShowAllCells()) {
        gameView.setShowAllCells(false);
    } else {
        gameView.setShowAllCells(true);
    }
    gameView.getKsession().update(fh, gameView);
    gameView.getKsession().fireAllRules();
}",java:S1161,11
"public void mousePressed(MouseEvent e){
    gameView.getKsession().insert(new MoveCommand(move));
    gameView.getKsession().fireAllRules();
}",java:S1161,11
"public void init(Cell[][] cells){
}",java:S1186,16
"private boolean removeEntry(final int pos){
    size--;
    shiftKeys(pos);
    if (n > minN && size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE)
        rehash(n / 2);
    return true;
}",java:S2177,28
"public String getNativeReadMethodName(){
    return ""getValue"";
}",java:S1161,11
"public void resume(Tuple tuple){
    it = treeMemory.tree.object2ObjectEntrySet().iterator();
}",java:S1172,13
"public Tuple getFirst(Tuple tuple){
    key = TupleIndexRBTree.coerceType(treeMemory.index, !treeMemory.tree.isEmpty() ? treeMemory.tree.firstKey() : null, treeMemory.getIndexedValue(tuple, !treeMemory.left));
    if (key == null) {
        switch(constraintType) {
            case EQUAL:
            case GREATER_OR_EQUAL:
            case LESS_OR_EQUAL:
                return treeMemory.nullTupleList.getFirst();
            default:
                return null;
        }
    }
    HolderEntry from = HolderEntry.getInstance().setKey(key);
    if (constraintType == ConstraintTypeOperator.LESS_THAN || constraintType == ConstraintTypeOperator.LESS_OR_EQUAL) {
        it = treeMemory.tree.object2ObjectEntrySet().iterator();
    } else {
        it = treeMemory.tree.object2ObjectEntrySet().iterator(from);
    }
    Tuple first = null;
    if (it.hasNext()) {
        switch(constraintType) {
            case LESS_THAN:
                {
                    Object2ObjectMap.Entry<Comparable, TupleList> tempKey = it.next();
                    if (tempKey.getKey().compareTo(key) < 0) {
                        first = tempKey.getValue().getFirst();
                    } else {
                        key = null;
                        it = null;
                    }
                    break;
                }
            case LESS_OR_EQUAL:
                {
                    Object2ObjectMap.Entry<Comparable, TupleList> tempKey = it.next();
                    if (tempKey.getKey().compareTo(key) <= 0) {
                        first = tempKey.getValue().getFirst();
                    } else {
                        key = null;
                        it = null;
                    }
                    break;
                }
            case GREATER_OR_EQUAL:
                {
                    if (it.hasPrevious()) {
                        Object2ObjectMap.Entry<Comparable, TupleList> prev = it.previous();
                        if (prev.getKey().compareTo(key) >= 0) {
                            Object2ObjectMap.Entry<Comparable, TupleList> entry = prev;
                            first = entry.getValue().getFirst();
                        }
                        break;
                    }
                }
            default:
                {
                    Object2ObjectMap.Entry<Comparable, TupleList> entry = it.next();
                    first = entry.getValue().getFirst();
                    break;
                }
        }
    }
    current = first;
    return first;
}",java:S3776,39
"public int hashCode(){
    return this.objectType.hashCode();
}",java:S1161,11
"private GraphAnalysis generateGraphAnalysis(AnalysisModel model){
    GraphAnalysis graphAnalysis = new GraphAnalysis();
    for (Package pkg : model.getPackages()) {
        List<Rule> rules = pkg.getRules();
        for (Rule rule : rules) {
            graphAnalysis.addNode(new Node(rule));
            LeftHandSide lhs = rule.getLhs();
            List<Pattern> patterns = lhs.getPatterns();
            for (Pattern pattern : patterns) {
                Class<?> patternClass = pattern.getPatternClass();
                Collection<String> reactOnFields = pattern.getReactOnFields();
                if (pattern.isClassReactive()) {
                    graphAnalysis.addClassReactiveRule(patternClass, rule, pattern.isPositive());
                } else if (reactOnFields.isEmpty()) {
                    graphAnalysis.addInsertReactiveRule(patternClass, rule, pattern.isPositive());
                } else {
                    for (String field : reactOnFields) {
                        graphAnalysis.addPropertyReactiveRule(patternClass, field, rule, pattern.isPositive());
                    }
                }
            }
        }
    }
    return graphAnalysis;
}",java:S3776,39
"private void processInsert(GraphAnalysis graphAnalysis, String pkgName, String ruleName, InsertAction action){
    Node source = graphAnalysis.getNode(fqdn(pkgName, ruleName));
    Class<?> insertedClass = action.getActionClass();
    if (!graphAnalysis.isRegisteredClass(insertedClass)) {
        logger.warn(""Not found {} in reactiveMap"", insertedClass);
        return;
    }
    List<InsertedProperty> insertedProperties = action.getInsertedProperties();
    for (InsertedProperty insertedProperty : insertedProperties) {
        String property = insertedProperty.getProperty();
        for (AnalyzedRule reactedRule : graphAnalysis.getRulesReactiveTo(insertedClass, property)) {
            List<Pattern> patterns = reactedRule.getRule().getLhs().getPatterns().stream().filter(pattern -> pattern.getPatternClass() == insertedClass).collect(Collectors.toList());
            for (Pattern pattern : patterns) {
                List<Constraint> constraints = pattern.getConstraints().stream().filter(constraint -> constraint.getProperty() != null && constraint.getProperty().equals(property)).collect(Collectors.toList());
                ReactivityType combinedLinkType = ReactivityType.UNKNOWN;
                if (constraints.isEmpty()) {
                    combinedLinkType = ReactivityType.UNKNOWN;
                } else {
                    for (Constraint constraint : constraints) {
                        ReactivityType linkType = linkType(constraint, insertedProperty);
                        if (linkType == ReactivityType.POSITIVE) {
                            combinedLinkType = ReactivityType.POSITIVE;
                            break;
                        } else if (linkType == ReactivityType.NEGATIVE) {
                            combinedLinkType = ReactivityType.NEGATIVE;
                        } else if (combinedLinkType == ReactivityType.NEGATIVE && linkType == ReactivityType.UNKNOWN) {
                        } else {
                            combinedLinkType = linkType;
                        }
                    }
                }
                if (combinedLinkType == ReactivityType.NEGATIVE) {
                    continue;
                }
                if (combinedLinkType == ReactivityType.POSITIVE && !pattern.isPositive()) {
                    combinedLinkType = combinedLinkType.negate();
                }
                Node target = graphAnalysis.getNode(fqdn(pkgName, reactedRule.getRule().getName()));
                linkNodesIfExpected(source, target, combinedLinkType);
            }
        }
    }
    for (AnalyzedRule reactedRule : graphAnalysis.getRulesReactiveToWithoutProperty(insertedClass)) {
        Node target = graphAnalysis.getNode(fqdn(pkgName, reactedRule.getRule().getName()));
        linkNodesIfExpected(source, target, reactedRule.getReactivityType());
    }
}",java:S3776,39
"private void processModify(GraphAnalysis graphAnalysis, String pkgName, String ruleName, ModifyAction action){
    Node source = graphAnalysis.getNode(fqdn(pkgName, ruleName));
    Class<?> modifiedClass = action.getActionClass();
    if (!graphAnalysis.isRegisteredClass(modifiedClass)) {
        logger.warn(""Not found {} in reactiveMap"", modifiedClass);
        return;
    }
    List<ModifiedProperty> modifiedProperties = action.getModifiedProperties();
    for (ModifiedProperty modifiedProperty : modifiedProperties) {
        String property = modifiedProperty.getProperty();
        for (AnalyzedRule reactedRule : graphAnalysis.getRulesReactiveTo(modifiedClass, property)) {
            List<Constraint> constraints = reactedRule.getRule().getLhs().getPatterns().stream().filter(pattern -> pattern.getPatternClass() == modifiedClass).flatMap(pattern -> pattern.getConstraints().stream()).filter(constraint -> constraint.getProperty() != null && constraint.getProperty().equals(property)).filter(constraint -> {
                if (constraint instanceof MapConstraint) {
                    return doesAssertSameKey((MapConstraint) constraint, modifiedProperty);
                } else {
                    return true;
                }
            }).collect(Collectors.toList());
            ReactivityType combinedLinkType = ReactivityType.UNKNOWN;
            if (constraints.isEmpty()) {
                combinedLinkType = ReactivityType.UNKNOWN;
            } else {
                for (Constraint constraint : constraints) {
                    ReactivityType linkType = linkType(constraint, modifiedProperty);
                    if (linkType == ReactivityType.POSITIVE) {
                        combinedLinkType = ReactivityType.POSITIVE;
                        break;
                    } else if (linkType == ReactivityType.NEGATIVE) {
                        combinedLinkType = ReactivityType.NEGATIVE;
                    } else if (combinedLinkType == ReactivityType.NEGATIVE && linkType == ReactivityType.UNKNOWN) {
                    } else {
                        combinedLinkType = linkType;
                    }
                }
            }
            if (reactedRule.getReactivityType() == ReactivityType.NEGATIVE) {
                combinedLinkType = combinedLinkType.negate();
            }
            Node target = graphAnalysis.getNode(fqdn(pkgName, reactedRule.getRule().getName()));
            linkNodesIfExpected(source, target, combinedLinkType);
        }
    }
}",java:S3776,39
"private ReactivityType linkType(Constraint constraint, ModifiedProperty modifiedProperty){
    Object value = constraint.getValue();
    Object modifiedValue = modifiedProperty.getValue();
    if (modifiedValue == null || value == null) {
        return ReactivityType.UNKNOWN;
    }
    if (value instanceof Number && modifiedValue instanceof Number) {
        value = ((Number) value).doubleValue();
        modifiedValue = ((Number) modifiedValue).doubleValue();
    }
    switch(constraint.getType()) {
        case EQUAL:
            if (modifiedValue.equals(value)) {
                return ReactivityType.POSITIVE;
            } else {
                return ReactivityType.NEGATIVE;
            }
        case NOT_EQUAL:
            if (!modifiedValue.equals(value)) {
                return ReactivityType.POSITIVE;
            } else {
                return ReactivityType.NEGATIVE;
            }
        case GREATER_THAN:
            if (((Comparable) modifiedValue).compareTo(value) > 0) {
                return ReactivityType.POSITIVE;
            } else {
                return ReactivityType.NEGATIVE;
            }
        case GREATER_OR_EQUAL:
            if (((Comparable) modifiedValue).compareTo(value) >= 0) {
                return ReactivityType.POSITIVE;
            } else {
                return ReactivityType.NEGATIVE;
            }
        case LESS_THAN:
            if (((Comparable) modifiedValue).compareTo(value) < 0) {
                return ReactivityType.POSITIVE;
            } else {
                return ReactivityType.NEGATIVE;
            }
        case LESS_OR_EQUAL:
            if (((Comparable) modifiedValue).compareTo(value) <= 0) {
                return ReactivityType.POSITIVE;
            } else {
                return ReactivityType.NEGATIVE;
            }
        case RANGE:
            break;
        case UNKNOWN:
            break;
    }
    return ReactivityType.UNKNOWN;
}",java:S3776,39
"public boolean equals(final Object obj){
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof PatternExtractor)) {
        return false;
    }
    final PatternExtractor other = (PatternExtractor) obj;
    return this.objectType.equals(other.objectType);
}",java:S1161,11
"private guru.nidi.graphviz.model.Graph convertGraph(Graph g){
    guru.nidi.graphviz.model.Graph graph = graph(graphName).directed().graphAttr().with(Rank.dir(rankDir).sep(sep));
    List<Node> nodeList = g.getNodeMap().values().stream().collect(Collectors.toList());
    for (Node n : nodeList) {
        guru.nidi.graphviz.model.Node node = node(n.getRuleName());
        if (n.getStatus() == Node.Status.CHANGED) {
            node = node.with(Color.RED, Style.FILLED);
        } else if (n.getStatus() == Node.Status.IMPACTED) {
            node = node.with(Color.YELLOW, Style.FILLED);
        } else if (n.getStatus() == Node.Status.TARGET) {
            node = node.with(Color.ORANGE, Style.FILLED);
        } else if (n.getStatus() == Node.Status.IMPACTING) {
            node = node.with(Color.LIGHTBLUE, Style.FILLED);
        }
        for (Link l : n.getOutgoingLinks()) {
            if (!nodeList.contains(l.getTarget())) {
                continue;
            }
            Style<ForNodeLink> style;
            if (l.getReactivityType() == ReactivityType.POSITIVE) {
                style = Style.SOLID;
            } else if (l.getReactivityType() == ReactivityType.NEGATIVE) {
                style = Style.DASHED;
            } else {
                style = Style.DOTTED;
            }
            node = node.link(to(node(l.getTarget().getRuleName())).with(style));
        }
        graph = graph.with(node);
    }
    return graph;
}",java:S3776,39
"protected KieBuilder createKieBuilder(KieServices ks, KieModuleModel model, ReleaseId releaseId, boolean failIfBuildError, KieFile... stringRules){
    KieFileSystem kfs = ks.newKieFileSystem();
    if (model != null) {
        kfs.writeKModuleXML(model.toXML());
    }
    kfs.writePomXML(getPom(releaseId));
    for (int i = 0; i < stringRules.length; i++) {
        kfs.write(stringRules[i].path, stringRules[i].content);
    }
    KieBuilder kieBuilder = ks.newKieBuilder(kfs).buildAll(ImpactAnalysisProject.class);
    return kieBuilder;
}",java:S1172,13
"public boolean isGlobal(){
    return false;
}",java:S1161,11
"private InsertAction processInsert(RuleContext context, MethodCallExpr consequenceExpr, MethodCallExpr statement, BlockStmt ruleVariablesBlock){
    Class<?> actionClass = getActionClass(context, consequenceExpr, statement);
    InsertAction action = new InsertAction(actionClass);
    Expression insertedArgument = statement.getArgument(0);
    String insertedId = insertedArgument.toString();
    List<MethodCallExpr> insertedExprs = consequenceExpr.findAll(MethodCallExpr.class).stream().filter(m -> m.getScope().map(s -> s.toString().equals(insertedId) || s.toString().equals(""("" + insertedId + "")"")).orElse(false)).collect(Collectors.toList());
    for (MethodCallExpr expr : insertedExprs) {
        String methodName = expr.getNameAsString();
        String property = ClassUtils.setter2property(methodName);
        if (property != null) {
            Object value = getLiteralValue(context, expr.getArgument(0));
            action.addInsertedProperty(new InsertedProperty(property, value));
        }
    }
    if (isLiteral(actionClass) && insertedArgument.isLiteralExpr()) {
        action.addInsertedProperty(new InsertedProperty(""this"", literalToValue(insertedArgument.asLiteralExpr())));
    }
    return action;
}",java:S1172,13
"private ModifyAction processModify(RuleContext context, MethodCallExpr consequenceExpr, MethodCallExpr statement, BlockStmt ruleVariablesBlock){
    String modifiedId = statement.getArgument(0).toString();
    Class<?> modifiedClass = context.getDeclarationById(modifiedId).orElseThrow(() -> new RuntimeException(""Unknown declaration: "" + modifiedId)).getDeclarationClass();
    ModifyAction action = new ModifyAction(modifiedClass);
    if (statement.getArguments().size() > 1) {
        String maskId = statement.getArgument(1).toString();
        AssignExpr maskAssignExpr = ruleVariablesBlock.findAll(AssignExpr.class).stream().filter(assign -> ((VariableDeclarationExpr) assign.getTarget()).getVariable(0).toString().equals(maskId)).findFirst().orElseThrow(() -> new RuntimeException(""Unknown mask: "" + maskId));
        MethodCallExpr maskMethod = ((MethodCallExpr) maskAssignExpr.getValue());
        List<MethodCallExpr> modifyingExprs = consequenceExpr.findAll(MethodCallExpr.class).stream().filter(m -> m.getScope().map(s -> s.toString().equals(modifiedId) || s.toString().equals(""("" + modifiedId + "")"")).orElse(false)).collect(Collectors.toList());
        for (int i = 1; i < maskMethod.getArguments().size(); i++) {
            String property = maskMethod.getArgument(i).asStringLiteralExpr().asString();
            String setter = ""set"" + ucFirst(property);
            MethodCallExpr setterExpr = modifyingExprs.stream().filter(m -> m.getNameAsString().equals(setter)).filter(m -> m.getArguments().size() == 1).findFirst().orElse(null);
            Object value = null;
            if (setterExpr != null) {
                Expression arg = setterExpr.getArgument(0);
                arg = stripEnclosedAndCast(arg);
                if (arg.isLiteralExpr()) {
                    value = literalToValue(arg.asLiteralExpr());
                } else if (arg.isNameExpr()) {
                    value = ((ImpactAnalysisRuleContext) context).getBindVariableLiteralMap().get(arg.asNameExpr().getName().asString());
                } else if (arg.isObjectCreationExpr()) {
                    value = objectCreationExprToValue((ObjectCreationExpr) arg, context);
                }
            }
            Method accessor = ClassUtils.getAccessor(modifiedClass, property);
            if (accessor != null && Map.class.isAssignableFrom(accessor.getReturnType())) {
                String mapName = property;
                List<MethodCallExpr> mapPutExprs = consequenceExpr.findAll(MethodCallExpr.class).stream().filter(m -> isMapPutExpr(m, modifiedId, accessor.getName())).collect(Collectors.toList());
                mapPutExprs.stream().forEach(expr -> {
                    String mapKey = getLiteralString(context, expr.getArgument(0));
                    Object mapValue = getLiteralValue(context, expr.getArgument(1));
                    action.addModifiedProperty(new ModifiedMapProperty(mapName, mapKey, mapValue));
                });
            } else {
                action.addModifiedProperty(new ModifiedProperty(property, value));
            }
        }
    }
    return action;
}",java:S3776,39
"public boolean isSelfReference(){
    return true;
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    this.path = (String) in.readObject();
    this.encoding = (String) in.readObject();
}",java:S1161,11
"public boolean equals(Object object){
    if (!(object instanceof ClassPathResource)) {
        return false;
    }
    ClassPathResource other = (ClassPathResource) object;
    return this.path.equals(other.path) && this.clazz == other.clazz && this.classLoader == other.classLoader;
}",java:S1161,11
"public int hashCode(){
    return this.path.hashCode();
}",java:S1161,11
"public String toString(){
    return ""ClassPathResource[path="" + this.path + ""]"";
}",java:S1161,11
"public String toString(){
    return ""DescrResource[resource="" + this.descr + ""]"";
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(this.file);
    out.writeObject(this.encoding);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    this.file = (File) in.readObject();
    this.encoding = (String) in.readObject();
}",java:S1161,11
"public String toString(){
    return ""FileResource[file="" + this.file.toString() + ""]"";
}",java:S1161,11
"public boolean equals(Object object){
    if (object == null) {
        return false;
    }
    return (object == this || (object instanceof FileSystemResource && file.equals(((FileSystemResource) object).file)));
}",java:S1161,11
"public int hashCode(){
    return this.file.hashCode();
}",java:S1161,11
"public synchronized int read(byte[] b, int off, int len) throws IOException{
    if (in == null) {
        throw new IOException(""Stream Closed"");
    }
    if (len == 0) {
        return 0;
    }
    while (slack == null) {
        char[] buf = new char[len];
        int n = in.read(buf);
        if (n == -1) {
            return -1;
        }
        if (n > 0) {
            slack = new String(buf, 0, n).getBytes(encoding);
            begin = 0;
        }
    }
    if (len > slack.length - begin) {
        len = slack.length - begin;
    }
    System.arraycopy(slack, begin, b, off, len);
    if ((begin += len) >= slack.length) {
        slack = null;
    }
    return len;
}",java:S1161,11
"public synchronized void mark(final int limit){
    try {
        in.mark(limit);
    } catch (IOException ioe) {
        throw new RuntimeException(ioe.getMessage());
    }
}",java:S1161,11
"public synchronized int available() throws IOException{
    if (in == null) {
        throw new IOException(""Stream Closed"");
    }
    if (slack != null) {
        return slack.length - begin;
    }
    if (in.ready()) {
        return 1;
    }
    return 0;
}",java:S1161,11
"public boolean markSupported(){
    return false;
}",java:S1161,11
"public synchronized void reset() throws IOException{
    if (in == null) {
        throw new IOException(""Stream Closed"");
    }
    slack = null;
    in.reset();
}",java:S1161,11
"public synchronized void close() throws IOException{
    if (in != null) {
        in.close();
        slack = null;
        in = null;
    }
}",java:S1161,11
"public String toString(){
    return ""ReaderResource[resource="" + this.reader + "",encoding="" + this.encoding + ""]"";
}",java:S1161,11
"public void handleException(InternalMatch internalMatch, Exception e){
    agendas[0].handleException(internalMatch, e);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    activationId = (String) in.readObject();
    rule = (String) in.readObject();
    declarations = (String) in.readObject();
    ruleFlowGroup = (String) in.readObject();
    factHandleIds = (String) in.readObject();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(activationId);
    out.writeObject(rule);
    out.writeObject(declarations);
    out.writeObject(ruleFlowGroup);
    out.writeObject(factHandleIds);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    type = in.readInt();
}",java:S1130,7
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    factId = in.readLong();
    objectToString = (String) in.readObject();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeLong(factId);
    out.writeObject(objectToString);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    packageName = (String) in.readObject();
    ruleName = (String) in.readObject();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(packageName);
    out.writeObject(ruleName);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    groupName = (String) in.readObject();
    size = in.readInt();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(groupName);
    out.writeInt(size);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    processId = (String) in.readObject();
    processName = (String) in.readObject();
    processInstanceId = in.readObject();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(processId);
    out.writeObject(processName);
    out.writeObject(processInstanceId);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    nodeId = (String) in.readObject();
    nodeName = (String) in.readObject();
    nodeInstanceId = (String) in.readObject();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(nodeId);
    out.writeObject(nodeName);
    out.writeObject(nodeInstanceId);
}",java:S1161,11
"public String toString(){
    String msg = null;
    switch(this.getType()) {
        case BEFORE_RULEFLOW_NODE_TRIGGERED:
            msg = ""BEFORE PROCESS NODE TRIGGERED"";
            break;
        case AFTER_RULEFLOW_NODE_TRIGGERED:
            msg = ""AFTER PROCESS NODE TRIGGERED"";
            break;
        case BEFORE_RULEFLOW_NODE_EXITED:
            msg = ""BEFORE PROCESS NODE EXITED"";
            break;
        case AFTER_RULEFLOW_NODE_EXITED:
            msg = ""AFTER PROCESS NODE EXITED"";
            break;
        default:
            return super.toString();
    }
    return msg + "" node:"" + nodeName + ""[id="" + nodeId + ""] process:"" + getProcessName() + ""[id="" + getProcessId() + ""]"";
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    variableId = (String) in.readObject();
    variableInstanceId = (String) in.readObject();
    objectToString = (String) in.readObject();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(variableId);
    out.writeObject(variableInstanceId);
    out.writeObject(objectToString);
}",java:S1161,11
"public String toString(){
    String msg = null;
    switch(this.getType()) {
        case BEFORE_VARIABLE_INSTANCE_CHANGED:
            msg = ""BEFORE RULEFLOW VARIABLE CHANGED"";
            break;
        case AFTER_VARIABLE_INSTANCE_CHANGED:
            msg = ""AFTER RULEFLOW VARIABLE CHANGED"";
            break;
        default:
            return super.toString();
    }
    return msg + "" "" + variableId + ""="" + objectToString + "" process:"" + getProcessName() + ""[id="" + getProcessId() + ""]"";
}",java:S1161,11
"public void stop(){
    writer.interrupt();
    super.stop();
}",java:S1161,11
"public synchronized void logEventCreated(final LogEvent logEvent){
    super.logEventCreated(logEvent);
}",java:S1161,11
"public synchronized void writeToDisk(){
    super.writeToDisk();
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
}",java:S1185,15
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
}",java:S1185,15
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(events);
    out.writeObject(fileName);
    out.writeInt(maxEventsInMemory);
    out.writeInt(nbOfFile);
    out.writeBoolean(split);
    out.writeBoolean(initialized);
    out.writeBoolean(terminate);
}",java:S1161,11
"public boolean isSequential(){
    return delegate.isSequential();
}",java:S1161,11
"public void startOperation(InternalOperationType operationType){
    delegate.startOperation(operationType);
}",java:S1161,11
"public void endOperation(InternalOperationType operationType){
    delegate.endOperation(operationType);
}",java:S1161,11
"public Collection<? extends NodeInfo> getNodeInfos(){
    return this.nodesInfo.values();
}",java:S1452,23
"protected ObjectStore createObjectStore(EntryPointId entryPoint, RuleBaseConfiguration conf, ReteEvaluator reteEvaluator){
    boolean useClassAwareStore = isEqualityBehaviour || conf.getOption(KieBaseMutabilityOption.KEY).isMutabilityEnabled();
    return useClassAwareStore ? new ClassAwareObjectStore(isEqualityBehaviour, this.lock) : new IdentityObjectStore();
}",java:S1172,13
"protected void beforeUpdate(InternalFactHandle handle, Object object, InternalMatch internalMatch, Object originalObject, PropagationContext propagationContext){
}",java:S1186,16
"protected void beforeDestroy(RuleImpl rule, TerminalNode terminalNode, InternalFactHandle handle){
}",java:S1186,16
"protected void afterRetract(InternalFactHandle handle, RuleImpl rule, TerminalNode terminalNode){
}",java:S1186,16
"public String toString(){
    return ""ConstraintType::"" + this.desc;
}",java:S1161,11
"public void attach(KieRuntimeEventManager ksession){
    ksession.addEventListener(ruleRuntimeStats);
    super.attach(ksession);
}",java:S1161,11
"public void detach(KieRuntimeEventManager ksession){
    ksession.removeEventListener(ruleRuntimeStats);
    super.detach(ksession);
}",java:S1161,11
"public void dispose(){
    for (KieRuntimeEventManager ksession : ksessions) {
        ksession.removeEventListener(ruleRuntimeStats);
    }
    super.dispose();
}",java:S1161,11
"public void reset(){
    this.ruleRuntimeStats.reset();
    super.reset();
}",java:S1161,11
"public void fireBeforeFunctionRemoved(final InternalKnowledgePackage pkg, final String function){
    if (hasListeners()) {
        BeforeFunctionRemovedEvent event = new BeforeFunctionRemovedEventImpl(this.kBase, function);
        notifyAllListeners(event, (l, e) -> l.beforeFunctionRemoved(e));
    }
}",java:S1172,13
"public void fireAfterFunctionRemoved(final InternalKnowledgePackage pkg, final String function){
    if (hasListeners()) {
        AfterFunctionRemovedEvent event = new AfterFunctionRemovedEventImpl(this.kBase, function);
        notifyAllListeners(event, (l, e) -> l.afterFunctionRemoved(e));
    }
}",java:S1172,13
"public void replaceDeclaration(Declaration oldDecl, Declaration newDecl){
}",java:S1186,16
"public boolean isSequential(){
    return this.sequential;
}",java:S1161,11
"public Constraint clone(){
    return new QueryNameConstraint(readAccessor, queryName);
}",java:S2975,34
"public static UnitData<?> unitData(String name){
    return new UnitDataImpl(name);
}",java:S1452,23
"public static ExprViewItem<A> expr(String exprId, Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Predicate6<A, B, C, D, E, F> predicate){
    return new Expr6ViewItemImpl<>(exprId, var1, var2, var3, var4, var5, var6, new Predicate6.Impl<>(predicate));
}",java:S107,1
"public Constraint clone(){
    return new QueryNameConstraint(readAccessor, queryName);
}",java:S1182,14
"public static ExprViewItem<A> expr(Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Variable<G> var7, Predicate7<A, B, C, D, E, F, G> predicate){
    return new Expr7ViewItemImpl<>(var1, var2, var3, var4, var5, var6, var7, new Predicate7.Impl<>(predicate));
}",java:S107,1
"public static ExprViewItem<A> expr(String exprId, Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Variable<G> var7, Predicate7<A, B, C, D, E, F, G> predicate){
    return new Expr7ViewItemImpl<>(exprId, var1, var2, var3, var4, var5, var6, var7, new Predicate7.Impl<>(predicate));
}",java:S107,1
"public static ExprViewItem<A> expr(Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Variable<G> var7, Variable<H> var8, Predicate8<A, B, C, D, E, F, G, H> predicate){
    return new Expr8ViewItemImpl<>(var1, var2, var3, var4, var5, var6, var7, var8, new Predicate8.Impl<>(predicate));
}",java:S107,1
"public static ExprViewItem<A> expr(String exprId, Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Variable<G> var7, Variable<H> var8, Predicate8<A, B, C, D, E, F, G, H> predicate){
    return new Expr8ViewItemImpl<>(exprId, var1, var2, var3, var4, var5, var6, var7, var8, new Predicate8.Impl<>(predicate));
}",java:S107,1
"public static ExprViewItem<A> expr(Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Variable<G> var7, Variable<H> var8, Variable<I> var9, Predicate9<A, B, C, D, E, F, G, H, I> predicate){
    return new Expr9ViewItemImpl<>(var1, var2, var3, var4, var5, var6, var7, var8, var9, new Predicate9.Impl<>(predicate));
}",java:S107,1
"public static ExprViewItem<A> expr(String exprId, Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Variable<G> var7, Variable<H> var8, Variable<I> var9, Predicate9<A, B, C, D, E, F, G, H, I> predicate){
    return new Expr9ViewItemImpl<>(exprId, var1, var2, var3, var4, var5, var6, var7, var8, var9, new Predicate9.Impl<>(predicate));
}",java:S107,1
"public static ExprViewItem<A> expr(Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Variable<G> var7, Variable<H> var8, Variable<I> var9, Variable<J> var10, Predicate10<A, B, C, D, E, F, G, H, I, J> predicate){
    return new Expr10ViewItemImpl<>(var1, var2, var3, var4, var5, var6, var7, var8, var9, var10, new Predicate10.Impl<>(predicate));
}",java:S107,1
"public static ExprViewItem<A> expr(String exprId, Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Variable<G> var7, Variable<H> var8, Variable<I> var9, Variable<J> var10, Predicate10<A, B, C, D, E, F, G, H, I, J> predicate){
    return new Expr10ViewItemImpl<>(exprId, var1, var2, var3, var4, var5, var6, var7, var8, var9, var10, new Predicate10.Impl<>(predicate));
}",java:S107,1
"public static ExprViewItem<A> expr(Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Variable<G> var7, Variable<H> var8, Variable<I> var9, Variable<J> var10, Variable<K> var11, Predicate11<A, B, C, D, E, F, G, H, I, J, K> predicate){
    return new Expr11ViewItemImpl<>(var1, var2, var3, var4, var5, var6, var7, var8, var9, var10, var11, new Predicate11.Impl<>(predicate));
}",java:S107,1
"public static ExprViewItem<A> expr(String exprId, Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Variable<G> var7, Variable<H> var8, Variable<I> var9, Variable<J> var10, Variable<K> var11, Predicate11<A, B, C, D, E, F, G, H, I, J, K> predicate){
    return new Expr11ViewItemImpl<>(exprId, var1, var2, var3, var4, var5, var6, var7, var8, var9, var10, var11, new Predicate11.Impl<>(predicate));
}",java:S107,1
"public static ExprViewItem<A> expr(Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Variable<G> var7, Variable<H> var8, Variable<I> var9, Variable<J> var10, Variable<K> var11, Variable<L> var12, Predicate12<A, B, C, D, E, F, G, H, I, J, K, L> predicate){
    return new Expr12ViewItemImpl<>(var1, var2, var3, var4, var5, var6, var7, var8, var9, var10, var11, var12, new Predicate12.Impl<>(predicate));
}",java:S107,1
"public static ExprViewItem<A> expr(String exprId, Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Variable<G> var7, Variable<H> var8, Variable<I> var9, Variable<J> var10, Variable<K> var11, Variable<L> var12, Predicate12<A, B, C, D, E, F, G, H, I, J, K, L> predicate){
    return new Expr12ViewItemImpl<>(exprId, var1, var2, var3, var4, var5, var6, var7, var8, var9, var10, var11, var12, new Predicate12.Impl<>(predicate));
}",java:S107,1
"public static ExprViewItem<A> expr(Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Variable<G> var7, Variable<H> var8, Variable<I> var9, Variable<J> var10, Variable<K> var11, Variable<L> var12, Variable<M> var13, Predicate13<A, B, C, D, E, F, G, H, I, J, K, L, M> predicate){
    return new Expr13ViewItemImpl<>(var1, var2, var3, var4, var5, var6, var7, var8, var9, var10, var11, var12, var13, new Predicate13.Impl<>(predicate));
}",java:S107,1
"public static ExprViewItem<A> expr(String exprId, Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<E> var5, Variable<F> var6, Variable<G> var7, Variable<H> var8, Variable<I> var9, Variable<J> var10, Variable<K> var11, Variable<L> var12, Variable<M> var13, Predicate13<A, B, C, D, E, F, G, H, I, J, K, L, M> predicate){
    return new Expr13ViewItemImpl<>(exprId, var1, var2, var3, var4, var5, var6, var7, var8, var9, var10, var11, var12, var13, new Predicate13.Impl<>(predicate));
}",java:S107,1
"public static ExprViewItem<T> groupBy(ViewItem<T> viewItem, Variable<A> var1, Variable<B> var2, Variable<C> var3, Variable<D> var4, Variable<K> varKey, Function4<A, B, C, D, K> groupingFunction, AccumulateFunction... accFunctions){
    return new GroupByExprViewItem<>(viewItem, new Variable[] { var1, var2, var3, var4 }, varKey, toFunctionN(groupingFunction), accFunctions);
}",java:S107,1
"public static ConsequenceBuilder._8<T1, T2, T3, T4, T5, T6, T7, T8> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8){
    return new ConsequenceBuilder._8(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
}",java:S107,1
"public static ConsequenceBuilder._9<T1, T2, T3, T4, T5, T6, T7, T8, T9> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9){
    return new ConsequenceBuilder._9(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
}",java:S107,1
"public static ConsequenceBuilder._10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10){
    return new ConsequenceBuilder._10(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
}",java:S107,1
"public static ConsequenceBuilder._10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10){
    return new ConsequenceBuilder._10(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
}",java:S119,17
"public static ConsequenceBuilder._11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11){
    return new ConsequenceBuilder._11(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
}",java:S107,1
"public static ConsequenceBuilder._11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11){
    return new ConsequenceBuilder._11(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
}",java:S119,17
"public static ConsequenceBuilder._11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11){
    return new ConsequenceBuilder._11(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
}",java:S119,17
"public static ConsequenceBuilder._12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12){
    return new ConsequenceBuilder._12(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
}",java:S107,1
"public static ConsequenceBuilder._12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12){
    return new ConsequenceBuilder._12(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
}",java:S119,17
"public static ConsequenceBuilder._12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12){
    return new ConsequenceBuilder._12(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
}",java:S119,17
"public static ConsequenceBuilder._12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12){
    return new ConsequenceBuilder._12(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
}",java:S119,17
"public static ConsequenceBuilder._13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13){
    return new ConsequenceBuilder._13(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
}",java:S107,1
"public static ConsequenceBuilder._13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13){
    return new ConsequenceBuilder._13(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
}",java:S119,17
"public static ConsequenceBuilder._13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13){
    return new ConsequenceBuilder._13(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
}",java:S119,17
"public static ConsequenceBuilder._13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13){
    return new ConsequenceBuilder._13(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
}",java:S119,17
"public static ConsequenceBuilder._13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13){
    return new ConsequenceBuilder._13(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
}",java:S119,17
"public static ConsequenceBuilder._14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14){
    return new ConsequenceBuilder._14(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
}",java:S107,1
"public static ConsequenceBuilder._14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14){
    return new ConsequenceBuilder._14(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
}",java:S119,17
"public static ConsequenceBuilder._14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14){
    return new ConsequenceBuilder._14(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
}",java:S119,17
"public static ConsequenceBuilder._14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14){
    return new ConsequenceBuilder._14(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
}",java:S119,17
"public static ConsequenceBuilder._14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14){
    return new ConsequenceBuilder._14(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
}",java:S119,17
"public static ConsequenceBuilder._14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14){
    return new ConsequenceBuilder._14(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
}",java:S119,17
"public static ConsequenceBuilder._15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15){
    return new ConsequenceBuilder._15(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
}",java:S107,1
"public static ConsequenceBuilder._15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15){
    return new ConsequenceBuilder._15(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
}",java:S119,17
"public static ConsequenceBuilder._15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15){
    return new ConsequenceBuilder._15(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
}",java:S119,17
"public static ConsequenceBuilder._15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15){
    return new ConsequenceBuilder._15(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
}",java:S119,17
"public static ConsequenceBuilder._15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15){
    return new ConsequenceBuilder._15(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
}",java:S119,17
"public static ConsequenceBuilder._15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15){
    return new ConsequenceBuilder._15(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
}",java:S119,17
"public static ConsequenceBuilder._15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15){
    return new ConsequenceBuilder._15(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
}",java:S119,17
"public static ConsequenceBuilder._16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16){
    return new ConsequenceBuilder._16(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
}",java:S107,1
"public static ConsequenceBuilder._16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16){
    return new ConsequenceBuilder._16(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
}",java:S119,17
"public static ConsequenceBuilder._16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16){
    return new ConsequenceBuilder._16(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
}",java:S119,17
"public static ConsequenceBuilder._16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16){
    return new ConsequenceBuilder._16(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
}",java:S119,17
"public static ConsequenceBuilder._16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16){
    return new ConsequenceBuilder._16(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
}",java:S119,17
"public LinkedList<XpathChunk> getChunks(){
    return chunks;
}",java:S1319,22
"public static ConsequenceBuilder._16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16){
    return new ConsequenceBuilder._16(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
}",java:S119,17
"public static ConsequenceBuilder._16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16){
    return new ConsequenceBuilder._16(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
}",java:S119,17
"public static ConsequenceBuilder._16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16){
    return new ConsequenceBuilder._16(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
}",java:S119,17
"public static ConsequenceBuilder._17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17){
    return new ConsequenceBuilder._17(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17);
}",java:S107,1
"public static ConsequenceBuilder._17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17){
    return new ConsequenceBuilder._17(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17);
}",java:S119,17
"public static ConsequenceBuilder._17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17){
    return new ConsequenceBuilder._17(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17);
}",java:S119,17
"public static ConsequenceBuilder._17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17){
    return new ConsequenceBuilder._17(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17);
}",java:S119,17
"public static ConsequenceBuilder._17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17){
    return new ConsequenceBuilder._17(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17);
}",java:S119,17
"public static ConsequenceBuilder._17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17){
    return new ConsequenceBuilder._17(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17);
}",java:S119,17
"public static ConsequenceBuilder._17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17){
    return new ConsequenceBuilder._17(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17);
}",java:S119,17
"public static ConsequenceBuilder._17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17){
    return new ConsequenceBuilder._17(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17);
}",java:S119,17
"public static ConsequenceBuilder._18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18){
    return new ConsequenceBuilder._18(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18);
}",java:S107,1
"public static ConsequenceBuilder._18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18){
    return new ConsequenceBuilder._18(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18);
}",java:S119,17
"public static ConsequenceBuilder._18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18){
    return new ConsequenceBuilder._18(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18);
}",java:S119,17
"public static ConsequenceBuilder._18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18){
    return new ConsequenceBuilder._18(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18);
}",java:S119,17
"public static ConsequenceBuilder._18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18){
    return new ConsequenceBuilder._18(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18);
}",java:S119,17
"public static ConsequenceBuilder._18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18){
    return new ConsequenceBuilder._18(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18);
}",java:S119,17
"public static ConsequenceBuilder._18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18){
    return new ConsequenceBuilder._18(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18);
}",java:S119,17
"public static ConsequenceBuilder._18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18){
    return new ConsequenceBuilder._18(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18);
}",java:S119,17
"public static ConsequenceBuilder._18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18){
    return new ConsequenceBuilder._18(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18);
}",java:S119,17
"private List<Object> evaluateObject(ValueResolver valueResolver, BaseTuple leftBaseTuple, XpathChunk chunk, List<Object> list, Object object){
    Object result = chunk.evaluate(object);
    if (!chunk.lazy && result instanceof ReactiveObject) {
        ((ReactiveObject) result).addTuple(leftBaseTuple);
    }
    if (chunk.iterate && result instanceof Iterable) {
        for (Object value : (Iterable<?>) result) {
            if (!chunk.lazy && value instanceof ReactiveObject) {
                ((ReactiveObject) value).addTuple(leftBaseTuple);
            }
            if (value != null) {
                list.add(value);
            }
        }
    } else if (result != null) {
        list.add(result);
    }
    return list;
}",java:S1172,13
"public static ConsequenceBuilder._18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18){
    return new ConsequenceBuilder._18(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18);
}",java:S119,17
"public static ConsequenceBuilder._19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19){
    return new ConsequenceBuilder._19(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19);
}",java:S107,1
"public static ConsequenceBuilder._19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19){
    return new ConsequenceBuilder._19(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19);
}",java:S119,17
"public static ConsequenceBuilder._19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19){
    return new ConsequenceBuilder._19(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19);
}",java:S119,17
"public static ConsequenceBuilder._19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19){
    return new ConsequenceBuilder._19(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19);
}",java:S119,17
"public static ConsequenceBuilder._19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19){
    return new ConsequenceBuilder._19(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19);
}",java:S119,17
"public static ConsequenceBuilder._19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19){
    return new ConsequenceBuilder._19(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19);
}",java:S119,17
"public static ConsequenceBuilder._19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19){
    return new ConsequenceBuilder._19(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19);
}",java:S119,17
"public static ConsequenceBuilder._19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19){
    return new ConsequenceBuilder._19(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19);
}",java:S119,17
"public static ConsequenceBuilder._19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19){
    return new ConsequenceBuilder._19(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19);
}",java:S119,17
"public static ConsequenceBuilder._19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19){
    return new ConsequenceBuilder._19(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19);
}",java:S119,17
"public static ConsequenceBuilder._19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19){
    return new ConsequenceBuilder._19(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19);
}",java:S119,17
"public static ConsequenceBuilder._20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20){
    return new ConsequenceBuilder._20(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
}",java:S107,1
"public static ConsequenceBuilder._20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20){
    return new ConsequenceBuilder._20(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
}",java:S119,17
"public static ConsequenceBuilder._20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20){
    return new ConsequenceBuilder._20(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
}",java:S119,17
"public static ConsequenceBuilder._20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20){
    return new ConsequenceBuilder._20(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
}",java:S119,17
"public static ConsequenceBuilder._20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20){
    return new ConsequenceBuilder._20(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
}",java:S119,17
"public static ConsequenceBuilder._20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20){
    return new ConsequenceBuilder._20(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
}",java:S119,17
"public static ConsequenceBuilder._20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20){
    return new ConsequenceBuilder._20(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
}",java:S119,17
"public static ConsequenceBuilder._20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20){
    return new ConsequenceBuilder._20(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
}",java:S119,17
"public static ConsequenceBuilder._20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20){
    return new ConsequenceBuilder._20(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
}",java:S119,17
"public static ConsequenceBuilder._20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20){
    return new ConsequenceBuilder._20(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
}",java:S119,17
"public static ConsequenceBuilder._20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20){
    return new ConsequenceBuilder._20(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
}",java:S119,17
"public static ConsequenceBuilder._20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20){
    return new ConsequenceBuilder._20(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
}",java:S119,17
"public static ConsequenceBuilder._21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21){
    return new ConsequenceBuilder._21(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
}",java:S107,1
"public static ConsequenceBuilder._21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21){
    return new ConsequenceBuilder._21(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
}",java:S119,17
"public static ConsequenceBuilder._21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21){
    return new ConsequenceBuilder._21(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
}",java:S119,17
"public static ConsequenceBuilder._21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21){
    return new ConsequenceBuilder._21(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
}",java:S119,17
"public static ConsequenceBuilder._21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21){
    return new ConsequenceBuilder._21(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
}",java:S119,17
"public static ConsequenceBuilder._21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21){
    return new ConsequenceBuilder._21(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
}",java:S119,17
"public static ConsequenceBuilder._21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21){
    return new ConsequenceBuilder._21(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
}",java:S119,17
"public static ConsequenceBuilder._21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21){
    return new ConsequenceBuilder._21(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
}",java:S119,17
"public static ConsequenceBuilder._21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21){
    return new ConsequenceBuilder._21(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
}",java:S119,17
"public static ConsequenceBuilder._21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21){
    return new ConsequenceBuilder._21(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
}",java:S119,17
"public static ConsequenceBuilder._21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21){
    return new ConsequenceBuilder._21(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
}",java:S119,17
"public static ConsequenceBuilder._21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21){
    return new ConsequenceBuilder._21(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
}",java:S119,17
"public static ConsequenceBuilder._21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21){
    return new ConsequenceBuilder._21(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
}",java:S119,17
"public static ConsequenceBuilder._22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22){
    return new ConsequenceBuilder._22(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
}",java:S107,1
"public static ConsequenceBuilder._22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22){
    return new ConsequenceBuilder._22(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
}",java:S119,17
"public static ConsequenceBuilder._22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22){
    return new ConsequenceBuilder._22(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
}",java:S119,17
"public static ConsequenceBuilder._22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22){
    return new ConsequenceBuilder._22(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
}",java:S119,17
"public static ConsequenceBuilder._22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22){
    return new ConsequenceBuilder._22(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
}",java:S119,17
"public static ConsequenceBuilder._22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22){
    return new ConsequenceBuilder._22(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
}",java:S119,17
"public static ConsequenceBuilder._22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22){
    return new ConsequenceBuilder._22(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
}",java:S119,17
"public static ConsequenceBuilder._22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22){
    return new ConsequenceBuilder._22(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
}",java:S119,17
"public static ConsequenceBuilder._22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22){
    return new ConsequenceBuilder._22(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
}",java:S119,17
"public static ConsequenceBuilder._22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22){
    return new ConsequenceBuilder._22(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
}",java:S119,17
"public static ConsequenceBuilder._22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22){
    return new ConsequenceBuilder._22(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
}",java:S119,17
"public static ConsequenceBuilder._22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22){
    return new ConsequenceBuilder._22(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
}",java:S119,17
"public static ConsequenceBuilder._22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22){
    return new ConsequenceBuilder._22(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
}",java:S119,17
"public static ConsequenceBuilder._22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22){
    return new ConsequenceBuilder._22(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
}",java:S119,17
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S107,1
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S119,17
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S119,17
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S119,17
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S119,17
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S119,17
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S119,17
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S119,17
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S119,17
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S119,17
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S119,17
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S119,17
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S119,17
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S119,17
"public static ConsequenceBuilder._23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23){
    return new ConsequenceBuilder._23(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S107,1
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public static ConsequenceBuilder._24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> on(Variable<T1> arg1, Variable<T2> arg2, Variable<T3> arg3, Variable<T4> arg4, Variable<T5> arg5, Variable<T6> arg6, Variable<T7> arg7, Variable<T8> arg8, Variable<T9> arg9, Variable<T10> arg10, Variable<T11> arg11, Variable<T12> arg12, Variable<T13> arg13, Variable<T14> arg14, Variable<T15> arg15, Variable<T16> arg16, Variable<T17> arg17, Variable<T18> arg18, Variable<T19> arg19, Variable<T20> arg20, Variable<T21> arg21, Variable<T22> arg22, Variable<T23> arg23, Variable<T24> arg24){
    return new ConsequenceBuilder._24(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
}",java:S119,17
"public AlphaIndex<T, ?> getIndex(){
    return index;
}",java:S1452,23
"public static Query3Def<T1, T2, T3> query(String pkg, String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name){
    return new Query3DefImpl<>(VIEW_BUILDER, pkg, name, type1, arg1name, type2, arg2name, type3, arg3name);
}",java:S107,1
"public static Query4Def<T1, T2, T3, T4> query(String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name){
    return new Query4DefImpl<>(VIEW_BUILDER, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name);
}",java:S107,1
"public static Query4Def<T1, T2, T3, T4> query(String pkg, String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name){
    return new Query4DefImpl<>(VIEW_BUILDER, pkg, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name);
}",java:S107,1
"public static Query5Def<T1, T2, T3, T4, T5> query(String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name, Class<T5> type5, String arg5name){
    return new Query5DefImpl<>(VIEW_BUILDER, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name, type5, arg5name);
}",java:S107,1
"public static Query5Def<T1, T2, T3, T4, T5> query(String pkg, String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name, Class<T5> type5, String arg5name){
    return new Query5DefImpl<>(VIEW_BUILDER, pkg, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name, type5, arg5name);
}",java:S107,1
"public static Query6Def<T1, T2, T3, T4, T5, T6> query(String pkg, String name, Class<T1> type1, Class<T2> type2, Class<T3> type3, Class<T4> type4, Class<T5> type5, Class<T6> type6){
    return new Query6DefImpl<>(VIEW_BUILDER, pkg, name, type1, type2, type3, type4, type5, type6);
}",java:S107,1
"public static Query6Def<T1, T2, T3, T4, T5, T6> query(String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name, Class<T5> type5, String arg5name, Class<T6> type6, String arg6name){
    return new Query6DefImpl<>(VIEW_BUILDER, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name, type5, arg5name, type6, arg6name);
}",java:S107,1
"public static Query6Def<T1, T2, T3, T4, T5, T6> query(String pkg, String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name, Class<T5> type5, String arg5name, Class<T6> type6, String arg6name){
    return new Query6DefImpl<>(VIEW_BUILDER, pkg, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name, type5, arg5name, type6, arg6name);
}",java:S107,1
"public static Query7Def<T1, T2, T3, T4, T5, T6, T7> query(String name, Class<T1> type1, Class<T2> type2, Class<T3> type3, Class<T4> type4, Class<T5> type5, Class<T6> type6, Class<T7> type7){
    return new Query7DefImpl<>(VIEW_BUILDER, name, type1, type2, type3, type4, type5, type6, type7);
}",java:S107,1
"public static Query7Def<T1, T2, T3, T4, T5, T6, T7> query(String pkg, String name, Class<T1> type1, Class<T2> type2, Class<T3> type3, Class<T4> type4, Class<T5> type5, Class<T6> type6, Class<T7> type7){
    return new Query7DefImpl<>(VIEW_BUILDER, pkg, name, type1, type2, type3, type4, type5, type6, type7);
}",java:S107,1
"public static Query7Def<T1, T2, T3, T4, T5, T6, T7> query(String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name, Class<T5> type5, String arg5name, Class<T6> type6, String arg6name, Class<T7> type7, String arg7name){
    return new Query7DefImpl<>(VIEW_BUILDER, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name, type5, arg5name, type6, arg6name, type7, arg7name);
}",java:S107,1
"public static Query7Def<T1, T2, T3, T4, T5, T6, T7> query(String pkg, String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name, Class<T5> type5, String arg5name, Class<T6> type6, String arg6name, Class<T7> type7, String arg7name){
    return new Query7DefImpl<>(VIEW_BUILDER, pkg, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name, type5, arg5name, type6, arg6name, type7, arg7name);
}",java:S107,1
"public static Query8Def<T1, T2, T3, T4, T5, T6, T7, T8> query(String name, Class<T1> type1, Class<T2> type2, Class<T3> type3, Class<T4> type4, Class<T5> type5, Class<T6> type6, Class<T7> type7, Class<T8> type8){
    return new Query8DefImpl<>(VIEW_BUILDER, name, type1, type2, type3, type4, type5, type6, type7, type8);
}",java:S107,1
"public static Query8Def<T1, T2, T3, T4, T5, T6, T7, T8> query(String pkg, String name, Class<T1> type1, Class<T2> type2, Class<T3> type3, Class<T4> type4, Class<T5> type5, Class<T6> type6, Class<T7> type7, Class<T8> type8){
    return new Query8DefImpl<>(VIEW_BUILDER, pkg, name, type1, type2, type3, type4, type5, type6, type7, type8);
}",java:S107,1
"public static Query8Def<T1, T2, T3, T4, T5, T6, T7, T8> query(String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name, Class<T5> type5, String arg5name, Class<T6> type6, String arg6name, Class<T7> type7, String arg7name, Class<T8> type8, String arg8name){
    return new Query8DefImpl<>(VIEW_BUILDER, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name, type5, arg5name, type6, arg6name, type7, arg7name, type8, arg8name);
}",java:S107,1
"public static Query8Def<T1, T2, T3, T4, T5, T6, T7, T8> query(String pkg, String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name, Class<T5> type5, String arg5name, Class<T6> type6, String arg6name, Class<T7> type7, String arg7name, Class<T8> type8, String arg8name){
    return new Query8DefImpl<>(VIEW_BUILDER, pkg, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name, type5, arg5name, type6, arg6name, type7, arg7name, type8, arg8name);
}",java:S107,1
"public static Query9Def<T1, T2, T3, T4, T5, T6, T7, T8, T9> query(String name, Class<T1> type1, Class<T2> type2, Class<T3> type3, Class<T4> type4, Class<T5> type5, Class<T6> type6, Class<T7> type7, Class<T8> type8, Class<T9> type9){
    return new Query9DefImpl<>(VIEW_BUILDER, name, type1, type2, type3, type4, type5, type6, type7, type8, type9);
}",java:S107,1
"public static Query9Def<T1, T2, T3, T4, T5, T6, T7, T8, T9> query(String pkg, String name, Class<T1> type1, Class<T2> type2, Class<T3> type3, Class<T4> type4, Class<T5> type5, Class<T6> type6, Class<T7> type7, Class<T8> type8, Class<T9> type9){
    return new Query9DefImpl<>(VIEW_BUILDER, pkg, name, type1, type2, type3, type4, type5, type6, type7, type8, type9);
}",java:S107,1
"public static Query9Def<T1, T2, T3, T4, T5, T6, T7, T8, T9> query(String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name, Class<T5> type5, String arg5name, Class<T6> type6, String arg6name, Class<T7> type7, String arg7name, Class<T8> type8, String arg8name, Class<T9> type9, String arg9name){
    return new Query9DefImpl<>(VIEW_BUILDER, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name, type5, arg5name, type6, arg6name, type7, arg7name, type8, arg8name, type9, arg9name);
}",java:S107,1
"public Interval clone(){
    return new Interval(this.lowerBound, this.upperBound);
}",java:S2975,34
"public static Query9Def<T1, T2, T3, T4, T5, T6, T7, T8, T9> query(String pkg, String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name, Class<T5> type5, String arg5name, Class<T6> type6, String arg6name, Class<T7> type7, String arg7name, Class<T8> type8, String arg8name, Class<T9> type9, String arg9name){
    return new Query9DefImpl<>(VIEW_BUILDER, pkg, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name, type5, arg5name, type6, arg6name, type7, arg7name, type8, arg8name, type9, arg9name);
}",java:S107,1
"public static Query10Def<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> query(String name, Class<T1> type1, Class<T2> type2, Class<T3> type3, Class<T4> type4, Class<T5> type5, Class<T6> type6, Class<T7> type7, Class<T8> type8, Class<T9> type9, Class<T10> type10){
    return new Query10DefImpl<>(VIEW_BUILDER, name, type1, type2, type3, type4, type5, type6, type7, type8, type9, type10);
}",java:S107,1
"public static Query10Def<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> query(String name, Class<T1> type1, Class<T2> type2, Class<T3> type3, Class<T4> type4, Class<T5> type5, Class<T6> type6, Class<T7> type7, Class<T8> type8, Class<T9> type9, Class<T10> type10){
    return new Query10DefImpl<>(VIEW_BUILDER, name, type1, type2, type3, type4, type5, type6, type7, type8, type9, type10);
}",java:S119,17
"public static Query10Def<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> query(String pkg, String name, Class<T1> type1, Class<T2> type2, Class<T3> type3, Class<T4> type4, Class<T5> type5, Class<T6> type6, Class<T7> type7, Class<T8> type8, Class<T9> type9, Class<T10> type10){
    return new Query10DefImpl<>(VIEW_BUILDER, pkg, name, type1, type2, type3, type4, type5, type6, type7, type8, type9, type10);
}",java:S107,1
"public static Query10Def<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> query(String pkg, String name, Class<T1> type1, Class<T2> type2, Class<T3> type3, Class<T4> type4, Class<T5> type5, Class<T6> type6, Class<T7> type7, Class<T8> type8, Class<T9> type9, Class<T10> type10){
    return new Query10DefImpl<>(VIEW_BUILDER, pkg, name, type1, type2, type3, type4, type5, type6, type7, type8, type9, type10);
}",java:S119,17
"public static Query10Def<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> query(String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name, Class<T5> type5, String arg5name, Class<T6> type6, String arg6name, Class<T7> type7, String arg7name, Class<T8> type8, String arg8name, Class<T9> type9, String arg9name, Class<T10> type10, String arg10name){
    return new Query10DefImpl<>(VIEW_BUILDER, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name, type5, arg5name, type6, arg6name, type7, arg7name, type8, arg8name, type9, arg9name, type10, arg10name);
}",java:S107,1
"public static Query10Def<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> query(String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name, Class<T5> type5, String arg5name, Class<T6> type6, String arg6name, Class<T7> type7, String arg7name, Class<T8> type8, String arg8name, Class<T9> type9, String arg9name, Class<T10> type10, String arg10name){
    return new Query10DefImpl<>(VIEW_BUILDER, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name, type5, arg5name, type6, arg6name, type7, arg7name, type8, arg8name, type9, arg9name, type10, arg10name);
}",java:S119,17
"public static Query10Def<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> query(String pkg, String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name, Class<T5> type5, String arg5name, Class<T6> type6, String arg6name, Class<T7> type7, String arg7name, Class<T8> type8, String arg8name, Class<T9> type9, String arg9name, Class<T10> type10, String arg10name){
    return new Query10DefImpl<>(VIEW_BUILDER, pkg, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name, type5, arg5name, type6, arg6name, type7, arg7name, type8, arg8name, type9, arg9name, type10, arg10name);
}",java:S107,1
"public static Query10Def<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> query(String pkg, String name, Class<T1> type1, String arg1name, Class<T2> type2, String arg2name, Class<T3> type3, String arg3name, Class<T4> type4, String arg4name, Class<T5> type5, String arg5name, Class<T6> type6, String arg6name, Class<T7> type7, String arg7name, Class<T8> type8, String arg8name, Class<T9> type9, String arg9name, Class<T10> type10, String arg10name){
    return new Query10DefImpl<>(VIEW_BUILDER, pkg, name, type1, arg1name, type2, arg2name, type3, arg3name, type4, arg4name, type5, arg5name, type6, arg6name, type7, arg7name, type8, arg8name, type9, arg9name, type10, arg10name);
}",java:S119,17
"public Interval clone(){
    return new Interval(this.lowerBound, this.upperBound);
}",java:S1182,14
" QueryCallViewItem call(Argument<T1> var1, Argument<T2> var2, Argument<T3> var3, Argument<T4> var4, Argument<T5> var5, Argument<T6> var6, Argument<T7> var7, Argument<T8> var8, Argument<T9> var9, Argument<T10> var10){
    return call(true, var1, var2, var3, var4, var5, var6, var7, var8, var9, var10);
}",java:S107,1
" QueryCallViewItem call(Argument<T1> var1, Argument<T2> var2, Argument<T3> var3, Argument<T4> var4, Argument<T5> var5, Argument<T6> var6, Argument<T7> var7, Argument<T8> var8){
    return call(true, var1, var2, var3, var4, var5, var6, var7, var8);
}",java:S107,1
" QueryCallViewItem call(Argument<T1> var1, Argument<T2> var2, Argument<T3> var3, Argument<T4> var4, Argument<T5> var5, Argument<T6> var6, Argument<T7> var7, Argument<T8> var8, Argument<T9> var9){
    return call(true, var1, var2, var3, var4, var5, var6, var7, var8, var9);
}",java:S107,1
"public static long pop_array(long[] arr, int wordOffset, int numWords){
    long popCount = 0;
    for (int i = wordOffset, end = wordOffset + numWords; i < end; ++i) {
        popCount += Long.bitCount(arr[i]);
    }
    return popCount;
}",java:S100,0
"public static long pop_intersect(long[] arr1, long[] arr2, int wordOffset, int numWords){
    long popCount = 0;
    for (int i = wordOffset, end = wordOffset + numWords; i < end; ++i) {
        popCount += Long.bitCount(arr1[i] & arr2[i]);
    }
    return popCount;
}",java:S100,0
"public static long pop_union(long[] arr1, long[] arr2, int wordOffset, int numWords){
    long popCount = 0;
    for (int i = wordOffset, end = wordOffset + numWords; i < end; ++i) {
        popCount += Long.bitCount(arr1[i] | arr2[i]);
    }
    return popCount;
}",java:S100,0
"public static long pop_andnot(long[] arr1, long[] arr2, int wordOffset, int numWords){
    long popCount = 0;
    for (int i = wordOffset, end = wordOffset + numWords; i < end; ++i) {
        popCount += Long.bitCount(arr1[i] & ~arr2[i]);
    }
    return popCount;
}",java:S100,0
"public static long pop_xor(long[] arr1, long[] arr2, int wordOffset, int numWords){
    long popCount = 0;
    for (int i = wordOffset, end = wordOffset + numWords; i < end; ++i) {
        popCount += Long.bitCount(arr1[i] ^ arr2[i]);
    }
    return popCount;
}",java:S100,0
"public static long parseTimeString(String time){
    String trimmed = time.trim();
    long result = 0;
    if (trimmed.length() > 0) {
        Matcher mat = SIMPLE.matcher(trimmed);
        if (mat.matches()) {
            int days = (mat.group(SIM_DAY) != null) ? Integer.parseInt(mat.group(SIM_DAY)) : 0;
            int hours = (mat.group(SIM_HOU) != null) ? Integer.parseInt(mat.group(SIM_HOU)) : 0;
            int min = (mat.group(SIM_MIN) != null) ? Integer.parseInt(mat.group(SIM_MIN)) : 0;
            int sec = (mat.group(SIM_SEC) != null) ? Integer.parseInt(mat.group(SIM_SEC)) : 0;
            int ms = (mat.group(SIM_MS) != null) ? Integer.parseInt(mat.group(SIM_MS)) : 0;
            long r = days * DAY_MS + hours * HOU_MS + min * MIN_MS + sec * SEC_MS + ms;
            if (mat.group(SIM_SGN) != null && mat.group(SIM_SGN).equals(""-"")) {
                r = -r;
            }
            result = r;
        } else if (""*"".equals(trimmed) || ""+*"".equals(trimmed)) {
            result = Long.MAX_VALUE;
        } else if (""-*"".equals(trimmed)) {
            result = Long.MIN_VALUE;
        } else {
            throw new RuntimeException(""Error parsing time string: [ "" + time + "" ]"");
        }
    }
    return result;
}",java:S3776,39
"public static boolean isCompatible(int major, int minor, int revision){
    if (major != droolsMajorVersion) {
        return false;
    }
    return minor == 0 ? droolsMinorVersion == 0 : droolsMinorVersion > 0;
}",java:S1172,13
"public ResourceTypePackage<?> get(ResourceType type){
    return packages.get(type);
}",java:S1452,23
"public void buildParameterMapping(Class<T> target){
    Constructor[] cons = target.getConstructors();
    for (Constructor con : cons) {
        for (Annotation ann : con.getDeclaredAnnotations()) {
            if (ann.annotationType() == BayesVariableConstructor.class) {
                Class[] paramTypes = con.getParameterTypes();
                targetParameterMap = new int[paramTypes.length];
                if (paramTypes[0] != BayesInstance.class) {
                    throw new RuntimeException(""First Argument must be "" + BayesInstance.class.getSimpleName());
                }
                Annotation[][] paramAnns = con.getParameterAnnotations();
                for (int j = 1; j < paramAnns.length; j++) {
                    if (paramAnns[j][0].annotationType() == VarName.class) {
                        String varName = ((VarName) paramAnns[j][0]).value();
                        BayesVariable var = variables.get(varName);
                        Object[] outcomes = new Object[var.getOutcomes().length];
                        if (paramTypes[j].isAssignableFrom(Boolean.class) || paramTypes[j].isAssignableFrom(boolean.class)) {
                            for (int k = 0; k < var.getOutcomes().length; k++) {
                                outcomes[k] = Boolean.valueOf((String) var.getOutcomes()[k]);
                            }
                        }
                        varStates[var.getId()].setOutcomes(outcomes);
                        targetParameterMap[j] = var.getId();
                    }
                }
                targetConstructor = con;
            }
        }
    }
    if (targetConstructor == null) {
        throw new IllegalStateException(""Unable to find Constructor"");
    }
}",java:S3776,39
"public void setDecided(String varName, boolean bool){
}",java:S1186,16
"public Collection<ResourceTypePackage<?>> values(){
    return packages.values();
}",java:S1452,23
"public void collectParentEvidence(JunctionTreeClique clique, JunctionTreeSeparator sep, JunctionTreeClique child, JunctionTreeClique startClique){
    if (clique.getParentSeparator() != null) {
        collectParentEvidence(clique.getParentSeparator().getParent(), clique.getParentSeparator(), clique, startClique);
    }
    List<JunctionTreeSeparator> seps = clique.getChildren();
    for (JunctionTreeSeparator childSep : seps) {
        if (childSep.getChild() == child) {
            continue;
        }
        collectChildEvidence(childSep.getChild(), startClique);
    }
    passMessage(clique, child.getParentSeparator(), child);
}",java:S1172,13
"public void distributeParentEvidence(JunctionTreeClique clique, JunctionTreeSeparator sep, JunctionTreeClique child, JunctionTreeClique startClique){
    passMessage(child, child.getParentSeparator(), clique);
    if (clique.getParentSeparator() != null) {
        distributeParentEvidence(clique.getParentSeparator().getParent(), clique.getParentSeparator(), clique, startClique);
    }
    List<JunctionTreeSeparator> seps = clique.getChildren();
    for (JunctionTreeSeparator childSep : seps) {
        if (childSep.getChild() == child) {
            continue;
        }
        distributeChildEvidence(childSep.getChild(), startClique);
    }
}",java:S1172,13
"private static String getLambdaFingerprint(Object f){
    return f instanceof HashedExpression ? ((HashedExpression) f).getExpressionHash() : f.toString();
}",java:S2326,30
"private static String getLambdaFingerprint(Object f){
    return f instanceof HashedExpression ? ((HashedExpression) f).getExpressionHash() : f.toString();
}",java:S2326,30
"public T marginalize(){
    Object[] args = new Object[targetParameterMap.length];
    args[0] = this;
    for (int i = 1; i < targetParameterMap.length; i++) {
        int id = targetParameterMap[i];
        BayesVariableState varState = varStates[id];
        marginalize(varState);
        int highestIndex = 0;
        double highestValue = 0;
        int maximalCounts = 1;
        for (int j = 0, length = varState.getDistribution().length; j < length; j++) {
            if (varState.getDistribution()[j] > highestValue) {
                highestValue = varState.getDistribution()[j];
                highestIndex = j;
                maximalCounts = 1;
            } else if (j != 0 && varState.getDistribution()[j] == highestValue) {
                maximalCounts++;
            }
        }
        if (maximalCounts > 1) {
            int picked = randomGenerator.nextInt(maximalCounts);
            int count = 0;
            for (int j = 0, length = varState.getDistribution().length; j < length; j++) {
                if (varState.getDistribution()[j] == highestValue) {
                    highestIndex = j;
                    if (++count > picked) {
                        break;
                    }
                }
            }
        }
        args[i] = varState.getOutcomes()[highestIndex];
    }
    try {
        return targetConstructor.newInstance(args);
    } catch (Exception e) {
        throw new RuntimeException(""Unable to instantiate "" + targetClass.getSimpleName() + "" "" + Arrays.asList(args), e);
    }
}",java:S3776,39
"public Argument<?>[] getArguments(){
    return arguments;
}",java:S1452,23
"public BayesInstance getBayesInstance(String pkgName, String name){
    return null;
}",java:S1172,13
"public Class<?> loadClass(String className) throws ClassNotFoundException{
    try {
        return super.loadClass(className);
    } catch (ClassNotFoundException cnfe) {
    }
    String fileName = className.replace('.', '/') + "".class"";
    byte[] bytes = mfs.getBytes(fileName);
    if (bytes == null) {
        throw new ClassNotFoundException(className);
    }
    return defineClass(className, bytes, 0, bytes.length);
}",java:S1161,11
"public RuleSourceResult getRulesSource(){
    boolean hasRuleUnit = !ruleUnits.isEmpty();
    CompilationUnit cu = new CompilationUnit();
    cu.setPackageDeclaration(name);
    manageImportForCompilationUnit(cu);
    ClassOrInterfaceDeclaration rulesClass = cu.addClass(rulesFileName);
    rulesClass.addImplementedType(Model.class.getCanonicalName());
    BodyDeclaration<?> dateFormatter = parseBodyDeclaration(""public final static java.time.format.DateTimeFormatter "" + DATE_TIME_FORMATTER_FIELD + "" = new java.time.format.DateTimeFormatterBuilder().parseCaseInsensitive().appendPattern(org.drools.util.DateUtils.getDateFormatMask()).toFormatter(java.util.Locale.ENGLISH);\n"");
    rulesClass.addMember(dateFormatter);
    BodyDeclaration<?> getNameMethod = parseBodyDeclaration(""    @Override\n"" + ""    public String getName() {\n"" + ""        return \"""" + name + ""\"";\n"" + ""    }\n"");
    rulesClass.addMember(getNameMethod);
    BodyDeclaration<?> getGlobalsMethod = parseBodyDeclaration(""    @Override\n"" + ""    public java.util.List<org.drools.model.Global> getGlobals() {\n"" + ""        return globals;\n"" + ""    }\n"");
    rulesClass.addMember(getGlobalsMethod);
    BodyDeclaration<?> getTypeMetaDataMethod = parseBodyDeclaration(""    @Override\n"" + ""    public java.util.List<org.drools.model.TypeMetaData> getTypeMetaDatas() {\n"" + ""        return typeMetaDatas;\n"" + ""    }\n"");
    rulesClass.addMember(getTypeMetaDataMethod);
    for (Map.Entry<String, TypedExpression> dateField : dateFields.entrySet()) {
        FieldDeclaration f = rulesClass.addField(dateField.getValue().getJPType(), dateField.getKey(), publicModifier().getKeyword(), staticModifier().getKeyword(), finalModifier().getKeyword());
        f.getVariables().get(0).setInitializer(dateField.getValue().getExpression());
    }
    for (Map.Entry<String, MethodCallExpr> windowReference : windowReferences.entrySet()) {
        FieldDeclaration f = rulesClass.addField(WINDOW_REFERENCE_TYPE, windowReference.getKey(), publicModifier().getKeyword(), staticModifier().getKeyword(), finalModifier().getKeyword());
        f.getVariables().get(0).setInitializer(windowReference.getValue());
    }
    for (Map.Entry<String, QueryGenerator.QueryDefWithType> queryDef : queryDefWithType.entrySet()) {
        FieldDeclaration field = rulesClass.addField(queryDef.getValue().getQueryType(), queryDef.getKey(), publicModifier().getKeyword(), staticModifier().getKeyword(), finalModifier().getKeyword());
        field.getVariables().get(0).setInitializer(queryDef.getValue().getMethodCallExpr());
    }
    InitializerDeclaration rulesListInitializer = new InitializerDeclaration();
    BlockStmt rulesListInitializerBody = new BlockStmt();
    rulesListInitializer.setBody(rulesListInitializerBody);
    for (Map.Entry<String, java.lang.reflect.Type> g : globals.entrySet()) {
        addGlobalField(rulesClass, rulesListInitializerBody, getName(), g.getKey(), g.getValue());
    }
    rulesClass.addMember(generateListField(""org.drools.model.Global"", ""globals"", globals.isEmpty() && !hasRuleUnit));
    if (!typeMetaDataExpressions.isEmpty()) {
        BodyDeclaration<?> typeMetaDatasList = parseBodyDeclaration(""java.util.List<org.drools.model.TypeMetaData> typeMetaDatas = new java.util.ArrayList<>();"");
        rulesClass.addMember(typeMetaDatasList);
        for (Expression expr : typeMetaDataExpressions) {
            addInitStatement(rulesListInitializerBody, expr, ""typeMetaDatas"");
        }
    } else {
        BodyDeclaration<?> typeMetaDatasList = parseBodyDeclaration(""java.util.List<org.drools.model.TypeMetaData> typeMetaDatas = java.util.Collections.emptyList();"");
        rulesClass.addMember(typeMetaDatasList);
    }
    functions.forEach(rulesClass::addMember);
    RuleSourceResult results = new RuleSourceResult(cu);
    if (hasRuleUnit) {
        rulesClass.addModifier(Modifier.Keyword.ABSTRACT);
        ruleUnitMembers.forEach((unitName, unitMembers) -> {
            String className = rulesFileName + ""_"" + unitName;
            ClassOrInterfaceDeclaration unitClass = createCompilationUnit(results).addClass(className);
            unitClass.addExtendedType(rulesFileName);
            InitializerDeclaration unitInitializer = new InitializerDeclaration();
            BlockStmt unitInitializerBody = new BlockStmt();
            unitInitializer.setBody(unitInitializerBody);
            generateRulesInUnit(unitName, unitMembers, unitInitializerBody, results, unitClass);
            unitClass.addMember(generateGetEntryPointsMethod(unitMembers.entryPoints));
            for (Map.Entry<String, java.lang.reflect.Type> g : unitMembers.globals.entrySet()) {
                addGlobalField(unitClass, unitInitializerBody, getName(), g.getKey(), g.getValue());
            }
            Set<QueryModel> queries = queriesByRuleUnit.get(unitName);
            Collection<String> queryNames = queries == null ? Collections.emptyList() : queries.stream().map(QueryModel::getName).map(StringUtil::toId).map(name -> QUERY_METHOD_PREFIX + name).collect(toList());
            Collection<MethodDeclaration> queryImpls = queryNames.stream().map(queryMethods::get).collect(toList());
            generateQueriesInUnit(unitClass, unitInitializerBody, queryNames, queryImpls);
            if (!unitInitializerBody.getStatements().isEmpty()) {
                unitClass.addMember(unitInitializer);
            }
        });
    } else {
        generateRulesInUnit(DEFAULT_RULE_UNIT, ruleUnitMembers.get(DEFAULT_RULE_UNIT), rulesListInitializerBody, results, rulesClass);
        generateQueriesInUnit(rulesClass, rulesListInitializerBody, queryMethods.keySet(), queryMethods.values());
        rulesClass.addMember(generateGetEntryPointsMethod(entryPoints));
    }
    if (!rulesListInitializerBody.getStatements().isEmpty()) {
        rulesClass.addMember(rulesListInitializer);
    }
    return results;
}",java:S3776,39
"private void generateRulesInUnit(String ruleUnitName, RuleUnitMembers ruleUnitMembers, BlockStmt rulesListInitializerBody, RuleSourceResult results, ClassOrInterfaceDeclaration rulesClass){
    results.withModel(name + ""."" + ruleUnitName, name + ""."" + rulesClass.getNameAsString());
    Collection<MethodDeclaration> ruleMethodsInUnit = ruleUnitMembers != null ? ruleUnitMembers.ruleMethods.values() : null;
    if (ruleMethodsInUnit == null || ruleMethodsInUnit.isEmpty()) {
        BodyDeclaration<?> getQueriesMethod = parseBodyDeclaration(""    @Override\n"" + ""    public java.util.List<org.drools.model.Rule> getRules() {\n"" + ""        return java.util.Collections.emptyList();\n"" + ""    }\n"");
        rulesClass.addMember(getQueriesMethod);
        return;
    }
    if (!ruleUnitName.equals(DEFAULT_RULE_UNIT)) {
        BodyDeclaration<?> modelNameMethod = parseBodyDeclaration(""    @Override\n"" + ""    public String getName() {\n"" + ""        return super.getName() + \""."" + ruleUnitName + ""\"";\n"" + ""    }\n"");
        rulesClass.addMember(modelNameMethod);
        BodyDeclaration<?> modelPackageNameMethod = parseBodyDeclaration(""    @Override\n"" + ""    public String getPackageName() {\n"" + ""        return super.getName();\n"" + ""    }\n"");
        rulesClass.addMember(modelPackageNameMethod);
    }
    createAndAddGetRulesMethod(rulesClass);
    int ruleCount = ruleMethodsInUnit.size();
    boolean requiresMultipleRulesLists = ruleCount >= RULES_DECLARATION_PER_CLASS - 1;
    boolean parallelRulesLoad = ruleCount >= (RULES_DECLARATION_PER_CLASS * 3 - 1);
    MethodCallExpr parallelRulesGetter = null;
    MethodCallExpr rules = buildRulesField(rulesClass);
    if (requiresMultipleRulesLists) {
        rulesClass.addImplementedType(RulesSupplier.class);
        if (parallelRulesLoad) {
            parallelRulesGetter = new MethodCallExpr(new NameExpr(RulesSupplier.class.getCanonicalName()), ""getRules"");
            parallelRulesGetter.addArgument(new ThisExpr());
            rulesListInitializerBody.addStatement(new AssignExpr(new NameExpr(""this.rules""), parallelRulesGetter, AssignExpr.Operator.ASSIGN));
        } else {
            MethodCallExpr add = new MethodCallExpr(new NameExpr(""rules""), ""addAll"");
            add.addArgument(""getRulesList()"");
            rulesListInitializerBody.addStatement(add);
        }
    }
    ruleMethodsInUnit.parallelStream().forEach(DrlxParseUtil::transformDrlNameExprToNameExpr);
    int maxLength = ruleMethodsInUnit.parallelStream().map(MethodDeclaration::toString).mapToInt(String::length).max().orElse(1);
    int rulesPerClass = oneClassPerRule ? 1 : Math.max(50000 / maxLength, 1);
    int count = -1;
    Map<Integer, ClassOrInterfaceDeclaration> splitted = new LinkedHashMap<>();
    for (MethodDeclaration ruleMethod : ruleMethodsInUnit) {
        String methodName = ruleMethod.getNameAsString();
        ClassOrInterfaceDeclaration rulesMethodClass = splitted.computeIfAbsent(++count / rulesPerClass, i -> {
            String className = rulesClass.getNameAsString() + (oneClassPerRule ? ""_"" + methodName : ""RuleMethods"" + i);
            CompilationUnit cu = createCompilationUnit(results);
            cu.getImports().add(new ImportDeclaration(new Name(name + ""."" + rulesClass.getNameAsString()), true, true));
            return cu.addClass(className);
        });
        rulesMethodClass.addMember(ruleMethod);
        if (count % RULES_DECLARATION_PER_CLASS == RULES_DECLARATION_PER_CLASS - 1) {
            int index = count / RULES_DECLARATION_PER_CLASS;
            rules = buildRulesField(results, index);
            ObjectCreationExpr newObject = new ObjectCreationExpr(null, toClassOrInterfaceType(rulesFileName + ""Rules"" + index), NodeList.nodeList());
            if (parallelRulesLoad) {
                parallelRulesGetter.addArgument(newObject);
            } else {
                MethodCallExpr add = new MethodCallExpr(new NameExpr(""rules""), ""addAll"");
                add.addArgument(new MethodCallExpr(newObject, ""getRulesList""));
                rulesListInitializerBody.addStatement(add);
            }
        }
        rules.addArgument(new MethodCallExpr(new NameExpr(rulesMethodClass.getNameAsString()), methodName));
    }
    BodyDeclaration<?> rulesList = requiresMultipleRulesLists ? parseBodyDeclaration(""java.util.List<org.drools.model.Rule> rules = new java.util.ArrayList<>("" + ruleCount + "");"") : parseBodyDeclaration(""java.util.List<org.drools.model.Rule> rules = getRulesList();"");
    rulesClass.addMember(rulesList);
}",java:S3776,39
"public void visit(CompilationUnit u, Void arg){
    PackageDeclaration packageDeclaration = u.getPackageDeclaration().orElseThrow(() -> new ParseException(""Expected package declaration."", -1));
    String pkgName = packageDeclaration.getNameAsString();
    builder.name(pkgName);
    for (ImportDeclaration i : u.getImports()) {
        this.visit(i, null);
    }
    ModuleDeclaration moduleDeclaration = u.getModule().orElseThrow(() -> new ParseException(""Expected unit declaration."", -1));
    builder.newUnit().target(String.format(""%s.%s"", pkgName, moduleDeclaration.getNameAsString()));
    for (TypeDeclaration<?> typeDeclaration : u.getTypes()) {
        RuleDeclaration rd = (RuleDeclaration) typeDeclaration;
        this.visit(rd, null);
    }
}",java:S1161,11
"public void visit(RuleDeclaration decl, Void v){
    this.ruleDescrBuilder = builder.newRule();
    ruleDescrBuilder.name(decl.getNameAsString());
    CEDescrBuilder<?, ?> lhs = ruleDescrBuilder.lhs();
    lhsList.push(lhs);
    for (RuleItem item : decl.getRuleBody().getItems()) {
        item.accept(this, v);
    }
    lhsList.pop();
    ruleDescrBuilder = null;
}",java:S1161,11
"public void visit(RulePattern p, Void v){
    CEDescrBuilder<?, ?> lhs = lhsList.peek();
    PatternDescrBuilder<? extends CEDescrBuilder<?, ?>> pat = lhs.pattern();
    if (p.getBind() == null) {
        pat.constraint(PrintUtil.printNode(p.getExpr()));
    } else {
        pat.id(PrintUtil.printNode(p.getBind()), false).constraint(PrintUtil.printNode(p.getExpr()));
    }
}",java:S1161,11
"public void visit(RuleConsequence c, Void v){
    ruleDescrBuilder.rhs(PrintUtil.printNode(c.getStatement()));
}",java:S1161,11
"public void visit(RuleJoinedPatterns jp, Void v){
    if (jp.getType() == RuleJoinedPatterns.Type.AND) {
        CEDescrBuilder<?, ?> lhs = lhsList.peek().and();
        lhsList.push(lhs);
        for (RuleItem item : jp.getItems()) {
            item.accept(this, v);
        }
        lhsList.pop();
        return;
    }
    if (jp.getType() == RuleJoinedPatterns.Type.OR) {
        CEDescrBuilder<?, ?> lhs = lhsList.peek().or();
        lhsList.push(lhs);
        for (RuleItem ruleItem : jp.getItems()) {
            ruleItem.accept(this, v);
        }
        lhsList.pop();
        return;
    }
}",java:S1161,11
"private boolean rewriteMethodCall(List<MethodCallExpr> updateExprs, MethodCallExpr methodCallExpr){
    if (methodCallExpr.getScope().isPresent()) {
        if (dataStoreMethods.contains(methodCallExpr.getNameAsString())) {
            Expression scope = methodCallExpr.getScope().get();
            if (isDataStoreScope(scope)) {
                if (methodCallExpr.getNameAsString().equals(""addLogical"") && !TruthMaintenanceSystemFactory.present()) {
                    context.addCompilationError(new MissingDependencyError(TruthMaintenanceSystemFactory.NO_TMS));
                }
                NodeList<Expression> args = NodeList.nodeList(new CastExpr(toClassOrInterfaceType(org.kie.api.runtime.rule.RuleContext.class), new NameExpr(""drools"")), methodCallExpr.getScope().get());
                methodCallExpr.setScope(new ObjectCreationExpr(null, toClassOrInterfaceType(""org.drools.ruleunits.impl.datasources.ConsequenceDataStoreImpl""), args));
            }
        }
    } else if (implicitDroolsMethods.contains(methodCallExpr.getNameAsString())) {
        if (methodCallExpr.getNameAsString().equals(""insertLogical"") && !TruthMaintenanceSystemFactory.present()) {
            context.addCompilationError(new MissingDependencyError(TruthMaintenanceSystemFactory.NO_TMS));
        }
        methodCallExpr.setScope(new NameExpr(""drools""));
    }
    if (hasDroolsScope(methodCallExpr) || hasDroolsAsParameter(methodCallExpr)) {
        if (knowledgeHelperMethods.contains(methodCallExpr.getNameAsString())) {
            methodCallExpr.setScope(createAsKnowledgeHelperExpression());
        } else if (methodCallExpr.getNameAsString().equals(""update"")) {
            if (methodCallExpr.toString().contains(""FactHandle"")) {
                methodCallExpr.setScope(new EnclosedExpr(new CastExpr(toClassOrInterfaceType(DroolsImpl.class), new NameExpr(""drools""))));
            }
            updateExprs.add(methodCallExpr);
        } else if (methodCallExpr.getNameAsString().equals(""retract"")) {
            methodCallExpr.setName(new SimpleName(""delete""));
        }
        return true;
    }
    return false;
}",java:S3776,39
"private void addUpdateBitMask(BlockStmt ruleBlock, List<MethodCallExpr> methodCallExprs, List<AssignExpr> assignExprs, List<MethodCallExpr> updateExprs, Map<String, Type> rhsBodyDeclarations){
    Set<String> initializedBitmaskFields = new HashSet<>();
    for (MethodCallExpr updateExpr : updateExprs) {
        Expression argExpr = updateExpr.getArgument(0);
        if (argExpr instanceof NameExpr) {
            String updatedVar = ((NameExpr) argExpr).getNameAsString();
            Class<?> updatedClass = classFromRHSDeclarations(rhsBodyDeclarations, updatedVar);
            context.getPackageModel().registerDomainClass(updatedClass);
            if (context.isPropertyReactive(updatedClass)) {
                if (!initializedBitmaskFields.contains(updatedVar)) {
                    Set<String> modifiedProps = findModifiedProperties(methodCallExprs, updatedVar, updatedClass);
                    modifiedProps.addAll(findModifiedPropertiesFromAssignment(assignExprs, updatedVar));
                    MethodCallExpr bitMaskCreation = createBitMaskInitialization(updatedClass, modifiedProps);
                    AssignExpr bitMaskAssign = createBitMaskField(updatedVar, bitMaskCreation);
                    if (!DrlxParseUtil.hasDuplicateExpr(ruleBlock, bitMaskAssign)) {
                        ruleBlock.addStatement(bitMaskAssign);
                    }
                }
                Expression bitMaskArgExpr = new NameExpr(""mask_"" + updatedVar);
                if (hasRuleUnit() && updateExpr.toString().contains(""ConsequenceDataStoreImpl"")) {
                    bitMaskArgExpr = new MethodCallExpr(""org.drools.modelcompiler.util.EvaluationUtil.adaptBitMask"", bitMaskArgExpr);
                }
                updateExpr.addArgument(bitMaskArgExpr);
                initializedBitmaskFields.add(updatedVar);
            }
        }
    }
}",java:S3776,39
"private Set<String> findModifiedProperties(List<MethodCallExpr> methodCallExprs, String updatedVar, Class<?> updatedClass){
    Set<String> modifiedProps = new HashSet<>();
    for (MethodCallExpr methodCall : methodCallExprs) {
        if (!isDirectExpression(methodCall)) {
            continue;
        }
        DrlxParseUtil.RemoveRootNodeResult removeRootNodeViaScope = DrlxParseUtil.findRemoveRootNodeViaScope(methodCall);
        Optional<Expression> root = removeRootNodeViaScope.getRootNode().filter(s -> isNameExprWithName(s, updatedVar));
        if (methodCall.getScope().isPresent() && root.isPresent()) {
            boolean isDirectMethod = removeRootNodeViaScope.getFirstChild().equals(removeRootNodeViaScope.getWithoutRootNode());
            if (isDirectMethod) {
                ClassDefinition clsDef = packageModel.getClassDefinition(updatedClass);
                if (clsDef != null) {
                    String methodName = methodCall.getNameAsString();
                    int argNum = methodCall.getArguments().size();
                    List<String> propNames = clsDef.getModifiedPropsByMethod(methodName, argNum);
                    if (propNames != null && !propNames.isEmpty()) {
                        modifiedProps.addAll(propNames);
                        continue;
                    }
                }
            }
            String propName = null;
            if (isDirectMethod && isSetter(methodCall.getNameAsString())) {
                propName = setter2property(methodCall.getNameAsString());
            } else if (!isDirectMethod && !isGetter(methodCall.getNameAsString())) {
                Expression firstExpr = removeRootNodeViaScope.getFirstChild();
                if (firstExpr.isMethodCallExpr()) {
                    propName = getter2property(firstExpr.asMethodCallExpr().getNameAsString());
                }
            } else {
                continue;
            }
            if (propName != null) {
                if (isReadableProperty(updatedClass, propName)) {
                    modifiedProps.add(propName);
                }
            } else {
                return new HashSet<>();
            }
        }
    }
    return modifiedProps;
}",java:S3776,39
"private String generateNewId(){
    return generateName(""expr"");
}",java:S1144,10
"public static TypedExpression nameExprToMethodCallExpr(String name, java.lang.reflect.Type type, Expression scope, RuleContext context){
    if (type == null) {
        return null;
    }
    Class<?> clazz = toRawClass(type);
    Method accessor = getAccessor(clazz, name, context);
    if (accessor != null) {
        MethodCallExpr body = new MethodCallExpr(scope, accessor.getName());
        return new TypedExpression(body, accessor.getGenericReturnType());
    } else {
        for (Class<?> declaredClass : clazz.getClasses()) {
            if (declaredClass.getCanonicalName().endsWith(""."" + name)) {
                FieldAccessExpr fieldAccessExpr = new FieldAccessExpr(scope, name);
                return new TypedExpression(fieldAccessExpr, declaredClass);
            }
        }
    }
    if (clazz.isArray() && name.equals(""length"")) {
        FieldAccessExpr expr = new FieldAccessExpr(scope != null ? scope : new NameExpr(THIS_PLACEHOLDER), name);
        return new TypedExpression(expr, int.class);
    }
    try {
        Field field = clazz.getField(name);
        if (scope == null) {
            scope = new NameExpr(Modifier.isStatic(field.getModifiers()) ? clazz.getCanonicalName() : THIS_PLACEHOLDER);
        }
        FieldAccessExpr expr = new FieldAccessExpr(scope, name);
        return new TypedExpression(expr, field.getType());
    } catch (NoSuchFieldException e) {
    }
    if (Map.class.isAssignableFrom(clazz)) {
        MethodCallExpr body = new MethodCallExpr(scope, ""get"", new NodeList<>(new StringLiteralExpr(name)));
        return new TypedExpression(body, Object.class);
    }
    return null;
}",java:S3776,39
"public static java.lang.reflect.Type getExpressionType(RuleContext context, TypeResolver typeResolver, Expression expr, Collection<String> usedDeclarations){
    if (expr instanceof LiteralExpr) {
        return getLiteralExpressionType((LiteralExpr) expr);
    }
    if (expr instanceof UnaryExpr) {
        return getExpressionType(context, typeResolver, expr.asUnaryExpr().getExpression(), usedDeclarations);
    }
    if (expr instanceof ArrayAccessExpr) {
        return getClassFromContext(typeResolver, ((ArrayCreationExpr) ((ArrayAccessExpr) expr).getName()).getElementType().asString());
    }
    if (expr instanceof ArrayCreationExpr) {
        return getClassFromContext(typeResolver, ((ArrayCreationExpr) expr).getElementType().asString());
    }
    if (expr instanceof MapCreationLiteralExpression) {
        return Map.class;
    }
    if (expr instanceof ListCreationLiteralExpression) {
        return List.class;
    }
    if (expr instanceof NameExpr) {
        return expressionTypeNameExpr(context, usedDeclarations, ((NameExpr) expr).getNameAsString());
    }
    if (expr instanceof DrlNameExpr) {
        return expressionTypeNameExpr(context, usedDeclarations, ((DrlNameExpr) expr).getNameAsString());
    }
    if (expr instanceof BinaryExpr) {
        return boolean.class;
    }
    if (expr instanceof MethodCallExpr) {
        MethodCallExpr methodCallExpr = (MethodCallExpr) expr;
        Optional<Expression> scopeExpression = methodCallExpr.getScope();
        if (scopeExpression.isPresent()) {
            java.lang.reflect.Type scopeType = getExpressionType(context, typeResolver, scopeExpression.get(), usedDeclarations);
            return returnTypeOfMethodCallExpr(context, typeResolver, methodCallExpr, scopeType, usedDeclarations);
        } else {
            throw new IllegalStateException(""Scope expression is not present for "" + ((MethodCallExpr) expr).getNameAsString() + ""!"");
        }
    }
    if (expr instanceof ObjectCreationExpr) {
        final ClassOrInterfaceType type = ((ObjectCreationExpr) expr).getType();
        return getClassFromContext(typeResolver, type.asString());
    }
    if (expr.isCastExpr()) {
        String typeName = expr.asCastExpr().getType().toString();
        try {
            return typeResolver.resolveType(expr.asCastExpr().getType().toString());
        } catch (ClassNotFoundException e) {
            context.addCompilationError(new InvalidExpressionErrorResult(""Unknown type in cast expression: "" + typeName));
            throw new RuntimeException(""Unknown type in cast expression: "" + typeName);
        }
    }
    if (expr instanceof ConditionalExpr) {
        ConditionalExpr ternaryExpr = ((ConditionalExpr) expr);
        java.lang.reflect.Type conditionType = getExpressionType(context, typeResolver, ternaryExpr.getCondition(), usedDeclarations);
        if (conditionType != Boolean.class && conditionType != boolean.class) {
            context.addCompilationError(new InvalidExpressionErrorResult(""Condtion used in ternary expression '"" + expr + ""' isn't boolean""));
            return Object.class;
        }
        java.lang.reflect.Type leftType = getExpressionType(context, typeResolver, ternaryExpr.getThenExpr(), usedDeclarations);
        java.lang.reflect.Type rightType = getExpressionType(context, typeResolver, ternaryExpr.getElseExpr(), usedDeclarations);
        Class<?> leftClass = toRawClass(leftType);
        Class<?> rightClass = toRawClass(rightType);
        if (leftClass.isAssignableFrom(rightClass)) {
            return leftType;
        }
        if (rightClass.isAssignableFrom(leftClass)) {
            return rightType;
        }
        return Object.class;
    }
    if (expr.isClassExpr()) {
        return Class.class;
    }
    throw new RuntimeException(""Unknown expression type: "" + PrintUtil.printNode(expr));
}",java:S3776,39
"private static RemoveRootNodeResult findRootNodeViaScopeRec(Expression expr, LinkedList<Expression> acc){
    if (expr.isArrayAccessExpr()) {
        throw new RuntimeException(""This doesn't work on arrayAccessExpr convert them to a method call"");
    }
    if (expr instanceof EnclosedExpr) {
        return findRootNodeViaScopeRec(expr.asEnclosedExpr().getInner(), acc);
    } else if (expr instanceof CastExpr) {
        return findRootNodeViaScopeRec(expr.asCastExpr().getExpression(), acc);
    } else if (expr instanceof ThisExpr) {
        return new RemoveRootNodeResult(Optional.of(expr), expr, expr);
    } else if (expr instanceof NodeWithTraversableScope) {
        final NodeWithTraversableScope exprWithScope = (NodeWithTraversableScope) expr;
        return exprWithScope.traverseScope().flatMap((Expression scope) -> {
            if (isDslTopLevelNamespace(scope)) {
                return empty();
            }
            Expression sanitizedExpr = DrlxParseUtil.transformDrlNameExprToNameExpr(expr);
            acc.addLast(sanitizedExpr.clone());
            return of(findRootNodeViaScopeRec(scope, acc));
        }).orElse(new RemoveRootNodeResult(Optional.of(expr), expr, acc.isEmpty() ? expr : acc.getLast()));
    } else if (expr instanceof NameExpr) {
        if (!acc.isEmpty() && acc.getLast() instanceof NodeWithOptionalScope<?>) {
            ((NodeWithOptionalScope<?>) acc.getLast()).setScope(null);
            for (ListIterator<Expression> iterator = acc.listIterator(); iterator.hasNext(); ) {
                Expression e = iterator.next();
                if (e instanceof NodeWithOptionalScope) {
                    NodeWithOptionalScope<?> node = (NodeWithOptionalScope<?>) e;
                    if (iterator.hasNext()) {
                        node.setScope(acc.get(iterator.nextIndex()));
                    }
                }
            }
            return new RemoveRootNodeResult(Optional.of(expr), acc.getFirst(), acc.getLast());
        } else {
            return new RemoveRootNodeResult(Optional.of(expr), expr, expr);
        }
    }
    return new RemoveRootNodeResult(empty(), expr, expr);
}",java:S3776,39
"public static Type toJavaParserType(Class<?> cls, boolean primitive){
    if (primitive) {
        if (cls == int.class || cls == Integer.class) {
            return PrimitiveType.intType();
        } else if (cls == char.class || cls == Character.class) {
            return PrimitiveType.charType();
        } else if (cls == long.class || cls == Long.class) {
            return PrimitiveType.longType();
        } else if (cls == short.class || cls == Short.class) {
            return PrimitiveType.shortType();
        } else if (cls == double.class || cls == Double.class) {
            return PrimitiveType.doubleType();
        } else if (cls == float.class || cls == Float.class) {
            return PrimitiveType.floatType();
        } else if (cls == boolean.class || cls == Boolean.class) {
            return PrimitiveType.booleanType();
        } else if (cls == byte.class || cls == Byte.class) {
            return PrimitiveType.byteType();
        }
    }
    return toClassOrInterfaceType(cls);
}",java:S3776,39
"public static void rescopeNamesToNewScope(Expression newScope, List<String> names, Node e){
    if (e instanceof NodeWithArguments) {
        NodeWithArguments<?> arguments = (NodeWithArguments) e;
        for (Expression argument : arguments.getArguments()) {
            rescopeNamesToNewScope(newScope, names, argument);
        }
    }
    if (e instanceof AssignExpr) {
        AssignExpr assignExpr = (AssignExpr) e;
        rescopeNamesToNewScope(newScope, names, assignExpr.getTarget());
        rescopeNamesToNewScope(newScope, names, assignExpr.getValue());
    } else if (e instanceof BinaryExpr) {
        rescopeNamesToNewScope(newScope, names, ((BinaryExpr) e).getLeft());
        rescopeNamesToNewScope(newScope, names, ((BinaryExpr) e).getRight());
    } else if (e instanceof UnaryExpr) {
        rescopeNamesToNewScope(newScope, names, ((UnaryExpr) e).getExpression());
    } else if (e instanceof EnclosedExpr) {
        rescopeNamesToNewScope(newScope, names, ((EnclosedExpr) e).getInner());
    } else if (e instanceof Expression) {
        Optional<Expression> rootNode = DrlxParseUtil.findRootNodeViaScope((Expression) e);
        if (rootNode.isPresent() && rootNode.get() instanceof NameExpr) {
            NameExpr nameExpr = (NameExpr) rootNode.get();
            if (names.contains(nameExpr.getNameAsString())) {
                Expression prepend = new FieldAccessExpr(newScope, nameExpr.getNameAsString());
                if (e instanceof NameExpr) {
                    Optional<Node> parentNode = e.getParentNode();
                    if (parentNode.isPresent()) {
                        parentNode.get().replace(nameExpr, prepend);
                    } else {
                        throw new IllegalStateException(""Cannot find parent node for "" + ((NameExpr) e).getNameAsString() + ""!"");
                    }
                } else {
                    e.replace(nameExpr, prepend);
                }
            }
        }
    } else {
        for (Node child : e.getChildNodes()) {
            rescopeNamesToNewScope(newScope, names, child);
        }
    }
}",java:S3776,39
"private static List<MethodCallExpr> ruleAttributes(RuleContext context, RuleDescr ruleDescr){
    final List<MethodCallExpr> ruleAttributes = new ArrayList<>();
    final Set<Entry<String, AttributeDescr>> excludingDialect = ruleDescr.getAttributes().entrySet().stream().filter(r -> !r.getKey().equals(""dialect"")).collect(Collectors.toSet());
    for (Entry<String, AttributeDescr> as : excludingDialect) {
        MethodCallExpr attributeCall = new MethodCallExpr(null, ATTRIBUTE_CALL);
        attributeCall.addArgument(attributesMap.get(as.getKey()));
        String value = as.getValue().getValue().trim();
        switch(as.getKey()) {
            case ""salience"":
                try {
                    Integer.parseInt(value);
                    attributeCall.addArgument(value);
                } catch (NumberFormatException nfe) {
                    addDynamicAttributeArgument(context, attributeCall, value, int.class);
                }
                break;
            case ""enabled"":
                if (value.equalsIgnoreCase(""true"") || value.equalsIgnoreCase(""false"")) {
                    attributeCall.addArgument(value.toLowerCase());
                } else {
                    addDynamicAttributeArgument(context, attributeCall, value, boolean.class);
                }
                break;
            case ""no-loop"":
            case ""auto-focus"":
            case ""lock-on-active"":
                attributeCall.addArgument(value);
                break;
            case ""agenda-group"":
            case ""activation-group"":
            case ""ruleflow-group"":
            case ""duration"":
                attributeCall.addArgument(toStringLiteral(value));
                break;
            case ""timer"":
                if (validateTimer(value)) {
                    attributeCall.addArgument(toStringLiteral(value));
                } else {
                    context.addCompilationError(new InvalidExpressionErrorResult(value));
                }
                break;
            case ""calendars"":
                if (value.startsWith(""["")) {
                    value = value.substring(1, value.length() - 1).trim();
                }
                Expression arrayExpr = parseExpression(""new String[] { "" + value + "" }"");
                attributeCall.addArgument(arrayExpr);
                break;
            case ""date-effective"":
            case ""date-expires"":
                attributeCall.addArgument(parseExpression(String.format(""java.util.GregorianCalendar.from(java.time.LocalDate.parse(\""%s\"", "" + DATE_TIME_FORMATTER_FIELD + "").atStartOfDay(java.time.ZoneId.systemDefault()))"", as.getValue().getValue())));
                break;
            default:
                throw new UnsupportedOperationException(""Unhandled case for rule attribute: "" + as.getKey());
        }
        ruleAttributes.add(attributeCall);
    }
    return ruleAttributes;
}",java:S3776,39
"private static List<MethodCallExpr> ruleMetaAttributes(RuleContext context, RuleDescr ruleDescr){
    List<MethodCallExpr> ruleMetaAttributes = new ArrayList<>();
    for (String metaAttr : ruleDescr.getAnnotationNames()) {
        MethodCallExpr metaAttributeCall = new MethodCallExpr(METADATA_CALL);
        metaAttributeCall.addArgument(toStringLiteral(metaAttr));
        AnnotationDescr ad = ruleDescr.getAnnotation(metaAttr);
        String adFqn = ad.getFullyQualifiedName();
        if (""Propagation"".equals(metaAttr)) {
            metaAttributeCall.addArgument(parseExpression(org.kie.api.definition.rule.Propagation.Type.class.getCanonicalName() + ""."" + ad.getSingleValueAsString()));
        } else if (adFqn != null) {
            AnnotationDefinition annotationDefinition;
            try {
                annotationDefinition = AnnotationDefinition.build(context.getTypeResolver().resolveType(adFqn), ad.getValueMap(), context.getTypeResolver());
            } catch (NoSuchMethodException | ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
            if (annotationDefinition.getValues().size() == 1 && annotationDefinition.getValues().containsKey(AnnotationDescr.VALUE)) {
                Object annValue = annotationDefinition.getPropertyValue(AnnotationDescr.VALUE);
                metaAttributeCall.addArgument(toStringLiteral(annValue.toString()));
            } else {
                Map<String, Object> map = new HashMap<>(annotationDefinition.getValues().size());
                for (String key : annotationDefinition.getValues().keySet()) {
                    map.put(key, annotationDefinition.getPropertyValue(key));
                }
                metaAttributeCall.addArgument(objectAsJPExpression(map));
            }
        } else {
            if (ad.hasValue()) {
                if (ad.getValueMap().size() == 1) {
                    metaAttributeCall.addArgument(annotationSingleValueExpression(ad));
                } else {
                    metaAttributeCall.addArgument(objectAsJPExpression(ad.getValueMap()));
                }
            } else {
                metaAttributeCall.addArgument(new NullLiteralExpr());
            }
        }
        ruleMetaAttributes.add(metaAttributeCall);
    }
    return ruleMetaAttributes;
}",java:S3776,39
"public void visit(Class<?> originalClass, String originalBind, DrlxParseSuccess patternParseResult){
    final OOPathExpr ooPathExpr = (OOPathExpr) patternParseResult.getExpr();
    Class<?> previousClass = originalClass;
    String previousBind = originalBind;
    NodeList<OOPathChunk> chunks = ooPathExpr.getChunks();
    boolean passive = false;
    for (int i = 0; i < chunks.size(); i++) {
        OOPathChunk chunk = chunks.get(i);
        if (chunk.isPassive()) {
            if (passive) {
                context.addCompilationError(new InvalidExpressionErrorResult(""Invalid oopath expression '"" + PrintUtil.printNode(ooPathExpr) + ""': It is not possible to have 2 non-reactive parts in the same oopath""));
                break;
            }
            passive = true;
        }
        final String fieldName = chunk.getField().toString();
        final TypedExpression callExpr = DrlxParseUtil.nameExprToMethodCallExpr(fieldName, previousClass, null, context);
        if (callExpr == null) {
            context.addCompilationError(new InvalidExpressionErrorResult(""Unknown field "" + fieldName + "" on "" + previousClass));
            break;
        }
        Class<?> fieldType = (chunk.getInlineCast() != null) ? DrlxParseUtil.getClassFromContext(context.getTypeResolver(), chunk.getInlineCast().toString()) : callExpr.getRawClass();
        Type exprType = callExpr.getType();
        Expression ooPathChunkExpr = prepend(new NameExpr(THIS_PLACEHOLDER), callExpr.getExpression());
        if (Iterable.class.isAssignableFrom(fieldType) || isDataSource(fieldType)) {
            if (chunk.isSingleValue()) {
                ooPathChunkExpr = new MethodCallExpr(null, ""java.util.Collections.singletonList"", NodeList.nodeList(ooPathChunkExpr));
                exprType = creteListParameterizedType(exprType);
            } else {
                fieldType = extractGenericType(previousClass, ((MethodCallExpr) callExpr.getExpression()).getName().toString());
            }
        }
        final Expression accessorLambda = createLambdaAccessor(previousClass, exprType, ooPathChunkExpr);
        final MethodCallExpr reactiveFrom = createFromExpr(previousBind, accessorLambda, passive);
        previousBind = bindOOPathChunk(originalBind, patternParseResult, i, i == chunks.size() - 1, chunk, fieldName, fieldType, accessorLambda, reactiveFrom);
        previousClass = fieldType;
    }
}",java:S3776,39
"private String bindOOPathChunk(String originalBind, DrlxParseSuccess patternParseResult, int pos, boolean isLast, OOPathChunk chunk, String fieldName, Class<?> fieldType, Expression accessorLambda, MethodCallExpr reactiveFrom){
    String previousBind;
    final String bindingId;
    if (isLast && patternParseResult.getExprBinding() != null) {
        bindingId = patternParseResult.getExprBinding();
        context.removeDeclarationById(bindingId);
    } else {
        bindingId = context.getOOPathId(fieldType, originalBind + fieldName + pos);
    }
    DeclarationSpec newDeclaration = context.addDeclaration(bindingId, fieldType, reactiveFrom);
    context.addOOPathDeclaration(newDeclaration);
    final List<DrlxExpression> conditions = chunk.getConditions();
    if (conditions.isEmpty()) {
        toPatternExpr(bindingId, Collections.emptyList(), patternParseResult, fieldType);
    } else if (conditions.size() == 1 && conditions.get(0).getExpr().isIntegerLiteralExpr()) {
        reactiveFrom.setArgument(1, new MethodCallExpr(accessorLambda, ""get"", new NodeList<>(conditions.get(0).getExpr())));
        toPatternExpr(bindingId, Collections.emptyList(), patternParseResult, fieldType);
    } else {
        Class<?> finalFieldType = fieldType;
        final List<DrlxParseResult> conditionParseResult = conditions.stream().map((DrlxExpression c) -> ConstraintParser.defaultConstraintParser(context, packageModel).drlxParse(finalFieldType, bindingId, PrintUtil.printNode(c))).collect(Collectors.toList());
        toPatternExpr(bindingId, conditionParseResult, patternParseResult, fieldType);
    }
    previousBind = bindingId;
    return previousBind;
}",java:S107,1
"private void toPatternExpr(String bindingId, List<DrlxParseResult> list, DrlxParseSuccess patternParseResult, Class<?> fieldType){
    MethodCallExpr patternExpr = createDslTopLevelMethod(PATTERN_CALL);
    patternExpr.addArgument(context.getVar(bindingId));
    SingleDrlxParseSuccess oopathConstraint = null;
    for (DrlxParseResult drlx : list) {
        if (drlx.isSuccess()) {
            SingleDrlxParseSuccess singleDrlx = (SingleDrlxParseSuccess) drlx;
            if (singleDrlx.isOOPath()) {
                if (oopathConstraint != null) {
                    throw new UnsupportedOperationException(""An oopath chunk can only have a single oopath constraint"");
                }
                oopathConstraint = singleDrlx;
                continue;
            }
            if (singleDrlx.getExprBinding() != null) {
                MethodCallExpr expr = expressionBuilder.buildBinding(singleDrlx);
                expr.setScope(patternExpr);
                patternExpr = expr;
            }
            if (singleDrlx.getExpr() != null && !(singleDrlx.getExpr() instanceof NameExpr)) {
                MethodCallExpr expr = expressionBuilder.buildExpressionWithIndexing(singleDrlx);
                expr.setScope(patternExpr);
                patternExpr = expr;
            }
        }
    }
    context.addExpression(patternExpr);
    if (bindingId.equals(patternParseResult.getExprBinding())) {
        context.registerOOPathPatternExpr(bindingId, patternExpr);
    }
    if (oopathConstraint != null) {
        new OOPathExprGenerator(context, packageModel).visit(fieldType, bindingId, oopathConstraint);
    }
}",java:S3776,39
"public CoercedExpressionResult coerce(){
    final Class<?> leftClass = left.getRawClass();
    final Class<?> nonPrimitiveLeftClass = toNonPrimitiveType(leftClass);
    final Class<?> rightClass = right.getRawClass();
    final Class<?> nonPrimitiveRightClass = toNonPrimitiveType(rightClass);
    boolean sameClass = leftClass == rightClass;
    boolean isUnificationExpression = left instanceof UnificationTypedExpression || right instanceof UnificationTypedExpression;
    if (sameClass || isUnificationExpression) {
        return new CoercedExpressionResult(left, right);
    }
    if (!canCoerce()) {
        throw new CoercedExpressionException(new InvalidExpressionErrorResult(""Comparison operation requires compatible types. Found "" + leftClass + "" and "" + rightClass));
    }
    if ((nonPrimitiveLeftClass == Integer.class || nonPrimitiveLeftClass == Long.class) && nonPrimitiveRightClass == Double.class) {
        CastExpr castExpression = new CastExpr(PrimitiveType.doubleType(), this.left.getExpression());
        return new CoercedExpressionResult(new TypedExpression(castExpression, double.class, left.getType()), right, false);
    }
    final boolean leftIsPrimitive = leftClass.isPrimitive() || Number.class.isAssignableFrom(leftClass);
    final boolean canCoerceLiteralNumberExpr = canCoerceLiteralNumberExpr(leftClass);
    boolean rightAsStaticField = false;
    final Expression rightExpression = right.getExpression();
    final TypedExpression coercedRight;
    if (leftIsPrimitive && canCoerceLiteralNumberExpr && rightExpression instanceof LiteralStringValueExpr) {
        final Expression coercedLiteralNumberExprToType = coerceLiteralNumberExprToType((LiteralStringValueExpr) right.getExpression(), leftClass);
        coercedRight = right.cloneWithNewExpression(coercedLiteralNumberExprToType);
        coercedRight.setType(leftClass);
    } else if (shouldCoerceBToString(left, right)) {
        coercedRight = coerceToString(right);
    } else if (isNotBinaryExpression(right) && canBeNarrowed(leftClass, rightClass) && right.isNumberLiteral()) {
        coercedRight = castToClass(leftClass);
    } else if (leftClass == long.class && rightClass == int.class) {
        coercedRight = right.cloneWithNewExpression(new CastExpr(PrimitiveType.longType(), right.getExpression()));
    } else if (leftClass == Date.class && rightClass == String.class) {
        coercedRight = coerceToDate(right);
        rightAsStaticField = true;
    } else if (leftClass == LocalDate.class && rightClass == String.class) {
        coercedRight = coerceToLocalDate(right);
        rightAsStaticField = true;
    } else if (leftClass == LocalDateTime.class && rightClass == String.class) {
        coercedRight = coerceToLocalDateTime(right);
        rightAsStaticField = true;
    } else if (shouldCoerceBToMap()) {
        coercedRight = castToClass(toNonPrimitiveType(leftClass));
    } else if (isBoolean(leftClass) && !isBoolean(rightClass)) {
        coercedRight = coerceBoolean(right);
    } else {
        coercedRight = right;
    }
    final TypedExpression coercedLeft;
    if (nonPrimitiveLeftClass == Character.class && shouldCoerceBToString(right, left)) {
        coercedLeft = coerceToString(left);
    } else {
        coercedLeft = left;
    }
    return new CoercedExpressionResult(coercedLeft, coercedRight, rightAsStaticField);
}",java:S3776,39
"private DrlxParseResult compileToJavaRecursive(Class<?> patternType, String bindingId, ConstraintExpression constraint, Expression drlxExpr, boolean hasBind, boolean isPositional){
    boolean isEnclosed = false;
    SimpleName bind = null;
    if (drlxExpr instanceof FullyQualifiedInlineCastExpr) {
        drlxExpr = transformFullyQualifiedInlineCastExpr(context.getTypeResolver(), (FullyQualifiedInlineCastExpr) drlxExpr);
    }
    while (drlxExpr instanceof EnclosedExpr) {
        drlxExpr = ((EnclosedExpr) drlxExpr).getInner();
        isEnclosed = true;
    }
    if (drlxExpr instanceof DrlxExpression) {
        bind = ((DrlxExpression) drlxExpr).getBind();
        drlxExpr = ((DrlxExpression) drlxExpr).getExpr();
    }
    if (drlxExpr instanceof MethodCallExpr && ((MethodCallExpr) drlxExpr).getScope().isEmpty() && ((MethodCallExpr) drlxExpr).getNameAsString().equals(""eval"")) {
        drlxExpr = ((MethodCallExpr) drlxExpr).getArgument(0);
    }
    if (drlxExpr instanceof MethodCallExpr) {
        Optional<DrlxParseFail> optFail = convertBigDecimalArithmetic((MethodCallExpr) drlxExpr, patternType, bindingId, isPositional);
        if (optFail.isPresent()) {
            return optFail.get();
        }
    }
    if (drlxExpr instanceof BinaryExpr) {
        DrlxParseResult result = parseBinaryExpr((BinaryExpr) drlxExpr, patternType, bindingId, constraint, drlxExpr, hasBind, isPositional, isEnclosed);
        if (result instanceof SingleDrlxParseSuccess && bind != null) {
            ((SingleDrlxParseSuccess) result).setExprBinding(bind.asString());
        }
        return result;
    }
    if (drlxExpr instanceof ConditionalExpr) {
        return parseConditionalExpr((ConditionalExpr) drlxExpr, patternType, bindingId, constraint, hasBind, isPositional);
    }
    if (drlxExpr instanceof UnaryExpr) {
        return parseUnaryExpr((UnaryExpr) drlxExpr, patternType, bindingId, constraint, drlxExpr, hasBind, isPositional);
    }
    if (drlxExpr instanceof PointFreeExpr) {
        return parsePointFreeExpr((PointFreeExpr) drlxExpr, patternType, bindingId, isPositional);
    }
    if (patternType == null && drlxExpr instanceof MethodCallExpr) {
        MethodCallExpr methodCallExpr = (MethodCallExpr) drlxExpr;
        Optional<MethodDeclaration> functionCall = packageModel.getFunctions().stream().filter(m -> m.getName().equals(methodCallExpr.getName())).findFirst();
        if (functionCall.isPresent()) {
            return parseFunctionInEval(methodCallExpr, patternType, bindingId, isPositional, functionCall);
        }
    }
    if (drlxExpr instanceof FieldAccessExpr) {
        return parseFieldAccessExpr((FieldAccessExpr) drlxExpr, patternType, bindingId);
    }
    String expression = constraint.getExpression();
    if (drlxExpr instanceof DrlNameExpr) {
        return parseNameExpr((DrlNameExpr) drlxExpr, patternType, bindingId, drlxExpr, hasBind, expression);
    }
    if (drlxExpr instanceof OOPathExpr) {
        return parseOOPathExpr((OOPathExpr) drlxExpr, patternType, bindingId, drlxExpr, hasBind, expression);
    }
    if (drlxExpr instanceof LiteralExpr) {
        Class<?> literalExpressionType = getLiteralExpressionType(((LiteralExpr) drlxExpr));
        if (drlxExpr instanceof BigIntegerLiteralExpr) {
            drlxExpr = ((BigIntegerLiteralExpr) drlxExpr).convertToObjectCreationExpr();
        } else if (drlxExpr instanceof BigDecimalLiteralExpr) {
            drlxExpr = ((BigDecimalLiteralExpr) drlxExpr).convertToObjectCreationExpr();
        }
        return new SingleDrlxParseSuccess(patternType, bindingId, drlxExpr, literalExpressionType).setIsPredicate(isBooleanBoxedUnboxed(literalExpressionType));
    }
    if (patternType != null) {
        ExpressionTyperContext expressionTyperContext = new ExpressionTyperContext();
        ExpressionTyper expressionTyper = new ExpressionTyper(context, patternType, bindingId, isPositional, expressionTyperContext);
        TypedExpressionResult leftTypedExpressionResult = expressionTyper.toTypedExpression(drlxExpr);
        Optional<TypedExpression> optLeft = leftTypedExpressionResult.getTypedExpression();
        if (optLeft.isEmpty()) {
            return new DrlxParseFail();
        }
        TypedExpression left = optLeft.get();
        Expression combo = left.getExpression();
        Type exprType = left.getType();
        boolean isPredicate = isBooleanBoxedUnboxed(exprType);
        if (isPredicate) {
            combo = combineExpressions(leftTypedExpressionResult, combo);
        }
        return new SingleDrlxParseSuccess(patternType, bindingId, combo, exprType).setReactOnProperties(expressionTyperContext.getReactOnProperties()).setVariablesFromDifferentPattern(expressionTyperContext.getVariablesFromDifferentPattern()).setUsedDeclarations(expressionTyperContext.getUsedDeclarations()).setImplicitCastExpression(expressionTyperContext.getInlineCastExpression()).setNullSafeExpressions(expressionTyperContext.getNullSafeExpressions()).setIsPredicate(isPredicate);
    } else {
        final ExpressionTyperContext expressionTyperContext = new ExpressionTyperContext();
        final ExpressionTyper expressionTyper = new ExpressionTyper(context, null, bindingId, isPositional, expressionTyperContext);
        TypedExpressionResult leftTypedExpressionResult = expressionTyper.toTypedExpression(drlxExpr);
        Optional<TypedExpression> optLeft = leftTypedExpressionResult.getTypedExpression();
        if (optLeft.isEmpty()) {
            return new DrlxParseFail();
        }
        TypedExpression left = optLeft.get();
        return new SingleDrlxParseSuccess(null, bindingId, drlxExpr, left.getType()).setUsedDeclarations(expressionTyperContext.getUsedDeclarations()).setIsPredicate(true);
    }
}",java:S3776,39
"private DrlxParseResult parseOOPathExpr(OOPathExpr ooPathExpr, Class<?> patternType, String bindingId, Expression drlxExpr, boolean hasBind, String expression){
    Type exprType = null;
    if (hasBind) {
        final ExpressionTyper expressionTyper = new ExpressionTyper(context, patternType, bindingId, false, new ExpressionTyperContext());
        TypedExpressionResult typedExpressionResult = expressionTyper.toTypedExpression(ooPathExpr);
        Optional<TypedExpression> typedExpression = typedExpressionResult.getTypedExpression();
        if (typedExpression.isEmpty()) {
            return new DrlxParseFail();
        }
        exprType = typedExpression.get().getType();
    }
    return new SingleDrlxParseSuccess(patternType, bindingId, drlxExpr, exprType).setIsPredicate(true);
}",java:S1172,13
"private DrlxParseResult parseBinaryExpr(BinaryExpr binaryExpr, Class<?> patternType, String bindingId, ConstraintExpression constraint, Expression drlxExpr, boolean hasBind, boolean isPositional, boolean isEnclosed){
    BinaryExpr.Operator operator = binaryExpr.getOperator();
    boolean isOrBinary = operator == BinaryExpr.Operator.OR;
    if (isLogicalOperator(operator) && isCombinable(binaryExpr)) {
        DrlxParseResult leftResult = compileToJavaRecursive(patternType, bindingId, constraint, binaryExpr.getLeft(), hasBind, isPositional);
        Expression rightExpr = binaryExpr.getRight() instanceof HalfPointFreeExpr ? completeHalfExpr(((PointFreeExpr) binaryExpr.getLeft()).getLeft(), (HalfPointFreeExpr) binaryExpr.getRight()) : binaryExpr.getRight();
        DrlxParseResult rightResult = compileToJavaRecursive(patternType, bindingId, constraint, rightExpr, hasBind, isPositional);
        return isMultipleResult(leftResult, operator, rightResult) ? createMultipleDrlxParseSuccess(operator, (DrlxParseSuccess) leftResult, (DrlxParseSuccess) rightResult) : leftResult.combineWith(rightResult, operator);
    }
    final ExpressionTyperContext expressionTyperContext = new ExpressionTyperContext();
    final ExpressionTyper expressionTyper = new ExpressionTyper(context, patternType, bindingId, isPositional, expressionTyperContext);
    TypedExpressionResult leftTypedExpressionResult = expressionTyper.toTypedExpression(binaryExpr.getLeft());
    Optional<TypedExpression> optLeft = leftTypedExpressionResult.getTypedExpression();
    if (optLeft.isEmpty()) {
        return new DrlxParseFail();
    }
    TypedExpression left = optLeft.get();
    List<String> usedDeclarationsOnLeft = hasBind ? new ArrayList<>(expressionTyperContext.getUsedDeclarations()) : null;
    List<Expression> leftPrefixExpressions = new ArrayList<>();
    if (isOrBinary) {
        leftPrefixExpressions.addAll(expressionTyperContext.getNullSafeExpressions());
        expressionTyperContext.getNullSafeExpressions().clear();
        leftPrefixExpressions.addAll(expressionTyperContext.getPrefixExpresssions());
        expressionTyperContext.getPrefixExpresssions().clear();
    }
    List<Expression> rightPrefixExpresssions = new ArrayList<>();
    TypedExpression right;
    if (constraint.isNameClashingUnification()) {
        String name = constraint.getUnificationField();
        right = new TypedExpression(new NameExpr(name), left.getType());
        expressionTyperContext.addUsedDeclarations(name);
    } else {
        TypedExpressionResult rightExpressionResult = expressionTyper.toTypedExpression(binaryExpr.getRight());
        Optional<TypedExpression> optRight = rightExpressionResult.getTypedExpression();
        if (optRight.isEmpty()) {
            return new DrlxParseFail(new ParseExpressionErrorResult(drlxExpr));
        }
        right = optRight.get();
        if (isOrBinary) {
            rightPrefixExpresssions.addAll(expressionTyperContext.getNullSafeExpressions());
            expressionTyperContext.getNullSafeExpressions().clear();
            rightPrefixExpresssions.addAll(expressionTyperContext.getPrefixExpresssions());
            expressionTyperContext.getPrefixExpresssions().clear();
        }
    }
    boolean equalityExpr = operator == EQUALS || operator == NOT_EQUALS;
    CoercedExpression.CoercedExpressionResult coerced;
    try {
        coerced = new CoercedExpression(left, right, equalityExpr).coerce();
    } catch (CoercedExpression.CoercedExpressionException e) {
        return new DrlxParseFail(e.getInvalidExpressionErrorResult());
    }
    left = coerced.getCoercedLeft();
    right = getCoercedRightExpression(packageModel, coerced);
    Expression combo;
    boolean arithmeticExpr = ARITHMETIC_OPERATORS.contains(operator);
    boolean isBetaConstraint = right.getExpression() != null && hasDeclarationFromOtherPattern(expressionTyperContext);
    boolean requiresSplit = operator == BinaryExpr.Operator.AND && binaryExpr.getRight() instanceof HalfBinaryExpr && !isBetaConstraint;
    if (equalityExpr) {
        combo = getEqualityExpression(left, right, operator).expression;
    } else if (arithmeticExpr && (left.isBigDecimal())) {
        ConstraintCompiler constraintCompiler = createConstraintCompiler(this.context, of(patternType));
        CompiledExpressionResult compiledExpressionResult = constraintCompiler.compileExpression(binaryExpr);
        combo = compiledExpressionResult.getExpression();
    } else {
        if (left.getExpression() == null || right.getExpression() == null) {
            return new DrlxParseFail(new ParseExpressionErrorResult(drlxExpr));
        }
        SpecialComparisonResult specialComparisonResult = handleSpecialComparisonCases(expressionTyper, operator, left, right);
        combo = specialComparisonResult.expression;
        left = requiresSplit ? left : specialComparisonResult.coercedLeft;
        right = requiresSplit ? right : specialComparisonResult.coercedRight;
    }
    if (isOrBinary) {
        combo = combineExpressions(leftPrefixExpressions, rightPrefixExpresssions, combo);
    } else {
        combo = combineExpressions(leftTypedExpressionResult, combo);
    }
    boolean isPredicate = isPredicateBooleanExpression(binaryExpr);
    if (isEnclosed && !isPredicate) {
        combo = new EnclosedExpr(combo);
    }
    Index.ConstraintType constraintType = DrlxParseUtil.toConstraintType(operator);
    if (isForallSelfJoinConstraint(left, right, constraintType)) {
        constraintType = Index.ConstraintType.FORALL_SELF_JOIN;
    }
    return new SingleDrlxParseSuccess(patternType, bindingId, combo, isBooleanOperator(operator) ? boolean.class : left.getType()).setDecodeConstraintType(constraintType).setUsedDeclarations(expressionTyperContext.getUsedDeclarations()).setUsedDeclarationsOnLeft(usedDeclarationsOnLeft).setUnification(constraint.isUnification()).setReactOnProperties(expressionTyperContext.getReactOnProperties()).setVariablesFromDifferentPattern(expressionTyperContext.getVariablesFromDifferentPattern()).setLeft(left).setRight(right).setBetaConstraint(isBetaConstraint).setRequiresSplit(requiresSplit).setIsPredicate(isPredicate).setImplicitCastExpression(leftTypedExpressionResult.getInlineCastExpression()).setNullSafeExpressions(leftTypedExpressionResult.getNullSafeExpressions());
}",java:S3776,39
"private DrlxParseResult parseBinaryExpr(BinaryExpr binaryExpr, Class<?> patternType, String bindingId, ConstraintExpression constraint, Expression drlxExpr, boolean hasBind, boolean isPositional, boolean isEnclosed){
    BinaryExpr.Operator operator = binaryExpr.getOperator();
    boolean isOrBinary = operator == BinaryExpr.Operator.OR;
    if (isLogicalOperator(operator) && isCombinable(binaryExpr)) {
        DrlxParseResult leftResult = compileToJavaRecursive(patternType, bindingId, constraint, binaryExpr.getLeft(), hasBind, isPositional);
        Expression rightExpr = binaryExpr.getRight() instanceof HalfPointFreeExpr ? completeHalfExpr(((PointFreeExpr) binaryExpr.getLeft()).getLeft(), (HalfPointFreeExpr) binaryExpr.getRight()) : binaryExpr.getRight();
        DrlxParseResult rightResult = compileToJavaRecursive(patternType, bindingId, constraint, rightExpr, hasBind, isPositional);
        return isMultipleResult(leftResult, operator, rightResult) ? createMultipleDrlxParseSuccess(operator, (DrlxParseSuccess) leftResult, (DrlxParseSuccess) rightResult) : leftResult.combineWith(rightResult, operator);
    }
    final ExpressionTyperContext expressionTyperContext = new ExpressionTyperContext();
    final ExpressionTyper expressionTyper = new ExpressionTyper(context, patternType, bindingId, isPositional, expressionTyperContext);
    TypedExpressionResult leftTypedExpressionResult = expressionTyper.toTypedExpression(binaryExpr.getLeft());
    Optional<TypedExpression> optLeft = leftTypedExpressionResult.getTypedExpression();
    if (optLeft.isEmpty()) {
        return new DrlxParseFail();
    }
    TypedExpression left = optLeft.get();
    List<String> usedDeclarationsOnLeft = hasBind ? new ArrayList<>(expressionTyperContext.getUsedDeclarations()) : null;
    List<Expression> leftPrefixExpressions = new ArrayList<>();
    if (isOrBinary) {
        leftPrefixExpressions.addAll(expressionTyperContext.getNullSafeExpressions());
        expressionTyperContext.getNullSafeExpressions().clear();
        leftPrefixExpressions.addAll(expressionTyperContext.getPrefixExpresssions());
        expressionTyperContext.getPrefixExpresssions().clear();
    }
    List<Expression> rightPrefixExpresssions = new ArrayList<>();
    TypedExpression right;
    if (constraint.isNameClashingUnification()) {
        String name = constraint.getUnificationField();
        right = new TypedExpression(new NameExpr(name), left.getType());
        expressionTyperContext.addUsedDeclarations(name);
    } else {
        TypedExpressionResult rightExpressionResult = expressionTyper.toTypedExpression(binaryExpr.getRight());
        Optional<TypedExpression> optRight = rightExpressionResult.getTypedExpression();
        if (optRight.isEmpty()) {
            return new DrlxParseFail(new ParseExpressionErrorResult(drlxExpr));
        }
        right = optRight.get();
        if (isOrBinary) {
            rightPrefixExpresssions.addAll(expressionTyperContext.getNullSafeExpressions());
            expressionTyperContext.getNullSafeExpressions().clear();
            rightPrefixExpresssions.addAll(expressionTyperContext.getPrefixExpresssions());
            expressionTyperContext.getPrefixExpresssions().clear();
        }
    }
    boolean equalityExpr = operator == EQUALS || operator == NOT_EQUALS;
    CoercedExpression.CoercedExpressionResult coerced;
    try {
        coerced = new CoercedExpression(left, right, equalityExpr).coerce();
    } catch (CoercedExpression.CoercedExpressionException e) {
        return new DrlxParseFail(e.getInvalidExpressionErrorResult());
    }
    left = coerced.getCoercedLeft();
    right = getCoercedRightExpression(packageModel, coerced);
    Expression combo;
    boolean arithmeticExpr = ARITHMETIC_OPERATORS.contains(operator);
    boolean isBetaConstraint = right.getExpression() != null && hasDeclarationFromOtherPattern(expressionTyperContext);
    boolean requiresSplit = operator == BinaryExpr.Operator.AND && binaryExpr.getRight() instanceof HalfBinaryExpr && !isBetaConstraint;
    if (equalityExpr) {
        combo = getEqualityExpression(left, right, operator).expression;
    } else if (arithmeticExpr && (left.isBigDecimal())) {
        ConstraintCompiler constraintCompiler = createConstraintCompiler(this.context, of(patternType));
        CompiledExpressionResult compiledExpressionResult = constraintCompiler.compileExpression(binaryExpr);
        combo = compiledExpressionResult.getExpression();
    } else {
        if (left.getExpression() == null || right.getExpression() == null) {
            return new DrlxParseFail(new ParseExpressionErrorResult(drlxExpr));
        }
        SpecialComparisonResult specialComparisonResult = handleSpecialComparisonCases(expressionTyper, operator, left, right);
        combo = specialComparisonResult.expression;
        left = requiresSplit ? left : specialComparisonResult.coercedLeft;
        right = requiresSplit ? right : specialComparisonResult.coercedRight;
    }
    if (isOrBinary) {
        combo = combineExpressions(leftPrefixExpressions, rightPrefixExpresssions, combo);
    } else {
        combo = combineExpressions(leftTypedExpressionResult, combo);
    }
    boolean isPredicate = isPredicateBooleanExpression(binaryExpr);
    if (isEnclosed && !isPredicate) {
        combo = new EnclosedExpr(combo);
    }
    Index.ConstraintType constraintType = DrlxParseUtil.toConstraintType(operator);
    if (isForallSelfJoinConstraint(left, right, constraintType)) {
        constraintType = Index.ConstraintType.FORALL_SELF_JOIN;
    }
    return new SingleDrlxParseSuccess(patternType, bindingId, combo, isBooleanOperator(operator) ? boolean.class : left.getType()).setDecodeConstraintType(constraintType).setUsedDeclarations(expressionTyperContext.getUsedDeclarations()).setUsedDeclarationsOnLeft(usedDeclarationsOnLeft).setUnification(constraint.isUnification()).setReactOnProperties(expressionTyperContext.getReactOnProperties()).setVariablesFromDifferentPattern(expressionTyperContext.getVariablesFromDifferentPattern()).setLeft(left).setRight(right).setBetaConstraint(isBetaConstraint).setRequiresSplit(requiresSplit).setIsPredicate(isPredicate).setImplicitCastExpression(leftTypedExpressionResult.getInlineCastExpression()).setNullSafeExpressions(leftTypedExpressionResult.getNullSafeExpressions());
}",java:S107,1
" boolean isOOPath(){
    return getExpr() instanceof OOPathExpr;
}",java:S1161,11
"protected Expression narrowExpressionToType(TypedExpression right, java.lang.reflect.Type leftType){
    Expression expression = right.getExpression();
    if (expression instanceof NullLiteralExpr) {
        return expression;
    }
    if (leftType.equals(Double.class)) {
        return new CastExpr(PrimitiveType.doubleType(), expression);
    }
    if (leftType.equals(Long.class)) {
        if (right.getType().equals(Double.class) || right.getType().equals(double.class)) {
            return new MethodCallExpr(expression, ""longValue"");
        } else {
            return new CastExpr(PrimitiveType.longType(), expression);
        }
    }
    if (expression instanceof LiteralExpr) {
        if (expression instanceof BigDecimalLiteralExpr) {
            return toNewExpr(BigDecimal.class, toStringLiteral(((BigDecimalLiteralExpr) expression).asBigDecimal().toString()));
        }
        if (expression instanceof BigIntegerLiteralExpr) {
            return toNewExpr(toRawClass(leftType), toStringLiteral(((BigIntegerLiteralExpr) expression).asBigInteger().toString()));
        }
        if (leftType.equals(BigDecimal.class)) {
            String expressionString = stringValue(expression);
            final BigDecimal bigDecimal = new BigDecimal(expressionString);
            return toNewExpr(BigDecimal.class, toStringLiteral(bigDecimal.toString()));
        }
        if (leftType.equals(BigInteger.class)) {
            String expressionString = stringValue(expression);
            final BigInteger bigInteger = new BigDecimal(expressionString).toBigInteger();
            return toNewExpr(BigInteger.class, toStringLiteral(bigInteger.toString()));
        }
        if (leftType.equals(float.class)) {
            return new DoubleLiteralExpr(expression + ""f"");
        }
    }
    if (expression instanceof NameExpr) {
        if (leftType.equals(BigDecimal.class) && !right.getType().equals(BigDecimal.class)) {
            return toNewExpr(BigDecimal.class, expression);
        }
        if (leftType.equals(BigInteger.class) && !right.getType().equals(BigInteger.class)) {
            return toNewExpr(BigInteger.class, expression);
        }
    }
    return expression;
}",java:S3776,39
"protected MethodCallExpr buildTemporalExpression(SingleDrlxParseSuccess drlxParseResult, MethodCallExpr exprDSL){
    boolean thisOnRight = isThisOnRight(drlxParseResult);
    if (thisOnRight) {
        if (drlxParseResult.getRight() != null && !drlxParseResult.getRight().getExpression().isNameExpr()) {
            exprDSL.addArgument(generateLambdaForTemporalConstraint(drlxParseResult.getRight(), drlxParseResult.getPatternType()));
        }
    } else {
        if (drlxParseResult.getLeft() != null && !drlxParseResult.getLeft().getExpression().isNameExpr()) {
            exprDSL.addArgument(generateLambdaForTemporalConstraint(drlxParseResult.getLeft(), drlxParseResult.getPatternType()));
        }
    }
    drlxParseResult.getUsedDeclarations().stream().filter(s -> !(drlxParseResult.isSkipThisAsParam() && s.equals(drlxParseResult.getPatternBinding()))).map(context::getVarExpr).forEach(exprDSL::addArgument);
    if (drlxParseResult.getRightLiteral() != null) {
        exprDSL.addArgument("""" + drlxParseResult.getRightLiteral());
    } else {
        if (thisOnRight) {
            if (drlxParseResult.getLeft() != null && !drlxParseResult.getLeft().getExpression().isNameExpr()) {
                exprDSL.addArgument(generateLambdaForTemporalConstraint(drlxParseResult.getLeft(), drlxParseResult.getPatternType()));
            }
        } else {
            if (drlxParseResult.getRight() != null && !drlxParseResult.getRight().getExpression().isNameExpr()) {
                exprDSL.addArgument(generateLambdaForTemporalConstraint(drlxParseResult.getRight(), drlxParseResult.getPatternType()));
            }
        }
    }
    if (thisOnRight) {
        exprDSL.addArgument(buildConstraintExpression(drlxParseResult, new MethodCallExpr(drlxParseResult.getExpr(), ""thisOnRight"")));
    } else {
        exprDSL.addArgument(buildConstraintExpression(drlxParseResult, drlxParseResult.getExpr()));
    }
    return exprDSL;
}",java:S3776,39
"private Optional<TypedExpression> toTypedExpressionRec(Expression drlxExpr){
    Class<?> typeCursor = patternType;
    if (drlxExpr instanceof FullyQualifiedInlineCastExpr) {
        return toTypedExpressionRec(transformFullyQualifiedInlineCastExpr(ruleContext.getTypeResolver(), (FullyQualifiedInlineCastExpr) drlxExpr));
    }
    if (drlxExpr instanceof EnclosedExpr) {
        Expression inner = ((EnclosedExpr) drlxExpr).getInner();
        Optional<TypedExpression> typedExpression = toTypedExpressionRec(inner);
        return typedExpression.map(t -> t.cloneWithNewExpression(new EnclosedExpr(t.getExpression())));
    }
    if (drlxExpr instanceof MethodCallExpr) {
        MethodCallExpr methodExpr = (MethodCallExpr) drlxExpr;
        Expression expr = methodExpr;
        if (isEval(methodExpr.getNameAsString(), methodExpr.getScope(), methodExpr.getArguments())) {
            expr = methodExpr.getArgument(0);
        }
        drlxExpr = expr;
    }
    if (drlxExpr instanceof NullSafeMethodCallExpr) {
        NullSafeMethodCallExpr methodExpr = (NullSafeMethodCallExpr) drlxExpr;
        Expression expr = methodExpr;
        if (isEval(methodExpr.getNameAsString(), methodExpr.getScope(), methodExpr.getArguments())) {
            expr = methodExpr.getArgument(0);
        }
        drlxExpr = expr;
    }
    if (drlxExpr instanceof UnaryExpr) {
        UnaryExpr unaryExpr = (UnaryExpr) drlxExpr;
        Optional<TypedExpression> optTypedExpr = toTypedExpressionRec(unaryExpr.getExpression());
        return optTypedExpr.map(typedExpr -> new TypedExpression(new UnaryExpr(typedExpr.getExpression(), unaryExpr.getOperator()), typedExpr.getType()));
    }
    if (drlxExpr instanceof BinaryExpr) {
        BinaryExpr binaryExpr = (BinaryExpr) drlxExpr;
        BinaryExpr.Operator operator = binaryExpr.getOperator();
        Optional<TypedExpression> optLeft = toTypedExpressionRec(binaryExpr.getLeft());
        Optional<TypedExpression> optRight = toTypedExpressionRec(binaryExpr.getRight());
        if (optLeft.isEmpty() || optRight.isEmpty()) {
            return empty();
        }
        TypedExpression left = optLeft.get();
        TypedExpression right = optRight.get();
        ArithmeticCoercedExpression.ArithmeticCoercedExpressionResult coerced;
        try {
            coerced = new ArithmeticCoercedExpression(left, right, operator).coerce();
        } catch (ArithmeticCoercedExpression.ArithmeticCoercedExpressionException e) {
            logger.error(""Failed to coerce : {}"", e.getInvalidExpressionErrorResult());
            return empty();
        }
        left = coerced.getCoercedLeft();
        right = coerced.getCoercedRight();
        final BinaryExpr combo = new BinaryExpr(left.getExpression(), right.getExpression(), operator);
        return of(new TypedExpression(combo, left.getType()));
    }
    if (drlxExpr instanceof HalfBinaryExpr) {
        final Expression binaryExpr = trasformHalfBinaryToBinary(drlxExpr);
        if (binaryExpr instanceof BinaryExpr && ((BinaryExpr) binaryExpr).getLeft() == drlxExpr) {
            throw new CannotTypeExpressionException(""left leaf is the same : drlxExpr = "" + drlxExpr + "", originalExpression = "" + context.getOriginalExpression());
        }
        return toTypedExpressionRec(binaryExpr);
    }
    if (drlxExpr instanceof LiteralExpr) {
        drlxExpr = normalizeDigit(drlxExpr);
        return of(new TypedExpression(drlxExpr, getLiteralExpressionType((LiteralExpr) drlxExpr)));
    }
    if (drlxExpr instanceof ThisExpr || (drlxExpr instanceof NameExpr && THIS_PLACEHOLDER.equals(printNode(drlxExpr)))) {
        return of(new TypedExpression(new NameExpr(THIS_PLACEHOLDER), patternType, ""this""));
    }
    if (drlxExpr instanceof CastExpr) {
        CastExpr castExpr = (CastExpr) drlxExpr;
        Optional<TypedExpression> optTypedExpr = toTypedExpressionRec(castExpr.getExpression());
        return optTypedExpr.map(typedExpr -> new TypedExpression(new CastExpr(castExpr.getType(), typedExpr.getExpression()), getClassFromContext(ruleContext.getTypeResolver(), castExpr.getType().asString())));
    }
    if (drlxExpr instanceof NameExpr) {
        return nameExpr(((NameExpr) drlxExpr).getNameAsString(), typeCursor);
    }
    if (drlxExpr instanceof FieldAccessExpr || drlxExpr instanceof MethodCallExpr || drlxExpr instanceof ObjectCreationExpr || drlxExpr instanceof NullSafeFieldAccessExpr || drlxExpr instanceof NullSafeMethodCallExpr || drlxExpr instanceof MapCreationLiteralExpression || drlxExpr instanceof ListCreationLiteralExpression) {
        return toTypedExpressionFromMethodCallOrField(drlxExpr).getTypedExpression();
    }
    if (drlxExpr instanceof PointFreeExpr) {
        final PointFreeExpr pointFreeExpr = (PointFreeExpr) drlxExpr;
        Optional<TypedExpression> optLeft = toTypedExpressionRec(pointFreeExpr.getLeft());
        Optional<TypedExpression> optRight = pointFreeExpr.getRight().size() == 1 ? toTypedExpressionRec(pointFreeExpr.getRight().get(0)) : Optional.empty();
        OperatorSpec opSpec = getOperatorSpec(pointFreeExpr.getRight(), pointFreeExpr.getOperator());
        return optLeft.map(left -> new TypedExpression(opSpec.getExpression(ruleContext, pointFreeExpr, left, this), left.getType()).setStatic(opSpec.isStatic()).setLeft(left).setRight(optRight.orElse(null)));
    }
    if (drlxExpr instanceof HalfPointFreeExpr) {
        final HalfPointFreeExpr halfPointFreeExpr = (HalfPointFreeExpr) drlxExpr;
        Expression parentLeft = findLeftLeafOfNameExprTraversingParent(halfPointFreeExpr);
        if (parentLeft == halfPointFreeExpr) {
            throw new CannotTypeExpressionException(""left leaf is the same : halfPointFreeExpr = "" + halfPointFreeExpr + "", originalExpression = "" + context.getOriginalExpression());
        }
        Optional<TypedExpression> optLeft = toTypedExpressionRec(parentLeft);
        OperatorSpec opSpec = getOperatorSpec(halfPointFreeExpr.getRight(), halfPointFreeExpr.getOperator());
        final PointFreeExpr transformedToPointFree = new PointFreeExpr(halfPointFreeExpr.getTokenRange().orElseThrow(() -> new IllegalStateException(""Token range is not present!"")), parentLeft, halfPointFreeExpr.getRight(), halfPointFreeExpr.getOperator(), halfPointFreeExpr.isNegated(), halfPointFreeExpr.getArg1(), halfPointFreeExpr.getArg2(), halfPointFreeExpr.getArg3(), halfPointFreeExpr.getArg4());
        return optLeft.map(left -> new TypedExpression(opSpec.getExpression(ruleContext, transformedToPointFree, left, this), left.getType()).setStatic(opSpec.isStatic()).setLeft(left));
    }
    if (drlxExpr instanceof ArrayAccessExpr) {
        final ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) drlxExpr;
        if (Map.class.isAssignableFrom(typeCursor)) {
            return createMapAccessExpression(arrayAccessExpr.getIndex(), arrayAccessExpr.getName() instanceof ThisExpr ? new NameExpr(THIS_PLACEHOLDER) : arrayAccessExpr.getName(), Object.class);
        } else if (arrayAccessExpr.getName() instanceof FieldAccessExpr) {
            Optional<TypedExpression> typedExpression = toTypedExpressionFromMethodCallOrField(drlxExpr).getTypedExpression();
            typedExpression.ifPresent(te -> {
                final Expression originalExpression = te.getExpression();
                DrlxParseUtil.removeRootNode(originalExpression);
            });
            return typedExpression;
        } else {
            Expression indexExpr = toTypedExpressionFromMethodCallOrField(arrayAccessExpr.getIndex()).getTypedExpression().orElseThrow(() -> new NoSuchElementException(""TypedExpressionResult doesn't contain TypedExpression!"")).getExpression();
            return toTypedExpressionRec(drlxExpr.asArrayAccessExpr().getName()).flatMap(te -> transformToArrayOrMapExpressionWithType(indexExpr, te));
        }
    }
    if (drlxExpr instanceof InstanceOfExpr) {
        InstanceOfExpr instanceOfExpr = (InstanceOfExpr) drlxExpr;
        ruleContext.addInlineCastType(printNode(instanceOfExpr.getExpression()), instanceOfExpr.getType());
        return toTypedExpressionRec(instanceOfExpr.getExpression()).map(e -> new TypedExpression(new InstanceOfExpr(e.getExpression(), instanceOfExpr.getType()), boolean.class));
    }
    if (drlxExpr instanceof ClassExpr) {
        return of(new TypedExpression(drlxExpr, Class.class));
    }
    if (drlxExpr instanceof InlineCastExpr) {
        return toTypedExpressionFromMethodCallOrField(drlxExpr).getTypedExpression();
    }
    if (drlxExpr instanceof OOPathExpr) {
        Class<?> type = patternType;
        for (OOPathChunk chunk : ((OOPathExpr) drlxExpr).getChunks()) {
            final String fieldName = chunk.getField().toString();
            final TypedExpression callExpr = DrlxParseUtil.nameExprToMethodCallExpr(fieldName, type, null, ruleContext);
            if (callExpr == null) {
                return empty();
            }
            Class<?> fieldType = (chunk.getInlineCast() != null) ? DrlxParseUtil.getClassFromContext(ruleContext.getTypeResolver(), chunk.getInlineCast().toString()) : callExpr.getRawClass();
            if (!chunk.isSingleValue() && Iterable.class.isAssignableFrom(fieldType) || isDataSource(fieldType)) {
                type = extractGenericType(type, ((MethodCallExpr) callExpr.getExpression()).getName().toString());
            } else {
                type = fieldType;
            }
        }
        return of(new TypedExpression(drlxExpr, type));
    }
    if (drlxExpr.isAssignExpr()) {
        AssignExpr assignExpr = drlxExpr.asAssignExpr();
        final Expression rightSide = assignExpr.getValue();
        return toTypedExpressionRec(rightSide).map(e -> {
            final AssignExpr newExpression = new AssignExpr(assignExpr.getTarget(), e.getExpression(), assignExpr.getOperator());
            return new TypedExpression(newExpression, e.getType());
        });
    }
    throw new UnsupportedOperationException();
}",java:S3776,39
"private TypedExpressionResult toTypedExpressionFromMethodCallOrField(Expression drlxExpr){
    if (drlxExpr instanceof FieldAccessExpr) {
        final Optional<TypedExpression> typedExpression = tryParseAsConstantField(ruleContext.getTypeResolver(), ((FieldAccessExpr) drlxExpr).getScope(), ((FieldAccessExpr) drlxExpr).getNameAsString());
        if (typedExpression.isPresent()) {
            return new TypedExpressionResult(typedExpression, context);
        }
    }
    if (patternType == null && drlxExpr instanceof NullSafeFieldAccessExpr) {
        final Optional<TypedExpression> typedExpression = tryParseAsConstantField(ruleContext.getTypeResolver(), ((NullSafeFieldAccessExpr) drlxExpr).getScope(), ((NullSafeFieldAccessExpr) drlxExpr).getNameAsString());
        if (typedExpression.isPresent()) {
            return new TypedExpressionResult(typedExpression, context);
        }
    }
    final List<Node> childrenNodes = flattenScope(ruleContext.getTypeResolver(), drlxExpr);
    final Node firstChild = childrenNodes.get(0);
    boolean isInLineCast = firstChild instanceof InlineCastExpr;
    java.lang.reflect.Type originalTypeCursor;
    final Node firstNode;
    if (isInLineCast) {
        InlineCastExpr inlineCast = (InlineCastExpr) firstChild;
        originalTypeCursor = originalTypeCursorFromInlineCast(inlineCast);
        firstNode = inlineCast.getExpression();
        if (inlineCast.getExpression().isThisExpr()) {
            context.setInlineCastExpression(Optional.of(new InstanceOfExpr(new NameExpr(THIS_PLACEHOLDER), (ReferenceType) inlineCast.getType())));
        } else {
            context.setInlineCastExpression(toTypedExpression(inlineCast.getExpression()).getTypedExpression().map(TypedExpression::getExpression).map(expr -> new InstanceOfExpr(expr, (ReferenceType) inlineCast.getType())));
        }
    } else {
        originalTypeCursor = patternType;
        firstNode = firstChild;
    }
    if (originalTypeCursor != null && originalTypeCursor.equals(Object.class)) {
        final Optional<DeclarationSpec> declarationById = ruleContext.getDeclarationById(printNode(firstChild));
        originalTypeCursor = declarationById.map(d -> (java.lang.reflect.Type) d.getDeclarationClass()).orElse(originalTypeCursor);
    }
    final Optional<TypedExpressionCursor> teCursor = processFirstNode(drlxExpr, childrenNodes, firstNode, isInLineCast, originalTypeCursor);
    if (firstNode instanceof MethodCallExpr) {
        MethodCallExpr me = (MethodCallExpr) firstNode;
        addReactOnProperty(me.getNameAsString(), me.getArguments());
    }
    if (firstNode instanceof NullSafeMethodCallExpr) {
        NullSafeMethodCallExpr me = (NullSafeMethodCallExpr) firstNode;
        addReactOnProperty(me.getNameAsString(), me.getArguments());
    }
    if (teCursor.isEmpty()) {
        return new TypedExpressionResult(empty(), context);
    }
    Expression previous = teCursor.get().expressionCursor;
    java.lang.reflect.Type typeCursor = teCursor.get().typeCursor;
    List<Node> childrenWithoutFirst = childrenNodes.subList(1, childrenNodes.size());
    for (Node part : childrenWithoutFirst) {
        if (part instanceof SimpleName) {
            String field = part.toString();
            TypedExpression expression = nameExprToMethodCallExpr(field, typeCursor, previous, ruleContext);
            if (expression == null) {
                ruleContext.addCompilationError(new InvalidExpressionErrorResult(""Unknown field "" + field + "" on "" + typeCursor));
                break;
            }
            typeCursor = expression.getType();
            previous = expression.getExpression();
        } else if (part instanceof MethodCallExpr) {
            TypedExpressionCursor typedExpr = methodCallExpr((MethodCallExpr) part, typeCursor, previous);
            typeCursor = typedExpr.typeCursor;
            previous = typedExpr.expressionCursor;
        } else if (part instanceof NullSafeMethodCallExpr) {
            TypedExpressionCursor typedExpr = nullSafeMethodCallExpr((NullSafeMethodCallExpr) part, typeCursor, previous);
            typeCursor = typedExpr.typeCursor;
            previous = typedExpr.expressionCursor;
        } else if (part instanceof InlineCastExpr && ((InlineCastExpr) part).getExpression() instanceof FieldAccessExpr) {
            InlineCastExpr inlineCastExprPart = (InlineCastExpr) part;
            final FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) inlineCastExprPart.getExpression();
            final TypedExpression toMethodCallExpr = nameExprToMethodCallExpr(fieldAccessExpr.getNameAsString(), typeCursor, previous, ruleContext);
            if (toMethodCallExpr == null) {
                ruleContext.addCompilationError(new InvalidExpressionErrorResult(""Unknown field "" + fieldAccessExpr.getNameAsString() + "" on "" + typeCursor));
                break;
            }
            final Class<?> castClass = getClassFromType(ruleContext.getTypeResolver(), inlineCastExprPart.getType());
            previous = addCastToExpression(castClass, toMethodCallExpr.getExpression(), false);
            typeCursor = castClass;
        } else if (part instanceof ArrayAccessExpr) {
            final ArrayAccessExpr inlineCastExprPart = (ArrayAccessExpr) part;
            TypedExpressionCursor typedExpr = arrayAccessExpr(inlineCastExprPart, typeCursor, previous).orElseThrow(() -> new NoSuchElementException(""ArrayAccessExpr doesn't contain TypedExpressionCursor!""));
            typeCursor = typedExpr.typeCursor;
            previous = typedExpr.expressionCursor;
        } else {
            throw new UnsupportedOperationException();
        }
    }
    return new TypedExpressionResult(of(new TypedExpression(previous, typeCursor, accessorToFieldName(drlxExpr))), context);
}",java:S3776,39
"private Optional<TypedExpressionCursor> processFirstNode(Expression drlxExpr, List<Node> childNodes, Node firstNode, boolean isInLineCast, java.lang.reflect.Type originalTypeCursor){
    Optional<TypedExpressionCursor> result;
    if (isThisExpression(firstNode) || (firstNode instanceof DrlNameExpr && printNode(firstNode).equals(bindingId))) {
        result = of(thisExpr(drlxExpr, childNodes, isInLineCast, originalTypeCursor));
    } else if (firstNode instanceof DrlNameExpr) {
        result = drlNameExpr(drlxExpr, (DrlNameExpr) firstNode, isInLineCast, originalTypeCursor);
    } else if (firstNode instanceof NameExpr) {
        result = drlNameExpr(drlxExpr, new DrlNameExpr(((NameExpr) firstNode).getName()), isInLineCast, originalTypeCursor);
    } else if (firstNode instanceof FieldAccessExpr) {
        if (((FieldAccessExpr) firstNode).getScope() instanceof ThisExpr) {
            result = of(fieldAccessExpr(originalTypeCursor, ((FieldAccessExpr) firstNode).getName()));
        } else {
            try {
                Class<?> resolvedType = ruleContext.getTypeResolver().resolveType(PrintUtil.printNode(firstNode));
                result = of(new TypedExpressionCursor(new NameExpr(PrintUtil.printNode(firstNode)), resolvedType));
            } catch (ClassNotFoundException e) {
                result = empty();
            }
        }
    } else if (firstNode instanceof NullSafeFieldAccessExpr && ((NullSafeFieldAccessExpr) firstNode).getScope() instanceof ThisExpr) {
        result = of(fieldAccessExpr(originalTypeCursor, ((NullSafeFieldAccessExpr) firstNode).getName()));
    } else if (firstNode instanceof MethodCallExpr) {
        Optional<Expression> scopeExpr = ((MethodCallExpr) firstNode).getScope();
        Optional<DeclarationSpec> scopeDecl = scopeExpr.flatMap(scope -> ruleContext.getDeclarationById(PrintUtil.printNode(scope)));
        Expression scope;
        java.lang.reflect.Type type;
        if (scopeDecl.isPresent() && !scopeDecl.get().getBindingId().equals(bindingId)) {
            type = scopeDecl.get().getDeclarationClass();
            scope = new NameExpr(scopeDecl.get().getBindingId());
            context.addUsedDeclarations(scopeDecl.get().getBindingId());
        } else if (scopeExpr.isPresent()) {
            TypedExpressionCursor parsedScope = processFirstNode(drlxExpr, childNodes, scopeExpr.get(), isInLineCast, originalTypeCursor).get();
            type = parsedScope.typeCursor;
            scope = parsedScope.expressionCursor;
        } else {
            type = originalTypeCursor;
            scope = new NameExpr(THIS_PLACEHOLDER);
        }
        result = of(methodCallExpr((MethodCallExpr) firstNode, type, scope));
    } else if (firstNode instanceof ObjectCreationExpr) {
        result = of(objectCreationExpr((ObjectCreationExpr) firstNode));
    } else if (firstNode instanceof StringLiteralExpr) {
        result = of(stringLiteralExpr((StringLiteralExpr) firstNode));
    } else if (firstNode instanceof EnclosedExpr) {
        result = processFirstNode(drlxExpr, childNodes, ((EnclosedExpr) firstNode).getInner(), isInLineCast, originalTypeCursor);
    } else if (firstNode instanceof CastExpr) {
        result = castExpr((CastExpr) firstNode, isInLineCast);
    } else if (firstNode instanceof ArrayCreationExpr) {
        result = of(arrayCreationExpr(((ArrayCreationExpr) firstNode)));
    } else if (firstNode instanceof BinaryExpr) {
        result = of(binaryExpr((BinaryExpr) firstNode));
    } else if (firstNode instanceof ArrayAccessExpr) {
        Optional<DeclarationSpec> scopeDecl = ruleContext.getDeclarationById(((ArrayAccessExpr) firstNode).getName().toString());
        Expression scope;
        java.lang.reflect.Type type;
        if (scopeDecl.isPresent() && !scopeDecl.get().getBindingId().equals(bindingId)) {
            type = scopeDecl.get().getDeclarationClass();
            scope = new NameExpr(scopeDecl.get().getBindingId());
            context.addUsedDeclarations(scopeDecl.get().getBindingId());
        } else {
            type = originalTypeCursor;
            scope = new NameExpr(THIS_PLACEHOLDER);
        }
        result = arrayAccessExpr((ArrayAccessExpr) firstNode, type, scope);
    } else if (firstNode instanceof MapCreationLiteralExpression) {
        result = mapCreationLiteral((MapCreationLiteralExpression) firstNode, originalTypeCursor);
    } else if (firstNode instanceof ListCreationLiteralExpression) {
        result = listCreationLiteral((ListCreationLiteralExpression) firstNode, originalTypeCursor);
    } else {
        result = of(new TypedExpressionCursor((Expression) firstNode, getExpressionType(ruleContext, ruleContext.getTypeResolver(), (Expression) firstNode, context.getUsedDeclarations())));
    }
    if (result.isPresent()) {
        processNullSafeDereferencing(drlxExpr);
    }
    return result.map(te -> {
        if (isInLineCast) {
            Expression exprWithInlineCast = addCastToExpression(toRawClass(te.typeCursor), te.expressionCursor, isInLineCast);
            return new TypedExpressionCursor(exprWithInlineCast, te.typeCursor);
        } else {
            return te;
        }
    });
}",java:S3776,39
"private Optional<TypedExpressionCursor> drlNameExpr(Expression drlxExpr, DrlNameExpr firstNode, boolean isInLineCast, java.lang.reflect.Type originalTypeCursor){
    String firstName = firstNode.getName().getIdentifier();
    java.lang.reflect.Type typeCursor;
    Optional<DeclarationSpec> backReference = empty();
    if (firstNode.getBackReferencesCount() > 0) {
        List<DeclarationSpec> ooPathDeclarations = ruleContext.getOOPathDeclarations();
        DeclarationSpec backReferenceDeclaration = ooPathDeclarations.get(ooPathDeclarations.size() - 1 - firstNode.getBackReferencesCount());
        typeCursor = backReferenceDeclaration.getDeclarationClass();
        backReference = of(backReferenceDeclaration);
        context.addUsedDeclarations(backReferenceDeclaration.getBindingId());
    } else {
        typeCursor = originalTypeCursor;
    }
    try {
        Class<?> resolvedType = ruleContext.getTypeResolver().resolveType(firstName);
        return of(new TypedExpressionCursor(new NameExpr(firstName), resolvedType));
    } catch (ClassNotFoundException e) {
    }
    Class<?> classCursor = toRawClass(typeCursor);
    if (classCursor != null) {
        Method firstAccessor = DrlxParseUtil.getAccessor(!isInLineCast ? classCursor : patternType, firstName, ruleContext);
        if (firstAccessor != null) {
            if (!"""".equals(firstName)) {
                context.addReactOnProperties(firstName);
            }
            NameExpr thisAccessor = new NameExpr(THIS_PLACEHOLDER);
            NameExpr scope = backReference.map(d -> new NameExpr(d.getBindingId())).orElse(thisAccessor);
            Expression fieldAccessor = new MethodCallExpr(scope, firstAccessor.getName());
            if (isInLineCast) {
                return of(new TypedExpressionCursor(fieldAccessor, typeCursor));
            }
            Optional<java.lang.reflect.Type> castType = ruleContext.explicitCastType(firstName).flatMap(t -> safeResolveType(ruleContext.getTypeResolver(), t.asString()));
            if (castType.isPresent()) {
                java.lang.reflect.Type typeOfFirstAccessor = castType.get();
                ClassOrInterfaceType typeWithoutDollar = toClassOrInterfaceType(typeOfFirstAccessor.getTypeName());
                return of(new TypedExpressionCursor(addCastToExpression(typeWithoutDollar, fieldAccessor, false), typeOfFirstAccessor));
            }
            return of(new TypedExpressionCursor(fieldAccessor, firstAccessor.getGenericReturnType()));
        }
        Field field = DrlxParseUtil.getField(classCursor, firstName);
        if (field != null) {
            NameExpr scope = new NameExpr(Modifier.isStatic(field.getModifiers()) ? classCursor.getCanonicalName() : THIS_PLACEHOLDER);
            return of(new TypedExpressionCursor(new FieldAccessExpr(scope, field.getName()), field.getType()));
        }
    }
    Optional<DeclarationSpec> declarationById = ruleContext.getDeclarationById(firstName);
    if (declarationById.isPresent()) {
        context.addUsedDeclarations(firstName);
        typeCursor = isInLineCast ? originalTypeCursor : declarationById.get().getDeclarationClass();
        return of(new TypedExpressionCursor(new NameExpr(firstName), typeCursor));
    }
    if (ruleContext.getGlobals().containsKey(firstName)) {
        context.addUsedDeclarations(firstName);
        return of(new TypedExpressionCursor(new NameExpr(firstName), ruleContext.getGlobals().get(firstName)));
    }
    final Optional<Node> rootNode = findRootNodeViaParent(drlxExpr);
    rootNode.ifPresent(n -> {
        Node withHalfBinaryReplaced = replaceAllHalfBinaryChildren(n);
        ruleContext.addCompilationError(new ParseExpressionErrorResult((Expression) withHalfBinaryReplaced, ruleContext.getCurrentConstraintDescr()));
    });
    return empty();
}",java:S3776,39
"public static List<Node> flattenScope(TypeResolver typeResolver, Expression expressionWithScope){
    List<Node> res = new ArrayList<>();
    if (expressionWithScope instanceof FullyQualifiedInlineCastExpr) {
        res.addAll(flattenScope(typeResolver, transformFullyQualifiedInlineCastExpr(typeResolver, (FullyQualifiedInlineCastExpr) expressionWithScope)));
    } else if (expressionWithScope instanceof FieldAccessExpr) {
        FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) expressionWithScope;
        res.addAll(flattenScope(typeResolver, fieldAccessExpr.getScope()));
        res.add(fieldAccessExpr.getName());
    } else if (expressionWithScope instanceof NullSafeFieldAccessExpr) {
        NullSafeFieldAccessExpr fieldAccessExpr = (NullSafeFieldAccessExpr) expressionWithScope;
        res.addAll(flattenScope(typeResolver, fieldAccessExpr.getScope()));
        res.add(fieldAccessExpr.getName());
    } else if (expressionWithScope instanceof MethodCallExpr) {
        MethodCallExpr methodCallExpr = (MethodCallExpr) expressionWithScope;
        if (methodCallExpr.getScope().isPresent()) {
            Expression scope = methodCallExpr.getScope().get();
            if (isFullyQualifiedClassName(typeResolver, scope)) {
                res.add(scope);
            } else {
                res.addAll(flattenScope(typeResolver, scope));
            }
        }
        res.add(methodCallExpr);
    } else if (expressionWithScope instanceof NullSafeMethodCallExpr) {
        NullSafeMethodCallExpr methodCallExpr = (NullSafeMethodCallExpr) expressionWithScope;
        if (methodCallExpr.getScope().isPresent()) {
            res.addAll(flattenScope(typeResolver, methodCallExpr.getScope().orElseThrow(() -> new IllegalStateException(""Scope expression is not present!""))));
        }
        res.add(methodCallExpr);
    } else if (expressionWithScope instanceof InlineCastExpr && ((InlineCastExpr) expressionWithScope).getExpression() instanceof FieldAccessExpr) {
        InlineCastExpr inlineCastExpr = (InlineCastExpr) expressionWithScope;
        Expression internalScope = ((FieldAccessExpr) inlineCastExpr.getExpression()).getScope();
        res.addAll(flattenScope(typeResolver, internalScope));
        res.add(expressionWithScope);
    } else if (expressionWithScope instanceof ArrayAccessExpr) {
        ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) expressionWithScope;
        res.addAll(flattenScope(typeResolver, arrayAccessExpr.getName()));
        res.add(arrayAccessExpr);
    } else if (expressionWithScope instanceof EnclosedExpr) {
        res.addAll(flattenScope(typeResolver, ((EnclosedExpr) expressionWithScope).getInner()));
    } else {
        res.add(expressionWithScope);
    }
    return res;
}",java:S3776,39
"protected Operator addOperatorArgument(RuleContext context, MethodCallExpr methodCallExpr, String opName){
    Operator operator = Operator.Register.getOperator(opName);
    try {
        operator.getClass().getField(""INSTANCE"");
        methodCallExpr.addArgument(operator.getClass().getCanonicalName() + "".INSTANCE"");
    } catch (NoSuchFieldException e) {
        methodCallExpr.addArgument(toStringLiteral(opName));
    }
    return operator;
}",java:S1172,13
"private Optional<Expression> fromConstructorExpr(String expression, ObjectCreationExpr parsedExpression){
    MethodCallExpr fromCall = createDslTopLevelMethod(FROM_CALL);
    List<String> bindingIds = new ArrayList<>();
    for (Expression argument : parsedExpression.getArguments()) {
        final String argumentName = PrintUtil.printNode(argument);
        if (context.hasDeclaration(argumentName)) {
            bindingIds.add(argumentName);
            fromCall.addArgument(context.getVarExpr(argumentName));
        }
    }
    Expression newExpr = generateLambdaWithoutParameters(bindingIds, parsedExpression, true, Optional.empty(), context);
    if (newExpr instanceof LambdaExpr) {
        context.getPackageModel().registerLambdaReturnType((LambdaExpr) newExpr, DrlxParseUtil.getClassFromType(context.getTypeResolver(), parsedExpression.getType()));
    }
    fromCall.addArgument(newExpr);
    return of(fromCall);
}",java:S1172,13
"private MethodCallExpr whenThenDSL(ConditionalBranchDescr desc, PatternDescr patternRelated, Class<?> patternType, String callMethod, MethodCallExpr parentExpression){
    MethodCallExpr when = parentExpression == null ? createDslTopLevelMethod(callMethod) : new MethodCallExpr(parentExpression, callMethod);
    final String condition = desc.getCondition().toString();
    if (!condition.equals(""true"")) {
        when.addArgument(new StringLiteralExpr(context.getConditionId(patternType, condition)));
        String identifier = patternRelated.getIdentifier();
        DrlxParseResult parseResult;
        if (identifier == null) {
            parseResult = ConstraintParser.defaultConstraintParser(context, packageModel).drlxParse(Object.class, """", condition);
            parseResult.accept((DrlxParseSuccess parseSuccess) -> {
                SingleDrlxParseSuccess parseSuccess1 = (SingleDrlxParseSuccess) parseSuccess;
                AccumulateDescr source = (AccumulateDescr) patternRelated.getSource();
                for (String usedDeclaration : parseSuccess1.getUsedDeclarations()) {
                    for (AccumulateDescr.AccumulateFunctionCallDescr functionCallDescr : source.getFunctions()) {
                        if (functionCallDescr.getBind().equals(usedDeclaration)) {
                            addVariable(patternRelated, when, functionCallDescr);
                        }
                    }
                }
                when.addArgument(generateLambdaWithoutParameters(parseSuccess1.getUsedDeclarations(), parseSuccess.getExpr(), true, Optional.empty()));
            });
        } else {
            when.addArgument(context.getVarExpr(identifier));
            parseResult = ConstraintParser.defaultConstraintParser(context, packageModel).drlxParse(patternType, identifier, condition);
            Collection<String> usedDeclarations = ((SingleDrlxParseSuccess) parseResult).getUsedDeclarations();
            if (usedDeclarations.isEmpty()) {
                parseResult.accept(parseSuccess -> when.addArgument(generateLambdaWithoutParameters(Collections.emptySortedSet(), parseSuccess.getExpr())));
            } else {
                parseResult.accept(parseSuccess -> when.addArgument(generateLambdaWithoutParameters(usedDeclarations, parseSuccess.getExpr(), true, Optional.empty())));
            }
        }
    }
    MethodCallExpr then = new MethodCallExpr(when, THEN_CALL);
    MethodCallExpr rhs = onDSL(desc.getConsequence());
    then.addArgument(rhs);
    return then;
}",java:S3776,39
"private void addVariable(PatternDescr patternRelated, MethodCallExpr when, AccumulateDescr.AccumulateFunctionCallDescr accFuncCallDescr){
    String identifierDeclaration = ofNullable(accFuncCallDescr).map(AccumulateDescr.AccumulateFunctionCallDescr::getBind).orElseThrow(() -> new InvalidNamedConsequenceException(""Cannot find function identifier""));
    when.addArgument(context.getVarExpr(identifierDeclaration));
}",java:S1172,13
"private void processNewBinding(Optional<NewBinding> optNewBinding, MethodCallExpr accumulateDSL){
    optNewBinding.ifPresent(newBinding -> {
        final List<Expression> allExpressions = context.getExpressions();
        final MethodCallExpr newBindingExpression = newBinding.bindExpression;
        if (newBinding.patternBinding.size() == 1) {
            new PatternToReplace(context, newBinding.patternBinding).findFromPattern().ifPresent(pattern -> addBindAsLastChainCall(newBindingExpression, pattern));
            String binding = newBinding.patternBinding.iterator().next();
            composeTwoBindings(binding, newBindingExpression);
        } else if (newBinding.patternBinding.size() == 2) {
            String binding = newBinding.patternBinding.iterator().next();
            composeTwoBindings(binding, newBindingExpression);
        } else {
            final MethodCallExpr lastPattern = DrlxParseUtil.findLastPattern(allExpressions).orElseThrow(() -> new RuntimeException(""Need the last pattern to add the binding""));
            final MethodCallExpr replacedBinding = replaceBindingWithPatternBinding(newBindingExpression, lastPattern);
            addBindAsLastChainCall(replacedBinding, lastPattern);
        }
    });
}",java:S1172,13
"protected void processAccumulateFunctions(AccumulateDescr descr, PatternDescr basePattern, BaseDescr input, MethodCallExpr accumulateDSL){
    accumulateDSL.setName(GROUP_BY_CALL);
    GroupByDescr groupByDescr = (GroupByDescr) descr;
    Expression expr = parseExpression(groupByDescr.getGroupingFunction());
    TypedExpressionResult result = new ExpressionTyper(context).toTypedExpression(expr);
    Optional<TypedExpression> optResult = result.getTypedExpression();
    if (optResult.isEmpty()) {
        context.addCompilationError(new InvalidExpressionErrorResult(""Unable to parse grouping expression: "" + groupByDescr.getGroupingFunction()));
        return;
    }
    for (String used : result.getUsedDeclarations()) {
        accumulateDSL.addArgument(context.getVarExpr(used));
    }
    TypedExpression typedExpression = optResult.get();
    String groupingKey = groupByDescr.getGroupingKey() != null ? groupByDescr.getGroupingKey() : generateUUID();
    context.addDeclarationReplacing(new DeclarationSpec(groupingKey, typedExpression.getRawClass()));
    accumulateDSL.addArgument(toVar(groupingKey));
    accumulateDSL.addArgument(buildConstraintExpression(typedExpression.getExpression(), result.getUsedDeclarations()));
    super.processAccumulateFunctions(descr, basePattern, input, accumulateDSL);
}",java:S1161,11
"public void build(){
    Pattern pattern = (Pattern) new PatternBuilder().build(ruleBuildContext, basePattern);
    Accumulate accumulate = (Accumulate) pattern.getSource();
    final Set<String> imports = ruleBuildContext.getPkg().getImports().keySet();
    final String packageName = ruleBuildContext.getPkg().getName();
    if (context.getLegacyAccumulateCounter() == 0) {
        GeneratedClassWithPackage generatedClassWithPackage = createAllAccumulateClass(imports, packageName);
        packageModel.addGeneratedAccumulateClasses(generatedClassWithPackage);
    } else {
        for (GeneratedClassWithPackage c : packageModel.getGeneratedAccumulateClasses()) {
            String ruleClassName = StringUtils.ucFirst(context.getRuleDescr().getClassName());
            if (ruleClassName.equals(c.getClassName())) {
                for (String m : ruleBuildContext.getMethods()) {
                    c.getGeneratedClass().addMember(parseBodyDeclaration(m));
                }
                break;
            }
        }
    }
    GeneratedClassWithPackage invokerGenerated = createInvokerClass(imports, packageName);
    packageModel.addGeneratedAccumulateClasses(invokerGenerated);
    final String generatedClassName = invokerGenerated.getGeneratedClass().getName().asString();
    String typeWithPackage = String.format(""%s.%s"", packageName, generatedClassName);
    Expression accExpr = new MethodReferenceExpr(new NameExpr(typeWithPackage), new NodeList<>(), ""new"");
    MethodCallExpr accFunctionCall = createDslTopLevelMethod(ACC_FUNCTION_CALL, nodeList(accExpr));
    if (accumulate.getRequiredDeclarations().length > 0) {
        accFunctionCall = new MethodCallExpr(accFunctionCall, ACC_WITH_EXTERNAL_DECLRS_CALL);
        for (Declaration requiredDeclaration : accumulate.getRequiredDeclarations()) {
            accFunctionCall.addArgument(context.getVar(requiredDeclaration.getIdentifier()));
        }
    }
    final String identifier;
    if (basePattern.getIdentifier() != null) {
        identifier = basePattern.getIdentifier();
    } else {
        identifier = generatedClassName;
        context.addDeclaration(generatedClassName, Object.class);
    }
    Expression bindingVariable = context.getVarExpr(identifier);
    accFunctionCall = new MethodCallExpr(accFunctionCall, BIND_AS_CALL, nodeList(bindingVariable));
    context.addExpression(accFunctionCall);
    context.increaseLegacyAccumulateCounter();
}",java:S3776,39
"private void addModifiedItemsToChangeSet(ResourceChangeSet mainChangeSet, Map<String, ResourceChangeSet> changes, ResourceChange.Type type, List<? extends NamedModelItem> oldItems, List<? extends NamedModelItem> newItems){
    if (oldItems.isEmpty()) {
        if (!newItems.isEmpty()) {
            for (NamedModelItem newItem : newItems) {
                registerChange(mainChangeSet, changes, type, ChangeType.ADDED, newItem);
            }
        }
        return;
    } else if (newItems.isEmpty()) {
        for (NamedModelItem oldItem : oldItems) {
            registerChange(mainChangeSet, changes, type, ChangeType.REMOVED, oldItem);
        }
        return;
    }
    oldItems.sort(Comparator.comparing(NamedModelItem::getName));
    newItems.sort(Comparator.comparing(NamedModelItem::getName));
    Iterator<? extends NamedModelItem> oldRulesIterator = oldItems.iterator();
    Iterator<? extends NamedModelItem> newRulesIterator = newItems.iterator();
    NamedModelItem currentOld = oldRulesIterator.next();
    NamedModelItem currentNew = newRulesIterator.next();
    while (true) {
        int compare = currentOld.getName().compareTo(currentNew.getName());
        if (compare == 0) {
            if (!areEqualInModel(currentOld, currentNew)) {
                registerChange(mainChangeSet, changes, type, ChangeType.UPDATED, currentOld);
            }
            if (oldRulesIterator.hasNext()) {
                currentOld = oldRulesIterator.next();
            } else {
                break;
            }
            if (newRulesIterator.hasNext()) {
                currentNew = newRulesIterator.next();
            } else {
                registerChange(mainChangeSet, changes, type, ChangeType.REMOVED, currentOld);
                break;
            }
        } else if (compare < 0) {
            registerChange(mainChangeSet, changes, type, ChangeType.REMOVED, currentOld);
            if (oldRulesIterator.hasNext()) {
                currentOld = oldRulesIterator.next();
            } else {
                registerChange(mainChangeSet, changes, type, ChangeType.ADDED, currentNew);
                break;
            }
        } else {
            registerChange(mainChangeSet, changes, type, ChangeType.ADDED, currentNew);
            if (newRulesIterator.hasNext()) {
                currentNew = newRulesIterator.next();
            } else {
                registerChange(mainChangeSet, changes, type, ChangeType.REMOVED, currentOld);
                break;
            }
        }
    }
    while (oldRulesIterator.hasNext()) {
        registerChange(mainChangeSet, changes, type, ChangeType.REMOVED, oldRulesIterator.next());
    }
    while (newRulesIterator.hasNext()) {
        registerChange(mainChangeSet, changes, type, ChangeType.ADDED, newRulesIterator.next());
    }
}",java:S3776,39
"private RuleConditionElement buildAccumulate(RuleContext ctx, GroupElement group, AccumulatePattern accumulatePattern){
    Pattern pattern = null;
    boolean isGroupBy = accumulatePattern instanceof GroupByPattern;
    if (accumulatePattern.getAccumulateFunctions() != null) {
        if (!isGroupBy && accumulatePattern.getAccumulateFunctions().length == 1) {
            pattern = ctx.getPattern(accumulatePattern.getAccumulateFunctions()[0].getResult());
        } else if (accumulatePattern.getAccumulateFunctions().length > 0 && ctx.getPattern(accumulatePattern.getAccumulateFunctions()[0].getResult()) != null) {
            throw new RuntimeException(""Only single accumulate functions, with no group by can optimize the result pattern to be the function return value"");
        }
    }
    boolean existingPattern = pattern != null;
    if (!existingPattern) {
        ObjectType type = !isGroupBy && accumulatePattern.getAccumulateFunctions().length == 1 ? new ClassObjectType(accumulatePattern.getAccumulateFunctions()[0].getResult().getType()) : JAVA_CLASS_ARRAY_TYPE;
        pattern = new Pattern(ctx.getNextPatternIndex(), type);
    }
    org.drools.model.Pattern sourcePattern = accumulatePattern.getPattern();
    Set<String> usedVariableName = new LinkedHashSet<>();
    if (sourcePattern != null) {
        for (Variable v : sourcePattern.getInputVariables()) {
            usedVariableName.add(v.getName());
        }
    }
    RuleConditionElement source;
    if (accumulatePattern.isQuerySource()) {
        source = buildQueryPattern(ctx, ((QueryCallPattern) accumulatePattern.getCondition()));
    } else if (accumulatePattern.isCompositePatterns()) {
        CompositePatterns compositePatterns = (CompositePatterns) accumulatePattern.getCondition();
        GroupElement allSubConditions = new GroupElement(conditionToGroupElementType(compositePatterns.getType()));
        for (Condition c : compositePatterns.getSubConditions()) {
            recursivelyAddConditions(ctx, group, allSubConditions, c);
        }
        source = allSubConditions.getChildren().size() == 1 ? allSubConditions.getChildren().get(0) : allSubConditions;
    } else {
        source = buildPattern(ctx, group, accumulatePattern);
    }
    Collection<Binding> bindings = new ArrayList<>();
    if (sourcePattern != null) {
        bindings.addAll(sourcePattern.getBindings());
        bindings.add(new SelfPatternBiding<>(sourcePattern.getPatternVariable()));
    } else {
        addInnerBindings(bindings, accumulatePattern.getAccumulateFunctions(), accumulatePattern.getCondition());
    }
    pattern.setSource(buildAccumulate(ctx, accumulatePattern, group, source, pattern, usedVariableName, bindings));
    return existingPattern ? null : pattern;
}",java:S3776,39
"private void processFunctions(RuleContext ctx, AccumulatePattern accPattern, RuleConditionElement source, Pattern pattern, Set<String> usedVariableName, Collection<Binding> bindings, boolean isGroupBy, AccumulateFunction accFunction, ReadAccessor selfReader, Accumulator[] accumulators, List<Declaration> requiredDeclarationList, int arrayIndexOffset, int i){
    Binding binding = findBindingForAccumulate(bindings, accFunction);
    if (binding != null) {
        for (Variable var : binding.getInputVariables()) {
            usedVariableName.add(var.getName());
        }
    }
    final BindingEvaluator bindingEvaluator = createBindingEvaluator(ctx, binding);
    final Accumulator accumulator = createAccumulator(usedVariableName, bindingEvaluator, accFunction);
    Variable boundVar = accPattern.getBoundVariables()[i];
    Declaration declaration;
    if (!isGroupBy && accumulators.length == 1) {
        declaration = new Declaration(boundVar.getName(), new PatternExtractor(new ClassObjectType(boundVar.getType())), pattern, true);
    } else {
        declaration = new Declaration(boundVar.getName(), new ArrayElementReader(selfReader, i + arrayIndexOffset, boundVar.getType()), pattern, true);
    }
    pattern.addDeclaration(declaration);
    ctx.addDeclaration(boundVar, declaration);
    accumulators[i] = accumulator;
    Declaration[] requiredDeclarations = getRequiredDeclarationsForAccumulate(ctx, source, accFunction, binding, bindingEvaluator);
    requiredDeclarationList.addAll(Arrays.asList(requiredDeclarations));
}",java:S107,1
"private Pattern addPatternForVariable(RuleContext ctx, GroupElement group, Variable patternVariable, Condition.Type type){
    Pattern pattern = null;
    if (patternVariable instanceof org.drools.model.Declaration) {
        org.drools.model.Declaration decl = (org.drools.model.Declaration) patternVariable;
        if (decl.getSource() == null) {
            Accumulate accSource = ctx.getAccumulateSource(patternVariable);
            if (accSource != null) {
                for (RuleConditionElement element : group.getChildren()) {
                    if (element instanceof Pattern && ((Pattern) element).getSource() == accSource) {
                        pattern = (Pattern) element;
                        break;
                    }
                }
            }
        }
    }
    PatternSource priorSource = null;
    if (pattern != null && type == Condition.Type.ACCUMULATE) {
        if (pattern.getSource() instanceof SingleAccumulate) {
            group.getChildren().remove(pattern);
            priorSource = pattern.getSource();
            pattern = null;
        }
    }
    if (pattern == null) {
        pattern = new Pattern(ctx.getNextPatternIndex(), 0, 0, getObjectType(patternVariable), patternVariable.getName(), true);
        pattern.setSource(priorSource);
    }
    if (patternVariable instanceof org.drools.model.Declaration) {
        org.drools.model.Declaration decl = (org.drools.model.Declaration) patternVariable;
        if (decl.getSource() != null) {
            if (decl.getSource() instanceof EntryPoint) {
                pattern.setSource(new EntryPointId(((EntryPoint) decl.getSource()).getName()));
            } else if (decl.getSource() instanceof WindowReference) {
                WindowReference<?> window = (WindowReference) decl.getSource();
                if (!ctx.getPkg().getWindowDeclarations().containsKey(window.getName())) {
                    createWindowReference(ctx, window);
                }
                pattern.setSource(new org.drools.base.rule.WindowReference(window.getName()));
            } else if (decl.getSource() instanceof From) {
                pattern.setSource(buildFrom(ctx, pattern, (From) decl.getSource()));
            } else if (decl.getSource() instanceof UnitData) {
                UnitData unitData = (UnitData) decl.getSource();
                pattern.setSource(new EntryPointId(ctx.getRule().getRuleUnitClassName() + ""."" + unitData.getName()));
            } else {
                throw new UnsupportedOperationException(""Unknown source: "" + decl.getSource());
            }
        }
        if (decl.getWindow() != null) {
            pattern.addBehavior(createWindow(decl.getWindow()));
            ctx.setNeedStreamMode();
        }
    } else if (patternVariable instanceof Exchange) {
        if (type == Condition.Type.SENDER) {
            Function0 supplier = ((Exchange) patternVariable).getMessageSupplier();
            DataProvider provider = new LambdaDataProvider(x -> supplier.apply(), false);
            pattern.setSource(new AsyncSend(pattern, patternVariable.getName(), provider));
        } else if (type == Condition.Type.RECEIVER) {
            pattern.setSource(new AsyncReceive(pattern, patternVariable.getName()));
        } else {
            throw new UnsupportedOperationException();
        }
    }
    ctx.registerPattern(patternVariable, pattern);
    return pattern;
}",java:S3776,39
"public int compareTo(GlobalSupplier o){
    return globalName.compareTo(o.globalName);
}",java:S1210,20
"public void replaceDeclaration(Declaration oldDecl, Declaration newDecl){
    for (int i = 0; i < declarations.length; i++) {
        if (declarations[i].equals(oldDecl)) {
            declarations[i] = newDecl;
            switch(i) {
                case 0:
                    if (innerEvaluator instanceof InnerEvaluator._1) {
                        ((InnerEvaluator._1) innerEvaluator).declaration = newDecl;
                    } else if (innerEvaluator instanceof InnerEvaluator._1_FH) {
                        ((InnerEvaluator._1_FH) innerEvaluator).declaration = newDecl;
                    } else if (innerEvaluator instanceof InnerEvaluator._2) {
                        ((InnerEvaluator._2) innerEvaluator).declaration1 = newDecl;
                    } else if (innerEvaluator instanceof InnerEvaluator._3) {
                        ((InnerEvaluator._3) innerEvaluator).declaration1 = newDecl;
                    } else if (innerEvaluator instanceof InnerEvaluator._4) {
                        ((InnerEvaluator._4) innerEvaluator).declaration1 = newDecl;
                    } else if (innerEvaluator instanceof InnerEvaluator._5) {
                        ((InnerEvaluator._5) innerEvaluator).declaration1 = newDecl;
                    }
                    break;
                case 1:
                    if (innerEvaluator instanceof InnerEvaluator._2) {
                        ((InnerEvaluator._2) innerEvaluator).declaration2 = newDecl;
                    } else if (innerEvaluator instanceof InnerEvaluator._3) {
                        ((InnerEvaluator._3) innerEvaluator).declaration2 = newDecl;
                    } else if (innerEvaluator instanceof InnerEvaluator._4) {
                        ((InnerEvaluator._4) innerEvaluator).declaration2 = newDecl;
                    } else if (innerEvaluator instanceof InnerEvaluator._5) {
                        ((InnerEvaluator._5) innerEvaluator).declaration2 = newDecl;
                    }
                    break;
                case 2:
                    if (innerEvaluator instanceof InnerEvaluator._3) {
                        ((InnerEvaluator._3) innerEvaluator).declaration3 = newDecl;
                    } else if (innerEvaluator instanceof InnerEvaluator._4) {
                        ((InnerEvaluator._4) innerEvaluator).declaration3 = newDecl;
                    } else if (innerEvaluator instanceof InnerEvaluator._5) {
                        ((InnerEvaluator._5) innerEvaluator).declaration3 = newDecl;
                    }
                    break;
                case 3:
                    if (innerEvaluator instanceof InnerEvaluator._4) {
                        ((InnerEvaluator._4) innerEvaluator).declaration4 = newDecl;
                    } else if (innerEvaluator instanceof InnerEvaluator._5) {
                        ((InnerEvaluator._5) innerEvaluator).declaration4 = newDecl;
                    }
                    break;
                case 4:
                    if (innerEvaluator instanceof InnerEvaluator._5) {
                        ((InnerEvaluator._5) innerEvaluator).declaration5 = newDecl;
                    }
                    break;
            }
            break;
        }
    }
}",java:S3776,39
"public ConstraintEvaluator clone(){
    return pattern == null ? new ConstraintEvaluator(getClonedDeclarations(), constraint) : new ConstraintEvaluator(getClonedDeclarations(), pattern, constraint);
}",java:S2975,34
"public ConstraintEvaluator clone(){
    return pattern == null ? new ConstraintEvaluator(getClonedDeclarations(), constraint) : new ConstraintEvaluator(getClonedDeclarations(), pattern, constraint);
}",java:S1182,14
"private static void wireMetaTypeAnnotations(TypeMetaData metaType, TypeDeclaration typeDeclaration){
    for (Map.Entry<String, AnnotationValue[]> ann : metaType.getAnnotations().entrySet()) {
        switch(ann.getKey()) {
            case ""role"":
                for (AnnotationValue annVal : ann.getValue()) {
                    if (annVal.getKey().equals(""value"") && annVal.getValue().equals(""event"")) {
                        typeDeclaration.setRole(Role.Type.EVENT);
                    }
                }
                break;
            case ""duration"":
                for (AnnotationValue annVal : ann.getValue()) {
                    if (annVal.getKey().equals(""value"")) {
                        wireDurationAccessor(annVal.getValue().toString(), typeDeclaration);
                    }
                }
                break;
            case ""timestamp"":
                for (AnnotationValue annVal : ann.getValue()) {
                    if (annVal.getKey().equals(""value"")) {
                        wireTimestampAccessor(annVal.getValue().toString(), typeDeclaration);
                    }
                }
                break;
            case ""expires"":
                for (AnnotationValue annVal : ann.getValue()) {
                    if (annVal.getKey().equals(""value"")) {
                        long offset = TimeIntervalParser.parseSingle(annVal.getValue().toString());
                        typeDeclaration.setExpirationOffset(offset == -1L ? Long.MAX_VALUE : offset);
                        typeDeclaration.setExpirationType(Expires.Policy.TIME_HARD);
                    } else if (annVal.getKey().equals(""policy"")) {
                        typeDeclaration.setExpirationType(Enum.valueOf(Expires.Policy.class, annVal.getValue().toString()));
                    }
                }
                break;
            case ""propertyReactive"":
                typeDeclaration.setPropertyReactive(true);
                break;
            case ""classReactive"":
                typeDeclaration.setPropertyReactive(false);
                break;
        }
    }
}",java:S3776,39
"private void processAnnotations(Class<?> cls, TypeResolver typeResolver){
    for (Annotation ann : cls.getAnnotations()) {
        try {
            Map<String, Object> valueMap = new HashMap<>();
            Class<?> annotationClass = null;
            Object value = null;
            for (Method m : ann.getClass().getMethods()) {
                if (m.getParameterCount() == 0 && m.getReturnType() != Void.class && m.getDeclaringClass() != Object.class && !m.getName().equals(""hashCode"") && !m.getName().equals(""toString"")) {
                    if (m.getName().equals(""annotationType"")) {
                        annotationClass = (Class<?>) m.invoke(ann);
                    } else {
                        valueMap.put(m.getName(), m.invoke(ann));
                        if (m.getName().equals(""value"")) {
                            value = m.invoke(ann);
                        }
                    }
                }
            }
            if (annotationClass != null) {
                addAnnotation(AnnotationDefinition.build(annotationClass, valueMap, typeResolver));
                if (value != null && annotationClass.getCanonicalName().startsWith(""org.kie.api.definition.type"")) {
                    addMetaData(annotationClass.getSimpleName().toLowerCase(), value.toString().toLowerCase());
                }
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}",java:S3776,39
"public void setKind(int kind){
    this.kind = kind;
}",java:S2177,28
"public static Bif loadBif(Resource resource, ArrayList<KnowledgeBuilderError> errors){
    InputStream is = null;
    try {
        is = resource.getInputStream();
    } catch (IOException e) {
        errors.add(new ParserError(resource, ""Exception opening Stream:\n"" + e.toString(), 0, 0));
        return null;
    }
    try {
        String encoding = resource instanceof InternalResource ? ((InternalResource) resource).getEncoding() : null;
        XStream xstream = encoding != null ? createNonTrustingXStream(new DomDriver(encoding)) : createNonTrustingXStream();
        initXStream(xstream);
        Bif bif = (Bif) xstream.fromXML(is);
        return bif;
    } catch (Exception e) {
        errors.add(new BayesNetworkAssemblerError(resource, ""Unable to parse opening Stream:\n"" + e.toString()));
        return null;
    }
}",java:S1319,22
"public void printComment(final Optional<Comment> comment, final Void arg){
    comment.ifPresent(c -> c.accept(this, arg));
}",java:S1161,11
"public void printTypeArgs(final NodeWithTypeArguments<?> nodeWithTypeArguments, final Void arg){
    NodeList<Type> typeArguments = nodeWithTypeArguments.getTypeArguments().orElse(null);
    if (!isNullOrEmpty(typeArguments)) {
        printer.print(""<"");
        for (final Iterator<Type> i = typeArguments.iterator(); i.hasNext(); ) {
            final Type t = i.next();
            t.accept(this, arg);
            if (i.hasNext()) {
                printer.print("", "");
            }
        }
        printer.print("">"");
    }
}",java:S1161,11
"public void printArguments(final NodeList<Expression> args, final Void arg){
    printer.print(""("");
    if (!isNullOrEmpty(args)) {
        boolean columnAlignParameters = (args.size() > 1) && configuration.get(new DefaultConfigurationOption(DefaultPrinterConfiguration.ConfigOption.COLUMN_ALIGN_PARAMETERS)).map(ConfigurationOption::asBoolean).orElse(false);
        if (columnAlignParameters) {
            printer.indentWithAlignTo(printer.getCursor().column);
        }
        for (final Iterator<Expression> i = args.iterator(); i.hasNext(); ) {
            final Expression e = i.next();
            e.accept(this, arg);
            if (i.hasNext()) {
                printer.print("","");
                if (columnAlignParameters) {
                    printer.println();
                } else {
                    printer.print("" "");
                }
            }
        }
        if (columnAlignParameters) {
            printer.unindent();
        }
    }
    printer.print("")"");
}",java:S3776,39
"public void printArguments(final NodeList<Expression> args, final Void arg){
    printer.print(""("");
    if (!isNullOrEmpty(args)) {
        boolean columnAlignParameters = (args.size() > 1) && configuration.get(new DefaultConfigurationOption(DefaultPrinterConfiguration.ConfigOption.COLUMN_ALIGN_PARAMETERS)).map(ConfigurationOption::asBoolean).orElse(false);
        if (columnAlignParameters) {
            printer.indentWithAlignTo(printer.getCursor().column);
        }
        for (final Iterator<Expression> i = args.iterator(); i.hasNext(); ) {
            final Expression e = i.next();
            e.accept(this, arg);
            if (i.hasNext()) {
                printer.print("","");
                if (columnAlignParameters) {
                    printer.println();
                } else {
                    printer.print("" "");
                }
            }
        }
        if (columnAlignParameters) {
            printer.unindent();
        }
    }
    printer.print("")"");
}",java:S1161,11
"private void jitObjectBinary(SingleCondition singleCondition, Expression left, Expression right, Class<?> type){
    Class<?> leftType = isDeclarationExpression(left) ? convertFromPrimitiveType(left.getType()) : left.getType();
    Class<?> rightType = isDeclarationExpression(right) ? convertFromPrimitiveType(right.getType()) : right.getType();
    jitExpression(left, type != null && type != CoercingComparisonType.class ? type : leftType);
    if (isDeclarationExpression(left) && left.getType().isPrimitive()) {
        castFromPrimitive(left.getType());
    }
    store(LEFT_OPERAND, leftType);
    jitExpression(right, type != null && type != CoercingComparisonType.class ? type : rightType);
    if (isDeclarationExpression(right) && right.getType().isPrimitive()) {
        castFromPrimitive(right.getType());
    }
    store(RIGHT_OPERAND, rightType);
    Label shortcutEvaluation = new Label();
    BooleanOperator operation = singleCondition.getOperation();
    prepareLeftOperand(operation, type, leftType, rightType, shortcutEvaluation);
    prepareRightOperand(right, type, rightType, shortcutEvaluation, operation);
    load(LEFT_OPERAND);
    load(RIGHT_OPERAND);
    switch(operation) {
        case CONTAINS:
            if (leftType == String.class && CharSequence.class.isAssignableFrom(rightType)) {
                invokeVirtual(String.class, ""contains"", boolean.class, CharSequence.class);
            } else {
                invokeStatic(EvaluatorHelper.class, ""contains"", boolean.class, Object.class, rightType.isPrimitive() ? rightType : Object.class);
            }
            break;
        case MATCHES:
            invokeVirtual(type, ""matches"", boolean.class, String.class);
            break;
        case SOUNDSLIKE:
            invokeStatic(EvaluatorHelper.class, ""soundslike"", boolean.class, String.class, String.class);
            break;
        default:
            if (operation.isEquality() && type != BigDecimal.class) {
                if (type.isInterface()) {
                    invokeInterface(type, ""equals"", boolean.class, Object.class);
                } else {
                    invokeVirtual(type, ""equals"", boolean.class, Object.class);
                }
            } else {
                if (type == CoercingComparisonType.class || type == Double.class) {
                    mv.visitLdcInsn(operation.toString());
                    invokeStatic(EvaluatorHelper.class, ""coercingComparison"", boolean.class, Object.class, Object.class, String.class);
                } else {
                    if (type.isInterface()) {
                        invokeInterface(type, ""compareTo"", int.class, type == Comparable.class ? Object.class : findComparingClass(type));
                    } else {
                        invokeVirtual(type, ""compareTo"", int.class, findComparingClass(type));
                    }
                    mv.visitInsn(ICONST_0);
                    jitPrimitiveOperation(operation == BooleanOperator.NE ? BooleanOperator.EQ : operation, int.class);
                }
            }
            if (operation == BooleanOperator.NE) {
                singleCondition.toggleNegation();
            }
    }
    mv.visitLabel(shortcutEvaluation);
}",java:S3776,39
"private Class<?> findCommonClass(Class<?> class1, boolean primitive1, Class<?> class2, boolean primitive2, BooleanOperator op){
    Class<?> result = null;
    if (class1 == class2) {
        result = class1;
    } else if (class1 == NullType.class) {
        result = convertFromPrimitiveType(class2);
    } else if (class2 == NullType.class) {
        result = convertFromPrimitiveType(class1);
    } else if (class1 == Object.class) {
        result = findCommonClassWithObject(class2, op);
    } else if (class2 == Object.class) {
        result = findCommonClassWithObject(class1, op);
    } else if (class1 == String.class && isCoercibleToString(class2)) {
        result = convertFromPrimitiveType(class2);
    } else if (class2 == String.class && isCoercibleToString(class1)) {
        result = convertFromPrimitiveType(class1);
    }
    if (result == null) {
        result = findCommonClass(class1, class2, primitive2);
    }
    if (result == null) {
        result = findCommonClass(class2, class1, primitive1);
    }
    if (result == null) {
        if (op.isEquality()) {
            return Object.class;
        } else {
            throw new RuntimeException(""Cannot find a common class between "" + class1.getName() + "" and "" + class2.getName() + "" ||  "" + class1.hashCode() + "" vs "" + class2.hashCode());
        }
    }
    return result == Number.class ? Double.class : result;
}",java:S3776,39
"private static double[][] getPosition(String stringPosition, double[][] position){
    if (stringPosition != null) {
        stringPosition = clearStringPostion(stringPosition);
        int i = 0;
        int j = 0;
        for (String pos : stringPosition.split("","")) {
            position[i][j] = Double.parseDouble(pos);
            if (i < j) {
                i += 1;
            }
            j += 1;
        }
    }
    return null;
}",java:S1144,10
"private Class<?> findCommonClass(Class<?> class1, Class<?> class2, boolean canBePrimitive){
    if (class1.isAssignableFrom(class2)) {
        return class1;
    }
    if (class1 == boolean.class && class2 == Boolean.class) {
        return canBePrimitive ? boolean.class : Boolean.class;
    }
    if (class1 == char.class && class2 == Character.class) {
        return canBePrimitive ? char.class : Character.class;
    }
    if (class1 == byte.class && class2 == Byte.class) {
        return canBePrimitive ? byte.class : Byte.class;
    }
    if (class1 == short.class && class2 == Short.class) {
        return canBePrimitive ? short.class : Short.class;
    }
    if (class1 == Number.class && class2.isPrimitive()) {
        return Double.class;
    }
    if (class1 == int.class || class1 == short.class || class1 == byte.class) {
        if (class2 == Integer.class) {
            return canBePrimitive ? int.class : Integer.class;
        }
        if (class2 == long.class) {
            return long.class;
        }
        if (class2 == Long.class) {
            return canBePrimitive ? long.class : Long.class;
        }
        if (class2 == float.class) {
            return float.class;
        }
        if (class2 == Float.class) {
            return canBePrimitive ? float.class : Float.class;
        }
        if (class2 == double.class) {
            return double.class;
        }
        if (class2 == Double.class) {
            return canBePrimitive ? double.class : Double.class;
        }
        if (class2 == BigInteger.class) {
            return BigInteger.class;
        }
        if (class2 == BigDecimal.class) {
            return BigDecimal.class;
        }
    }
    if (class1 == long.class) {
        if (class2 == int.class) {
            return long.class;
        }
        if (class2 == Integer.class) {
            return canBePrimitive ? long.class : Long.class;
        }
        if (class2 == Long.class) {
            return canBePrimitive ? long.class : Long.class;
        }
        if (class2 == float.class) {
            return double.class;
        }
        if (class2 == Float.class) {
            return canBePrimitive ? double.class : Double.class;
        }
        if (class2 == double.class) {
            return double.class;
        }
        if (class2 == Double.class) {
            return canBePrimitive ? double.class : Double.class;
        }
        if (class2 == BigInteger.class) {
            return BigInteger.class;
        }
        if (class2 == BigDecimal.class) {
            return BigDecimal.class;
        }
    }
    if (class1 == float.class) {
        if (class2 == int.class) {
            return float.class;
        }
        if (class2 == Integer.class) {
            return canBePrimitive ? float.class : Float.class;
        }
        if (class2 == long.class) {
            return double.class;
        }
        if (class2 == Long.class) {
            return canBePrimitive ? double.class : Double.class;
        }
        if (class2 == Float.class) {
            return canBePrimitive ? float.class : Float.class;
        }
        if (class2 == double.class) {
            return double.class;
        }
        if (class2 == Double.class) {
            return canBePrimitive ? double.class : Double.class;
        }
        if (class2 == BigInteger.class) {
            return BigDecimal.class;
        }
        if (class2 == BigDecimal.class) {
            return BigDecimal.class;
        }
    }
    if (class1 == double.class) {
        if (class2 == int.class) {
            return float.class;
        }
        if (class2 == Integer.class) {
            return canBePrimitive ? double.class : Double.class;
        }
        if (class2 == long.class) {
            return double.class;
        }
        if (class2 == Long.class) {
            return canBePrimitive ? double.class : Double.class;
        }
        if (class2 == float.class) {
            return double.class;
        }
        if (class2 == Float.class) {
            return canBePrimitive ? double.class : Double.class;
        }
        if (class2 == Double.class) {
            return canBePrimitive ? double.class : Double.class;
        }
        if (class2 == BigInteger.class) {
            return BigDecimal.class;
        }
        if (class2 == BigDecimal.class) {
            return BigDecimal.class;
        }
    }
    if (class1 == Integer.class) {
        if (class2 == Long.class) {
            return Long.class;
        }
        if (class2 == Float.class) {
            return Float.class;
        }
        if (class2 == Double.class) {
            return Double.class;
        }
        if (class2 == BigInteger.class) {
            return BigInteger.class;
        }
        if (class2 == BigDecimal.class) {
            return BigDecimal.class;
        }
    }
    if (class1 == Long.class) {
        if (class2 == Float.class) {
            return Double.class;
        }
        if (class2 == Double.class) {
            return Double.class;
        }
        if (class2 == BigInteger.class) {
            return BigInteger.class;
        }
        if (class2 == BigDecimal.class) {
            return BigDecimal.class;
        }
    }
    if (class1 == Float.class) {
        if (class2 == Double.class) {
            return Double.class;
        }
        if (class2 == BigInteger.class) {
            return BigDecimal.class;
        }
        if (class2 == BigDecimal.class) {
            return BigDecimal.class;
        }
    }
    if (class1 == Double.class) {
        if (class2 == BigInteger.class) {
            return BigDecimal.class;
        }
        if (class2 == BigDecimal.class) {
            return BigDecimal.class;
        }
    }
    if (class1 == BigInteger.class && class2 == BigDecimal.class) {
        return BigDecimal.class;
    }
    return null;
}",java:S3776,39
"public void toggleNegation(){
    throw new UnsupportedOperationException();
}",java:S1161,11
"public String toString(){
    return symbol;
}",java:S1161,11
"public String toString(){
    return symbol;
}",java:S1161,11
"public EvaluatorConstraint clone(){
    if (isLiteral()) {
        return new EvaluatorConstraint(field, evaluator, rightReadAccessor);
    }
    Declaration[] clonedDeclarations = new Declaration[declarations.length];
    System.arraycopy(declarations, 0, clonedDeclarations, 0, declarations.length);
    return new EvaluatorConstraint(clonedDeclarations, evaluator, rightReadAccessor);
}",java:S2975,34
"public EvaluatorConstraint clone(){
    if (isLiteral()) {
        return new EvaluatorConstraint(field, evaluator, rightReadAccessor);
    }
    Declaration[] clonedDeclarations = new Declaration[declarations.length];
    System.arraycopy(declarations, 0, clonedDeclarations, 0, declarations.length);
    return new EvaluatorConstraint(clonedDeclarations, evaluator, rightReadAccessor);
}",java:S1182,14
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(field);
    out.writeObject(declarations);
    out.writeObject(rightReadAccessor);
    out.writeObject(evaluator);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    field = (FieldValue) in.readObject();
    declarations = (Declaration[]) in.readObject();
    rightReadAccessor = (ReadAccessor) in.readObject();
    evaluator = (Evaluator) in.readObject();
}",java:S1161,11
"public void resetTuple(){
}",java:S1186,16
"private static boolean isEvaluated(ASTNode node){
    node = unwrapSubstatement(node);
    if (node == null) {
        return true;
    }
    if (node instanceof Contains) {
        return ((Contains) node).getFirstStatement().getAccessor() != null;
    }
    if (node instanceof BooleanNode) {
        return isEvaluated(((BooleanNode) node).getLeft()) && isEvaluated(((BooleanNode) node).getRight());
    }
    Accessor accessor = node.getAccessor();
    if (accessor == null) {
        return node instanceof LiteralNode;
    }
    if (accessor instanceof AccessorNode) {
        AccessorNode nextNode = ((AccessorNode) accessor).getNextNode();
        if (nextNode instanceof MethodAccessor && ((MethodAccessor) nextNode).getParms() != null) {
            for (ExecutableStatement param : ((MethodAccessor) nextNode).getParms()) {
                if (!isFullyEvaluated(param)) {
                    return false;
                }
            }
        }
    }
    return true;
}",java:S3776,39
"protected boolean evaluate(FactHandle handle, ValueResolver valueResolver, BaseTuple tuple){
    if (!jitted) {
        int jittingThreshold = TEST_JITTING ? 0 : valueResolver.getRuleBase().getConfiguration().getOption(ConstraintJittingThresholdOption.KEY).getThreshold();
        if (conditionEvaluator == null) {
            if (jittingThreshold == 0 && !isDynamic) {
                synchronized (this) {
                    if (conditionEvaluator == null) {
                        conditionEvaluator = forceJitEvaluator(handle, valueResolver, tuple);
                    }
                }
            } else {
                conditionEvaluator = createMvelConditionEvaluator(valueResolver);
            }
        }
        if (jittingThreshold != 0 && !isDynamic && invocationCounter.getAndIncrement() == jittingThreshold) {
            jitEvaluator(handle, valueResolver, tuple);
        }
    }
    try {
        return conditionEvaluator.evaluate(handle, valueResolver, tuple);
    } catch (Exception e) {
        throw new ConstraintEvaluationException(expression, evaluationContext, e);
    }
}",java:S3776,39
"private BitMask calculateMaskFromExpression(Optional<Pattern> pattern, List<String> settableProperties){
    BitMask mask = getEmptyPropertyReactiveMask(settableProperties.size());
    String[] simpleExpressions = expression.split(""\\Q&&\\E|\\Q||\\E"");
    for (String simpleExpression : simpleExpressions) {
        List<String> properties = getPropertyNamesFromSimpleExpression(simpleExpression);
        if (properties.isEmpty()) {
            return allSetBitMask();
        }
        boolean firstProp = true;
        for (String propertyName : properties) {
            String originalPropertyName = propertyName;
            if (propertyName == null || propertyName.equals(""this"") || propertyName.length() == 0) {
                return allSetButTraitBitMask();
            }
            int pos = settableProperties.indexOf(propertyName);
            if (pos < 0) {
                if (Character.isUpperCase(propertyName.charAt(0))) {
                    propertyName = propertyName.substring(0, 1).toLowerCase() + propertyName.substring(1);
                    pos = settableProperties.indexOf(propertyName);
                } else {
                    propertyName = findBoundVariable(propertyName, pattern);
                    if (propertyName != null) {
                        pos = settableProperties.indexOf(propertyName);
                    }
                }
            }
            if (pos >= 0) {
                mask = mask.set(pos + PropertySpecificUtil.CUSTOM_BITS_OFFSET);
            } else {
                if (firstProp) {
                    if (simpleExpression.indexOf("" contains "") > simpleExpression.indexOf(originalPropertyName)) {
                        continue;
                    }
                    if (isBoundVariableFromDifferentPattern(originalPropertyName, pattern)) {
                        logger.warn(""{} is not relevant to this pattern, so it causes class reactivity."" + "" Consider placing this constraint in the original pattern if possible : {}"", originalPropertyName, simpleExpression);
                    }
                    return allSetBitMask();
                }
            }
            firstProp = false;
        }
    }
    return mask;
}",java:S3776,39
"private int nextPropertyName(String expression, List<String> names, int cursor){
    StringBuilder propertyNameBuilder = new StringBuilder();
    cursor = extractFirstIdentifier(expression, propertyNameBuilder, cursor);
    if (propertyNameBuilder.length() == 0) {
        return cursor;
    }
    boolean isAccessor = false;
    String propertyName = propertyNameBuilder.toString();
    if (propertyName.equals(""this"")) {
        cursor = skipBlanks(expression, cursor);
        if (cursor >= expression.length() || expression.charAt(cursor) != '.') {
            names.add(""this"");
            return cursor;
        }
        propertyNameBuilder = new StringBuilder();
        extractFirstIdentifier(expression, propertyNameBuilder, cursor);
        propertyName = propertyNameBuilder.toString();
    } else if (propertyName.equals(""null"") || propertyName.equals(""true"") || propertyName.equals(""false"")) {
        propertyNameBuilder = new StringBuilder();
        extractFirstIdentifier(expression, propertyNameBuilder, cursor);
        propertyName = propertyNameBuilder.toString();
    }
    if (propertyName.startsWith(""is"") || propertyName.startsWith(""get"")) {
        int exprPos = expression.indexOf(propertyName);
        int propNameEnd = exprPos + propertyName.length();
        if (expression.length() > propNameEnd + 1 && expression.charAt(propNameEnd) == '(') {
            int argsEnd = expression.indexOf(')', propNameEnd);
            if (expression.substring(propNameEnd + 1, argsEnd).trim().isEmpty()) {
                propertyName = getter2property(propertyName);
                isAccessor = true;
            }
        }
    }
    if (!isAccessor) {
        Character lookAhead = lookAheadIgnoringSpaces(expression, cursor);
        boolean isMethodInvocation = lookAhead != null && lookAhead.equals('(');
        if (isMethodInvocation) {
            return nextPropertyName(expression, names, cursor);
        }
    }
    if (propertyName != null && propertyName.length() > 0) {
        names.add(propertyName);
    }
    return skipOperator(expression, cursor);
}",java:S3776,39
"private String getFirstInvokedPropertyName(ObjectType modifiedType, Expression expression){
    if (!(expression instanceof EvaluatedExpression)) {
        return null;
    }
    List<Invocation> invocations = ((EvaluatedExpression) expression).invocations;
    Invocation invocation = invocations.get(0);
    if (invocation instanceof MethodInvocation) {
        Method method = ((MethodInvocation) invocation).getMethod();
        if (method == null) {
            if (invocations.size() > 1) {
                invocation = invocations.get(1);
                if (invocation instanceof MethodInvocation) {
                    method = ((MethodInvocation) invocation).getMethod();
                } else if (invocation instanceof FieldAccessInvocation) {
                    return ((FieldAccessInvocation) invocation).getField().getName();
                }
            } else {
                return null;
            }
        }
        return method != null && !Modifier.isStatic(method.getModifiers()) && modifiedType.isAssignableTo(method.getDeclaringClass()) ? getter2property(method.getName()) : null;
    }
    if (invocation instanceof FieldAccessInvocation) {
        return ((FieldAccessInvocation) invocation).getField().getName();
    }
    return null;
}",java:S3776,39
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(packageNames);
    out.writeObject(expression);
    if (extractor instanceof ClassFieldReader) {
        out.writeObject(((ClassFieldReader) extractor).getAccessorKey());
    } else {
        out.writeObject(extractor);
    }
    out.writeObject(indexingDeclaration);
    out.writeObject(declarations);
    out.writeObject(constraintType);
    out.writeBoolean(isUnification);
    out.writeBoolean(isDynamic);
    out.writeObject(fieldValue);
    out.writeObject(compilationUnit);
    out.writeObject(evaluationContext);
    out.writeObject(operators);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    packageNames = (Set<String>) in.readObject();
    expression = (String) in.readObject();
    if (in instanceof DroolsObjectInputStream) {
        ((DroolsObjectInputStream) in).readExtractor(this::setReadAccessor);
    } else {
        extractor = (ReadAccessor) in.readObject();
    }
    indexingDeclaration = (Declaration) in.readObject();
    declarations = (Declaration[]) in.readObject();
    constraintType = (ConstraintTypeOperator) in.readObject();
    isUnification = in.readBoolean();
    isDynamic = in.readBoolean();
    fieldValue = (FieldValue) in.readObject();
    compilationUnit = (MVELCompilationUnit) in.readObject();
    evaluationContext = (EvaluationContext) in.readObject();
    operators = (EvaluatorWrapper[]) in.readObject();
}",java:S1161,11
"public MVELConstraint clone(){
    Declaration[] clonedDeclarations = new Declaration[declarations.length];
    System.arraycopy(declarations, 0, clonedDeclarations, 0, declarations.length);
    MVELConstraint clone = new MVELConstraint();
    clone.setType(getType());
    clone.packageNames = packageNames;
    clone.expression = expression;
    clone.fieldValue = fieldValue;
    clone.constraintType = constraintType;
    clone.declarations = clonedDeclarations;
    clone.operators = operators;
    if (indexingDeclaration != null) {
        clone.indexingDeclaration = indexingDeclaration.clone();
    }
    clone.extractor = extractor;
    clone.isUnification = isUnification;
    clone.isDynamic = isDynamic;
    clone.conditionEvaluator = conditionEvaluator;
    clone.compilationUnit = compilationUnit != null ? compilationUnit.clone() : null;
    return clone;
}",java:S2975,34
"public MVELConstraint clone(){
    Declaration[] clonedDeclarations = new Declaration[declarations.length];
    System.arraycopy(declarations, 0, clonedDeclarations, 0, declarations.length);
    MVELConstraint clone = new MVELConstraint();
    clone.setType(getType());
    clone.packageNames = packageNames;
    clone.expression = expression;
    clone.fieldValue = fieldValue;
    clone.constraintType = constraintType;
    clone.declarations = clonedDeclarations;
    clone.operators = operators;
    if (indexingDeclaration != null) {
        clone.indexingDeclaration = indexingDeclaration.clone();
    }
    clone.extractor = extractor;
    clone.isUnification = isUnification;
    clone.isDynamic = isDynamic;
    clone.conditionEvaluator = conditionEvaluator;
    clone.compilationUnit = compilationUnit != null ? compilationUnit.clone() : null;
    return clone;
}",java:S1182,14
"private static List<String> splitExpression(String expression){
    List<String> tokens = new ArrayList<>();
    int lastStart = -1;
    boolean isQuoted = false;
    for (int i = 0; i < expression.length(); i++) {
        if (lastStart == -1) {
            if (!isQuoted && Character.isJavaIdentifierStart(expression.charAt(i))) {
                lastStart = i;
            }
        } else if (!Character.isJavaIdentifierPart(expression.charAt(i))) {
            tokens.add(expression.subSequence(lastStart, i).toString());
            lastStart = -1;
        }
        if (expression.charAt(i) == '""' || expression.charAt(i) == '\'') {
            if (i == 0 || expression.charAt(i - 1) != '\\') {
                isQuoted = !isQuoted;
            }
            if (isQuoted) {
                lastStart = -1;
            }
        }
    }
    if (lastStart != -1) {
        tokens.add(expression.subSequence(lastStart, expression.length()).toString());
    }
    return tokens;
}",java:S3776,39
"public void registerEvaluationContext(RuleBuildContext buildContext){
    evaluationContext.addContext(buildContext);
}",java:S1161,11
"public void onRemove(){
}",java:S1186,16
"private void rewireImportedMethods(){
    if (imports != null) {
        Map<String, Object> rewiredMethod = new HashMap<>();
        for (Object imp : imports.values()) {
            if (imp instanceof Method) {
                Method method = (Method) imp;
                try {
                    Class<?> c = Class.forName(method.getDeclaringClass().getName(), false, getPackageClassLoader());
                    for (Method m : c.getDeclaredMethods()) {
                        if (method.getName().equals(m.getName()) && method.getParameterTypes().length == m.getParameterTypes().length) {
                            rewiredMethod.put(m.getName(), m);
                            break;
                        }
                    }
                } catch (ClassNotFoundException e) {
                    throw new RuntimeException(e);
                }
            }
        }
        imports.putAll(rewiredMethod);
    }
}",java:S3776,39
"public void removeRule(KnowledgePackageImpl pkg, RuleImpl rule){
}",java:S1186,16
"public void reload(){
}",java:S1186,16
"public VariableResolver createVariable(String name, Object value){
    throw new RuntimeException(""variable is a read-only function pointer"");
}",java:S1161,11
"public VariableResolver createIndexedVariable(int index, String name, Object value, Class<?> type){
    throw new RuntimeException(""variable is a read-only function pointer"");
}",java:S1161,11
"public ParserConfiguration getParserConfiguration(){
    if (parserConfiguration == null) {
        ClassLoader packageClassLoader = getPackageClassLoader();
        String key = null;
        Object value = null;
        try {
            for (Entry<String, Object> entry : this.imports.entrySet()) {
                key = entry.getKey();
                value = entry.getValue();
                if (entry.getValue() instanceof String) {
                    String str = (String) value;
                    if (str.startsWith(""m:"")) {
                        Class cls = packageClassLoader.loadClass(str.substring(2));
                        for (Method method : cls.getDeclaredMethods()) {
                            if (method.getName().equals(key)) {
                                entry.setValue(method);
                                break;
                            }
                        }
                    } else {
                        Class cls = packageClassLoader.loadClass(str);
                        entry.setValue(cls);
                    }
                }
            }
        } catch (ClassNotFoundException e) {
            throw new IllegalArgumentException(""Unable to resolve method of field: "" + key + "" - "" + value, e);
        }
        final ParserConfiguration conf = new ParserConfiguration();
        conf.setImports(this.imports);
        conf.setPackageImports(this.packageImports);
        conf.setClassLoader(packageClassLoader);
        this.parserConfiguration = conf;
    }
    return this.parserConfiguration;
}",java:S3776,39
"public void compile(ReadAccessor reader){
    addCompileable((MVELCompileable) reader);
    ((MVELCompileable) reader).compile(this);
}",java:S1161,11
"public ClassLoader getRootClassLoader(){
    return rootClassLoader;
}",java:S1161,11
"protected Date getDate(ValueResolver valueResolver, Object object){
    LocalDate ld = ((LocalDate) getValue(valueResolver, object));
    return Date.from(ld.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant());
}",java:S1161,11
"protected Date getDate(ValueResolver valueResolver, Object object){
    LocalDateTime ldt = ((LocalDateTime) getValue(valueResolver, object));
    return Date.from(ldt.atZone(ZoneId.systemDefault()).toInstant());
}",java:S1161,11
"protected Date getDate(ValueResolver valueResolver, Object object){
    ZonedDateTime zdt = ((ZonedDateTime) getValue(valueResolver, object));
    return Date.from(zdt.toInstant());
}",java:S1161,11
"private static void parseInsertDescr(RuleBuildContext context, JavaBlockDescr block){
    String expr = block.getTargetExpression();
    if (expr.startsWith(""new "")) {
        int argsStart = expr.indexOf('(');
        if (argsStart > 0) {
            String className = expr.substring(4, argsStart).trim();
            Class<?> typeClass = findClassByName(context, className);
            TypeDeclaration typeDeclaration = typeClass == null ? null : context.getKnowledgeBuilder().getTypeDeclaration(typeClass);
            if (typeDeclaration != null) {
                ConsequenceMetaData.Statement statement = new ConsequenceMetaData.Statement(ConsequenceMetaData.Statement.Type.INSERT, typeClass);
                context.getRule().getConsequenceMetaData().addStatement(statement);
                String constructorParams = expr.substring(argsStart + 1, expr.indexOf(')')).trim();
                List<String> args = splitArgumentsList(constructorParams);
                ClassDefinition classDefinition = typeDeclaration.getTypeClassDef();
                List<FactField> fields = classDefinition.getFields();
                if (args.size() == fields.size()) {
                    for (int i = 0; i < args.size(); i++) {
                        statement.addField(fields.get(i).getName(), args.get(i));
                    }
                }
            }
        }
    }
}",java:S3776,39
"private static void rewriteDescr(final RuleBuildContext context, final StringBuilder consequence, final JavaBlockDescr d, final JavaAnalysisResult analysis, final Map<String, Declaration> decls){
    if (d.getEnd() == 0) {
        return;
    }
    boolean typeSafety = context.isTypesafe();
    context.setTypesafe(false);
    Map<String, Class<?>> localTypes = d.getInputs();
    if (d.getInScopeLocalVars() != null && !d.getInScopeLocalVars().isEmpty()) {
        localTypes = new HashMap<>(d.getInputs() != null ? d.getInputs() : Collections.emptyMap());
        for (JavaLocalDeclarationDescr local : d.getInScopeLocalVars()) {
            try {
                Class<?> type = context.getDialect(""java"").getPackageRegistry().getTypeResolver().resolveType(local.getRawType());
                for (JavaLocalDeclarationDescr.IdentifierDescr id : local.getIdentifiers()) {
                    localTypes.put(id.getIdentifier(), type);
                }
            } catch (ClassNotFoundException e) {
                context.addError(new DescrBuildError(context.getRuleDescr(), context.getParentDescr(), null, ""Unable to resolve type "" + local.getRawType() + "":\n"" + e.getMessage()));
            }
        }
    }
    MVELDialect mvel = (MVELDialect) context.getDialect(""mvel"");
    MVELAnalysisResult mvelAnalysis = (MVELAnalysisResult) mvel.analyzeBlock(context, d.getTargetExpression(), analysis.getBoundIdentifiers(), localTypes, ""drools"", KnowledgeHelper.class);
    context.setTypesafe(typeSafety);
    if (mvelAnalysis == null) {
        return;
    }
    Class<?> ret = mvelAnalysis.getReturnType();
    if (ret == null) {
        context.addError(new DescrBuildError(context.getParentDescr(), context.getRuleDescr(), analysis.getAnalyzedExpr(), ""Unable to determine the resulting type of the expression: "" + d.getTargetExpression() + ""\n""));
        return;
    }
    String retString = ClassUtils.canonicalName(ret);
    String declrString;
    if (d.getTargetExpression().charAt(0) == '(') {
        declrString = d.getTargetExpression().substring(1, d.getTargetExpression().length() - 1).trim();
    } else {
        declrString = d.getTargetExpression();
    }
    String obj = declrString;
    Declaration declr = decls.get(declrString);
    consequence.append(""{ "");
    if (declr == null) {
        obj = ""__obj__"";
        consequence.append(retString);
        consequence.append("" "");
        consequence.append(obj);
        consequence.append("" = "");
        consequence.append(d.getTargetExpression());
        consequence.append(""; "");
    }
    if (declr == null || declr.isInternalFact()) {
        consequence.append(""org.kie.api.runtime.rule.FactHandle "");
        consequence.append(obj);
        consequence.append(""__Handle2__ = drools.getFactHandle("");
        consequence.append(obj);
        consequence.append("");"");
    }
    String originalBlock = analysis.getAnalyzedExpr().substring(d.getStart() - 1, d.getEnd());
    switch(d.getType()) {
        case MODIFY:
            rewriteModifyDescr(context, d, analysis, originalBlock, consequence, declr, obj);
            break;
        case UPDATE:
            rewriteUpdateDescr(context, d, analysis, consequence, declr, obj);
            break;
        case DELETE:
            rewriteDeleteDescr(context, d, consequence, declr, obj);
            break;
    }
}",java:S3776,39
"private static BitMask parseModifiedProperties(ConsequenceMetaData.Statement statement, List<String> settableProperties, TypeDeclaration typeDeclaration, boolean propertyReactive, BitMask modificationMask, String exprStr){
    int endMethodName = exprStr.indexOf('(');
    if (endMethodName >= 0) {
        String methodName = exprStr.substring(0, endMethodName).trim();
        String propertyName = setter2property(methodName);
        int endMethodArgs = findEndOfMethodArgsIndex(exprStr, endMethodName);
        String methodParams = exprStr.substring(endMethodName + 1, endMethodArgs).trim();
        List<String> args = splitArgumentsList(methodParams);
        int argsNr = args.size();
        if (propertyName == null && exprStr.length() > endMethodArgs + 1 && exprStr.substring(endMethodArgs + 1).trim().startsWith(""."")) {
            propertyName = getter2property(methodName);
        }
        if (propertyName != null) {
            modificationMask = updateModificationMask(settableProperties, propertyReactive, modificationMask, propertyName);
            statement.addField(propertyName, argsNr > 0 ? args.get(0) : null);
        }
        List<String> modifiedProps = typeDeclaration.getTypeClassDef().getModifiedPropsByMethod(methodName, argsNr);
        if (modifiedProps != null) {
            for (String modifiedProp : modifiedProps) {
                modificationMask = updateModificationMask(settableProperties, propertyReactive, modificationMask, modifiedProp);
                statement.addField(modifiedProp, argsNr > 0 ? args.get(0) : null);
            }
        }
        if (propertyReactive && propertyName == null && modifiedProps == null) {
            modificationMask = allSetButTraitBitMask();
        }
    } else {
        String propertyName = extractFirstIdentifier(exprStr, 0);
        modificationMask = updateModificationMask(settableProperties, propertyReactive, modificationMask, propertyName);
        int equalPos = exprStr.indexOf('=');
        if (equalPos >= 0) {
            String value = exprStr.substring(equalPos + 1).trim();
            statement.addField(propertyName, value);
        }
    }
    return modificationMask;
}",java:S3776,39
"private static Class<?> getReaderSuperClassFor(final Class<?> fieldType){
    Class<?> ret = null;
    if (fieldType.isPrimitive()) {
        if (fieldType == char.class) {
            ret = BaseCharClassFieldReader.class;
        } else if (fieldType == byte.class) {
            ret = BaseByteClassFieldReader.class;
        } else if (fieldType == short.class) {
            ret = BaseShortClassFieldReader.class;
        } else if (fieldType == int.class) {
            ret = BaseIntClassFieldReader.class;
        } else if (fieldType == long.class) {
            ret = BaseLongClassFieldReader.class;
        } else if (fieldType == float.class) {
            ret = BaseFloatClassFieldReader.class;
        } else if (fieldType == double.class) {
            ret = BaseDoubleClassFieldReader.class;
        } else if (fieldType == boolean.class) {
            ret = BaseBooleanClassFieldReader.class;
        }
    } else if (Number.class.isAssignableFrom(fieldType)) {
        ret = BaseNumberClassFieldReader.class;
    } else if (Date.class.isAssignableFrom(fieldType)) {
        ret = BaseDateClassFieldReader.class;
    } else if (LocalDate.class.isAssignableFrom(fieldType)) {
        ret = BaseLocalDateClassFieldReader.class;
    } else if (LocalDateTime.class.isAssignableFrom(fieldType)) {
        ret = BaseLocalDateTimeClassFieldReader.class;
    } else if (ZonedDateTime.class.isAssignableFrom(fieldType)) {
        ret = BaseZonedDateTimeClassFieldReader.class;
    } else {
        ret = BaseObjectClassFieldReader.class;
    }
    return ret;
}",java:S3776,39
"private void processClassWithoutByteCode(final Class<?> clazz, final boolean includeFinalMethods){
    final List<Method> methods = Arrays.asList(clazz.getMethods());
    methods.sort((m1, m2) -> {
        String n1 = m1.getName();
        String n2 = m2.getName();
        if (n1.equals(n2) && m1.getDeclaringClass() != m2.getDeclaringClass()) {
            return m1.getDeclaringClass().isAssignableFrom(m2.getDeclaringClass()) ? -1 : 1;
        } else {
            return n1.compareTo(n2);
        }
    });
    final int mask = includeFinalMethods ? Modifier.PUBLIC : Modifier.PUBLIC | Modifier.FINAL;
    for (Method method : methods) {
        if ((method.getModifiers() & mask) == Opcodes.ACC_PUBLIC) {
            if (method.getParameterTypes().length == 0 && !method.getName().equals(""<init>"") && !method.getName().equals(""<clinit>"") && method.getReturnType() != void.class) {
                addToMapping(method, currentFieldIndex());
            } else if (method.getParameterTypes().length == 1 && method.getName().startsWith(""set"")) {
                addToMapping(method, currentFieldIndex());
            }
        }
    }
    final List<Field> flds = Arrays.asList(clazz.getFields());
    Collections.sort(flds, Comparator.comparing(Field::getName));
    for (Field fld : flds) {
        if (!Modifier.isStatic(fld.getModifiers()) && !fieldNames.containsKey(fld.getName())) {
            this.fieldNames.put(fld.getName(), currentFieldIndex());
            this.fieldTypes.put(fld.getName(), fld.getType());
            this.fieldTypesField.put(fld.getName(), fld);
        }
    }
}",java:S3776,39
"private void storeGetterSetter(Method method, String fieldName){
    Field f = getAllFields(classUnderInspection).get(fieldName);
    if (method.getName().startsWith(""set"") && method.getParameterTypes().length == 1) {
        this.setterMethods.put(fieldName, method);
        if (!fieldTypes.containsKey(fieldName)) {
            this.fieldTypes.put(fieldName, method.getParameterTypes()[0]);
        }
        if (!fieldTypesField.containsKey(fieldName)) {
            this.fieldTypesField.put(fieldName, f);
        }
    } else if (!void.class.isAssignableFrom(method.getReturnType())) {
        Method existingMethod = getterMethods.get(fieldName);
        if (existingMethod != null && !MethodUtils.isOverride(existingMethod, method)) {
            if (method.getReturnType() != existingMethod.getReturnType()) {
                if (method.getReturnType().isAssignableFrom(existingMethod.getReturnType())) {
                    return;
                } else if (existingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {
                } else {
                    addResult(fieldName, new IncompatibleGetterOverloadError(classUnderInspection, this.getterMethods.get(fieldName).getName(), this.fieldTypes.get(fieldName), method.getName(), method.getReturnType()));
                }
            } else if (Modifier.isAbstract(method.getModifiers()) && Modifier.isAbstract(existingMethod.getModifiers())) {
            } else {
                Map<String, Integer> accessorPriorityMap = ClassUtils.accessorPriorityMap(fieldName);
                if (accessorPriorityMap.get(existingMethod.getName()) > accessorPriorityMap.get(method.getName())) {
                    return;
                }
            }
        }
        this.getterMethods.put(fieldName, method);
        this.fieldTypes.put(fieldName, method.getReturnType());
        this.fieldTypesField.put(fieldName, f);
    }
}",java:S3776,39
"public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions){
    final int mask = this.includeFinalMethods ? Opcodes.ACC_PUBLIC : Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL;
    if ((access & mask) == Opcodes.ACC_PUBLIC) {
        try {
            if (desc.startsWith(""()"") && (!name.equals(""<init>"")) && (!name.equals(""<clinit>""))) {
                final Method method = this.clazz.getMethod(name, (Class[]) null);
                if (method.getReturnType() != void.class) {
                    this.inspector.addToMapping(method, inspector.currentFieldIndex());
                }
            } else if (name.startsWith(""set"")) {
                Method[] methods = this.clazz.getMethods();
                for (Method method : methods) {
                    if (name.equals(method.getName()) && desc.equals(Type.getMethodDescriptor(method))) {
                        this.inspector.addToMapping(method, inspector.currentFieldIndex());
                        break;
                    }
                }
            }
        } catch (final Exception e) {
            throw new RuntimeException(""Error getting field access method: "" + name + "": "" + e.getMessage(), e);
        }
    }
    return null;
}",java:S3776,39
"public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions){
    final int mask = this.includeFinalMethods ? Opcodes.ACC_PUBLIC : Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL;
    if ((access & mask) == Opcodes.ACC_PUBLIC) {
        try {
            if (desc.startsWith(""()"") && (!name.equals(""<init>"")) && (!name.equals(""<clinit>""))) {
                final Method method = this.clazz.getMethod(name, (Class[]) null);
                if (method.getReturnType() != void.class) {
                    this.inspector.addToMapping(method, inspector.currentFieldIndex());
                }
            } else if (name.startsWith(""set"")) {
                Method[] methods = this.clazz.getMethods();
                for (Method method : methods) {
                    if (name.equals(method.getName()) && desc.equals(Type.getMethodDescriptor(method))) {
                        this.inspector.addToMapping(method, inspector.currentFieldIndex());
                        break;
                    }
                }
            }
        } catch (final Exception e) {
            throw new RuntimeException(""Error getting field access method: "" + name + "": "" + e.getMessage(), e);
        }
    }
    return null;
}",java:S1161,11
"public void visitInnerClass(final String arg0, final String arg1, final String arg2, final int arg3){
}",java:S1186,16
"public void visitInnerClass(final String arg0, final String arg1, final String arg2, final int arg3){
}",java:S1161,11
"public void visitAttribute(final Attribute arg0){
}",java:S1186,16
"public void visitAttribute(final Attribute arg0){
}",java:S1161,11
"public void visitEnd(){
}",java:S1186,16
"public void visitEnd(){
}",java:S1161,11
"public void visit(final int arg0, final int arg1, final String arg2, final String arg3, final String arg4, final String[] arg5){
}",java:S1186,16
"public void visit(final int arg0, final int arg1, final String arg2, final String arg3, final String arg4, final String[] arg5){
}",java:S1161,11
"public void visitSource(final String arg0, final String arg1){
}",java:S1186,16
"public void visitSource(final String arg0, final String arg1){
}",java:S1161,11
"public void visitOuterClass(final String arg0, final String arg1, final String arg2){
}",java:S1186,16
"public void visitOuterClass(final String arg0, final String arg1, final String arg2){
}",java:S1161,11
"public AnnotationVisitor visitAnnotation(final String arg0, final boolean arg1){
    return new ClassFieldAnnotationVisitor();
}",java:S1161,11
"public FieldVisitor visitField(final int arg0, final String arg1, final String arg2, final String arg3, final Object arg4){
    return null;
}",java:S1161,11
"public void visit(final String arg0, final Object arg1){
}",java:S1186,16
"public void visit(final String arg0, final Object arg1){
}",java:S1161,11
"public void visitEnum(final String arg0, final String arg1, final String arg2){
}",java:S1186,16
"public void visitEnum(final String arg0, final String arg1, final String arg2){
}",java:S1161,11
"public AnnotationVisitor visitAnnotation(final String arg0, final String arg1){
    return new ClassFieldAnnotationVisitor();
}",java:S1161,11
"public AnnotationVisitor visitArray(final String arg0){
    return new ClassFieldAnnotationVisitor();
}",java:S1161,11
"public void visitEnd(){
}",java:S1186,16
"public void visitEnd(){
}",java:S1161,11
"protected final void castPrimitiveToPrimitive(Class<?> from, Class<?> to){
    if (from == to)
        return;
    if (from == int.class) {
        if (to == long.class)
            mv.visitInsn(I2L);
        else if (to == float.class)
            mv.visitInsn(I2F);
        else if (to == double.class)
            mv.visitInsn(I2D);
        else if (to == byte.class)
            mv.visitInsn(I2B);
        else if (to == char.class)
            mv.visitInsn(I2C);
        else if (to == short.class)
            mv.visitInsn(I2S);
    } else if (from == long.class) {
        if (to == int.class)
            mv.visitInsn(L2I);
        else if (to == float.class)
            mv.visitInsn(L2F);
        else if (to == double.class)
            mv.visitInsn(L2D);
    } else if (from == float.class) {
        if (to == int.class)
            mv.visitInsn(F2I);
        else if (to == long.class)
            mv.visitInsn(F2L);
        else if (to == double.class)
            mv.visitInsn(F2D);
    } else if (from == double.class) {
        if (to == int.class)
            mv.visitInsn(D2I);
        else if (to == long.class)
            mv.visitInsn(D2L);
        else if (to == float.class)
            mv.visitInsn(D2F);
    }
}",java:S3776,39
"private Type type(String typeName){
    return classGenerator.toType(typeName);
}",java:S1144,10
"protected String getCommonSuperClass(final String type1, final String type2){
    Class c, d;
    try {
        c = Class.forName(type1.replace('/', '.'), false, classLoader);
        d = Class.forName(type2.replace('/', '.'), false, classLoader);
    } catch (Exception e) {
        throw new RuntimeException(e.toString());
    }
    if (c.isAssignableFrom(d)) {
        return type1;
    }
    if (d.isAssignableFrom(c)) {
        return type2;
    }
    if (c.isInterface() || d.isInterface()) {
        return ""java/lang/Object"";
    } else {
        do {
            c = c.getSuperclass();
        } while (!c.isAssignableFrom(d));
        return c.getName().replace('.', '/');
    }
}",java:S1161,11
"public T relativeAfter(long duration){
    return (T) this;
}",java:S1172,13
"protected boolean initFieldWithDefaultValue(MethodVisitor mv, ClassDefinition classDef, FieldDefinition field){
    if (field.getInitExpr() == null && field.isInherited()) {
        return false;
    }
    Object val = BuildUtils.getDefaultValue(field);
    boolean hasObjects = false;
    if (val != null) {
        mv.visitVarInsn(Opcodes.ALOAD, 0);
        if (BuildUtils.isPrimitive(field.getTypeName()) || BuildUtils.isBoxed(field.getTypeName()) || String.class.getName().equals(field.getTypeName())) {
            mv.visitLdcInsn(val);
            if (BuildUtils.isBoxed(field.getTypeName())) {
                mv.visitMethodInsn(Opcodes.INVOKESTATIC, BuildUtils.getInternalType(field.getTypeName()), ""valueOf"", ""("" + BuildUtils.unBox(field.getTypeName()) + "")"" + BuildUtils.getTypeDescriptor(field.getTypeName()));
            }
        } else {
            hasObjects = true;
            String type = BuildUtils.getInternalType(val.getClass().getName());
            mv.visitTypeInsn(NEW, type);
            mv.visitInsn(DUP);
            mv.visitMethodInsn(INVOKESPECIAL, type, ""<init>"", ""()V"");
        }
    } else {
        if (field.getInitExpr() != null) {
            mv.visitVarInsn(ALOAD, 0);
            mv.visitLdcInsn(field.getInitExpr());
            mv.visitMethodInsn(INVOKESTATIC, ""org/mvel2/MVEL"", ""eval"", ""(Ljava/lang/String;)Ljava/lang/Object;"");
            mv.visitTypeInsn(CHECKCAST, BuildUtils.getInternalType(field.getTypeName()));
            val = field.getInitExpr();
        }
    }
    if (val != null) {
        if (!field.isInherited()) {
            mv.visitFieldInsn(Opcodes.PUTFIELD, BuildUtils.getInternalType(classDef.getClassName()), field.getName(), BuildUtils.getTypeDescriptor(field.getTypeName()));
        } else {
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, BuildUtils.getInternalType(classDef.getClassName()), field.getWriteMethod(), Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(BuildUtils.getTypeDescriptor(field.getTypeName()))));
        }
    }
    return hasObjects;
}",java:S3776,39
"protected void buildEquals(ClassVisitor cw, ClassDefinition classDef){
    MethodVisitor mv;
    {
        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, ""equals"", ""(Ljava/lang/Object;)Z"", null, null);
        mv.visitCode();
        Label l0 = null;
        if (this.debug) {
            l0 = new Label();
            mv.visitLabel(l0);
        }
        mv.visitVarInsn(Opcodes.ALOAD, 0);
        mv.visitVarInsn(Opcodes.ALOAD, 1);
        Label l1 = new Label();
        mv.visitJumpInsn(Opcodes.IF_ACMPNE, l1);
        mv.visitInsn(Opcodes.ICONST_1);
        mv.visitInsn(Opcodes.IRETURN);
        mv.visitLabel(l1);
        mv.visitVarInsn(Opcodes.ALOAD, 1);
        Label l2 = new Label();
        mv.visitJumpInsn(Opcodes.IFNONNULL, l2);
        mv.visitInsn(Opcodes.ICONST_0);
        mv.visitInsn(Opcodes.IRETURN);
        mv.visitLabel(l2);
        mv.visitVarInsn(Opcodes.ALOAD, 0);
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(Object.class), ""getClass"", Type.getMethodDescriptor(Type.getType(Class.class)));
        mv.visitVarInsn(Opcodes.ALOAD, 1);
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(Object.class), ""getClass"", Type.getMethodDescriptor(Type.getType(Class.class)));
        Label l3 = new Label();
        mv.visitJumpInsn(Opcodes.IF_ACMPEQ, l3);
        mv.visitInsn(Opcodes.ICONST_0);
        mv.visitInsn(Opcodes.IRETURN);
        mv.visitLabel(l3);
        mv.visitVarInsn(Opcodes.ALOAD, 1);
        mv.visitTypeInsn(Opcodes.CHECKCAST, BuildUtils.getInternalType(classDef.getClassName()));
        mv.visitVarInsn(Opcodes.ASTORE, 2);
        int count = 0;
        for (FieldDefinition field : classDef.getFieldsDefinitions()) {
            if (field.isKey()) {
                count++;
                Label goNext = new Label();
                if (BuildUtils.isPrimitive(field.getTypeName())) {
                    mv.visitVarInsn(Opcodes.ALOAD, 0);
                    visitFieldOrGetter(mv, classDef, field);
                    mv.visitVarInsn(Opcodes.ALOAD, 2);
                    visitFieldOrGetter(mv, classDef, field);
                    if (field.getTypeName().equals(""long"")) {
                        mv.visitInsn(Opcodes.LCMP);
                        mv.visitJumpInsn(Opcodes.IFEQ, goNext);
                    } else if (field.getTypeName().equals(""double"")) {
                        mv.visitInsn(Opcodes.DCMPL);
                        mv.visitJumpInsn(Opcodes.IFEQ, goNext);
                    } else if (field.getTypeName().equals(""float"")) {
                        mv.visitInsn(Opcodes.FCMPL);
                        mv.visitJumpInsn(Opcodes.IFEQ, goNext);
                    } else {
                        mv.visitJumpInsn(Opcodes.IF_ICMPEQ, goNext);
                    }
                    mv.visitInsn(Opcodes.ICONST_0);
                    mv.visitInsn(Opcodes.IRETURN);
                } else {
                    mv.visitVarInsn(Opcodes.ALOAD, 0);
                    visitFieldOrGetter(mv, classDef, field);
                    Label secondIfPart = new Label();
                    mv.visitJumpInsn(Opcodes.IFNONNULL, secondIfPart);
                    mv.visitVarInsn(Opcodes.ALOAD, 2);
                    visitFieldOrGetter(mv, classDef, field);
                    Label returnFalse = new Label();
                    mv.visitJumpInsn(Opcodes.IFNONNULL, returnFalse);
                    mv.visitLabel(secondIfPart);
                    mv.visitVarInsn(Opcodes.ALOAD, 0);
                    visitFieldOrGetter(mv, classDef, field);
                    mv.visitJumpInsn(Opcodes.IFNULL, goNext);
                    mv.visitVarInsn(Opcodes.ALOAD, 0);
                    visitFieldOrGetter(mv, classDef, field);
                    mv.visitVarInsn(Opcodes.ALOAD, 2);
                    visitFieldOrGetter(mv, classDef, field);
                    if (!BuildUtils.isArray(field.getTypeName())) {
                        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, ""java/lang/Object"", ""equals"", ""(Ljava/lang/Object;)Z"");
                    } else {
                        mv.visitMethodInsn(Opcodes.INVOKESTATIC, ""java/util/Arrays"", ""equals"", ""("" + BuildUtils.arrayType(field.getTypeName()) + BuildUtils.arrayType(field.getTypeName()) + "")Z"");
                    }
                    mv.visitJumpInsn(Opcodes.IFNE, goNext);
                    mv.visitLabel(returnFalse);
                    mv.visitInsn(Opcodes.ICONST_0);
                    mv.visitInsn(Opcodes.IRETURN);
                }
                mv.visitLabel(goNext);
            }
        }
        if (count > 0) {
            mv.visitInsn(Opcodes.ICONST_1);
        } else {
            mv.visitInsn(Opcodes.ICONST_0);
        }
        mv.visitInsn(Opcodes.IRETURN);
        Label lastLabel;
        if (this.debug) {
            lastLabel = new Label();
            mv.visitLabel(lastLabel);
            mv.visitLocalVariable(""this"", BuildUtils.getTypeDescriptor(classDef.getClassName()), null, l0, lastLabel, 0);
            mv.visitLocalVariable(""obj"", Type.getDescriptor(Object.class), null, l0, lastLabel, 1);
            mv.visitLocalVariable(""other"", BuildUtils.getTypeDescriptor(classDef.getClassName()), null, l0, lastLabel, 2);
        }
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
}",java:S3776,39
"protected void buildHashCode(ClassVisitor cw, ClassDefinition classDef){
    MethodVisitor mv;
    {
        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, ""hashCode"", ""()I"", null, null);
        mv.visitCode();
        Label l0 = null;
        if (this.debug) {
            l0 = new Label();
            mv.visitLabel(l0);
        }
        mv.visitInsn(Opcodes.ICONST_1);
        mv.visitVarInsn(Opcodes.ISTORE, 1);
        for (FieldDefinition field : classDef.getFieldsDefinitions()) {
            if (field.isKey()) {
                mv.visitVarInsn(Opcodes.ILOAD, 1);
                mv.visitIntInsn(Opcodes.BIPUSH, 31);
                mv.visitVarInsn(Opcodes.ILOAD, 1);
                mv.visitInsn(Opcodes.IMUL);
                mv.visitVarInsn(Opcodes.ALOAD, 0);
                visitFieldOrGetter(mv, classDef, field);
                if (""boolean"".equals(field.getTypeName())) {
                    Label blabel1 = new Label();
                    mv.visitJumpInsn(Opcodes.IFEQ, blabel1);
                    mv.visitIntInsn(Opcodes.SIPUSH, 1231);
                    Label blabel2 = new Label();
                    mv.visitJumpInsn(Opcodes.GOTO, blabel2);
                    mv.visitLabel(blabel1);
                    mv.visitIntInsn(Opcodes.SIPUSH, 1237);
                    mv.visitLabel(blabel2);
                } else if (""long"".equals(field.getTypeName())) {
                    mv.visitVarInsn(Opcodes.ALOAD, 0);
                    visitFieldOrGetter(mv, classDef, field);
                    mv.visitIntInsn(Opcodes.BIPUSH, 32);
                    mv.visitInsn(Opcodes.LUSHR);
                    mv.visitInsn(Opcodes.LXOR);
                    mv.visitInsn(Opcodes.L2I);
                } else if (""float"".equals(field.getTypeName())) {
                    mv.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Float.class), ""floatToIntBits"", ""(F)I"");
                } else if (""double"".equals(field.getTypeName())) {
                    mv.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Double.class), ""doubleToLongBits"", ""(D)J"");
                    mv.visitInsn(Opcodes.DUP2);
                    mv.visitIntInsn(Opcodes.BIPUSH, 32);
                    mv.visitInsn(Opcodes.LUSHR);
                    mv.visitInsn(Opcodes.LXOR);
                    mv.visitInsn(Opcodes.L2I);
                } else if (!BuildUtils.isPrimitive(field.getTypeName())) {
                    Label olabel1 = new Label();
                    mv.visitJumpInsn(Opcodes.IFNONNULL, olabel1);
                    mv.visitInsn(Opcodes.ICONST_0);
                    Label olabel2 = new Label();
                    mv.visitJumpInsn(Opcodes.GOTO, olabel2);
                    mv.visitLabel(olabel1);
                    mv.visitVarInsn(Opcodes.ALOAD, 0);
                    visitFieldOrGetter(mv, classDef, field);
                    if (!BuildUtils.isArray(field.getTypeName())) {
                        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, ""java/lang/Object"", ""hashCode"", ""()I"");
                    } else {
                        mv.visitMethodInsn(INVOKESTATIC, ""java/util/Arrays"", ""hashCode"", ""("" + BuildUtils.arrayType(field.getTypeName()) + "")I"");
                    }
                    mv.visitLabel(olabel2);
                }
                mv.visitInsn(Opcodes.IADD);
                mv.visitVarInsn(Opcodes.ISTORE, 1);
            }
        }
        mv.visitVarInsn(Opcodes.ILOAD, 1);
        mv.visitInsn(Opcodes.IRETURN);
        Label lastLabel;
        if (this.debug) {
            lastLabel = new Label();
            mv.visitLabel(lastLabel);
            mv.visitLocalVariable(""this"", BuildUtils.getTypeDescriptor(classDef.getClassName()), null, l0, lastLabel, 0);
            mv.visitLocalVariable(""hash"", Type.getDescriptor(int.class), null, l0, lastLabel, 1);
        }
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
}",java:S3776,39
"public RequestContext execute(Executable executable, RequestContext ctx){
    new Thread(new Runnable() {

        public void run() {
            executeNext(executable, ctx);
        }
    }).start();
    return ctx;
}",java:S1161,11
"protected void buildToString(ClassWriter cw, EnumClassDefinition classDef){
}",java:S1186,16
"protected void buildEqualityMethods(ClassWriter cw, ClassDefinition classDef){
}",java:S1186,16
"public int compareTo(Object obj){
    return ((DeclarationMatcher) obj).tupleIndex - tupleIndex;
}",java:S1210,20
"private static ClassLoader getClassLoader(final Object obj, final ValueResolver valueResolver){
    return obj.getClass().getClassLoader();
}",java:S1172,13
"public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces){
}",java:S1186,16
"public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces){
}",java:S1161,11
"public AnnotationVisitor visitAnnotation(final String desc, final boolean visible){
    return new DummyAnnotationVisitor();
}",java:S1161,11
"public void visitAttribute(final Attribute attr){
}",java:S1186,16
"public void visitAttribute(final Attribute attr){
}",java:S1161,11
"public void visitEnd(){
}",java:S1186,16
"public void visitEnd(){
}",java:S1161,11
"public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value){
    return null;
}",java:S1161,11
"public void visitInnerClass(final String name, final String outerName, final String innerName, final int access){
}",java:S1186,16
"public void visitInnerClass(final String name, final String outerName, final String innerName, final int access){
}",java:S1161,11
"public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions){
    return this.methodName.equals(name) ? new DumpMethodVisitor(this::setText) : null;
}",java:S1161,11
"public void visitOuterClass(final String owner, final String name, final String desc){
}",java:S1186,16
"public void visitOuterClass(final String owner, final String name, final String desc){
}",java:S1161,11
"public void visitSource(final String source, final String debug){
}",java:S1186,16
"public void visitSource(final String source, final String debug){
}",java:S1161,11
"public void visit(final String name, final Object value){
}",java:S1186,16
"public void visit(final String name, final Object value){
}",java:S1161,11
"public AnnotationVisitor visitAnnotation(final String name, final String desc){
    return new DummyAnnotationVisitor();
}",java:S1161,11
"public AnnotationVisitor visitArray(final String name){
    return new DummyAnnotationVisitor();
}",java:S1161,11
"public void visitEnd(){
}",java:S1186,16
"public void visitEnd(){
}",java:S1161,11
"public void visitEnum(final String name, final String desc, final String value){
}",java:S1186,16
"public void visitEnum(final String name, final String desc, final String value){
}",java:S1161,11
"public static String getMethodBytecode(Class cls, String ruleClassName, String packageName, String methodName, String resource){
    try (InputStream is = cls.getClassLoader().getResourceAsStream(resource)) {
        byte[] data = readBytesFromInputStream(is);
        MethodComparator.Tracer visit = new MethodComparator.Tracer(methodName);
        new org.mvel2.asm.ClassReader(data).accept(visit, org.mvel2.asm.ClassReader.SKIP_DEBUG);
        return visit.getText();
    } catch (java.io.IOException e) {
        throw new RuntimeException(""Unable getResourceAsStream for Class '"" + ruleClassName + ""' "");
    }
}",java:S1172,13
"public static String rewriteUpdates(Function<String, Class<?>> classResolver, Function<Class<?>, List<String>> propsResolver, String text){
    int start = 0;
    while (true) {
        int updatePos = text.indexOf(""drools.update("", start);
        if (updatePos < 0) {
            break;
        }
        start = updatePos + ""drools.update("".length();
        int end = text.indexOf(')', start);
        String identifier = text.substring(start, end).trim();
        Class<?> updatedType = classResolver.apply(identifier);
        if (updatedType == null) {
            continue;
        }
        List<String> settableProperties = propsResolver.apply(updatedType);
        if (settableProperties.isEmpty()) {
            continue;
        }
        BitMask modificationMask = getEmptyPropertyReactiveMask(settableProperties.size());
        boolean directAccess = false;
        for (String expr : splitStatementsAcrossBlocks(text)) {
            if (expr.startsWith(identifier + ""."")) {
                int fieldEnd = identifier.length() + 1;
                while (Character.isJavaIdentifierPart(expr.charAt(fieldEnd))) fieldEnd++;
                String propertyName = expr.substring(identifier.length() + 1, fieldEnd);
                if (propertyName.length() > 3) {
                    if (propertyName.startsWith(""set"")) {
                        propertyName = Character.toLowerCase(propertyName.charAt(3)) + propertyName.substring(4);
                    } else if (propertyName.startsWith(""get"")) {
                        int endMethodName = expr.indexOf('(');
                        int endMethodArgs = findEndOfMethodArgsIndex(expr, endMethodName);
                        String methodParams = expr.substring(endMethodName + 1, endMethodArgs).trim();
                        if (expr.length() > endMethodArgs + 1 && expr.substring(endMethodArgs + 1).trim().startsWith(""."")) {
                            propertyName = Character.toLowerCase(propertyName.charAt(3)) + propertyName.substring(4);
                        }
                    } else {
                        directAccess = true;
                    }
                }
                int index = findPropertyIndex(settableProperties, propertyName, directAccess);
                if (index >= 0) {
                    modificationMask = setPropertyOnMask(modificationMask, index);
                } else {
                    modificationMask = allSetButTraitBitMask();
                    break;
                }
            }
        }
        String updateArgs = "", "" + modificationMask.getInstancingStatement() + "", "" + updatedType.getCanonicalName() + "".class"";
        text = text.substring(0, end) + updateArgs + text.substring(end);
        start = end + updateArgs.length();
    }
    return text;
}",java:S3776,39
"public static String delimitExpressions(String s){
    StringBuilder result = new StringBuilder();
    char[] cs = s.toCharArray();
    int brace = 0;
    int sqre = 0;
    int crly = 0;
    int skippedNewLines = 0;
    boolean inString = false;
    char lastNonWhite = ';';
    for (int i = 0; i < cs.length; i++) {
        char c = cs[i];
        switch(c) {
            case ' ':
            case '\t':
                if (!inString && lookAhead(cs, i + 1) == '.') {
                    continue;
                }
                break;
            case '\""':
                if (i == 0 || cs[i - 1] != '\\') {
                    inString = !inString;
                }
                break;
            case '/':
                if (i < cs.length - 1 && cs[i + 1] == '*' && !inString) {
                    int start = i;
                    i += 2;
                    for (; i < cs.length; i++) {
                        if (cs[i] == '*' && i < cs.length - 1 && cs[i + 1] == '/') {
                            i++;
                            break;
                        } else if (cs[i] == '\n' || cs[i] == '\r') {
                            lastNonWhite = checkAndAddSemiColon(result, inString, brace, sqre, crly, lastNonWhite);
                        }
                    }
                    result.append(cs, start, i - start);
                    break;
                } else if (i < cs.length - 1 && cs[i + 1] != '/') {
                    break;
                }
            case '#':
                lastNonWhite = checkAndAddSemiColon(result, inString, brace, sqre, crly, lastNonWhite);
                if (inString) {
                    result.append(c);
                } else {
                    i = processLineComment(cs, i, result);
                }
                continue;
            case '(':
                brace++;
                break;
            case '{':
                crly++;
                break;
            case '[':
                sqre++;
                break;
            case ')':
                brace--;
                break;
            case '}':
                crly--;
                break;
            case ']':
                sqre--;
                break;
            default:
                break;
        }
        if (c == '\n' || c == '\r') {
            if (brace == 0 && sqre == 0 && crly == 0 && lastNonWhite != '.' && lookAhead(cs, i + 1) != '.') {
                if (lastNonWhite != ';') {
                    result.append(';');
                    lastNonWhite = ';';
                }
                for (int j = 0; j < skippedNewLines; j++) {
                    result.append(""\n"");
                }
                skippedNewLines = 0;
            } else {
                skippedNewLines++;
                continue;
            }
        } else if (!Character.isWhitespace(c)) {
            lastNonWhite = c;
        }
        result.append(c);
    }
    for (int i = 0; i < skippedNewLines; i++) {
        result.append(""\n"");
    }
    return result.toString();
}",java:S3776,39
"public void preCompileAddFunction(FunctionDescr functionDescr, TypeResolver typeResolver){
}",java:S1186,16
"public void postCompileAddFunction(FunctionDescr functionDescr, TypeResolver typeResolver){
}",java:S1186,16
"public void compileAll(){
}",java:S1186,16
"public static MVELCompilationUnit getMVELCompilationUnit(final String expression, final AnalysisResult analysis, Declaration[] previousDeclarations, Declaration[] localDeclarations, final Map<String, Class<?>> otherInputVariables, final PackageBuildContext context, String contextIndeifier, Class kcontextClass, boolean readLocalsFromTuple, MVELCompilationUnit.Scope scope){
    Map<String, Type> resolvedInputs = new LinkedHashMap<>();
    List<String> ids = new ArrayList<>();
    if (analysis.getBoundIdentifiers().getThisClass() != null || (localDeclarations != null && localDeclarations.length > 0)) {
        Class cls = analysis.getBoundIdentifiers().getThisClass();
        ids.add(""this"");
        resolvedInputs.put(""this"", (cls != null) ? cls : Object.class);
    }
    ids.add(contextIndeifier);
    resolvedInputs.put(contextIndeifier, kcontextClass);
    ids.add(""kcontext"");
    resolvedInputs.put(""kcontext"", kcontextClass);
    if (scope.hasRule()) {
        ids.add(""rule"");
        resolvedInputs.put(""rule"", Rule.class);
    }
    List<String> strList = new ArrayList<>();
    for (String identifier : analysis.getIdentifiers()) {
        Type type = identifier.equals(WM_ARGUMENT) ? InternalWorkingMemory.class : analysis.getBoundIdentifiers().resolveVarType(identifier);
        if (type != null) {
            strList.add(identifier);
            ids.add(identifier);
            resolvedInputs.put(identifier, type);
        }
    }
    String[] globalIdentifiers = strList.toArray(new String[strList.size()]);
    strList.clear();
    for (String op : analysis.getBoundIdentifiers().getOperators().keySet()) {
        strList.add(op);
        ids.add(op);
        resolvedInputs.put(op, EvaluatorWrapper.class);
    }
    EvaluatorWrapper[] operators = new EvaluatorWrapper[strList.size()];
    for (int i = 0; i < operators.length; i++) {
        operators[i] = analysis.getBoundIdentifiers().getOperators().get(strList.get(i));
    }
    if (previousDeclarations != null) {
        for (Declaration decl : previousDeclarations) {
            if (analysis.getBoundIdentifiers().getDeclrClasses().containsKey(decl.getIdentifier())) {
                ids.add(decl.getIdentifier());
                resolvedInputs.put(decl.getIdentifier(), decl.getDeclarationClass());
            }
        }
    }
    if (localDeclarations != null) {
        for (Declaration decl : localDeclarations) {
            if (analysis.getBoundIdentifiers().getDeclrClasses().containsKey(decl.getIdentifier())) {
                ids.add(decl.getIdentifier());
                resolvedInputs.put(decl.getIdentifier(), decl.getDeclarationClass());
            }
        }
    }
    strList = new ArrayList<>();
    if (otherInputVariables != null) {
        MVELAnalysisResult mvelAnalysis = (MVELAnalysisResult) analysis;
        for (Entry<String, Class<?>> stringClassEntry : otherInputVariables.entrySet()) {
            if ((!analysis.getNotBoundedIdentifiers().contains(stringClassEntry.getKey()) && !mvelAnalysis.getMvelVariables().containsKey(stringClassEntry.getKey())) || ""rule"".equals(stringClassEntry.getKey())) {
                continue;
            }
            ids.add(stringClassEntry.getKey());
            strList.add(stringClassEntry.getKey());
            resolvedInputs.put(stringClassEntry.getKey(), stringClassEntry.getValue());
        }
    }
    String[] otherIdentifiers = strList.toArray(new String[strList.size()]);
    String[] inputIdentifiers = new String[resolvedInputs.size()];
    String[] inputTypes = new String[resolvedInputs.size()];
    int i = 0;
    for (String id : ids) {
        inputIdentifiers[i] = id;
        Type inputType = resolvedInputs.get(id);
        inputTypes[i++] = inputType instanceof Class ? ((Class<?>) inputType).getName() : inputType.getTypeName();
    }
    String name;
    if (context != null && context.getPkg() != null && context.getPkg().getName() != null) {
        if (context instanceof RuleBuildContext) {
            name = context.getPkg().getName() + ""."" + ((RuleBuildContext) context).getRuleDescr().getClassName();
        } else {
            name = context.getPkg().getName() + "".Unknown"";
        }
    } else {
        name = ""Unknown"";
    }
    return new MVELCompilationUnit(name, expression, globalIdentifiers, operators, previousDeclarations, localDeclarations, otherIdentifiers, inputIdentifiers, inputTypes, analysis.isTypesafe(), readLocalsFromTuple);
}",java:S3776,39
"public static MVELCompilationUnit getMVELCompilationUnit(final String expression, final AnalysisResult analysis, Declaration[] previousDeclarations, Declaration[] localDeclarations, final Map<String, Class<?>> otherInputVariables, final PackageBuildContext context, String contextIndeifier, Class kcontextClass, boolean readLocalsFromTuple, MVELCompilationUnit.Scope scope){
    Map<String, Type> resolvedInputs = new LinkedHashMap<>();
    List<String> ids = new ArrayList<>();
    if (analysis.getBoundIdentifiers().getThisClass() != null || (localDeclarations != null && localDeclarations.length > 0)) {
        Class cls = analysis.getBoundIdentifiers().getThisClass();
        ids.add(""this"");
        resolvedInputs.put(""this"", (cls != null) ? cls : Object.class);
    }
    ids.add(contextIndeifier);
    resolvedInputs.put(contextIndeifier, kcontextClass);
    ids.add(""kcontext"");
    resolvedInputs.put(""kcontext"", kcontextClass);
    if (scope.hasRule()) {
        ids.add(""rule"");
        resolvedInputs.put(""rule"", Rule.class);
    }
    List<String> strList = new ArrayList<>();
    for (String identifier : analysis.getIdentifiers()) {
        Type type = identifier.equals(WM_ARGUMENT) ? InternalWorkingMemory.class : analysis.getBoundIdentifiers().resolveVarType(identifier);
        if (type != null) {
            strList.add(identifier);
            ids.add(identifier);
            resolvedInputs.put(identifier, type);
        }
    }
    String[] globalIdentifiers = strList.toArray(new String[strList.size()]);
    strList.clear();
    for (String op : analysis.getBoundIdentifiers().getOperators().keySet()) {
        strList.add(op);
        ids.add(op);
        resolvedInputs.put(op, EvaluatorWrapper.class);
    }
    EvaluatorWrapper[] operators = new EvaluatorWrapper[strList.size()];
    for (int i = 0; i < operators.length; i++) {
        operators[i] = analysis.getBoundIdentifiers().getOperators().get(strList.get(i));
    }
    if (previousDeclarations != null) {
        for (Declaration decl : previousDeclarations) {
            if (analysis.getBoundIdentifiers().getDeclrClasses().containsKey(decl.getIdentifier())) {
                ids.add(decl.getIdentifier());
                resolvedInputs.put(decl.getIdentifier(), decl.getDeclarationClass());
            }
        }
    }
    if (localDeclarations != null) {
        for (Declaration decl : localDeclarations) {
            if (analysis.getBoundIdentifiers().getDeclrClasses().containsKey(decl.getIdentifier())) {
                ids.add(decl.getIdentifier());
                resolvedInputs.put(decl.getIdentifier(), decl.getDeclarationClass());
            }
        }
    }
    strList = new ArrayList<>();
    if (otherInputVariables != null) {
        MVELAnalysisResult mvelAnalysis = (MVELAnalysisResult) analysis;
        for (Entry<String, Class<?>> stringClassEntry : otherInputVariables.entrySet()) {
            if ((!analysis.getNotBoundedIdentifiers().contains(stringClassEntry.getKey()) && !mvelAnalysis.getMvelVariables().containsKey(stringClassEntry.getKey())) || ""rule"".equals(stringClassEntry.getKey())) {
                continue;
            }
            ids.add(stringClassEntry.getKey());
            strList.add(stringClassEntry.getKey());
            resolvedInputs.put(stringClassEntry.getKey(), stringClassEntry.getValue());
        }
    }
    String[] otherIdentifiers = strList.toArray(new String[strList.size()]);
    String[] inputIdentifiers = new String[resolvedInputs.size()];
    String[] inputTypes = new String[resolvedInputs.size()];
    int i = 0;
    for (String id : ids) {
        inputIdentifiers[i] = id;
        Type inputType = resolvedInputs.get(id);
        inputTypes[i++] = inputType instanceof Class ? ((Class<?>) inputType).getName() : inputType.getTypeName();
    }
    String name;
    if (context != null && context.getPkg() != null && context.getPkg().getName() != null) {
        if (context instanceof RuleBuildContext) {
            name = context.getPkg().getName() + ""."" + ((RuleBuildContext) context).getRuleDescr().getClassName();
        } else {
            name = context.getPkg().getName() + "".Unknown"";
        }
    } else {
        name = ""Unknown"";
    }
    return new MVELCompilationUnit(name, expression, globalIdentifiers, operators, previousDeclarations, localDeclarations, otherIdentifiers, inputIdentifiers, inputTypes, analysis.isTypesafe(), readLocalsFromTuple);
}",java:S107,1
"public void remove(){
    throw new UnsupportedOperationException(""remove() method is not supported"");
}",java:S1161,11
"public DataProvider clone(){
    MVELDataProvider clone = new MVELDataProvider(unit.clone(), id);
    clone.evaluator = evaluator;
    if (clones == null) {
        clones = new ArrayList<>();
    }
    clones.add(clone);
    return clone;
}",java:S2975,34
"public DataProvider clone(){
    MVELDataProvider clone = new MVELDataProvider(unit.clone(), id);
    clone.evaluator = evaluator;
    if (clones == null) {
        clones = new ArrayList<>();
    }
    clones.add(clone);
    return clone;
}",java:S1182,14
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    startDev = in.readLong();
    endDev = in.readLong();
    unwrapLeft = in.readBoolean();
    unwrapRight = in.readBoolean();
    paramText = (String) in.readObject();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeLong(startDev);
    out.writeLong(endDev);
    out.writeBoolean(unwrapLeft);
    out.writeBoolean(unwrapRight);
    out.writeObject(paramText);
}",java:S1161,11
"public String toString(){
    return ""coincides["" + startDev + "", "" + endDev + ""]"";
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    startMinDev = in.readLong();
    startMaxDev = in.readLong();
    endMinDev = in.readLong();
    endMaxDev = in.readLong();
    paramText = (String) in.readObject();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeLong(startMinDev);
    out.writeLong(startMaxDev);
    out.writeLong(endMinDev);
    out.writeLong(endMaxDev);
    out.writeObject(paramText);
}",java:S1161,11
"public String toString(){
    return ""during["" + ((paramText != null) ? paramText : """") + ""]"";
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    endDev = in.readLong();
    paramText = (String) in.readObject();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeLong(endDev);
    out.writeObject(paramText);
}",java:S1161,11
"public String toString(){
    return ""finishes["" + ((paramText != null) ? paramText : """") + ""]"";
}",java:S1161,11
"public String toString(){
    return ""String matches"";
}",java:S1161,11
"public String toString(){
    return ""String not matches"";
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    finalRange = in.readLong();
    paramText = (String) in.readObject();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeLong(finalRange);
    out.writeObject(paramText);
}",java:S1161,11
"public String toString(){
    return ""metby["" + ((paramText != null) ? paramText : """") + ""]"";
}",java:S1161,11
"public String toString(){
    return ""overlappedby["" + ((paramText != null) ? paramText : """") + ""]"";
}",java:S1161,11
"public String toString(){
    return ""Array contains"";
}",java:S1161,11
"public String toString(){
    return ""Array not contains"";
}",java:S1161,11
"private static boolean contains(Object[] array, Object value){
    for (int i = 0; i < array.length; i++) {
        if (array[i] == null && value == null || array[i] != null && array[i].equals(value)) {
            return true;
        }
    }
    return false;
}",java:S1144,10
"public ValueType getCoercedValueType(){
    return ValueType.OBJECT_TYPE;
}",java:S1161,11
"public ValueType getCoercedValueType(){
    return ValueType.OBJECT_TYPE;
}",java:S1161,11
"public RequestContext execute(Executable executable, RequestContext ctx){
    executeNext(executable, ctx);
    if (requiresFireAllRules(((InternalExecutable) executable))) {
        new FireAllRulesCommand().execute(ctx);
    }
    return ctx;
}",java:S1161,11
"public String toString(){
    return ""Object contains"";
}",java:S1161,11
"public String toString(){
    return ""Object excludes"";
}",java:S1161,11
"public RequestContext execute(Executable executable, RequestContext ctx){
    logger.info(""Executing --> "" + executable);
    executeNext(executable, ctx);
    logger.info(""Done executing --> "" + executable);
    return ctx;
}",java:S1161,11
"public String toString(){
    return ""Strings sound alike"";
}",java:S1161,11
"public String toString(){
    return ""Strings not sound alike"";
}",java:S1161,11
"public String toString(){
    return ""starts["" + ((paramText != null) ? paramText : """") + ""]"";
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    left = in.readObject();
    right = in.readObject();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(left);
    out.writeObject(right);
}",java:S1161,11
"public void resetTuple(){
    this.left = null;
    this.tuple = null;
}",java:S1161,11
"public void resetFactHandle(){
    this.right = null;
    this.object = null;
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    left = in.readLong();
    right = in.readLong();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeLong(left);
    out.writeLong(right);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    left = in.readChar();
    right = in.readChar();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeChar(left);
    out.writeChar(right);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    left = in.readDouble();
    right = in.readDouble();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeDouble(left);
    out.writeDouble(right);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    left = in.readBoolean();
    right = in.readBoolean();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeBoolean(left);
    out.writeBoolean(right);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    startTS = in.readLong();
    endTS = in.readLong();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeLong(startTS);
    out.writeLong(startTS);
}",java:S1161,11
"public VariableResolverFactory getFactory(final Object knowledgeHelper, final Declaration[] prevDecl, final Rule rule, final FactHandle rightHandle, final BaseTuple tuple, final Object[] otherVars, final ValueResolver valueResolver, final GlobalResolver globals){
    VariableResolverFactory factory = createFactory();
    updateFactory(knowledgeHelper, prevDecl, rule, rightHandle, rightHandle != null ? rightHandle.getObject() : null, tuple, otherVars, valueResolver, globals, factory);
    return factory;
}",java:S107,1
"private void updateFactory(Object knowledgeHelper, Declaration[] prevDecl, Rule rule, FactHandle rightHandle, Object rightObject, BaseTuple tuple, Object[] otherVars, ValueResolver valueResolver, GlobalResolver globals, VariableResolverFactory factory){
    int varLength = inputIdentifiers.length;
    int i = 0;
    if (""this"".equals(inputIdentifiers[0])) {
        factory.getIndexedVariableResolver(i++).setValue(rightObject);
    }
    factory.getIndexedVariableResolver(i++).setValue(knowledgeHelper);
    factory.getIndexedVariableResolver(i++).setValue(knowledgeHelper);
    if (inputIdentifiers.length > i && ""rule"".equals(inputIdentifiers[i])) {
        factory.getIndexedVariableResolver(i++).setValue(rule);
    }
    if (globalIdentifiers != null) {
        for (String globalIdentifier : globalIdentifiers) {
            if (WM_ARGUMENT.equals(globalIdentifier)) {
                factory.getIndexedVariableResolver(i++).setValue(valueResolver);
            } else {
                factory.getIndexedVariableResolver(i++).setValue(globals.resolveGlobal(globalIdentifier));
            }
        }
    }
    FactHandle[] handles = tuple instanceof LeftTuple ? tuple.toFactHandles() : null;
    if (operators.length > 0) {
        for (EvaluatorWrapper operator : operators) {
            factory.getIndexedVariableResolver(i++).setValue(operator);
            operator.loadHandles(handles, rightHandle);
        }
    }
    Object[] objs = null;
    if (tuple != null) {
        if (handles == null) {
            objs = tuple.toObjects();
        }
        if (this.previousDeclarations != null && this.previousDeclarations.length > 0) {
            if (prevDecl == null) {
                prevDecl = this.previousDeclarations;
            }
            for (Declaration decl : prevDecl) {
                Object o = decl.getValue(valueResolver, objs != null ? objs[decl.getObjectIndex()] : handles[decl.getObjectIndex()].getObject());
                factory.getIndexedVariableResolver(i++).setValue(o);
            }
        }
    }
    if (this.localDeclarations != null && this.localDeclarations.length > 0) {
        for (Declaration decl : this.localDeclarations) {
            Object value;
            if (readLocalsFromTuple && tuple != null) {
                value = decl.getValue(valueResolver, objs != null ? objs[decl.getObjectIndex()] : handles[decl.getObjectIndex()].getObject());
            } else {
                value = decl.getValue(valueResolver, rightObject);
            }
            factory.getIndexedVariableResolver(i++).setValue(value);
        }
    }
    int otherVarsPos = 0;
    if (otherVars != null) {
        otherVarsPos = i;
        for (Object o : otherVars) {
            factory.getIndexedVariableResolver(i++).setValue(o);
        }
    }
    int otherVarsLength = i - otherVarsPos;
    for (i = varLength; i < this.allVarsLength; i++) {
        factory.getIndexedVariableResolver(i).setValue(null);
    }
    DroolsVarFactory df = (DroolsVarFactory) factory.getNextFactory();
    df.setOtherVarsPos(otherVarsPos);
    df.setOtherVarsLength(otherVarsLength);
    if (knowledgeHelper instanceof KnowledgeHelper) {
        KnowledgeHelper kh = (KnowledgeHelper) knowledgeHelper;
        df.setKnowledgeHelper(kh);
    }
}",java:S3776,39
"private void updateFactory(Object knowledgeHelper, Declaration[] prevDecl, Rule rule, FactHandle rightHandle, Object rightObject, BaseTuple tuple, Object[] otherVars, ValueResolver valueResolver, GlobalResolver globals, VariableResolverFactory factory){
    int varLength = inputIdentifiers.length;
    int i = 0;
    if (""this"".equals(inputIdentifiers[0])) {
        factory.getIndexedVariableResolver(i++).setValue(rightObject);
    }
    factory.getIndexedVariableResolver(i++).setValue(knowledgeHelper);
    factory.getIndexedVariableResolver(i++).setValue(knowledgeHelper);
    if (inputIdentifiers.length > i && ""rule"".equals(inputIdentifiers[i])) {
        factory.getIndexedVariableResolver(i++).setValue(rule);
    }
    if (globalIdentifiers != null) {
        for (String globalIdentifier : globalIdentifiers) {
            if (WM_ARGUMENT.equals(globalIdentifier)) {
                factory.getIndexedVariableResolver(i++).setValue(valueResolver);
            } else {
                factory.getIndexedVariableResolver(i++).setValue(globals.resolveGlobal(globalIdentifier));
            }
        }
    }
    FactHandle[] handles = tuple instanceof LeftTuple ? tuple.toFactHandles() : null;
    if (operators.length > 0) {
        for (EvaluatorWrapper operator : operators) {
            factory.getIndexedVariableResolver(i++).setValue(operator);
            operator.loadHandles(handles, rightHandle);
        }
    }
    Object[] objs = null;
    if (tuple != null) {
        if (handles == null) {
            objs = tuple.toObjects();
        }
        if (this.previousDeclarations != null && this.previousDeclarations.length > 0) {
            if (prevDecl == null) {
                prevDecl = this.previousDeclarations;
            }
            for (Declaration decl : prevDecl) {
                Object o = decl.getValue(valueResolver, objs != null ? objs[decl.getObjectIndex()] : handles[decl.getObjectIndex()].getObject());
                factory.getIndexedVariableResolver(i++).setValue(o);
            }
        }
    }
    if (this.localDeclarations != null && this.localDeclarations.length > 0) {
        for (Declaration decl : this.localDeclarations) {
            Object value;
            if (readLocalsFromTuple && tuple != null) {
                value = decl.getValue(valueResolver, objs != null ? objs[decl.getObjectIndex()] : handles[decl.getObjectIndex()].getObject());
            } else {
                value = decl.getValue(valueResolver, rightObject);
            }
            factory.getIndexedVariableResolver(i++).setValue(value);
        }
    }
    int otherVarsPos = 0;
    if (otherVars != null) {
        otherVarsPos = i;
        for (Object o : otherVars) {
            factory.getIndexedVariableResolver(i++).setValue(o);
        }
    }
    int otherVarsLength = i - otherVarsPos;
    for (i = varLength; i < this.allVarsLength; i++) {
        factory.getIndexedVariableResolver(i).setValue(null);
    }
    DroolsVarFactory df = (DroolsVarFactory) factory.getNextFactory();
    df.setOtherVarsPos(otherVarsPos);
    df.setOtherVarsLength(otherVarsLength);
    if (knowledgeHelper instanceof KnowledgeHelper) {
        KnowledgeHelper kh = (KnowledgeHelper) knowledgeHelper;
        df.setKnowledgeHelper(kh);
    }
}",java:S107,1
"public void clear(){
}",java:S1186,16
"public static void receiveBreakpoints(){
}",java:S1186,16
"private static final int onBreak(Frame frame){
    if (verbose) {
        logger.info(""Continuing with "" + (onBreakReturn == Debugger.CONTINUE ? ""continue"" : ""step-over""));
    }
    return onBreakReturn;
}",java:S1172,13
"private static final int onBreak(Frame frame){
    if (verbose) {
        logger.info(""Continuing with "" + (onBreakReturn == Debugger.CONTINUE ? ""continue"" : ""step-over""));
    }
    return onBreakReturn;
}",java:S1124,6
"protected static final void registerBreakpoint(String sourceName, int lineNumber){
    if (verbose) {
        logger.info(""Registering breakpoint for "" + sourceName + "":"" + lineNumber);
    }
    MVELRuntime.registerBreakpoint(sourceName, lineNumber);
}",java:S1124,6
"protected static final void clearAllBreakpoints(){
    if (verbose) {
        logger.info(""Clearing all breakpoints"");
    }
    MVELRuntime.clearAllBreakpoints();
}",java:S1124,6
"protected static final void removeBreakpoint(String sourceName, int lineNumber){
    if (verbose) {
        logger.info(""Removing breakpoint from "" + sourceName + "":"" + lineNumber);
    }
    MVELRuntime.removeBreakpoint(sourceName, lineNumber);
}",java:S1124,6
"protected static final void setOnBreakReturn(int value){
    onBreakReturn = value;
}",java:S1124,6
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(this.className);
    out.writeObject(this.expr);
    out.writeBoolean(this.typesafe);
    out.writeObject(this.evaluationContext);
}",java:S1161,11
"public FieldValue getFieldValue(Object value, ValueType valueType){
    FieldValue field = null;
    if (value == null) {
        field = new ObjectFieldImpl(null);
    } else if (valueType == ValueType.PCHAR_TYPE || valueType == ValueType.CHAR_TYPE) {
        if (value instanceof String && ((String) value).length() == 1) {
            field = new LongFieldImpl(((String) value).charAt(0));
        } else {
            field = new LongFieldImpl(((Character) value).charValue());
        }
    } else if (valueType == ValueType.PBYTE_TYPE || valueType == ValueType.BYTE_TYPE) {
        if (value instanceof String) {
            field = new LongFieldImpl(Byte.parseByte((String) value));
        } else {
            field = new LongFieldImpl(((Number) value).byteValue());
        }
    } else if (valueType == ValueType.PSHORT_TYPE || valueType == ValueType.SHORT_TYPE) {
        if (value instanceof String) {
            try {
                field = new LongFieldImpl(NumberFormat.getInstance().parse((String) value).shortValue());
            } catch (ParseException e) {
                throw new NumberFormatException(""Error parsing number '"" + value + ""'"");
            }
        } else {
            field = new LongFieldImpl(((Number) value).shortValue());
        }
    } else if (valueType == ValueType.PINTEGER_TYPE || valueType == ValueType.INTEGER_TYPE) {
        if (value instanceof String) {
            try {
                field = new LongFieldImpl(NumberFormat.getInstance().parse((String) value).intValue());
            } catch (ParseException e) {
                throw new NumberFormatException(""Error parsing number '"" + value + ""'"");
            }
        } else {
            field = new LongFieldImpl(((Number) value).intValue());
        }
    } else if (valueType == ValueType.PLONG_TYPE || valueType == ValueType.LONG_TYPE) {
        if (value instanceof String) {
            try {
                field = new LongFieldImpl(NumberFormat.getInstance().parse((String) value).longValue());
            } catch (ParseException e) {
                throw new NumberFormatException(""Error parsing number '"" + value + ""'"");
            }
        } else {
            field = new LongFieldImpl(((Number) value).longValue());
        }
    } else if (valueType == ValueType.PFLOAT_TYPE || valueType == ValueType.FLOAT_TYPE) {
        if (value instanceof String) {
            try {
                field = new DoubleFieldImpl(NumberFormat.getInstance().parse((String) value).floatValue());
            } catch (ParseException e) {
                throw new NumberFormatException(""Error parsing number '"" + value + ""'"");
            }
        } else {
            field = new DoubleFieldImpl(((Number) value).floatValue());
        }
    } else if (valueType == ValueType.PDOUBLE_TYPE || valueType == ValueType.DOUBLE_TYPE) {
        if (value instanceof String) {
            try {
                field = new DoubleFieldImpl(NumberFormat.getInstance().parse((String) value).doubleValue());
            } catch (ParseException e) {
                throw new NumberFormatException(""Error parsing number '"" + value + ""'"");
            }
        } else {
            field = new DoubleFieldImpl(((Number) value).doubleValue());
        }
    } else if (valueType == ValueType.PBOOLEAN_TYPE || valueType == ValueType.BOOLEAN_TYPE) {
        if (value instanceof String) {
            field = new BooleanFieldImpl(Boolean.valueOf((String) value));
        } else {
            field = new BooleanFieldImpl((Boolean) value);
        }
    } else if (valueType == ValueType.STRING_TYPE) {
        field = new ObjectFieldImpl(value.toString());
    } else if (valueType.isDate()) {
        if (value instanceof String) {
            Date date = DateUtils.parseDate((String) value);
            field = new ObjectFieldImpl(date);
        } else {
            field = new ObjectFieldImpl(value);
        }
    } else if (valueType == ValueType.ARRAY_TYPE) {
        field = new ObjectFieldImpl(value);
    } else if (valueType == ValueType.OBJECT_TYPE) {
        field = new ObjectFieldImpl(value);
    } else if (valueType == ValueType.TRAIT_TYPE) {
        field = new ObjectFieldImpl(value);
    } else if (valueType == ValueType.BIG_DECIMAL_TYPE) {
        field = new ObjectFieldImpl(MathUtils.getBigDecimal(value));
    } else if (valueType == ValueType.BIG_INTEGER_TYPE) {
        field = new ObjectFieldImpl(MathUtils.getBigInteger(value));
    } else if (valueType == ValueType.CLASS_TYPE) {
        field = new ClassFieldImpl((Class) value);
    }
    return field;
}",java:S3776,39
"private String stripNumericType(String value){
    if (Character.getType(value.charAt(value.length() - 1)) != Character.DECIMAL_DIGIT_NUMBER) {
        value = value.substring(0, value.length() - 1);
    }
    return value;
}",java:S1144,10
"public String toString(){
    return ""[JavaDialectError message='"" + this.message + ""']"";
}",java:S1161,11
"public static synchronized TemplateRegistry getRuleTemplateRegistry(ClassLoader cl){
    if (!RULE_REGISTRY.contains(""rules"")) {
        InputStream javaRuleMvelStream = JavaRuleBuilderHelper.class.getResourceAsStream(JAVA_RULE_MVEL);
        RULE_REGISTRY.addNamedTemplate(""rules"", TemplateCompiler.compileTemplate(javaRuleMvelStream));
        try {
            javaRuleMvelStream.close();
        } catch (IOException ex) {
            logger.debug(""Failed to close stream!"", ex);
        }
        TemplateRuntime.execute(RULE_REGISTRY.getNamedTemplate(""rules""), null, RULE_REGISTRY);
    }
    return RULE_REGISTRY;
}",java:S1172,13
"public static synchronized TemplateRegistry getInvokerTemplateRegistry(ClassLoader cl){
    if (!INVOKER_REGISTRY.contains(""invokers"")) {
        InputStream javaInvokersMvelStream = JavaRuleBuilderHelper.class.getResourceAsStream(JAVA_INVOKERS_MVEL);
        INVOKER_REGISTRY.addNamedTemplate(""invokers"", TemplateCompiler.compileTemplate(javaInvokersMvelStream));
        try {
            javaInvokersMvelStream.close();
        } catch (IOException ex) {
            logger.debug(""Failed to close stream!"", ex);
        }
        TemplateRuntime.execute(INVOKER_REGISTRY.getNamedTemplate(""invokers""), null, INVOKER_REGISTRY);
    }
    return INVOKER_REGISTRY;
}",java:S1172,13
"public void setFactHandles(HashMap<String, Object> facts){
    this.facts = facts;
}",java:S1319,22
"public void initTransactionManager(Environment env){
    Object tm = env.get(EnvironmentName.TRANSACTION_MANAGER);
    if (env.get(EnvironmentName.PERSISTENCE_CONTEXT_MANAGER) != null && env.get(EnvironmentName.TRANSACTION_MANAGER) != null) {
        this.txm = (TransactionManager) tm;
        this.jpm = (PersistenceContextManager) env.get(EnvironmentName.PERSISTENCE_CONTEXT_MANAGER);
    } else {
        if (tm != null && isSpringTransactionManager(tm.getClass())) {
            try {
                logger.debug(""Instantiating KieSpringTransactionManager"");
                Class<?> cls = Class.forName(""org.kie.spring.persistence.KieSpringTransactionManager"");
                Constructor<?> con = cls.getConstructors()[0];
                this.txm = (TransactionManager) con.newInstance(tm);
                env.set(EnvironmentName.TRANSACTION_MANAGER, this.txm);
                cls = Class.forName(""org.kie.spring.persistence.KieSpringJpaManager"");
                con = cls.getConstructors()[0];
                this.jpm = (PersistenceContextManager) con.newInstance(this.env);
            } catch (Exception e) {
                logger.warn(""Could not instantiate KieSpringTransactionManager. Trying with DroolsSpringTransactionManager."");
                try {
                    logger.debug(""Instantiating DroolsSpringTransactionManager"");
                    Class<?> cls = Class.forName(""org.drools.container.spring.beans.persistence.DroolsSpringTransactionManager"");
                    Constructor<?> con = cls.getConstructors()[0];
                    this.txm = (TransactionManager) con.newInstance(tm);
                    env.set(EnvironmentName.TRANSACTION_MANAGER, this.txm);
                    cls = Class.forName(""org.drools.container.spring.beans.persistence.DroolsSpringJpaManager"");
                    con = cls.getConstructors()[0];
                    this.jpm = (PersistenceContextManager) con.newInstance(this.env);
                } catch (Exception ex) {
                    logger.warn(""Could not instantiate DroolsSpringTransactionManager"");
                    throw new RuntimeException(""Could not instantiate org.kie.container.spring.beans.persistence.DroolsSpringTransactionManager"", ex);
                }
            }
        } else {
            logger.debug(""Instantiating JtaTransactionManager"");
            this.txm = TransactionManagerFactory.get().newTransactionManager(env);
            env.set(EnvironmentName.TRANSACTION_MANAGER, this.txm);
            try {
                Class<?> jpaPersistenceCtxMngrClass = Class.forName(""org.jbpm.persistence.JpaProcessPersistenceContextManager"");
                Constructor<?> jpaPersistenceCtxMngrCtor = jpaPersistenceCtxMngrClass.getConstructors()[0];
                this.jpm = (PersistenceContextManager) jpaPersistenceCtxMngrCtor.newInstance(this.env);
            } catch (ClassNotFoundException e) {
                this.jpm = new JpaPersistenceContextManager(this.env);
            } catch (Exception e) {
                throw new RuntimeException(""Error creating JpaProcessPersistenceContextManager"", e);
            }
        }
        env.set(EnvironmentName.PERSISTENCE_CONTEXT_MANAGER, this.jpm);
        env.set(EnvironmentName.TRANSACTION_MANAGER, this.txm);
    }
}",java:S3776,39
"public RequestContext createContext(){
    return PersistableRunner.this.createContext();
}",java:S1161,11
"public void remove(){
    this.iterator.remove();
}",java:S1161,11
"private static WorkItem readWorkItem(MarshallerReaderContext context) throws IOException{
    ObjectInputStream stream = (ObjectInputStream) context;
    WorkItemImpl workItem = new WorkItemImpl();
    workItem.setId(stream.readLong());
    workItem.setProcessInstanceId(stream.readUTF());
    workItem.setName(stream.readUTF());
    workItem.setState(stream.readInt());
    int nbVariables = stream.readInt();
    if (nbVariables > 0) {
        for (int i = 0; i < nbVariables; i++) {
            String name = stream.readUTF();
            try {
                int index = stream.readInt();
                ObjectMarshallingStrategy strategy = null;
                if (index >= 0) {
                    strategy = context.getResolverStrategyFactory().getStrategy(index);
                    if (strategy == null) {
                        throw new IllegalStateException(""No strategy of with index "" + index + "" available."");
                    }
                } else if (index == -2) {
                    String strategyClassName = stream.readUTF();
                    if (""org.drools.marshalling.impl.SerializablePlaceholderResolverStrategy"".equals(strategyClassName)) {
                        strategyClassName = ""org.drools.core.marshalling.impl.SerializablePlaceholderResolverStrategy"";
                    }
                    strategy = context.getResolverStrategyFactory().getStrategyObject(strategyClassName);
                    if (strategy == null) {
                        throw new IllegalStateException(""No strategy of type "" + strategyClassName + "" available."");
                    }
                } else {
                    throw new IllegalStateException(""Wrong index of strategy field read: "" + index + ""!"");
                }
                Object value = strategy.read(stream);
                workItem.setParameter(name, value);
            } catch (ClassNotFoundException e) {
                throw new IllegalArgumentException(""Could not reload variable "" + name);
            }
        }
    }
    return workItem;
}",java:S3776,39
"public Void call() throws Exception{
    try {
        JDKCallableJobCommand command = new JDKCallableJobCommand(this);
        runner.execute(command);
    } catch (Exception e) {
        logger.error(""Unable to execute job!"", e);
        throw e;
    }
    return null;
}",java:S1161,11
"public Void call() throws Exception{
    try {
        JDKCallableJobCommand command = new JDKCallableJobCommand(this);
        ExecutableRunner runner = ((CommandServiceTimerJobFactoryManager) ((TimerService) scheduler).getTimerJobFactoryManager()).getRunner();
        runner.execute(command);
        return null;
    } catch (Exception e) {
        logger.error(""Unable to execute timer job!"", e);
        throw e;
    }
}",java:S1161,11
"protected RequestContext internalExecute(Executable executable, RequestContext ctx){
    int attempt = 0;
    long sleepTime = delay;
    RuntimeException originException = null;
    while (true) {
        if (attempt > 1) {
            logger.trace(""retrying (attempt {})..."", attempt);
        }
        try {
            executeNext(executable, ctx);
            return ctx;
        } catch (RuntimeException ex) {
            if (hasInterceptorInStack()) {
                throw ex;
            }
            logger.trace(ex.getClass().getSimpleName() + "" caught in "" + this.getClass().getSimpleName() + "": "" + ex.getMessage());
            if (!isCausedByOptimisticLockingFailure(ex) && !isCausedByConstraintViolationFailure(ex)) {
                throw ex;
            }
            attempt++;
            if (originException == null) {
                originException = ex;
            }
            if (attempt > retries) {
                break;
            }
            logger.trace(""Command failed due to optimistic locking {} waiting {} millis before retry"", ex, sleepTime);
            try {
                Thread.sleep(sleepTime);
            } catch (InterruptedException e1) {
                logger.trace(""retry sleeping got interrupted"");
            }
            sleepTime *= delayFactor;
        }
    }
    logger.warn(""Retry failed after {} attempts"", attempt);
    throw originException;
}",java:S3776,39
"public String getName(){
    return this.name;
}",java:S1161,11
"public void rollback(boolean transactionOwner){
}",java:S1186,16
"public void joinTransaction(){
}",java:S1186,16
"public PersistenceContext getCommandScopedPersistenceContext(){
    return persistenceContext;
}",java:S4144,40
"public void beginCommandScopedEntityManager(){
}",java:S1186,16
"public void endCommandScopedEntityManager(){
}",java:S1186,16
"public void clearPersistenceContext(){
}",java:S1186,16
"public void diagramRete(Rete rete){
    String timestampPrefix = (new SimpleDateFormat(""yyyyMMddHHmmssSSS"")).format(new Date());
    String fileNameNoExtension = (prefixTimestamp ? timestampPrefix + ""."" : """") + rete.getRuleBase().getId();
    String gvFileName = fileNameNoExtension + "".gv"";
    String svgFileName = fileNameNoExtension + "".svg"";
    String pngFileName = fileNameNoExtension + "".png"";
    File gvFile = new File(outputPath, gvFileName);
    File svgFile = new File(outputPath, svgFileName);
    File pngFile = new File(outputPath, pngFileName);
    try (PrintStream out = new PrintStream(new FileOutputStream(gvFile))) {
        out.println(""digraph g {\n"" + ""graph [fontname = \""Overpass\"" fontsize=11];\n"" + "" node [fontname = \""Overpass\"" fontsize=11];\n"" + "" edge [fontname = \""Overpass\"" fontsize=11];"");
        HashMap<Class<? extends BaseNode>, Set<BaseNode>> levelMap = new HashMap<>();
        HashMap<Class<? extends BaseNode>, List<BaseNode>> nodeMap = new HashMap<>();
        List<Vertex<BaseNode, BaseNode>> vertexes = new ArrayList<>();
        Set<Integer> visitedNodesIDs = new HashSet<>();
        for (EntryPointNode entryPointNode : rete.getEntryPointNodes().values()) {
            visitNodes(entryPointNode, """", visitedNodesIDs, nodeMap, vertexes, levelMap, out);
        }
        out.println();
        printNodeMap(nodeMap, out);
        out.println();
        printVertexes(vertexes, out);
        out.println();
        printLevelMap(levelMap, out, vertexes);
        out.println();
        if (layout == Layout.PARTITION) {
            printPartitionMap(nodeMap, out, vertexes);
        }
        out.println(""}"");
    } catch (Exception e) {
        LOG.error(""Error building diagram"", e);
    }
    LOG.info(""Written gvFile: {}"", gvFile);
    if (outputSVG) {
        try {
            MutableGraph g = new Parser().read(gvFile);
            Graphviz.fromGraph(g).render(Format.SVG).toFile(svgFile);
            LOG.info(""Written svgFile: {}"", svgFile);
        } catch (Exception e) {
            LOG.error(""Error building SVG file"", e);
        }
    }
    if (outputPNG) {
        try {
            MutableGraph g = new Parser().read(gvFile);
            Graphviz.fromGraph(g).render(Format.PNG).toFile(pngFile);
            LOG.info(""Written pngFile: {}"", pngFile);
        } catch (Exception e) {
            LOG.error(""Error building PNG file"", e);
        }
    }
    if (outputSVG && openSVG) {
        try {
            java.awt.Desktop.getDesktop().open(svgFile);
        } catch (Exception e) {
            LOG.error(""Error opening SVG file"", e);
        }
    }
    if (outputPNG && openPNG) {
        try {
            java.awt.Desktop.getDesktop().open(pngFile);
        } catch (Exception e) {
            LOG.error(""Error opening PNG file"", e);
        }
    }
}",java:S3776,39
"private static void printPartitionMap(HashMap<Class<? extends BaseNode>, List<BaseNode>> nodeMap, PrintStream out, List<Vertex<BaseNode, BaseNode>> vertexes){
    Map<Integer, List<BaseNode>> byPartition = nodeMap.entrySet().stream().flatMap(kv -> kv.getValue().stream()).collect(groupingBy(n -> n.getPartitionId() == null ? 0 : n.getPartitionId().getId()));
    for (Entry<Integer, List<BaseNode>> kv : byPartition.entrySet()) {
        printClusterMapCluster(""P"" + kv.getKey(), new HashSet<>(kv.getValue()), out);
    }
}",java:S1172,13
"private static String printNodeAttributes(BaseNode node){
    if (node instanceof EntryPointNode) {
        EntryPointNode n = (EntryPointNode) node;
        return String.format(""[shape=circle width=0.15 fillcolor=black style=filled label=\""\"" xlabel=\""%1$s\""]"", n.getEntryPoint().getEntryPointId());
    } else if (node instanceof ObjectTypeNode) {
        ObjectTypeNode n = (ObjectTypeNode) node;
        return String.format(""[shape=rect style=rounded label=\""%1$s\""]"", strObjectType(n.getObjectType()));
    } else if (node instanceof AlphaNode) {
        AlphaNode n = (AlphaNode) node;
        return String.format(""[label=\""%1$s\""]"", escapeDot(n.getConstraint().toString()));
    } else if (node instanceof LeftInputAdapterNode) {
        return ""[shape=house orientation=-90]"";
    } else if (node instanceof RightInputAdapterNode) {
        return ""[shape=house orientation=90]"";
    } else if (node instanceof JoinNode) {
        BetaNode n = (BetaNode) node;
        BetaNodeFieldConstraint[] constraints = n.getConstraints();
        String label = ""\u22C8"";
        if (constraints.length > 0) {
            label = strObjectType(n.getObjectType(), false);
            label = label + ""( "" + Arrays.stream(constraints).map(Object::toString).collect(joining("", "")) + "" )"";
        }
        return String.format(""[shape=box label=\""%1$s\"" href=\""http://drools.org\""]"", escapeDot(label));
    } else if (node instanceof NotNode) {
        NotNode n = (NotNode) node;
        String label = ""\u22C8"";
        if (n.getObjectType() != null) {
            label = strObjectType(n.getObjectType(), false);
            label = label + ""("";
            if (n.getConstraints().length > 0) {
                label = label + "" "" + Arrays.stream(n.getConstraints()).map(Object::toString).collect(joining("", "")) + "" "";
            }
            label = label + "")"";
        }
        return String.format(""[shape=box label=\""not( %1$s )\""]"", label);
    } else if (node instanceof AccumulateNode) {
        AccumulateNode n = (AccumulateNode) node;
        return String.format(""[shape=box label=<%1$s<BR/>%2$s<BR/>%3$s>]"", n, Arrays.asList(n.getAccumulate().getAccumulators()), Arrays.asList(n.getConstraints()));
    } else if (node instanceof RuleTerminalNode) {
        RuleTerminalNode n = (RuleTerminalNode) node;
        return String.format(""[shape=doublecircle width=0.2 fillcolor=black style=filled label=\""\"" xlabel=\""%1$s\"" href=\""http://drools.org\""]"", n.getRule().getName());
    }
    return String.format(""[shape=box style=dotted label=\""%1$s\""]"", node.toString());
}",java:S3776,39
"public static Accumulator1<A, Long> count(){
    return new Accumulator1<>(identity(), CountAccumulateFunction::new, Long.class);
}",java:S2326,30
"public static Accumulator1<A, List> collect(){
    return collect(identity());
}",java:S2326,30
"public static Accumulator1<A, Set> collectSet(){
    return collectSet(identity());
}",java:S2326,30
"public DataStore<T> getDataStore(String name, Class<T> clazz){
    return (DataStore<T>) dataSources.get(name).getDataSource();
}",java:S1172,13
"public DataStream<T> getDataStream(String name, Class<T> clazz){
    return (DataStream<T>) dataSources.get(name).getDataSource();
}",java:S1172,13
"public SingletonStore<T> getSingletonStore(String name, Class<T> clazz){
    return (SingletonStore<T>) dataSources.get(name).getDataSource();
}",java:S1172,13
"public T getGlobal(String name, Class<T> clazz){
    return (T) globals.get(name);
}",java:S1172,13
"public Function1<A, ?> getBindingFunc(){
    return bindingFunc;
}",java:S1452,23
"public Supplier<?> getAccFuncSupplier(){
    return accFuncSupplier;
}",java:S1452,23
"protected ExpressionEvaluatorResult verifyList(ArrayNode json, List<Object> resultRaw){
    if (resultRaw == null) {
        return ExpressionEvaluatorResult.of(isListEmpty(json));
    }
    int elementNumber = 0;
    for (JsonNode node : json) {
        elementNumber++;
        boolean success = false;
        boolean simpleTypeNode = isSimpleTypeNode(node);
        for (Object result : resultRaw) {
            if (simpleTypeNode && internalUnaryEvaluation(getSimpleTypeNodeTextValue(node), result, result.getClass(), true)) {
                success = true;
            } else if (!simpleTypeNode && verifyObject((ObjectNode) node, result).isSuccessful()) {
                success = true;
            }
            if (success) {
                break;
            }
        }
        if (!success) {
            ExpressionEvaluatorResult evaluatorResult = ExpressionEvaluatorResult.ofFailed();
            if (simpleTypeNode) {
                evaluatorResult.setWrongValue(getSimpleTypeNodeTextValue(node));
            }
            evaluatorResult.addListItemStepToPath(elementNumber);
            return evaluatorResult;
        }
    }
    return ExpressionEvaluatorResult.ofSuccessful();
}",java:S3776,39
"protected ExpressionEvaluatorResult verifyObject(ObjectNode json, Object resultRaw){
    if (resultRaw == null) {
        return ExpressionEvaluatorResult.of(isObjectEmpty(json));
    }
    Iterator<Map.Entry<String, JsonNode>> fields = json.fields();
    while (fields.hasNext()) {
        Map.Entry<String, JsonNode> element = fields.next();
        String key = element.getKey();
        JsonNode jsonNode = element.getValue();
        Object fieldValue = extractFieldValue(resultRaw, key);
        Class<?> fieldClass = fieldValue != null ? fieldValue.getClass() : null;
        ExpressionEvaluatorResult evaluatorResult = ExpressionEvaluatorResult.ofFailed();
        if (isSimpleTypeNode(jsonNode)) {
            String nodeValue = getSimpleTypeNodeTextValue(jsonNode);
            if (!internalUnaryEvaluation(nodeValue, fieldValue, fieldClass, true)) {
                evaluatorResult.setWrongValue(nodeValue);
                evaluatorResult.addMapItemStepToPath(key);
                return evaluatorResult;
            }
        } else if (jsonNode.isArray()) {
            evaluatorResult = verifyList((ArrayNode) jsonNode, (List) fieldValue);
            if (!evaluatorResult.isSuccessful()) {
                evaluatorResult.addMapItemStepToPath(key);
                return evaluatorResult;
            }
        } else if (jsonNode.isObject()) {
            evaluatorResult = verifyObject((ObjectNode) jsonNode, fieldValue);
            if (!evaluatorResult.isSuccessful()) {
                if (resultRaw instanceof Map) {
                    evaluatorResult.addMapItemStepToPath(key);
                } else {
                    evaluatorResult.addFieldItemStepToPath(key);
                }
                return evaluatorResult;
            }
        } else {
            if (!internalUnaryEvaluation(jsonNode.textValue(), fieldValue, fieldClass, true)) {
                return ExpressionEvaluatorResult.ofFailed(jsonNode.textValue(), key);
            }
        }
    }
    return ExpressionEvaluatorResult.ofSuccessful();
}",java:S3776,39
"public void run(KieContainer kieContainer, ScesimModelDescriptor scesimModelDescriptor, ScenarioWithIndex scenarioWithIndex, ExpressionEvaluatorFactory expressionEvaluatorFactory, ClassLoader classLoader, ScenarioRunnerData scenarioRunnerData, Settings settings, Background background){
    Scenario scenario = scenarioWithIndex.getScesimData();
    extractBackgroundValues(background, classLoader, expressionEvaluatorFactory).forEach(scenarioRunnerData::addBackground);
    extractGivenValues(scesimModelDescriptor, scenario.getUnmodifiableFactMappingValues(), classLoader, expressionEvaluatorFactory).forEach(scenarioRunnerData::addGiven);
    extractExpectedValues(scenario.getUnmodifiableFactMappingValues()).forEach(scenarioRunnerData::addExpect);
    Map<String, Object> requestContext = executeScenario(kieContainer, scenarioRunnerData, expressionEvaluatorFactory, scesimModelDescriptor, settings);
    scenarioRunnerData.setMetadata(extractResultMetadata(requestContext, scenarioWithIndex));
    verifyConditions(scesimModelDescriptor, scenarioRunnerData, expressionEvaluatorFactory, requestContext);
    validateAssertion(scenarioRunnerData.getResults(), scesimModelDescriptor);
}",java:S107,1
"public static String cleanupNodes(String fullXml, String containerNodeName, String nodeToRemoveName) throws Exception{
    Document document = getDocument(fullXml);
    cleanupNodes(document, containerNodeName, nodeToRemoveName);
    return getString(document);
}",java:S112,4
"public static Map<Node, List<Node>> getChildrenNodesMap(String fullXml, String containerNodeName, String childNodeName) throws Exception{
    Document document = getDocument(fullXml);
    return getChildrenNodesMap(document, containerNodeName, childNodeName);
}",java:S112,4
"private static void loadStrategiesIndex(MarshallerReaderContext context, ProtobufMessages.Header _header) throws IOException, ClassNotFoundException{
    for (ProtobufMessages.Header.StrategyIndex _entry : _header.getStrategyList()) {
        ObjectMarshallingStrategy strategyObject = context.getResolverStrategyFactory().getStrategyObject(_entry.getName());
        if (strategyObject == null) {
            throw new IllegalStateException(""No strategy of type "" + _entry.getName() + "" available."");
        }
        context.getUsedStrategies().put(_entry.getId(), strategyObject);
        Context ctx = strategyObject.createContext();
        context.getStrategyContexts().put(strategyObject, ctx);
        if (_entry.hasData() && ctx != null) {
            ClassLoader classLoader = null;
            if (context.getClassLoader() != null) {
                classLoader = context.getClassLoader();
            } else if (context.getKnowledgeBase() != null) {
                classLoader = context.getKnowledgeBase().getRootClassLoader();
            }
            if (classLoader instanceof ProjectClassLoader) {
                readRuntimeDefinedClasses(_header, (ProjectClassLoader) classLoader);
            }
            ctx.read(new DroolsObjectInputStream(_entry.getData().newInput(), classLoader));
        }
    }
}",java:S117,12
"public static void readRuntimeDefinedClasses(Header _header, ProjectClassLoader pcl) throws IOException, ClassNotFoundException{
    if (_header.getRuntimeClassDefinitionsCount() > 0) {
        for (ProtobufMessages.RuntimeClassDef def : _header.getRuntimeClassDefinitionsList()) {
            String resourceName = def.getClassFqName();
            byte[] byteCode = def.getClassDef().toByteArray();
            if (!pcl.getStore().containsKey(resourceName)) {
                pcl.getStore().put(resourceName, byteCode);
            }
        }
    }
}",java:S117,12
"private static void checkSignature(Header _header, byte[] sessionbuff){
    KeyStoreHelper helper = KeyStoreHelper.get();
    boolean signed = _header.hasSignature();
    if (helper.isSigned() != signed) {
        throw new RuntimeException(""This environment is configured to work with "" + (helper.isSigned() ? ""signed"" : ""unsigned"") + "" serialized objects, but the given object is "" + (signed ? ""signed"" : ""unsigned"") + "". Deserialization aborted."");
    }
    if (signed) {
        if (helper.getPubKeyStore() == null) {
            throw new RuntimeException(""The session was serialized with a signature. Please configure a public keystore with the public key to check the signature. Deserialization aborted."");
        }
        try {
            if (!helper.checkDataWithPublicKey(_header.getSignature().getKeyAlias(), sessionbuff, _header.getSignature().getSignature().toByteArray())) {
                throw new RuntimeException(""Signature does not match serialized package. This is a security violation. Deserialisation aborted."");
            }
        } catch (InvalidKeyException e) {
            throw new RuntimeException(""Invalid key checking signature: "" + e.getMessage(), e);
        } catch (KeyStoreException e) {
            throw new RuntimeException(""Error accessing Key Store: "" + e.getMessage(), e);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(""No algorithm available: "" + e.getMessage(), e);
        } catch (SignatureException e) {
            throw new RuntimeException(""Signature Exception: "" + e.getMessage(), e);
        }
    }
}",java:S3776,39
"private static void checkSignature(Header _header, byte[] sessionbuff){
    KeyStoreHelper helper = KeyStoreHelper.get();
    boolean signed = _header.hasSignature();
    if (helper.isSigned() != signed) {
        throw new RuntimeException(""This environment is configured to work with "" + (helper.isSigned() ? ""signed"" : ""unsigned"") + "" serialized objects, but the given object is "" + (signed ? ""signed"" : ""unsigned"") + "". Deserialization aborted."");
    }
    if (signed) {
        if (helper.getPubKeyStore() == null) {
            throw new RuntimeException(""The session was serialized with a signature. Please configure a public keystore with the public key to check the signature. Deserialization aborted."");
        }
        try {
            if (!helper.checkDataWithPublicKey(_header.getSignature().getKeyAlias(), sessionbuff, _header.getSignature().getSignature().toByteArray())) {
                throw new RuntimeException(""Signature does not match serialized package. This is a security violation. Deserialisation aborted."");
            }
        } catch (InvalidKeyException e) {
            throw new RuntimeException(""Invalid key checking signature: "" + e.getMessage(), e);
        } catch (KeyStoreException e) {
            throw new RuntimeException(""Error accessing Key Store: "" + e.getMessage(), e);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(""No algorithm available: "" + e.getMessage(), e);
        } catch (SignatureException e) {
            throw new RuntimeException(""Signature Exception: "" + e.getMessage(), e);
        }
    }
}",java:S117,12
"public static StatefulKnowledgeSessionImpl readSession(ProtobufMessages.KnowledgeSession _session, StatefulKnowledgeSessionImpl session, InternalAgenda agenda, ProtobufMarshallerReaderContext context) throws IOException, ClassNotFoundException{
    GlobalResolver globalResolver = (GlobalResolver) context.env.get(EnvironmentName.GLOBALS);
    if (globalResolver != null) {
        session.setGlobalResolver(globalResolver);
    }
    if (session.getTimerService() instanceof PseudoClockScheduler) {
        PseudoClockScheduler clock = (PseudoClockScheduler) session.getTimerService();
        clock.advanceTime(_session.getTime(), TimeUnit.MILLISECONDS);
    }
    context.setWorkingMemory(session);
    readNodeMemories(context, _session.getRuleData());
    List<PropagationContext> pctxs = new ArrayList<>();
    if (_session.getRuleData().hasInitialFact()) {
        session.setInitialFactHandle(session.initInitialFact(context));
        context.getHandles().put(session.getInitialFactHandle().getId(), session.getInitialFactHandle());
    }
    for (ProtobufMessages.EntryPoint _ep : _session.getRuleData().getEntryPointList()) {
        EntryPoint wmep = context.getWorkingMemory().getEntryPoint(_ep.getEntryPointId());
        readFactHandles(context, _ep, ((WorkingMemoryEntryPoint) wmep).getObjectStore(), pctxs);
        context.getWorkingMemory().getFactHandleFactory().doRecycleIds(context.getHandles().keySet());
        context.getFilter().fireRNEAs(context.getWorkingMemory());
        readTruthMaintenanceSystem(session, context, wmep, _ep, pctxs);
        context.getWorkingMemory().getFactHandleFactory().stopRecycleIds();
    }
    cleanReaderContexts(pctxs);
    readActionQueue(context, _session.getRuleData());
    if (processMarshaller != null) {
        if (_session.hasProcessData()) {
            context.setParameterObject(_session.getProcessData());
            processMarshaller.readProcessInstances(context);
            context.setParameterObject(_session.getProcessData());
            processMarshaller.readWorkItems(context);
            context.setParameterObject(_session.getProcessData());
            processMarshaller.readProcessTimers(context);
        }
    } else {
        if (_session.hasProcessData()) {
            throw new IllegalStateException(""No process marshaller, unable to unmarshall process data."");
        }
    }
    if (_session.hasTimers()) {
        for (ProtobufMessages.Timers.Timer _timer : _session.getTimers().getTimerList()) {
            readTimer(context, _timer);
        }
    }
    if (!context.timerNodeSchedulers.isEmpty()) {
        for (Map<TupleKey, Scheduler> schedulers : context.timerNodeSchedulers.values()) {
            for (Scheduler scheduler : schedulers.values()) {
                scheduler.schedule(scheduler.getTrigger());
            }
        }
        context.timerNodeSchedulers.clear();
    }
    agenda.setActivationsFilter(null);
    return session;
}",java:S3776,39
"public static StatefulKnowledgeSessionImpl readSession(ProtobufMessages.KnowledgeSession _session, StatefulKnowledgeSessionImpl session, InternalAgenda agenda, ProtobufMarshallerReaderContext context) throws IOException, ClassNotFoundException{
    GlobalResolver globalResolver = (GlobalResolver) context.env.get(EnvironmentName.GLOBALS);
    if (globalResolver != null) {
        session.setGlobalResolver(globalResolver);
    }
    if (session.getTimerService() instanceof PseudoClockScheduler) {
        PseudoClockScheduler clock = (PseudoClockScheduler) session.getTimerService();
        clock.advanceTime(_session.getTime(), TimeUnit.MILLISECONDS);
    }
    context.setWorkingMemory(session);
    readNodeMemories(context, _session.getRuleData());
    List<PropagationContext> pctxs = new ArrayList<>();
    if (_session.getRuleData().hasInitialFact()) {
        session.setInitialFactHandle(session.initInitialFact(context));
        context.getHandles().put(session.getInitialFactHandle().getId(), session.getInitialFactHandle());
    }
    for (ProtobufMessages.EntryPoint _ep : _session.getRuleData().getEntryPointList()) {
        EntryPoint wmep = context.getWorkingMemory().getEntryPoint(_ep.getEntryPointId());
        readFactHandles(context, _ep, ((WorkingMemoryEntryPoint) wmep).getObjectStore(), pctxs);
        context.getWorkingMemory().getFactHandleFactory().doRecycleIds(context.getHandles().keySet());
        context.getFilter().fireRNEAs(context.getWorkingMemory());
        readTruthMaintenanceSystem(session, context, wmep, _ep, pctxs);
        context.getWorkingMemory().getFactHandleFactory().stopRecycleIds();
    }
    cleanReaderContexts(pctxs);
    readActionQueue(context, _session.getRuleData());
    if (processMarshaller != null) {
        if (_session.hasProcessData()) {
            context.setParameterObject(_session.getProcessData());
            processMarshaller.readProcessInstances(context);
            context.setParameterObject(_session.getProcessData());
            processMarshaller.readWorkItems(context);
            context.setParameterObject(_session.getProcessData());
            processMarshaller.readProcessTimers(context);
        }
    } else {
        if (_session.hasProcessData()) {
            throw new IllegalStateException(""No process marshaller, unable to unmarshall process data."");
        }
    }
    if (_session.hasTimers()) {
        for (ProtobufMessages.Timers.Timer _timer : _session.getTimers().getTimerList()) {
            readTimer(context, _timer);
        }
    }
    if (!context.timerNodeSchedulers.isEmpty()) {
        for (Map<TupleKey, Scheduler> schedulers : context.timerNodeSchedulers.values()) {
            for (Scheduler scheduler : schedulers.values()) {
                scheduler.schedule(scheduler.getTrigger());
            }
        }
        context.timerNodeSchedulers.clear();
    }
    agenda.setActivationsFilter(null);
    return session;
}",java:S117,12
"public Properties toProperties(){
    Properties prop = super.toProperties();
    prop.setProperty(DROOLS_DT_TYPE, inputType.toString());
    if (worksheetName != null) {
        prop.setProperty(DROOLS_DT_WORKSHEET, worksheetName);
    }
    return prop;
}",java:S1161,11
"private static void readBeliefSet(MarshallerReaderContext context, TruthMaintenanceSystem tms, ProtobufMessages.EqualityKey _key) throws IOException, ClassNotFoundException{
    if (_key.hasBeliefSet()) {
        ProtobufMessages.BeliefSet _beliefSet = _key.getBeliefSet();
        InternalFactHandle handle = (InternalFactHandle) context.getHandles().get(_key.getHandleId());
        if (_beliefSet.getLogicalDependencyCount() > 0) {
            for (ProtobufMessages.LogicalDependency _logicalDependency : _beliefSet.getLogicalDependencyList()) {
                ProtobufMessages.Activation _activation = _logicalDependency.getActivation();
                ActivationKey activationKey = getActivationKey(context, _activation);
                InternalMatch internalMatch = (InternalMatch) ((PBActivationsFilter) context.getFilter()).getTuplesCache().get(activationKey);
                Object object = null;
                ObjectMarshallingStrategy strategy = null;
                if (_logicalDependency.hasObjectStrategyIndex()) {
                    strategy = context.getUsedStrategies().get(_logicalDependency.getObjectStrategyIndex());
                    object = strategy.unmarshal(context.getStrategyContexts().get(strategy), (ObjectInputStream) context, _logicalDependency.getObject().toByteArray(), (context.getKnowledgeBase() == null) ? null : context.getKnowledgeBase().getRootClassLoader());
                }
                Object value = null;
                if (_logicalDependency.hasValueStrategyIndex()) {
                    strategy = context.getUsedStrategies().get(_logicalDependency.getValueStrategyIndex());
                    value = strategy.unmarshal(context.getStrategyContexts().get(strategy), (ObjectInputStream) context, _logicalDependency.getValue().toByteArray(), (context.getKnowledgeBase() == null) ? null : context.getKnowledgeBase().getRootClassLoader());
                }
                ObjectTypeConf typeConf = context.getWorkingMemory().getObjectTypeConfigurationRegistry().getOrCreateObjectTypeConf(handle.getEntryPointId(), handle.getObject());
                tms.readLogicalDependency(handle, object, value, internalMatch, typeConf);
            }
        } else {
            ((TruthMaintenanceSystemEqualityKey) handle.getEqualityKey()).setBeliefSet(((TruthMaintenanceSystemImpl) tms).getBeliefSystem().newBeliefSet(handle));
        }
    }
}",java:S3776,39
"public ResourceConfiguration fromProperties(Properties prop){
    super.fromProperties(prop);
    inputType = DecisionTableInputType.valueOf(prop.getProperty(DROOLS_DT_TYPE, DecisionTableInputType.XLS.toString()));
    worksheetName = prop.getProperty(DROOLS_DT_WORKSHEET, null);
    return this;
}",java:S1161,11
"private static ActivationKey getActivationKey(MarshallerReaderContext context, ProtobufMessages.Activation _activation){
    ProtobufMessages.Tuple _tuple = _activation.getTuple();
    if (!_tuple.getObjectList().isEmpty()) {
        Object[] objects = new Object[_tuple.getObjectList().size()];
        int i = 0;
        for (ProtobufMessages.SerializedObject _object : _tuple.getObjectList()) {
            ObjectMarshallingStrategy strategy = context.getUsedStrategies().get(_object.getStrategyIndex());
            try {
                objects[i++] = strategy.unmarshal(context.getStrategyContexts().get(strategy), (ObjectInputStream) context, _object.getObject().toByteArray(), (context.getKnowledgeBase() == null) ? null : context.getKnowledgeBase().getRootClassLoader());
            } catch (IOException | ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
        }
        return PersisterHelper.createActivationKey(_activation.getPackageName(), _activation.getRuleName(), objects);
    }
    return PersisterHelper.createActivationKey(_activation.getPackageName(), _activation.getRuleName(), _tuple);
}",java:S117,12
"public static Trigger readTrigger(MarshallerReaderContext inCtx, ProtobufMessages.Trigger _trigger){
    switch(_trigger.getType()) {
        case CRON:
            {
                ProtobufMessages.Trigger.CronTrigger _cron = _trigger.getCron();
                CronTrigger trigger = new CronTrigger();
                trigger.setStartTime(new Date(_cron.getStartTime()));
                if (_cron.hasEndTime()) {
                    trigger.setEndTime(new Date(_cron.getEndTime()));
                }
                trigger.setRepeatLimit(_cron.getRepeatLimit());
                trigger.setRepeatCount(_cron.getRepeatCount());
                trigger.setCronExpression(_cron.getCronExpression());
                if (_cron.hasNextFireTime()) {
                    trigger.setNextFireTime(new Date(_cron.getNextFireTime()));
                }
                String[] calendarNames = new String[_cron.getCalendarNameCount()];
                for (int i = 0; i < calendarNames.length; i++) {
                    calendarNames[i] = _cron.getCalendarName(i);
                }
                trigger.setCalendarNames(calendarNames);
                return trigger;
            }
        case INTERVAL:
            {
                ProtobufMessages.Trigger.IntervalTrigger _interval = _trigger.getInterval();
                IntervalTrigger trigger = new IntervalTrigger();
                trigger.setStartTime(new Date(_interval.getStartTime()));
                if (_interval.hasEndTime()) {
                    trigger.setEndTime(new Date(_interval.getEndTime()));
                }
                trigger.setRepeatLimit(_interval.getRepeatLimit());
                trigger.setRepeatCount(_interval.getRepeatCount());
                if (_interval.hasNextFireTime()) {
                    long now = inCtx.getWorkingMemory().getSessionClock().getCurrentTime() + _interval.getPeriod();
                    long nextFireTime = Math.max(now, _interval.getNextFireTime());
                    trigger.setNextFireTime(new Date(nextFireTime));
                }
                trigger.setPeriod(_interval.getPeriod());
                String[] calendarNames = new String[_interval.getCalendarNameCount()];
                for (int i = 0; i < calendarNames.length; i++) {
                    calendarNames[i] = _interval.getCalendarName(i);
                }
                trigger.setCalendarNames(calendarNames);
                return trigger;
            }
        case POINT_IN_TIME:
            {
                PointInTimeTrigger trigger = PointInTimeTrigger.createPointInTimeTrigger(_trigger.getPit().getNextFireTime(), null);
                return trigger;
            }
        case COMPOSITE_MAX_DURATION:
            {
                ProtobufMessages.Trigger.CompositeMaxDurationTrigger _cmdTrigger = _trigger.getCmdt();
                CompositeMaxDurationTrigger trigger = new CompositeMaxDurationTrigger();
                if (_cmdTrigger.hasMaxDurationTimestamp()) {
                    trigger.setMaxDurationTimestamp(new Date(_cmdTrigger.getMaxDurationTimestamp()));
                }
                if (_cmdTrigger.hasTimerCurrentDate()) {
                    trigger.setTimerCurrentDate(new Date(_cmdTrigger.getTimerCurrentDate()));
                }
                if (_cmdTrigger.hasTimerTrigger()) {
                    trigger.setTimerTrigger(readTrigger(inCtx, _cmdTrigger.getTimerTrigger()));
                }
                return trigger;
            }
    }
    throw new RuntimeException(""Unable to deserialize Trigger for type: "" + _trigger.getType());
}",java:S3776,39
"public Properties toProperties(){
    Properties prop = super.toProperties();
    prop.setProperty(""drools.jaxb.conf.systemId"", systemId);
    prop.setProperty(""drools.jaxb.conf.classes"", classes.toString());
    if (xjcOpts != null) {
        prop.setProperty(""drools.jaxb.conf.opts.class"", xjcOpts.getClass().getName());
        if (xjcOpts.getSchemaLanguage() != null) {
            prop.setProperty(""drools.jaxb.conf.opts.lang"", xjcOpts.getSchemaLanguage().toString());
        }
    }
    return prop;
}",java:S1161,11
"public ResourceConfiguration fromProperties(Properties prop){
    super.fromProperties(prop);
    systemId = prop.getProperty(""drools.jaxb.conf.systemId"", null);
    String classesStr = prop.getProperty(""drools.jaxb.conf.classes"", ""[]"");
    classesStr = classesStr.substring(1, classesStr.length() - 1).trim();
    classes = new ArrayList<>();
    if (classesStr != null && classesStr.length() > 1) {
        for (String clz : classesStr.split("","")) {
            classes.add(clz.trim());
        }
    }
    String optsClass = prop.getProperty(""drools.jaxb.conf.opts.class"", null);
    if (optsClass != null) {
        try {
            xjcOpts = (Options) Class.forName(optsClass).newInstance();
            String optsLang = prop.getProperty(""drools.jaxb.conf.opts.lang"", null);
            if (optsLang != null) {
                xjcOpts.setSchemaLanguage(Language.valueOf(optsLang));
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    return this;
}",java:S1161,11
"public int compare(InternalMatch o1, InternalMatch o2){
    int result = o1.getRule().getName().compareTo(o2.getRule().getName());
    if (result == 0) {
        org.drools.core.reteoo.Tuple t1 = o1.getTuple();
        org.drools.core.reteoo.Tuple t2 = o2.getTuple();
        while (result == 0 && t1 != null && t2 != null) {
            if (t1.getFactHandle() == null) {
                result = t2.getFactHandle() == null ? 0 : -1;
            } else {
                result = t2.getFactHandle() == null ? 1 : Long.compare(t1.getFactHandle().getId(), t2.getFactHandle().getId());
            }
            t1 = t1.getParent();
            t2 = t2.getParent();
        }
    }
    return result;
}",java:S3776,39
"public static ProtobufMessages.Activation writeActivation(MarshallerWriteContext context, RuleAgendaItem agendaItem){
    ProtobufMessages.Activation.Builder _activation = ProtobufMessages.Activation.newBuilder();
    RuleImpl rule = agendaItem.getRule();
    _activation.setPackageName(rule.getPackage());
    _activation.setRuleName(rule.getName());
    _activation.setSalience(agendaItem.getSalience());
    _activation.setIsActivated(agendaItem.isQueued());
    return _activation.build();
}",java:S1172,13
"public static ProtobufMessages.Trigger writeTrigger(Trigger trigger, MarshallerWriteContext outCtx){
    if (trigger instanceof CronTrigger) {
        CronTrigger cronTrigger = (CronTrigger) trigger;
        ProtobufMessages.Trigger.CronTrigger.Builder _cron = ProtobufMessages.Trigger.CronTrigger.newBuilder().setStartTime(cronTrigger.getStartTime().getTime()).setRepeatLimit(cronTrigger.getRepeatLimit()).setRepeatCount(cronTrigger.getRepeatCount()).setCronExpression(cronTrigger.getCronEx().getCronExpression());
        if (cronTrigger.getEndTime() != null) {
            _cron.setEndTime(cronTrigger.getEndTime().getTime());
        }
        if (cronTrigger.getNextFireTime() != null) {
            _cron.setNextFireTime(cronTrigger.getNextFireTime().getTime());
        }
        if (cronTrigger.getCalendarNames() != null) {
            for (String calendarName : cronTrigger.getCalendarNames()) {
                _cron.addCalendarName(calendarName);
            }
        }
        return ProtobufMessages.Trigger.newBuilder().setType(ProtobufMessages.Trigger.TriggerType.CRON).setCron(_cron.build()).build();
    } else if (trigger instanceof IntervalTrigger) {
        IntervalTrigger intTrigger = (IntervalTrigger) trigger;
        ProtobufMessages.Trigger.IntervalTrigger.Builder _interval = ProtobufMessages.Trigger.IntervalTrigger.newBuilder().setStartTime(intTrigger.getStartTime().getTime()).setRepeatLimit(intTrigger.getRepeatLimit()).setRepeatCount(intTrigger.getRepeatCount()).setPeriod(intTrigger.getPeriod());
        if (intTrigger.getEndTime() != null) {
            _interval.setEndTime(intTrigger.getEndTime().getTime());
        }
        if (intTrigger.getNextFireTime() != null) {
            _interval.setNextFireTime(intTrigger.getNextFireTime().getTime());
        }
        if (intTrigger.getCalendarNames() != null) {
            for (String calendarName : intTrigger.getCalendarNames()) {
                _interval.addCalendarName(calendarName);
            }
        }
        return ProtobufMessages.Trigger.newBuilder().setType(ProtobufMessages.Trigger.TriggerType.INTERVAL).setInterval(_interval.build()).build();
    } else if (trigger instanceof PointInTimeTrigger) {
        PointInTimeTrigger pitTrigger = (PointInTimeTrigger) trigger;
        Date nextFireTime = pitTrigger.hasNextFireTime();
        if (nextFireTime != null) {
            return ProtobufMessages.Trigger.newBuilder().setType(ProtobufMessages.Trigger.TriggerType.POINT_IN_TIME).setPit(ProtobufMessages.Trigger.PointInTimeTrigger.newBuilder().setNextFireTime(nextFireTime.getTime()).build()).build();
        } else {
            return null;
        }
    } else if (trigger instanceof CompositeMaxDurationTrigger) {
        CompositeMaxDurationTrigger cmdTrigger = (CompositeMaxDurationTrigger) trigger;
        ProtobufMessages.Trigger.CompositeMaxDurationTrigger.Builder _cmdt = ProtobufMessages.Trigger.CompositeMaxDurationTrigger.newBuilder();
        if (cmdTrigger.getMaxDurationTimestamp() != null) {
            _cmdt.setMaxDurationTimestamp(cmdTrigger.getMaxDurationTimestamp().getTime());
        }
        if (cmdTrigger.getTimerCurrentDate() != null) {
            _cmdt.setTimerCurrentDate(cmdTrigger.getTimerCurrentDate().getTime());
        }
        if (cmdTrigger.getTimerTrigger() != null) {
            ProtobufMessages.Trigger timerTrigger = writeTrigger(cmdTrigger.getTimerTrigger(), outCtx);
            if (timerTrigger != null) {
                _cmdt.setTimerTrigger(timerTrigger);
            }
        }
        return ProtobufMessages.Trigger.newBuilder().setType(ProtobufMessages.Trigger.TriggerType.COMPOSITE_MAX_DURATION).setCmdt(_cmdt.build()).build();
    }
    throw new RuntimeException(""Unable to serialize Trigger for type: "" + trigger.getClass());
}",java:S3776,39
" Collection<? extends KnowledgeBuilderResult> getAllResults(){
    return getResults(ResultSeverity.values());
}",java:S1452,23
"public LeftTuple getNextLeftTuple(LeftTupleSource source, LeftTupleSink sink, LeftTuple leftTuple, InternalWorkingMemory wm){
    if (otnIterator != null) {
        LeftTuple leftParent = leftTuple.getLeftParent();
        while (leftTuple != null) {
            leftTuple = leftTuple.getHandleNext();
            for (; leftTuple != null; leftTuple = leftTuple.getHandleNext()) {
                if (leftTuple.getTupleSink() == sink) {
                    return leftTuple;
                }
            }
        }
        if (leftParent != null) {
            while (leftParent != null) {
                leftParent = getNextLeftTuple(source.getLeftTupleSource(), (LeftTupleSink) source, leftParent, wm);
                if (leftParent != null) {
                    for (leftTuple = leftParent.getFirstChild(); leftTuple != null; leftTuple = leftTuple.getHandleNext()) {
                        if (leftTuple.getTupleSink() == sink) {
                            return leftTuple;
                        }
                    }
                }
            }
            return null;
        }
        while (otnIterator.hasNext()) {
            InternalFactHandle handle = otnIterator.next();
            leftTuple = handle.findFirstLeftTuple(lt -> lt.getTupleSink() == sink);
            if (leftTuple != null) {
                return leftTuple;
            }
        }
        otnIterator = null;
    } else if (source instanceof AccumulateNode) {
        BetaMemory memory = ((AccumulateMemory) wm.getNodeMemory((MemoryFactory) source)).getBetaMemory();
        FastIterator localIt = memory.getLeftTupleMemory().fullFastIterator(leftTuple.getParent());
        LeftTuple childLeftTuple = leftTuple;
        leftTuple = childLeftTuple.getParent();
        while (leftTuple != null) {
            if (childLeftTuple == null) {
                childLeftTuple = leftTuple.getFirstChild();
            } else {
                childLeftTuple = childLeftTuple.getHandleNext();
            }
            for (; childLeftTuple != null; childLeftTuple = childLeftTuple.getHandleNext()) {
                if (childLeftTuple.getTupleSink() == sink) {
                    return childLeftTuple;
                }
            }
            leftTuple = (LeftTuple) localIt.next(leftTuple);
        }
    } else if (source instanceof JoinNode || source instanceof NotNode || source instanceof FromNode || source instanceof AccumulateNode) {
        BetaMemory memory;
        FastIterator localIt;
        if (source instanceof FromNode) {
            memory = ((FromMemory) wm.getNodeMemory((MemoryFactory) source)).getBetaMemory();
        } else if (source instanceof AccumulateNode) {
            memory = ((AccumulateMemory) wm.getNodeMemory((MemoryFactory) source)).getBetaMemory();
        } else {
            memory = (BetaMemory) wm.getNodeMemory((MemoryFactory) source);
        }
        localIt = memory.getLeftTupleMemory().fullFastIterator(leftTuple.getLeftParent());
        LeftTuple childLeftTuple = leftTuple;
        leftTuple = childLeftTuple.getLeftParent();
        while (leftTuple != null) {
            if (childLeftTuple == null) {
                childLeftTuple = leftTuple.getFirstChild();
            } else {
                childLeftTuple = childLeftTuple.getHandleNext();
            }
            for (; childLeftTuple != null; childLeftTuple = childLeftTuple.getHandleNext()) {
                if (childLeftTuple.getTupleSink() == sink) {
                    return childLeftTuple;
                }
            }
            leftTuple = (LeftTuple) localIt.next(leftTuple);
        }
    }
    if (source instanceof ExistsNode) {
        BetaMemory memory = (BetaMemory) wm.getNodeMemory((MemoryFactory) source);
        if (leftTuple != null) {
            RightTuple rightTuple = leftTuple.getLeftParent().getBlocker();
            FastIterator localIt = memory.getRightTupleMemory().fullFastIterator(rightTuple);
            for (LeftTuple childleftTuple = leftTuple.getHandleNext(); childleftTuple != null; childleftTuple = childleftTuple.getHandleNext()) {
                if (childleftTuple.getTupleSink() == sink) {
                    return childleftTuple;
                }
            }
            leftTuple = leftTuple.getLeftParent();
            while (rightTuple != null) {
                if (rightTuple.getBlocked() != null) {
                    if (leftTuple != null) {
                        leftTuple = leftTuple.getBlockedNext();
                    } else {
                        leftTuple = rightTuple.getBlocked();
                    }
                    for (; leftTuple != null; leftTuple = leftTuple.getBlockedNext()) {
                        for (LeftTuple childleftTuple = leftTuple.getFirstChild(); childleftTuple != null; childleftTuple = childleftTuple.getHandleNext()) {
                            if (childleftTuple.getTupleSink() == sink) {
                                return childleftTuple;
                            }
                        }
                    }
                }
                rightTuple = (RightTuple) localIt.next(rightTuple);
            }
        }
    } else if (source instanceof EvalConditionNode || source instanceof QueryElementNode) {
        LeftTuple childLeftTuple = leftTuple;
        if (leftTuple != null) {
            leftTuple = leftTuple.getLeftParent();
            while (leftTuple != null) {
                if (childLeftTuple != null) {
                    childLeftTuple = childLeftTuple.getHandleNext();
                } else {
                    childLeftTuple = leftTuple.getFirstChild();
                }
                for (; childLeftTuple != null; childLeftTuple = childLeftTuple.getHandleNext()) {
                    if (childLeftTuple.getTupleSink() == sink) {
                        return childLeftTuple;
                    }
                }
                leftTuple = getNextLeftTuple(source.getLeftTupleSource(), (LeftTupleSink) source, leftTuple, wm);
            }
        }
    }
    return null;
}",java:S3776,39
"public static void processLeftTuples(LeftTupleSource node, List<InternalMatch> internalMatches, Set<RuleTerminalNode> nodeSet, ReteEvaluator reteEvaluator){
    LeftTupleSource node1 = node;
    while (NodeTypeEnums.LeftInputAdapterNode != node1.getType()) {
        node1 = node1.getLeftTupleSource();
    }
    int maxShareCount = node1.getAssociationsSize();
    while (NodeTypeEnums.LeftInputAdapterNode != node.getType()) {
        Memory memory = reteEvaluator.getNodeMemories().peekNodeMemory(node);
        if (memory == null || memory.getSegmentMemory() == null) {
            return;
        }
        if (node.getAssociationsSize() == maxShareCount) {
            if (NodeTypeEnums.isBetaNode(node)) {
                BetaMemory bm;
                if (NodeTypeEnums.AccumulateNode == node.getType()) {
                    AccumulateMemory am = (AccumulateMemory) memory;
                    bm = am.getBetaMemory();
                    FastIterator it = bm.getLeftTupleMemory().fullFastIterator();
                    Tuple lt = BetaNode.getFirstTuple(bm.getLeftTupleMemory(), it);
                    for (; lt != null; lt = (LeftTuple) it.next(lt)) {
                        AccumulateContext accctx = (AccumulateContext) lt.getContextObject();
                        collectFromPeers((LeftTuple) accctx.getResultLeftTuple(), internalMatches, nodeSet, reteEvaluator);
                    }
                } else if (NodeTypeEnums.ExistsNode == node.getType()) {
                    bm = (BetaMemory) reteEvaluator.getNodeMemories().peekNodeMemory(node);
                    if (bm != null) {
                        bm = (BetaMemory) reteEvaluator.getNodeMemories().peekNodeMemory(node);
                        FastIterator it = bm.getRightTupleMemory().fullFastIterator();
                        RightTuple rt = (RightTuple) BetaNode.getFirstTuple(bm.getRightTupleMemory(), it);
                        for (; rt != null; rt = (RightTuple) it.next(rt)) {
                            for (LeftTuple lt = rt.getBlocked(); lt != null; lt = lt.getBlockedNext()) {
                                if (lt.getFirstChild() != null) {
                                    collectFromPeers(lt.getFirstChild(), internalMatches, nodeSet, reteEvaluator);
                                }
                            }
                        }
                    }
                } else {
                    bm = (BetaMemory) reteEvaluator.getNodeMemories().peekNodeMemory(node);
                    if (bm != null) {
                        FastIterator it = bm.getLeftTupleMemory().fullFastIterator();
                        Tuple lt = BetaNode.getFirstTuple(bm.getLeftTupleMemory(), it);
                        for (; lt != null; lt = (LeftTuple) it.next(lt)) {
                            if (lt.getFirstChild() != null) {
                                collectFromLeftInput(lt.getFirstChild(), internalMatches, nodeSet, reteEvaluator);
                            }
                        }
                    }
                }
                return;
            } else if (NodeTypeEnums.FromNode == node.getType()) {
                FromMemory fm = (FromMemory) reteEvaluator.getNodeMemories().peekNodeMemory(node);
                if (fm != null) {
                    TupleMemory ltm = fm.getBetaMemory().getLeftTupleMemory();
                    FastIterator it = ltm.fullFastIterator();
                    for (LeftTuple lt = (LeftTuple) ltm.getFirst(null); lt != null; lt = (LeftTuple) it.next(lt)) {
                        if (lt.getFirstChild() != null) {
                            collectFromLeftInput(lt.getFirstChild(), internalMatches, nodeSet, reteEvaluator);
                        }
                    }
                }
                return;
            }
        }
        node = node.getLeftTupleSource();
    }
    LeftInputAdapterNode lian = (LeftInputAdapterNode) node;
    if (!lian.isTerminal()) {
        Memory memory = reteEvaluator.getNodeMemories().peekNodeMemory(node);
        if (memory == null || memory.getSegmentMemory() == null) {
            return;
        }
    }
    ObjectSource os = lian.getObjectSource();
    while (os.getType() != NodeTypeEnums.ObjectTypeNode) {
        os = os.getParentObjectSource();
    }
    ObjectTypeNode otn = (ObjectTypeNode) os;
    LeftTupleSink firstLiaSink = lian.getSinkPropagator().getFirstLeftTupleSink();
    java.util.Iterator<InternalFactHandle> it = otn.getFactHandlesIterator((InternalWorkingMemory) reteEvaluator);
    while (it.hasNext()) {
        InternalFactHandle fh = it.next();
        fh.forEachLeftTuple(lt -> {
            if (lt.getTupleSink() == firstLiaSink) {
                collectFromLeftInput(lt, internalMatches, nodeSet, reteEvaluator);
            }
        });
    }
}",java:S3776,39
"protected void removeTypeFromStore(TypeDeclaration type){
}",java:S1186,16
"public KieModuleCache.VersionOrBuilder getVersionOrBuilder(){
    return version_;
}",java:S4144,40
"public KieModuleCache.SignatureOrBuilder getSignatureOrBuilder(){
    return signature_;
}",java:S4144,40
"public Collection<KnowledgeBuilderResult> getAllResults(){
    return results;
}",java:S1161,11
"public final boolean isInitialized(){
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
    }
    memoizedIsInitialized = 1;
    return true;
}",java:S1161,11
"public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException{
    getSerializedSize();
    com.google.protobuf.GeneratedMessage.ExtendableMessage<KieModuleCache.Header>.ExtensionWriter extensionWriter = newExtensionWriter();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, version_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(4, signature_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(10, payload_);
    }
    extensionWriter.writeUntil(200, output);
    getUnknownFields().writeTo(output);
}",java:S1161,11
"public int getSerializedSize(){
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, version_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(4, signature_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(10, payload_);
    }
    size += extensionsSerializedSize();
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}",java:S1161,11
"public Builder clear(){
    super.clear();
    if (versionBuilder_ == null) {
        version_ = KieModuleCache.Version.getDefaultInstance();
    } else {
        versionBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000001);
    if (signatureBuilder_ == null) {
        signature_ = KieModuleCache.Signature.getDefaultInstance();
    } else {
        signatureBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000002);
    payload_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000004);
    return this;
}",java:S1161,11
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S2975,34
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S1161,11
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S1182,14
"public void addAll(Collection<? extends KnowledgeBuilderResult> results){
    this.results.addAll(results);
}",java:S1161,11
"public Builder mergeFrom(com.google.protobuf.Message other){
    if (other instanceof KieModuleCache.Header) {
        return mergeFrom((KieModuleCache.Header) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}",java:S1161,11
"public final boolean isInitialized(){
    if (!extensionsAreInitialized()) {
        return false;
    }
    return true;
}",java:S1161,11
"protected boolean wireFields(AbstractClassTypeDeclarationDescr typeDescr, ClassDefinition def, PackageRegistry pkgRegistry, List<TypeDefinition> unresolvedTypeDefinitions){
    if (!typeDescr.getFields().isEmpty()) {
        if (unresolvedTypeDefinitions != null && !unresolvedTypeDefinitions.isEmpty()) {
            for (TypeFieldDescr fld : typeDescr.getFields().values()) {
                for (TypeDefinition typeDef : unresolvedTypeDefinitions) {
                    if (fld.getPattern().getObjectType().equals(typeDef.getTypeClassName())) {
                        return false;
                    }
                }
            }
        }
        List<FieldDefinition> fieldDefs = sortFields(typeDescr.getFields(), pkgRegistry.getTypeResolver(), context, results);
        int i = 0;
        for (FieldDefinition fieldDef : fieldDefs) {
            fieldDef.setIndex(i++);
            def.addField(fieldDef);
        }
    }
    return true;
}",java:S3776,39
"private static List<FieldDefinition> sortFields(Map<String, TypeFieldDescr> fields, TypeResolver typeResolver, TypeDeclarationContext tdContext, BuildResultCollector results){
    List<FieldDefinition> fieldDefs = new ArrayList<>(fields.size());
    int maxDeclaredPos = 0;
    BitSet occupiedPositions = new BitSet(fields.size());
    for (TypeFieldDescr field : fields.values()) {
        GenericTypeDefinition genericType = field.getPattern().getGenericType().map(type -> TypeDeclarationUtils.toBuildableType(type, tdContext != null ? tdContext.getRootClassLoader() : null));
        FieldDefinition fieldDef = new FieldDefinition(field.getFieldName(), genericType);
        fieldDefs.add(fieldDef);
        if (field.hasOverride()) {
            fieldDef.setOverriding(field.getOverriding().getPattern().getObjectType());
        }
        fieldDef.setInherited(field.isInherited());
        fieldDef.setRecursive(field.isRecursive());
        fieldDef.setInitExpr(TypeDeclarationUtils.rewriteInitExprWithImports(field.getInitExpr(), typeResolver));
        if (field.getIndex() >= 0) {
            int pos = field.getIndex();
            occupiedPositions.set(pos);
            maxDeclaredPos = Math.max(maxDeclaredPos, pos);
            fieldDef.addMetaData(""position"", pos);
        } else {
            Position position = getTypedAnnotation(field, Position.class);
            if (position != null) {
                int pos = position.value();
                field.setIndex(pos);
                occupiedPositions.set(pos);
                maxDeclaredPos = Math.max(maxDeclaredPos, pos);
                fieldDef.addMetaData(""position"", pos);
            }
        }
        if (field.hasAnnotation(Key.class)) {
            fieldDef.setKey(true);
            fieldDef.addMetaData(""key"", null);
        }
        for (AnnotationDescr annotationDescr : field.getAnnotations()) {
            if (annotationDescr.getFullyQualifiedName() == null) {
                if (annotationDescr.isStrict()) {
                    results.addBuilderResult(new TypeDeclarationError(field, ""Unknown annotation @"" + annotationDescr.getName() + "" on field "" + field.getFieldName()));
                } else {
                    fieldDef.addMetaData(annotationDescr.getName(), annotationDescr.getSingleValue());
                    continue;
                }
            }
            Annotation annotation = AnnotationFactory.buildAnnotation(typeResolver, annotationDescr);
            if (annotation != null) {
                try {
                    AnnotationDefinition annotationDefinition = AnnotationDefinition.build(annotation.annotationType(), field.getAnnotation(annotationDescr.getFullyQualifiedName()).getValueMap(), typeResolver);
                    fieldDef.addAnnotation(annotationDefinition);
                } catch (Exception e) {
                    results.addBuilderResult(new TypeDeclarationError(field, ""Annotated field "" + field.getFieldName() + ""  - undefined property in @annotation "" + annotationDescr.getName() + "": "" + e.getMessage() + "";""));
                }
            } else {
                if (annotationDescr.isStrict()) {
                    results.addBuilderResult(new TypeDeclarationError(field, ""Unknown annotation @"" + annotationDescr.getName() + "" on field "" + field.getFieldName()));
                }
            }
        }
        fieldDef.setDeclIndex(field.getIndex());
    }
    int curr = 0;
    for (FieldDefinition fieldDef : fieldDefs) {
        if (fieldDef.getDeclIndex() < 0) {
            int freePos = occupiedPositions.nextClearBit(0);
            if (freePos < maxDeclaredPos) {
                occupiedPositions.set(freePos);
            } else {
                freePos = maxDeclaredPos + 1;
            }
            fieldDef.setPriority(freePos * 256 + curr++);
        } else {
            fieldDef.setPriority(fieldDef.getDeclIndex() * 256 + curr++);
        }
    }
    Collections.sort(fieldDefs);
    return fieldDefs;
}",java:S3776,39
"public Version getDefaultInstanceForType(){
    return defaultInstance;
}",java:S4144,40
"public static void populateDefinitionFromClass(ClassDefinition def, Resource resource, Class<?> concrete, boolean asTrait){
    try {
        def.setClassName(concrete.getName());
        if (concrete.getSuperclass() != null) {
            def.setSuperClass(concrete.getSuperclass().getName());
        }
        ClassFieldInspector inspector = CoreComponentsBuilder.get().createClassFieldInspector(concrete);
        Map<String, Method> methods = inspector.getGetterMethods();
        Map<String, Method> setters = inspector.getSetterMethods();
        Map<String, TypeFieldDescr> fields = new HashMap<>();
        for (String fieldName : methods.keySet()) {
            if (asTrait && (""core"".equals(fieldName) || ""fields"".equals(fieldName))) {
                continue;
            }
            if (!inspector.isNonGetter(fieldName) && setters.containsKey(fieldName)) {
                Position position = null;
                if (!concrete.isInterface()) {
                    try {
                        Field fld = concrete.getDeclaredField(fieldName);
                        position = fld.getAnnotation(Position.class);
                    } catch (NoSuchFieldException nsfe) {
                    }
                }
                Class ret = methods.get(fieldName).getReturnType();
                TypeFieldDescr field = new TypeFieldDescr();
                field.setResource(resource);
                field.setFieldName(fieldName);
                field.setPattern(new PatternDescr(ret.getName()));
                field.setIndex(position != null ? position.value() : -1);
                fields.put(fieldName, field);
            }
        }
        if (!fields.isEmpty()) {
            List<FieldDefinition> fieldDefs = sortFields(fields, null, null, null);
            int i = 0;
            for (FieldDefinition fieldDef : fieldDefs) {
                fieldDef.setIndex(i++);
                def.addField(fieldDef);
            }
        }
        Set<String> interfaces = new HashSet<>();
        Collections.addAll(interfaces, def.getInterfaces());
        for (Class iKlass : ClassUtils.getAllImplementedInterfaceNames(concrete)) {
            interfaces.add(iKlass.getName());
        }
        def.setInterfaces(interfaces.toArray(new String[interfaces.size()]));
        def.setDefinedClass(concrete);
    } catch (IOException e) {
        LOG.error(""Exception"", e);
    }
}",java:S3776,39
"public final boolean isInitialized(){
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    memoizedIsInitialized = 1;
    return true;
}",java:S1161,11
"public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException{
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(1, versionMajor_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(2, versionMinor_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeInt32(3, versionRevision_);
    }
    getUnknownFields().writeTo(output);
}",java:S1161,11
"public int getSerializedSize(){
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, versionMajor_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(2, versionMinor_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(3, versionRevision_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}",java:S1161,11
"public Builder clear(){
    super.clear();
    versionMajor_ = 0;
    bitField0_ = (bitField0_ & ~0x00000001);
    versionMinor_ = 0;
    bitField0_ = (bitField0_ & ~0x00000002);
    versionRevision_ = 0;
    bitField0_ = (bitField0_ & ~0x00000004);
    return this;
}",java:S1161,11
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S2975,34
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S1161,11
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S1182,14
"public Builder mergeFrom(com.google.protobuf.Message other){
    if (other instanceof KieModuleCache.Version) {
        return mergeFrom((KieModuleCache.Version) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}",java:S1161,11
"public final boolean isInitialized(){
    return true;
}",java:S1161,11
"public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException{
    KieModuleCache.Version parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (KieModuleCache.Version) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}",java:S1161,11
"protected List<AbstractClassTypeDeclarationDescr> sortByHierarchy(Collection<AbstractClassTypeDeclarationDescr> unsortedDescrs, TypeDeclarationContext tdContext, BuildResultCollector results){
    taxonomy = new HashMap<>();
    Map<QualifiedName, AbstractClassTypeDeclarationDescr> cache = new HashMap<>();
    for (AbstractClassTypeDeclarationDescr tdescr : unsortedDescrs) {
        cache.put(tdescr.getType(), tdescr);
    }
    for (AbstractClassTypeDeclarationDescr tdescr : unsortedDescrs) {
        QualifiedName name = tdescr.getType();
        Collection<QualifiedName> supers = taxonomy.get(name);
        if (supers == null) {
            supers = new ArrayList<>();
            taxonomy.put(name, supers);
        } else {
            results.addBuilderResult(new TypeDeclarationError(tdescr, ""Found duplicate declaration for type "" + tdescr.getType()));
        }
        boolean circular = false;
        for (QualifiedName sup : tdescr.getSuperTypes()) {
            if (!Object.class.getName().equals(name.getFullName())) {
                if (!hasCircularDependency(tdescr.getType(), sup, taxonomy)) {
                    if (cache.containsKey(sup)) {
                        supers.add(sup);
                    }
                } else {
                    circular = true;
                    results.addBuilderResult(new TypeDeclarationError(tdescr, ""Found circular dependency for type "" + tdescr.getTypeName()));
                    break;
                }
            }
        }
        if (circular) {
            tdescr.getSuperTypes().clear();
        }
    }
    for (AbstractClassTypeDeclarationDescr tdescr : unsortedDescrs) {
        for (TypeFieldDescr field : tdescr.getFields().values()) {
            QualifiedName name = tdescr.getType();
            QualifiedName typeName = new QualifiedName(field.getPattern().getGenericType().getRawType());
            if (!hasCircularDependency(name, typeName, taxonomy)) {
                if (cache.containsKey(typeName)) {
                    taxonomy.get(name).add(typeName);
                }
            } else {
                field.setRecursive(true);
            }
        }
    }
    List<QualifiedName> sorted = new HierarchySorter<QualifiedName>().sort(taxonomy);
    ArrayList list = new ArrayList(sorted.size());
    for (QualifiedName name : sorted) {
        list.add(cache.get(name));
    }
    return list;
}",java:S3776,39
"public Signature getDefaultInstanceForType(){
    return defaultInstance;
}",java:S4144,40
"protected List<AbstractClassTypeDeclarationDescr> sortByHierarchy(Collection<AbstractClassTypeDeclarationDescr> unsortedDescrs, TypeDeclarationContext tdContext, BuildResultCollector results){
    taxonomy = new HashMap<>();
    Map<QualifiedName, AbstractClassTypeDeclarationDescr> cache = new HashMap<>();
    for (AbstractClassTypeDeclarationDescr tdescr : unsortedDescrs) {
        cache.put(tdescr.getType(), tdescr);
    }
    for (AbstractClassTypeDeclarationDescr tdescr : unsortedDescrs) {
        QualifiedName name = tdescr.getType();
        Collection<QualifiedName> supers = taxonomy.get(name);
        if (supers == null) {
            supers = new ArrayList<>();
            taxonomy.put(name, supers);
        } else {
            results.addBuilderResult(new TypeDeclarationError(tdescr, ""Found duplicate declaration for type "" + tdescr.getType()));
        }
        boolean circular = false;
        for (QualifiedName sup : tdescr.getSuperTypes()) {
            if (!Object.class.getName().equals(name.getFullName())) {
                if (!hasCircularDependency(tdescr.getType(), sup, taxonomy)) {
                    if (cache.containsKey(sup)) {
                        supers.add(sup);
                    }
                } else {
                    circular = true;
                    results.addBuilderResult(new TypeDeclarationError(tdescr, ""Found circular dependency for type "" + tdescr.getTypeName()));
                    break;
                }
            }
        }
        if (circular) {
            tdescr.getSuperTypes().clear();
        }
    }
    for (AbstractClassTypeDeclarationDescr tdescr : unsortedDescrs) {
        for (TypeFieldDescr field : tdescr.getFields().values()) {
            QualifiedName name = tdescr.getType();
            QualifiedName typeName = new QualifiedName(field.getPattern().getGenericType().getRawType());
            if (!hasCircularDependency(name, typeName, taxonomy)) {
                if (cache.containsKey(typeName)) {
                    taxonomy.get(name).add(typeName);
                }
            } else {
                field.setRecursive(true);
            }
        }
    }
    List<QualifiedName> sorted = new HierarchySorter<QualifiedName>().sort(taxonomy);
    ArrayList list = new ArrayList(sorted.size());
    for (QualifiedName name : sorted) {
        list.add(cache.get(name));
    }
    return list;
}",java:S1172,13
"public final boolean isInitialized(){
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    memoizedIsInitialized = 1;
    return true;
}",java:S1161,11
"public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException{
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, getKeyAliasBytes());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, signature_);
    }
    getUnknownFields().writeTo(output);
}",java:S1161,11
"public int getSerializedSize(){
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, getKeyAliasBytes());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, signature_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}",java:S1161,11
"public Builder clear(){
    super.clear();
    keyAlias_ = """";
    bitField0_ = (bitField0_ & ~0x00000001);
    signature_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    return this;
}",java:S1161,11
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S2975,34
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S1161,11
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S1182,14
"public Builder mergeFrom(com.google.protobuf.Message other){
    if (other instanceof KieModuleCache.Signature) {
        return mergeFrom((KieModuleCache.Signature) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}",java:S1161,11
"public final boolean isInitialized(){
    return true;
}",java:S1161,11
"public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException{
    KieModuleCache.Signature parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (KieModuleCache.Signature) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}",java:S1161,11
"protected void mergeFields(String simpleSuperTypeName, String superTypePackageName, String fullSuper, TypeDeclarationDescr typeDescr, Map<String, AbstractClassTypeDeclarationDescr> unprocessableDescrs, TypeResolver resolver, BuildResultCollector results){
    Map<String, TypeFieldDescr> fieldMap = new LinkedHashMap<>();
    PackageRegistry registry = tdContext.getPackageRegistry(superTypePackageName);
    InternalKnowledgePackage pack = null;
    if (registry != null) {
        pack = registry.getPackage();
    }
    if (unprocessableDescrs.containsKey(fullSuper)) {
        unprocessableDescrs.put(typeDescr.getType().getFullName(), typeDescr);
        return;
    }
    boolean isSuperClassTagged = false;
    boolean isSuperClassDeclared = true;
    if (pack != null) {
        TypeDeclaration superTypeDeclaration = pack.getTypeDeclaration(simpleSuperTypeName);
        if (superTypeDeclaration != null && superTypeDeclaration.getTypeClassDef() != null) {
            ClassDefinition classDef = superTypeDeclaration.getTypeClassDef();
            for (org.kie.api.definition.type.FactField fld : classDef.getFields()) {
                TypeFieldDescr inheritedFlDescr = buildInheritedFieldDescrFromDefinition(fld, typeDescr);
                fieldMap.put(inheritedFlDescr.getFieldName(), inheritedFlDescr);
            }
            isSuperClassTagged = !superTypeDeclaration.isNovel();
        }
    } else {
        isSuperClassDeclared = false;
    }
    if (!isSuperClassDeclared || isSuperClassTagged) {
        try {
            Class superKlass;
            if (registry != null) {
                superKlass = registry.getTypeResolver().resolveType(fullSuper);
            } else {
                superKlass = resolver.resolveType(fullSuper);
            }
            buildDescrsFromFields(superKlass, typeDescr, fieldMap);
        } catch (ClassNotFoundException cnfe) {
            unprocessableDescrs.put(typeDescr.getType().getFullName(), typeDescr);
            return;
        }
    }
    for (String fieldName : typeDescr.getFields().keySet()) {
        if (fieldMap.containsKey(fieldName)) {
            String type1 = fieldMap.get(fieldName).getPattern().getObjectType();
            String type2 = typeDescr.getFields().get(fieldName).getPattern().getObjectType();
            if (type2.lastIndexOf(""."") < 0) {
                try {
                    TypeResolver typeResolver = tdContext.getPackageRegistry(typeDescr.getNamespace()).getTypeResolver();
                    type1 = typeResolver.resolveType(type1).getName();
                    type2 = typeResolver.resolveType(type2).getName();
                    fieldMap.get(fieldName).getPattern().setObjectType(type1);
                    typeDescr.getFields().get(fieldName).getPattern().setObjectType(type2);
                } catch (ClassNotFoundException cnfe) {
                }
            }
            boolean clash = !type1.equals(type2);
            TypeFieldDescr overriding = null;
            if (clash) {
                try {
                    Class<?> sup = resolver.resolveType(type1);
                    Class<?> loc = resolver.resolveType(type2);
                    if (sup.isAssignableFrom(loc)) {
                        clash = false;
                        overriding = fieldMap.get(fieldName);
                    }
                } catch (ClassNotFoundException cnfe) {
                }
            }
            if (clash) {
                results.addBuilderResult(new TypeDeclarationError(typeDescr, ""Cannot redeclare field '"" + fieldName + "" from "" + type1 + "" to "" + type2));
                typeDescr.setType(null, null);
                return;
            } else {
                String initVal = fieldMap.get(fieldName).getInitExpr();
                TypeFieldDescr fd = typeDescr.getFields().get(fieldName);
                if (fd.getInitExpr() == null) {
                    fd.setInitExpr(initVal);
                }
                fd.setInherited(fieldMap.get(fieldName).isInherited());
                fd.setOverriding(overriding);
                for (String key : fieldMap.get(fieldName).getAnnotationNames()) {
                    if (fd.getAnnotation(key) == null) {
                        fd.addAnnotation(fieldMap.get(fieldName).getAnnotation(key));
                    }
                }
                if (fd.getIndex() < 0) {
                    fd.setIndex(fieldMap.get(fieldName).getIndex());
                }
            }
        }
        fieldMap.put(fieldName, typeDescr.getFields().get(fieldName));
    }
    typeDescr.setFields(fieldMap);
}",java:S3776,39
"public KModuleCache getDefaultInstanceForType(){
    return defaultInstance;
}",java:S4144,40
"public final boolean isInitialized(){
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    memoizedIsInitialized = 1;
    return true;
}",java:S1161,11
"public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException{
    getSerializedSize();
    for (int i = 0; i < compilationData_.size(); i++) {
        output.writeMessage(1, compilationData_.get(i));
    }
    getUnknownFields().writeTo(output);
}",java:S1161,11
"public int getSerializedSize(){
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    for (int i = 0; i < compilationData_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, compilationData_.get(i));
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}",java:S1161,11
"public Builder clear(){
    super.clear();
    if (compilationDataBuilder_ == null) {
        compilationData_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
    } else {
        compilationDataBuilder_.clear();
    }
    return this;
}",java:S1161,11
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S2975,34
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S1161,11
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S1182,14
"public Builder mergeFrom(com.google.protobuf.Message other){
    if (other instanceof KieModuleCache.KModuleCache) {
        return mergeFrom((KieModuleCache.KModuleCache) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}",java:S1161,11
"public Builder mergeFrom(KieModuleCache.KModuleCache other){
    if (other == KieModuleCache.KModuleCache.getDefaultInstance())
        return this;
    if (compilationDataBuilder_ == null) {
        if (!other.compilationData_.isEmpty()) {
            if (compilationData_.isEmpty()) {
                compilationData_ = other.compilationData_;
                bitField0_ = (bitField0_ & ~0x00000001);
            } else {
                ensureCompilationDataIsMutable();
                compilationData_.addAll(other.compilationData_);
            }
            onChanged();
        }
    } else {
        if (!other.compilationData_.isEmpty()) {
            if (compilationDataBuilder_.isEmpty()) {
                compilationDataBuilder_.dispose();
                compilationDataBuilder_ = null;
                compilationData_ = other.compilationData_;
                bitField0_ = (bitField0_ & ~0x00000001);
                compilationDataBuilder_ = alwaysUseFieldBuilders ? getCompilationDataFieldBuilder() : null;
            } else {
                compilationDataBuilder_.addAllMessages(other.compilationData_);
            }
        }
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}",java:S3776,39
"public final boolean isInitialized(){
    return true;
}",java:S1161,11
"public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException{
    KieModuleCache.KModuleCache parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (KieModuleCache.KModuleCache) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}",java:S1161,11
"public CompilationData getDefaultInstanceForType(){
    return defaultInstance;
}",java:S4144,40
"private void buildResourceType(ResourceBuilder resourceBuilder, ResourceType resourceType){
    List<ResourceDescr> resourcesByType = this.resourcesByType.remove(resourceType);
    if (resourcesByType != null) {
        for (ResourceDescr resourceDescr : resourcesByType) {
            try {
                kBuilder.setAssetFilter(resourceDescr.getFilter());
                resourceBuilder.build(kBuilder, resourceDescr);
            } catch (RuntimeException e) {
                if (buildException == null) {
                    buildException = e;
                }
            } catch (Exception e) {
                if (buildException == null) {
                    buildException = new RuntimeException(e);
                }
            } finally {
                kBuilder.setAssetFilter(null);
            }
        }
    }
}",java:S3776,39
"public final boolean isInitialized(){
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    memoizedIsInitialized = 1;
    return true;
}",java:S1161,11
"public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException{
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, getDialectBytes());
    }
    for (int i = 0; i < entry_.size(); i++) {
        output.writeMessage(2, entry_.get(i));
    }
    getUnknownFields().writeTo(output);
}",java:S1161,11
"public int getSerializedSize(){
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, getDialectBytes());
    }
    for (int i = 0; i < entry_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, entry_.get(i));
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}",java:S1161,11
"public Builder clear(){
    super.clear();
    dialect_ = """";
    bitField0_ = (bitField0_ & ~0x00000001);
    if (entryBuilder_ == null) {
        entry_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
    } else {
        entryBuilder_.clear();
    }
    return this;
}",java:S1161,11
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S2975,34
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S1161,11
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S1182,14
"public Builder mergeFrom(com.google.protobuf.Message other){
    if (other instanceof KieModuleCache.CompilationData) {
        return mergeFrom((KieModuleCache.CompilationData) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}",java:S1161,11
"public Builder mergeFrom(KieModuleCache.CompilationData other){
    if (other == KieModuleCache.CompilationData.getDefaultInstance())
        return this;
    if (other.hasDialect()) {
        bitField0_ |= 0x00000001;
        dialect_ = other.dialect_;
        onChanged();
    }
    if (entryBuilder_ == null) {
        if (!other.entry_.isEmpty()) {
            if (entry_.isEmpty()) {
                entry_ = other.entry_;
                bitField0_ = (bitField0_ & ~0x00000002);
            } else {
                ensureEntryIsMutable();
                entry_.addAll(other.entry_);
            }
            onChanged();
        }
    } else {
        if (!other.entry_.isEmpty()) {
            if (entryBuilder_.isEmpty()) {
                entryBuilder_.dispose();
                entryBuilder_ = null;
                entry_ = other.entry_;
                bitField0_ = (bitField0_ & ~0x00000002);
                entryBuilder_ = alwaysUseFieldBuilders ? getEntryFieldBuilder() : null;
            } else {
                entryBuilder_.addAllMessages(other.entry_);
            }
        }
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}",java:S3776,39
"public final boolean isInitialized(){
    return true;
}",java:S1161,11
"public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException{
    KieModuleCache.CompilationData parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (KieModuleCache.CompilationData) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}",java:S1161,11
"public CompDataEntry getDefaultInstanceForType(){
    return defaultInstance;
}",java:S4144,40
"public final boolean isInitialized(){
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    memoizedIsInitialized = 1;
    return true;
}",java:S1161,11
"public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException{
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, getIdBytes());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, data_);
    }
    getUnknownFields().writeTo(output);
}",java:S1161,11
"public int getSerializedSize(){
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, getIdBytes());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, data_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}",java:S1161,11
"public Builder clear(){
    super.clear();
    id_ = """";
    bitField0_ = (bitField0_ & ~0x00000001);
    data_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    return this;
}",java:S1161,11
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S2975,34
"public List<K> sort(Map<K, Collection<K>> hierarchy){
    Node<K, K> root = new Node<>(null);
    Map<K, Node<K, K>> map = new HashMap<>();
    for (K element : hierarchy.keySet()) {
        K key = element;
        Node<K, K> node = map.get(key);
        if (node == null) {
            node = new Node(key, element);
            map.put(key, node);
        } else if (node.getData() == null) {
            node.setData(element);
        }
        Collection<K> px = hierarchy.get(key);
        if (px.isEmpty()) {
            root.addChild(node);
        } else {
            for (K parentElement : px) {
                K superKey = parentElement;
                Node<K, K> superNode = map.get(superKey);
                if (superNode == null) {
                    superNode = new Node<>(superKey);
                    map.put(superKey, superNode);
                }
                if (!superNode.children.contains(node)) {
                    superNode.addChild(node);
                }
            }
        }
    }
    java.util.Iterator<Node<K, K>> iter = map.values().iterator();
    while (iter.hasNext()) {
        Node<K, K> n = iter.next();
        if (n.getData() == null)
            root.addChild(n);
    }
    List<K> sortedList = new java.util.LinkedList<>();
    root.accept(sortedList);
    return sortedList;
}",java:S3776,39
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S1161,11
"public Builder clone(){
    return create().mergeFrom(buildPartial());
}",java:S1182,14
"public Builder mergeFrom(com.google.protobuf.Message other){
    if (other instanceof KieModuleCache.CompDataEntry) {
        return mergeFrom((KieModuleCache.CompDataEntry) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}",java:S1161,11
"public final boolean isInitialized(){
    return true;
}",java:S1161,11
"public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException{
    KieModuleCache.CompDataEntry parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (KieModuleCache.CompDataEntry) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}",java:S1161,11
"public KieModuleMetaInfo generateKieModuleMetaInfo(ResourceStore trgMfs){
    Map<String, TypeMetaInfo> typeInfos = new HashMap<>();
    Map<String, Set<String>> rulesPerPackage = new HashMap<>();
    KieModuleModel kieModuleModel = kModule.getKieModuleModel();
    for (String kieBaseName : kieModuleModel.getKieBaseModels().keySet()) {
        KnowledgeBuilder kBuilder = kModule.getKnowledgeBuilderForKieBase(kieBaseName);
        KieModuleCache.KModuleCache.Builder _kmoduleCacheBuilder = createCacheBuilder();
        KieModuleCache.CompilationData.Builder _compData = createCompilationData();
        for (KiePackage kPkg : kBuilder.getKnowledgePackages()) {
            PackageRegistry pkgRegistry = ((InternalKnowledgeBuilder) kBuilder).getPackageRegistry(kPkg.getName());
            JavaDialectRuntimeData runtimeData = (JavaDialectRuntimeData) pkgRegistry.getDialectRuntimeRegistry().getDialectData(""java"");
            List<String> types = new ArrayList<>();
            for (FactType factType : kPkg.getFactTypes()) {
                Class<?> typeClass = ((ClassDefinition) factType).getDefinedClass();
                TypeDeclaration typeDeclaration = pkgRegistry.getPackage().getTypeDeclaration(typeClass);
                if (typeDeclaration != null) {
                    typeInfos.put(typeClass.getName(), new TypeMetaInfo(typeDeclaration));
                }
                String className = factType.getName();
                String internalName = className.replace('.', '/') + "".class"";
                if (trgMfs != null) {
                    byte[] bytes = runtimeData.getBytecode(internalName);
                    if (bytes != null) {
                        trgMfs.write(internalName, bytes, true);
                    }
                }
                types.add(internalName);
            }
            Set<String> rules = rulesPerPackage.get(kPkg.getName());
            if (rules == null) {
                rules = new HashSet<>();
            }
            for (Rule rule : kPkg.getRules()) {
                rules.add(rule.getName());
            }
            if (!rules.isEmpty()) {
                rulesPerPackage.put(kPkg.getName(), rules);
            }
            addToCompilationData(_compData, runtimeData, types);
        }
        _kmoduleCacheBuilder.addCompilationData(_compData.build());
        if (trgMfs != null) {
            writeCompilationDataToTrg(_kmoduleCacheBuilder.build(), kieBaseName, trgMfs);
        }
    }
    return new KieModuleMetaInfo(typeInfos, rulesPerPackage);
}",java:S1161,11
"private void addToCompilationData(KieModuleCache.CompilationData.Builder _cdata, JavaDialectRuntimeData runtimeData, List<String> types){
    for (Map.Entry<String, byte[]> entry : runtimeData.getStore().entrySet()) {
        if (!types.contains(entry.getKey())) {
            KieModuleCache.CompDataEntry _entry = KieModuleCache.CompDataEntry.newBuilder().setId(entry.getKey()).setData(ByteString.copyFrom(entry.getValue())).build();
            _cdata.addEntry(_entry);
        }
    }
}",java:S117,12
"private void writeCompilationDataToTrg(KieModuleCache.KModuleCache _kmoduleCache, String kieBaseName, ResourceStore trgMfs){
    try {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        KieModuleCacheHelper.writeToStreamWithHeader(out, _kmoduleCache);
        String compilatonDataPath = ""META-INF/"" + kieBaseName.replace('.', '/') + ""/kbase.cache"";
        trgMfs.write(compilatonDataPath, out.toByteArray(), true);
    } catch (IOException e) {
    }
}",java:S117,12
"public void renderDRL(final DRLOutput out){
    if (isCommented()) {
        out.writeLine(""//"" + getComment());
    }
    out.writeLine(""rule "" + this._name);
    if (this._description != null) {
        out.writeLine(""/* "" + this._description + "" */"");
    }
    for (String ms : this._metadata) {
        out.writeLine(""\t@"" + ms);
    }
    super.renderDRL(out);
    out.writeLine(""\twhen"");
    renderDRL(this._lhs, out);
    out.writeLine(""\tthen"");
    renderDRL(this._rhs, out);
    out.writeLine(""end\n"");
}",java:S1161,11
"public void addValue(Map<String, Object> vars){
    for (int i = 0; i < values.length; i++) {
        vars.put(column.getName() + i, values[i]);
    }
}",java:S1161,11
"public void setIndex(int i){
    throw new RuntimeException(""You cannot call setQueueIndex on an ArrayCell"");
}",java:S1161,11
"public int getIndex(){
    return -1;
}",java:S1161,11
"public boolean isEmpty(){
    return StringUtils.isEmpty(value);
}",java:S1161,11
"public String getCondition(String condition, int index){
    if (index == -1) {
        StringBuilder conditionString = new StringBuilder(""ArrayCell(row == r, column == $param"");
        if (!StringUtils.isEmpty(condition)) {
            conditionString.append("", value "").append(condition);
        }
        conditionString.append("")"");
        return conditionString.toString();
    } else {
        return type.getCondition(condition, index);
    }
}",java:S1161,11
"private CompiledTemplate getTemplate(String templateName) throws IOException{
    CompiledTemplate contents;
    if (!registry.contains(templateName)) {
        RuleTemplate template = ruleTemplates.get(templateName);
        contents = TemplateCompiler.compileTemplate(template.getContents());
        registry.addNamedTemplate(templateName, contents);
    } else {
        contents = registry.getNamedTemplate(templateName);
    }
    return contents;
}",java:S1130,7
"private void parseTemplate(final InputStream templateStream){
    try {
        final ColumnFactory cf = new ColumnFactory();
        final BufferedReader templateReader = new BufferedReader(new InputStreamReader(templateStream, IoUtils.UTF8_CHARSET));
        String line;
        boolean inTemplate = false;
        boolean inHeader = false;
        boolean inContents = false;
        boolean inMultiLineComment = false;
        RuleTemplate template = null;
        StringBuilder header = new StringBuilder();
        StringBuilder contents = new StringBuilder();
        while ((line = templateReader.readLine()) != null) {
            if (inMultiLineComment) {
                int commentEnd = line.indexOf(""*/"");
                if (commentEnd >= 0) {
                    line = line.substring(commentEnd + 2);
                    inMultiLineComment = false;
                } else {
                    line = """";
                }
            } else {
                int commentStart = line.indexOf(""/*"");
                if (commentStart >= 0) {
                    int commentEnd = line.indexOf(""*/"");
                    if (commentEnd > commentStart) {
                        line = line.substring(0, commentStart) + line.substring(commentEnd + 2);
                    } else {
                        line = line.substring(0, commentStart);
                        inMultiLineComment = true;
                    }
                }
            }
            String trimmed = line.trim();
            if (trimmed.length() > 0) {
                if (trimmed.startsWith(""template header"")) {
                    inHeader = true;
                } else if (trimmed.startsWith(""template "")) {
                    inTemplate = true;
                    inHeader = false;
                    String quotedName = trimmed.substring(8).trim();
                    quotedName = quotedName.substring(1, quotedName.length() - 1);
                    template = new RuleTemplate(quotedName, this, replaceOptionals);
                    addTemplate(template);
                } else if (trimmed.startsWith(""package "")) {
                    if (!inHeader) {
                        throw new DecisionTableParseException(""Missing header"");
                    }
                    inHeader = false;
                    header.append(line).append(""\n"");
                } else if (trimmed.startsWith(""import "")) {
                    inHeader = false;
                    header.append(line).append(""\n"");
                } else if (inHeader) {
                    addColumn(cf.getColumn(trimmed));
                } else if (!inTemplate) {
                    header.append(line).append(""\n"");
                } else if (!inContents && trimmed.startsWith(""rule "")) {
                    inContents = true;
                    contents.append(line).append(""\n"");
                } else if (trimmed.equals(""end template"")) {
                    template.setContents(contents.toString());
                    contents.setLength(0);
                    inTemplate = false;
                    inContents = false;
                } else if (inContents) {
                    contents.append(removeSingleLineComment(line)).append(""\n"");
                } else {
                    template.addColumn(trimmed);
                }
            }
        }
        if (inTemplate) {
            throw new DecisionTableParseException(""Missing end template"");
        }
        this.header = header.toString();
    } catch (IOException e) {
        throw new RuntimeException(e);
    } finally {
        if (templateStream != null) {
            closeStream(templateStream);
        }
    }
}",java:S3776,39
"public boolean isEmpty(){
    return StringUtils.isEmpty(value);
}",java:S1161,11
"public void startSheet(String name){
}",java:S1186,16
"public Set<String> getOptionSubKeys(OptionKey<T> option){
    switch(option.name()) {
        case KBuilderSeverityOption.PROPERTY_NAME:
            {
                return this.severityMap.keySet();
            }
        default:
            return compConfig.getOptionSubKeys(option);
    }
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(parameters);
}",java:S1161,11
"public Set<String> getOptionSubKeys(OptionKey<T> option){
    return compConfig.getOptionSubKeys(option);
}",java:S1161,11
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    this.parameters = (Declaration[]) in.readObject();
}",java:S1161,11
"private void mergePackage(InternalKnowledgePackage pkg, InternalKnowledgePackage newPkg){
    final Map<String, ImportDeclaration> imports = pkg.getImports();
    imports.putAll(newPkg.getImports());
    if (newPkg.getGlobals() != null && !newPkg.getGlobals().isEmpty()) {
        Map<String, Type> pkgGlobals = pkg.getGlobals();
        for (final Map.Entry<String, Type> entry : newPkg.getGlobals().entrySet()) {
            final String identifier = entry.getKey();
            final Type type = entry.getValue();
            if (pkgGlobals.containsKey(identifier) && !pkgGlobals.get(identifier).equals(type)) {
                throw new RuntimeException(pkg.getName() + "" cannot be integrated"");
            } else {
                pkg.addGlobal(identifier, type);
                this.globals.addGlobal(identifier, type);
            }
        }
    }
    if (newPkg.getTypeDeclarations() != null) {
        for (TypeDeclaration type : newPkg.getTypeDeclarations().values()) {
            if (!pkg.getTypeDeclarations().containsKey(type.getTypeName())) {
                pkg.addTypeDeclaration(type);
            }
        }
    }
    for (final org.kie.api.definition.rule.Rule newRule : newPkg.getRules()) {
        pkg.addRule(((RuleImpl) newRule));
    }
    if (newPkg.getRuleFlows() != null) {
        final Map flows = newPkg.getRuleFlows();
        for (Object o : flows.values()) {
            final Process flow = (Process) o;
            pkg.addProcess(flow);
        }
    }
}",java:S3776,39
"public boolean isValid(){
    return super.isSemanticallyValid();
}",java:S1161,11
"protected void doSecondBuildStep(Collection<CompositePackageDescr> packages){
}",java:S1186,16
"public boolean processAbduction(Match resultLeftTuple, DroolsQuery dquery, Object[] objects, ValueResolver valueResolver){
    return true;
}",java:S1172,13
"public InternalFactHandle insertLogical(Object object, Object value){
    return insertLogical(toStatefulKnowledgeSession().getDefaultEntryPoint(), object, value);
}",java:S1161,11
"public void add(M newDep){
    newDep.setStatus(resolveStatus(newDep));
    RuleImpl rule = newDep.getLogicalDependency().getJustifier().getRule();
    boolean wasDefeated = false;
    for (DefeasibleMode<M> existingDep = rootUndefeated; existingDep != null; existingDep = existingDep.getNext()) {
        wasDefeated = checkIsDefeated(newDep, rule, existingDep);
        if (wasDefeated) {
            existingDep.addDefeated(newDep);
            break;
        }
    }
    if (!wasDefeated) {
        M stagedDeps = null;
        for (M existingDep = rootUndefeated; existingDep != null; ) {
            M next = existingDep.getNext();
            if (checkIsDefeated(existingDep, existingDep.getLogicalDependency().getJustifier().getRule(), newDep)) {
                removeUndefeated(existingDep);
                newDep.addDefeated(existingDep);
                if (existingDep.getRootDefeated() != null) {
                    if (stagedDeps == null) {
                        stagedDeps = existingDep.getRootDefeated();
                    } else {
                        stagedDeps.setPrevious(existingDep.getTailDefeated());
                        stagedDeps = existingDep.getRootDefeated();
                    }
                }
                existingDep.clearDefeated();
            }
            existingDep = next;
        }
        addUndefeated(newDep);
        reprocessDefeated(stagedDeps);
    }
    updateStatus();
}",java:S3776,39
"public void addUndefeated(M dep){
    boolean pos = !(dep.getValue() != null && MODE.NEGATIVE.getId().equals(dep.getValue()));
    switch(dep.getStatus()) {
        case DEFINITELY:
            if (pos) {
                definitelyPosCount++;
                statusMask = statusMask | DEFINITELY_POS_BIT;
            } else {
                definitelyNegCount++;
                statusMask = statusMask | DEFINITELY_NEG_BIT;
            }
            break;
        case DEFEASIBLY:
            if (pos) {
                defeasiblyPosCount++;
                statusMask = statusMask | DEFEASIBLY_POS_BIT;
            } else {
                defeasiblyNegCount++;
                statusMask = statusMask | DEFEASIBLY_NEG_BIT;
            }
            break;
        case DEFEATEDLY:
            if (pos) {
                defeatedlyPosCount++;
                statusMask = statusMask | DEFEATEDLY_POS_BIT;
            } else {
                defeatedlyNegCount++;
                statusMask = statusMask | DEFEATEDLY_NEG_BIT;
            }
            break;
        case UNDECIDABLY:
            throw new IllegalStateException(""Individual logical dependencies cannot be undecidably"");
    }
    if (rootUndefeated == null) {
        rootUndefeated = dep;
        tailUndefeated = dep;
    } else {
        if (dep.getStatus() == DefeasibilityStatus.DEFINITELY) {
            rootUndefeated.setPrevious(dep);
            dep.setNext(rootUndefeated);
            rootUndefeated = dep;
        } else {
            tailUndefeated.setNext(dep);
            dep.setPrevious(tailUndefeated);
            tailUndefeated = dep;
        }
    }
}",java:S3776,39
"public void removeUndefeated(DefeasibleMode dep){
    boolean pos = !(dep.getValue() != null && MODE.NEGATIVE.getId().equals(dep.getValue()));
    switch(dep.getStatus()) {
        case DEFINITELY:
            if (pos) {
                definitelyPosCount--;
                if (definitelyPosCount == 0) {
                    statusMask = statusMask ^ DEFINITELY_POS_BIT;
                }
            } else {
                definitelyNegCount--;
                if (definitelyNegCount == 0) {
                    statusMask = statusMask ^ DEFINITELY_NEG_BIT;
                }
            }
            break;
        case DEFEASIBLY:
            if (pos) {
                defeasiblyPosCount--;
                if (defeasiblyPosCount == 0) {
                    statusMask = statusMask ^ DEFEASIBLY_POS_BIT;
                }
            } else {
                defeasiblyNegCount--;
                if (defeasiblyNegCount == 0) {
                    statusMask = statusMask ^ DEFEASIBLY_NEG_BIT;
                }
            }
            break;
        case DEFEATEDLY:
            if (pos) {
                defeatedlyPosCount--;
                if (defeatedlyPosCount == 0) {
                    statusMask = statusMask ^ DEFEATEDLY_POS_BIT;
                }
            } else {
                defeatedlyNegCount--;
                if (defeatedlyNegCount == 0) {
                    statusMask = statusMask ^ DEFEATEDLY_NEG_BIT;
                }
            }
            break;
        case UNDECIDABLY:
            throw new IllegalStateException(""Individual logical dependencies cannot be undecidably"");
    }
    if (this.rootUndefeated == dep) {
        removeFirst();
    } else if (this.tailUndefeated == dep) {
        removeLast();
    } else {
        dep.getPrevious().setNext(dep.getNext());
        dep.getNext().setPrevious(dep.getPrevious());
        dep.nullPrevNext();
    }
}",java:S3776,39
"public void clear(PropagationContext propagationContext){
}",java:S1186,16
"public void setWorkingMemoryAction(WorkingMemoryAction wmAction){
}",java:S1186,16
"private DefeasibilityStatus checkDefeasible(List<? extends FactHandle> premise){
    return DefeasibilityStatus.DEFEASIBLY;
}",java:S1172,13
"private DefeasibilityStatus checkDefeater(List<? extends FactHandle> premise){
    return DefeasibilityStatus.DEFEATEDLY;
}",java:S1172,13
"public BeliefSet newBeliefSet(InternalFactHandle fh){
    return new DefeasibleBeliefSet(this, fh);
}",java:S1161,11
"public LogicalDependency<M> newLogicalDependency(TruthMaintenanceSystemInternalMatch<M> activation, BeliefSet<M> beliefSet, Object object, Object value){
    M mode = asMode(value);
    DefeasibleLogicalDependency<M> dep = new DefeasibleLogicalDependency(activation, beliefSet, object, mode);
    mode.setLogicalDependency(dep);
    mode.initDefeats();
    return dep;
}",java:S1161,11
"public M asMode(Object value){
    DefeasibleMode<M> mode;
    if (value == null) {
        mode = new DefeasibleMode(MODE.POSITIVE.getId(), this);
    } else if (value instanceof String) {
        if (MODE.POSITIVE.getId().equals(value)) {
            mode = new DefeasibleMode(MODE.POSITIVE.getId(), this);
        } else {
            mode = new DefeasibleMode(MODE.NEGATIVE.getId(), this);
        }
    } else if (value instanceof DefeasibleMode) {
        return (M) value;
    } else {
        mode = new DefeasibleMode(((MODE) value).getId(), this);
    }
    return (M) mode;
}",java:S1161,11
"private boolean processBeliefSet(RuleImpl rule, InternalMatch internalMatch, Object payload, PropagationContext pctx, JTMSBeliefSet<M> jtmsBeliefSet, boolean wasDecided, boolean wasNegated, InternalFactHandle fh){
    if (!wasDecided && jtmsBeliefSet.isDecided()) {
        ep.insert(jtmsBeliefSet.getFactHandle(), payload, rule, internalMatch != null ? internalMatch.getTuple().getTupleSink() : null, getObjectTypeConf(jtmsBeliefSet));
        return true;
    } else if (wasDecided && !jtmsBeliefSet.isDecided()) {
        if (STRICT) {
            throw new IllegalStateException(""FATAL : A fact and its negation have been asserted "" + jtmsBeliefSet.getFactHandle().getObject());
        }
        ep.delete(fh, fh.getObject(), getObjectTypeConf(jtmsBeliefSet), pctx.getRuleOrigin(), internalMatch != null ? internalMatch.getTuple().getTupleSink() : null);
        return true;
    } else if (wasNegated != jtmsBeliefSet.isNegated()) {
        final PropagationContext updatePctx = ep.getPctxFactory().createPropagationContext(ep.getReteEvaluator().getNextPropagationIdCounter(), PropagationContext.Type.MODIFICATION, pctx.getRuleOrigin(), pctx.getTerminalNodeOrigin(), fh, ep.getEntryPoint());
        ep.update(fh, fh.getObject(), fh.getObject(), getObjectTypeConf(jtmsBeliefSet), updatePctx);
    }
    return false;
}",java:S107,1
"private void updateManyTraits(Object object, BitMask mask, Collection<Thing> originators, Class<?> modifiedClass, Collection<Thing> traits, InternalMatch internalMatch){
    for (Thing t : traits) {
        if (!originators.contains(t)) {
            InternalFactHandle h = (InternalFactHandle) lookupFactHandle(t);
            if (h != null) {
                NamedEntryPoint nep = (NamedEntryPoint) h.getEntryPoint(workingMemory);
                PropagationContext propagationContext = nep.getPctxFactory().createPropagationContext(nep.getReteEvaluator().getNextPropagationIdCounter(), PropagationContext.Type.MODIFICATION, internalMatch != null ? internalMatch.getRule() : null, internalMatch != null ? internalMatch.getTuple().getTupleSink() : null, h, nep.getEntryPoint(), mask, modifiedClass, null);
                nep.update(h, t, t, nep.getObjectTypeConfigurationRegistry().getObjectTypeConf(t), propagationContext);
            }
        }
    }
}",java:S1172,13
"private void updateCore(TraitableBean inner, Object core, Class<T> trait, boolean logical, InternalMatch internalMatch){
    FactHandle handle = lookupFactHandle(inner);
    InternalFactHandle h = (InternalFactHandle) handle;
    if (handle != null) {
        TraitFieldTMS fieldTMS = inner._getFieldTMS();
        BitMask mask = fieldTMS == null ? onlyTraitBitSetMask() : fieldTMS.getModificationMask();
        Object o = h.getObject();
        NamedEntryPoint nep = (NamedEntryPoint) h.getEntryPoint(workingMemory);
        PropagationContext propagationContext = nep.getPctxFactory().createPropagationContext(nep.getReteEvaluator().getNextPropagationIdCounter(), PropagationContext.Type.MODIFICATION, internalMatch.getRule(), internalMatch.getTuple().getTupleSink(), h, nep.getEntryPoint(), mask, core.getClass(), null);
        nep.update(h, o, o, nep.getObjectTypeConfigurationRegistry().getObjectTypeConf(o), propagationContext);
    } else {
        handle = this.workingMemory.insert(inner, false, internalMatch.getRule(), internalMatch.getTuple().getTupleSink());
    }
}",java:S1172,13
"public Thing<K> shed(TraitableBean<K, X> core, Class<T> trait, InternalMatch internalMatch){
    if (trait.isAssignableFrom(core.getClass())) {
        Collection<Thing<K>> removedTypes = core.removeTrait(trait.getName());
        if (!removedTypes.isEmpty()) {
            reassignNodes(core, removedTypes);
            FactHandle factHandle = getFactHandle(core);
            update(factHandle, onlyTraitBitSetMask(), core.getClass(), internalMatch);
        }
        if (core instanceof Thing) {
            return (Thing<K>) core;
        } else {
            return null;
        }
    } else {
        Collection<Thing<K>> removedTypes;
        Thing<K> thing = core.getTrait(Thing.class.getName());
        if (trait == Thing.class) {
            removedTypes = new ArrayList<>(core._getTraitMap().values());
            for (Thing t : removedTypes) {
                if (!((TraitType) t)._isVirtual()) {
                    delete(getFactHandle(t), internalMatch);
                }
            }
            core._getTraitMap().clear();
            core._setTraitMap(null);
            return thing;
        } else if (core.hasTrait(trait.getName())) {
            removedTypes = core.removeTrait(trait.getName());
        } else {
            HierarchyEncoder hier = ((TraitRuntimeComponentFactory) RuntimeComponentFactory.get()).getTraitRegistry(this.workingMemory.getKnowledgeBase()).getHierarchy();
            BitSet code = hier.getCode(trait.getName());
            removedTypes = core.removeTrait(code);
        }
        removedTypes = new ArrayList<>(removedTypes);
        reassignNodes(core, removedTypes);
        for (Thing t : removedTypes) {
            if (!((TraitType) t)._isVirtual()) {
                InternalFactHandle handle = (InternalFactHandle) getFactHandle(t);
                if (handle.getEqualityKey() != null && handle.getEqualityKey().getLogicalFactHandle() == handle) {
                    TruthMaintenanceSystemFactory.get().getOrCreateTruthMaintenanceSystem(entryPoint).delete(handle);
                } else {
                    delete(getFactHandle(t), internalMatch);
                }
            }
        }
        if (!core.hasTraits()) {
            don(internalMatch, core, Thing.class, false);
        } else if (!removedTypes.isEmpty()) {
            update(getFactHandle(core), onlyTraitBitSetMask(), core.getClass(), internalMatch);
        }
        return thing;
    }
}",java:S3776,39
"private T asTrait(K core, TraitableBean inner, Class<T> trait, boolean needsProxy, boolean hasTrait, boolean needsUpdate, TraitFactoryImpl builder, boolean logical, InternalMatch internalMatch) throws LogicalTypeInconsistencyException{
    T thing;
    if (needsProxy) {
        thing = (T) inner;
        inner.addTrait(trait.getName(), (Thing<K>) core);
    } else if (hasTrait) {
        thing = (T) inner.getTrait(trait.getName());
    } else {
        thing = (T) builder.getProxy(inner, trait, logical);
    }
    if (needsUpdate) {
        InternalFactHandle h = (InternalFactHandle) lookupFactHandle(core);
        if (h == null) {
            h = lookupHandleForWrapper(core);
        }
        if (h == null) {
            h = (InternalFactHandle) this.workingMemory.insert(core, false, internalMatch.getRule(), internalMatch.getTuple().getTupleSink());
        }
        if (!h.isTraitOrTraitable()) {
            throw new IllegalStateException(""A traited working memory element is being used with a default fact handle. "" + ""Please verify that its class was declared as @Traitable : "" + core.getClass().getName());
        }
        this.update(h, inner, internalMatch);
    }
    return thing;
}",java:S107,1
"private TraitableBean makeTraitable(K core, TraitFactoryImpl builder, boolean logical, InternalMatch internalMatch){
    boolean needsWrapping = !(core instanceof TraitableBean);
    ClassDefinition coreDef = lookupClassDefinition(core);
    TraitableBean<K, ? extends TraitableBean> inner = needsWrapping ? builder.asTraitable(core, coreDef) : (TraitableBean<K, ? extends TraitableBean>) core;
    if (needsWrapping) {
        InternalFactHandle h = (InternalFactHandle) lookupFactHandle(core);
        WorkingMemoryEntryPoint ep = h != null ? h.getEntryPoint(workingMemory) : workingMemory.getEntryPoint(""DEFAULT"");
        ObjectTypeConfigurationRegistry reg = ep.getObjectTypeConfigurationRegistry();
        ObjectTypeConf coreConf = reg.getOrCreateObjectTypeConf(ep.getEntryPoint(), core);
        ObjectTypeConf innerConf = reg.getOrCreateObjectTypeConf(ep.getEntryPoint(), inner);
        if (coreConf.isTMSEnabled()) {
            innerConf.enableTMS();
        }
        if (inner._getFieldTMS() != null && inner._getFieldTMS().needsInit()) {
            inner._getFieldTMS().init(workingMemory);
        }
    } else {
        TraitFieldTMS ftms = inner._getFieldTMS();
        if (ftms != null) {
            FactHandle handle = lookupFactHandle(inner);
            if (handle == null) {
                handle = this.workingMemory.insert(inner, false, internalMatch.getRule(), internalMatch.getTuple().getTupleSink());
            }
            if (ftms.needsInit()) {
                ftms.init(workingMemory);
            }
        }
    }
    return inner;
}",java:S3776,39
"private TraitableBean makeTraitable(K core, TraitFactoryImpl builder, boolean logical, InternalMatch internalMatch){
    boolean needsWrapping = !(core instanceof TraitableBean);
    ClassDefinition coreDef = lookupClassDefinition(core);
    TraitableBean<K, ? extends TraitableBean> inner = needsWrapping ? builder.asTraitable(core, coreDef) : (TraitableBean<K, ? extends TraitableBean>) core;
    if (needsWrapping) {
        InternalFactHandle h = (InternalFactHandle) lookupFactHandle(core);
        WorkingMemoryEntryPoint ep = h != null ? h.getEntryPoint(workingMemory) : workingMemory.getEntryPoint(""DEFAULT"");
        ObjectTypeConfigurationRegistry reg = ep.getObjectTypeConfigurationRegistry();
        ObjectTypeConf coreConf = reg.getOrCreateObjectTypeConf(ep.getEntryPoint(), core);
        ObjectTypeConf innerConf = reg.getOrCreateObjectTypeConf(ep.getEntryPoint(), inner);
        if (coreConf.isTMSEnabled()) {
            innerConf.enableTMS();
        }
        if (inner._getFieldTMS() != null && inner._getFieldTMS().needsInit()) {
            inner._getFieldTMS().init(workingMemory);
        }
    } else {
        TraitFieldTMS ftms = inner._getFieldTMS();
        if (ftms != null) {
            FactHandle handle = lookupFactHandle(inner);
            if (handle == null) {
                handle = this.workingMemory.insert(inner, false, internalMatch.getRule(), internalMatch.getTuple().getTupleSink());
            }
            if (ftms.needsInit()) {
                ftms.init(workingMemory);
            }
        }
    }
    return inner;
}",java:S1172,13
"public Set<String> getOptionSubKeys(OptionKey<T> option){
    switch(option.name()) {
        case AccumulateFunctionOption.PROPERTY_NAME:
            {
                return this.accumulateFunctions.keySet();
            }
        case EvaluatorOption.PROPERTY_NAME:
            {
                return this.evaluatorRegistry.keySet();
            }
        default:
            return compConfig.getOptionSubKeys(option);
    }
}",java:S1161,11
"public void setParameterText(String parameterText){
}",java:S1186,16
"public boolean evaluate(ValueResolver valueResolver, ReadAccessor extractor, FactHandle handle, FieldValue value){
    final Object objectValue = extractor.getValue(valueResolver, handle.getObject());
    final Object literal = value.getValue();
    if (cachedValue != literal) {
        cachedValue = literal;
        cacheLiteral(literal, valueResolver);
    }
    TraitableBean core;
    if (objectValue == null) {
        return this.getOperator().isNegated();
    }
    if (objectValue instanceof Thing) {
        Thing thing = (Thing) objectValue;
        core = (TraitableBean) thing.getCore();
        BitSet code = core.getCurrentTypeCode();
        if (code != null) {
            return this.getOperator().isNegated() ^ isA(code, cachedLiteral);
        } else {
            boolean hasTrait = this.getOperator().isNegated() ^ hasTrait(core, literal);
            return hasTrait || literal instanceof Class<?> && this.getOperator().isNegated() ^ ((Class<?>) literal).isInstance(objectValue);
        }
    } else if (objectValue instanceof TraitableBean) {
        core = (TraitableBean) objectValue;
        BitSet code = core.getCurrentTypeCode();
        if (code != null) {
            return this.getOperator().isNegated() ^ isA(code, cachedLiteral);
        } else {
            return this.getOperator().isNegated() ^ hasTrait(core, literal);
        }
    } else {
        core = lookForWrapper(objectValue, valueResolver);
        if (core == null) {
            if (literal instanceof Class<?>) {
                return this.getOperator().isNegated() ^ ((Class<?>) literal).isInstance(objectValue);
            } else {
                return this.getOperator().isNegated();
            }
        }
        BitSet code = core.getCurrentTypeCode();
        if (code != null) {
            return this.getOperator().isNegated() ^ isA(code, cachedLiteral);
        } else {
            return this.getOperator().isNegated() ^ hasTrait(core, literal);
        }
    }
}",java:S3776,39
"private boolean compare(Object source, Object target, ValueResolver valueResolver){
    BitSet sourceTraits = null;
    BitSet targetTraits = null;
    if (source instanceof Class) {
        CodedHierarchy x = ((TraitRuntimeComponentFactory) RuntimeComponentFactory.get()).getTraitRegistry(valueResolver.getRuleBase()).getHierarchy();
        sourceTraits = x.getCode(((Class) source).getName());
    } else if (source instanceof Thing) {
        sourceTraits = ((TraitableBean) ((Thing) source).getCore()).getCurrentTypeCode();
        if (sourceTraits == null && source instanceof TraitType) {
            CodedHierarchy x = ((TraitRuntimeComponentFactory) RuntimeComponentFactory.get()).getTraitRegistry(valueResolver.getRuleBase()).getHierarchy();
            sourceTraits = x.getCode(((TraitType) source)._getTraitName());
        }
    } else if (source instanceof TraitableBean) {
        sourceTraits = ((TraitableBean) source).getCurrentTypeCode();
    } else if (source instanceof String) {
        CodedHierarchy x = ((TraitRuntimeComponentFactory) RuntimeComponentFactory.get()).getTraitRegistry(valueResolver.getRuleBase()).getHierarchy();
        sourceTraits = x.getCode(source);
    } else {
        TraitableBean tbean = lookForWrapper(source, valueResolver);
        if (tbean != null) {
            sourceTraits = tbean.getCurrentTypeCode();
        }
    }
    if (target instanceof Class) {
        CodedHierarchy x = ((TraitRuntimeComponentFactory) RuntimeComponentFactory.get()).getTraitRegistry(valueResolver.getRuleBase()).getHierarchy();
        targetTraits = x.getCode(((Class) target).getName());
    } else if (target instanceof String) {
        CodedHierarchy x = ((TraitRuntimeComponentFactory) RuntimeComponentFactory.get()).getTraitRegistry(valueResolver.getRuleBase()).getHierarchy();
        targetTraits = x.getCode(target);
    } else if (target instanceof Thing) {
        targetTraits = ((TraitableBean) ((Thing) target).getCore()).getCurrentTypeCode();
        if (targetTraits == null && target instanceof TraitType) {
            CodedHierarchy x = ((TraitRuntimeComponentFactory) RuntimeComponentFactory.get()).getTraitRegistry(valueResolver.getRuleBase()).getHierarchy();
            targetTraits = x.getCode(((TraitType) target)._getTraitName());
        }
    } else if (target instanceof TraitableBean) {
        targetTraits = ((TraitableBean) target).getCurrentTypeCode();
    } else if (target instanceof Collection) {
        CodedHierarchy x = ((TraitRuntimeComponentFactory) RuntimeComponentFactory.get()).getTraitRegistry(valueResolver.getRuleBase()).getHierarchy();
        targetTraits = getCode(target, x);
    } else {
        TraitableBean tbean = lookForWrapper(target, valueResolver);
        if (tbean != null) {
            targetTraits = tbean.getCurrentTypeCode();
        }
    }
    if (sourceTraits == null || targetTraits == null) {
        return getOperator().isNegated();
    }
    return isA(sourceTraits, targetTraits) ^ getOperator().isNegated();
}",java:S3776,39
"public Collection<? extends KnowledgeBuilderResult> getResults(){
    return buildResultCollector.getAllResults();
}",java:S1452,23
"protected void buildHardSetter(ClassVisitor cw, FieldDefinition field, String proxyName, ClassDefinition trait, ClassDefinition core, String setterName, int accessMode){
    MethodVisitor mv = cw.visitMethod(accessMode, setterName, ""("" + Type.getDescriptor(field.getType()) + "")V"", null, null);
    mv.visitCode();
    if (core.isFullTraiting()) {
        helpSet(core, field, mv, proxyName);
    }
    TraitFactoryImpl.invokeInjector(mv, proxyName, core, field, false, 1);
    mv.visitInsn(RETURN);
    mv.visitMaxs(0, 0);
    mv.visitEnd();
}",java:S1172,13
"private void buildResource(Map<String, CompositePackageDescr> packages, ResourceType resourceType, ResourceHandler mapper, Map<ResourceType, List<CompositeKnowledgeBuilderImpl.ResourceDescr>> resourcesByType){
    List<CompositeKnowledgeBuilderImpl.ResourceDescr> resourceDescrs = resourcesByType.remove(resourceType);
    if (resourceDescrs != null) {
        for (CompositeKnowledgeBuilderImpl.ResourceDescr resourceDescr : resourceDescrs) {
            try {
                PackageDescr packageDescr = mapper.process(resourceDescr.resource, resourceDescr.configuration);
                mapper.getResults().forEach(buildResultCollector::addBuilderResult);
                registerPackageDescr(resourceDescr, packages, resourceDescr.resource, packageDescr);
            } catch (RuntimeException e) {
                if (buildException == null) {
                    buildException = e;
                }
            } catch (Exception e) {
                if (buildException == null) {
                    buildException = new RuntimeException(e);
                }
            }
        }
    }
}",java:S3776,39
"public void helpSet(ClassDefinition core, FieldDefinition field, MethodVisitor mv, String proxyName){
    FieldDefinition hardField = core.getFieldByAlias(field.resolveAlias());
    boolean isHardField = field.getTypeName().equals(hardField.getTypeName());
    if (!field.getType().isPrimitive() && !isHardField) {
        boolean isCoreTrait = hardField.getType().getAnnotation(Trait.class) != null;
        boolean isTraitTrait = field.getType().getAnnotation(Trait.class) != null;
        Label l0 = new Label();
        mv.visitVarInsn(ALOAD, 1);
        mv.visitJumpInsn(IFNULL, l0);
        if (isCoreTrait && !isTraitTrait) {
            mv.visitVarInsn(ALOAD, 1);
            mv.visitTypeInsn(CHECKCAST, Type.getInternalName(TraitableBean.class));
            mv.visitLdcInsn(hardField.getTypeName());
            mv.visitMethodInsn(INVOKEINTERFACE, Type.getInternalName(TraitableBean.class), ""getTrait"", Type.getMethodDescriptor(Type.getType(Thing.class), Type.getType(String.class)), true);
            mv.visitVarInsn(ASTORE, 1);
        } else if (!isCoreTrait && isTraitTrait) {
            mv.visitVarInsn(ALOAD, 1);
            mv.visitTypeInsn(CHECKCAST, Type.getInternalName(TraitProxyImpl.class));
            mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(TraitProxyImpl.class), ""getObject"", Type.getMethodDescriptor(Type.getType(TraitableBean.class)), false);
            mv.visitVarInsn(ASTORE, 1);
        } else if (isCoreTrait) {
            mv.visitVarInsn(ALOAD, 1);
            mv.visitTypeInsn(CHECKCAST, Type.getInternalName(TraitProxyImpl.class));
            mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(TraitProxyImpl.class), ""getObject"", Type.getMethodDescriptor(Type.getType(TraitableBean.class)), false);
            mv.visitTypeInsn(CHECKCAST, Type.getInternalName(TraitableBean.class));
            mv.visitLdcInsn(hardField.getTypeName());
            mv.visitMethodInsn(INVOKEINTERFACE, Type.getInternalName(TraitableBean.class), ""getTrait"", Type.getMethodDescriptor(Type.getType(Thing.class), Type.getType(String.class)), true);
            mv.visitVarInsn(ASTORE, 1);
        } else {
            if (!hardField.getType().isAssignableFrom(field.getType())) {
                mv.visitInsn(RETURN);
            }
        }
        Label l1 = new Label();
        mv.visitJumpInsn(GOTO, l1);
        mv.visitLabel(l0);
        mv.visitInsn(ACONST_NULL);
        mv.visitVarInsn(ASTORE, 1);
        mv.visitLabel(l1);
    } else if (field.getType().isPrimitive()) {
        if (!hardField.getType().equals(field.getType())) {
            mv.visitInsn(RETURN);
        }
    }
    if (isHardField && CoreWrapper.class.isAssignableFrom(core.getDefinedClass())) {
        logicalSetter(mv, field, proxyName, core);
    }
}",java:S3776,39
"protected Class<T> buildProxyClass(K core, Class<?> trait){
    Class coreKlass = core.getClass();
    ClassDefinition tdef = getTraitRegistry().getTrait(trait.getName());
    ClassDefinition cdef = getTraitRegistry().getTraitable(coreKlass.getName());
    if (tdef == null) {
        if (trait.getAnnotation(Trait.class) != null) {
            try {
                if (Thing.class.isAssignableFrom(trait)) {
                    tdef = buildClassDefinition(trait, null);
                } else {
                    throw new RuntimeException(""Unable to create definition for class "" + trait + "" : trait interfaces should extend "" + Thing.class.getName() + "" or be DECLARED as traits explicitly"");
                }
            } catch (IOException e) {
                throw new UncheckedIOException(""Unable to create definition for class "" + trait + "" : "" + e.getMessage(), e);
            }
            getTraitRegistry().addTrait(tdef);
        } else {
            throw new RuntimeException(""Unable to find Trait definition for class "" + trait.getName() + "". It should have been DECLARED as a trait"");
        }
    }
    if (cdef == null) {
        if (core.getClass().getAnnotation(Traitable.class) != null) {
            try {
                cdef = buildClassDefinition(core.getClass(), core.getClass());
            } catch (IOException e) {
                throw new UncheckedIOException(""Unable to create definition for class "" + coreKlass.getName() + "" : "" + e.getMessage(), e);
            }
            getTraitRegistry().addTraitable(cdef);
        } else {
            throw new RuntimeException(""Unable to find Core class definition for class "" + coreKlass.getName() + "". It should have been DECLARED as a trait"");
        }
    }
    String proxyName = getProxyName(tdef, cdef);
    String wrapperName = getPropertyWrapperName(tdef, cdef);
    TraitPropertyWrapperClassBuilder propWrapperBuilder = (TraitPropertyWrapperClassBuilder) traitClassBuilderFactory.getPropertyWrapperBuilder();
    propWrapperBuilder.init(tdef, getTraitRegistry());
    try {
        byte[] propWrapper = propWrapperBuilder.buildClass(cdef, getRootClassLoader());
        registerAndLoadTypeDefinition(wrapperName, propWrapper);
    } catch (Exception e) {
        LOG.error(""Exception"", e);
    }
    TraitProxyClassBuilder proxyBuilder = traitClassBuilderFactory.getTraitProxyBuilder();
    proxyBuilder.init(tdef, TraitProxyImpl.class, getTraitRegistry());
    try {
        byte[] proxy = proxyBuilder.buildClass(cdef, getRootClassLoader());
        registerAndLoadTypeDefinition(proxyName, proxy);
    } catch (Exception e) {
        LOG.error(""Exception"", e);
    }
    try {
        getTraitRegistry().getFieldMask(trait.getName(), cdef.getDefinedClass().getName());
        getRootClassLoader().loadClass(wrapperName);
        return (Class<T>) getRootClassLoader().loadClass(proxyName);
    } catch (ClassNotFoundException e) {
        LOG.error(""Exception"", e);
        return null;
    }
}",java:S3776,39
"public TraitableBean<K, CoreWrapper<K>> asTraitable(K core, ClassDefinition coreDef){
    if (coreDef == null || coreDef.getDefinedClass() != core.getClass()) {
        try {
            coreDef = buildClassDefinition(core.getClass(), core.getClass());
        } catch (IOException e) {
            LOG.error(""Exception"", e);
        }
    }
    if (coreDef == null) {
        throw new IllegalArgumentException(""Class definition is not specified!"");
    } else {
        if (core instanceof Map) {
            if (!coreDef.isTraitable()) {
                throw new UnsupportedOperationException(""Error: cannot apply a trait to non-traitable class "" + core.getClass() + "". Was it declared as @Traitable? "");
            }
            return coreDef.isFullTraiting() ? new LogicalMapCore((Map) core) : new MapCore((Map) core);
        }
        CoreWrapper<K> wrapper = (CoreWrapper<K>) getCoreWrapper(core.getClass(), coreDef);
        if (wrapper == null) {
            throw new UnsupportedOperationException(""Error: cannot apply a trait to non-traitable class "" + core.getClass() + "". Was it declared as @Traitable? "");
        }
        wrapper.init(core);
        return wrapper;
    }
}",java:S3776,39
"public ClassDefinition buildClassDefinition(Class<?> klazz, Class<?> wrapperClass) throws IOException{
    ClassFieldInspectorImpl inspector = new ClassFieldInspectorImpl(klazz);
    ClassFieldAccessorStore store = getClassFieldAccessorStore();
    ClassDefinition def;
    if (!klazz.isInterface()) {
        String className = wrapperClass.getName();
        String superClass = wrapperClass != klazz ? klazz.getName() : klazz.getSuperclass().getName();
        String[] interfaces = new String[klazz.getInterfaces().length + 1];
        for (int j = 0; j < klazz.getInterfaces().length; j++) {
            interfaces[j] = klazz.getInterfaces()[j].getName();
        }
        interfaces[interfaces.length - 1] = CoreWrapper.class.getName();
        def = new ClassDefinition(className, superClass, interfaces);
        def.setDefinedClass(wrapperClass);
        Traitable tbl = wrapperClass.getAnnotation(Traitable.class);
        def.setTraitable(true, tbl != null && tbl.logical());
        Map<String, Field> fields = inspector.getFieldTypesField();
        for (Field f : fields.values()) {
            if (f != null) {
                FieldDefinition fld = new FieldDefinition();
                fld.setName(f.getName());
                fld.setTypeName(f.getType().getName());
                fld.setInherited(true);
                ClassFieldAccessor accessor = store.getAccessor(def.getDefinedClass().getName(), fld.getName());
                fld.setReadWriteAccessor(accessor);
                if (inspector.getGetterMethods().containsKey(f.getName())) {
                    fld.setGetterName(inspector.getGetterMethods().get(f.getName()).getName());
                }
                if (inspector.getSetterMethods().containsKey(f.getName())) {
                    fld.setSetterName(inspector.getSetterMethods().get(f.getName()).getName());
                }
                def.addField(fld);
            }
        }
    } else {
        String className = klazz.getName();
        String superClass = Object.class.getName();
        String[] interfaces = new String[klazz.getInterfaces().length];
        for (int j = 0; j < klazz.getInterfaces().length; j++) {
            interfaces[j] = klazz.getInterfaces()[j].getName();
        }
        def = new ClassDefinition(className, superClass, interfaces);
        def.setDefinedClass(klazz);
        Map<String, Method> properties = inspector.getGetterMethods();
        for (Map.Entry<String, Method> propEntry : properties.entrySet()) {
            Method m = propEntry.getValue();
            if (m != null && m.getDeclaringClass() != TraitType.class && m.getDeclaringClass() != Thing.class && inspector.getSetterMethods().containsKey(propEntry.getKey())) {
                FieldDefinition fld = new FieldDefinition();
                fld.setName(getterToFieldName(m.getName()));
                fld.setTypeName(m.getReturnType().getName());
                fld.setInherited(true);
                ClassFieldAccessor accessor = store.getAccessor(def.getDefinedClass().getName(), fld.getName());
                fld.setReadWriteAccessor(accessor);
                fld.setGetterName(m.getName());
                fld.setSetterName(inspector.getSetterMethods().get(propEntry.getKey()).getName());
                def.addField(fld);
            }
        }
    }
    return def;
}",java:S3776,39
"public static boolean equals(Object object1, Object object2){
    if (object1 == null || object2 == null) {
        return object1 == object2;
    }
    Triple t1 = (Triple) object1;
    Triple t2 = (Triple) object2;
    if (t1.getInstance() != Variable.v) {
        if (t1.getInstance() == null) {
            return false;
        } else if (t1.getInstance() instanceof String) {
            if (!t1.getInstance().equals(t2.getInstance())) {
                return false;
            }
        } else if (t1.getInstance() != t2.getInstance()) {
            return false;
        }
    }
    if (t1.getProperty() != Variable.v && !t1.getProperty().equals(t2.getProperty())) {
        return false;
    }
    if (t1.getValue() != Variable.v) {
        if (t1.getValue() == null) {
            return t2.getValue() == null;
        } else {
            return t1.getValue().equals(t2.getValue());
        }
    }
    if (t1.getClass() == TripleStore.TripleCollector.class) {
        ((TripleStore.TripleCollector) t1).list.add(t2);
        return false;
    }
    return true;
}",java:S3776,39
"protected void normalizeForeignPackages(PackageDescr packageDescr){
    Map<String, PackageDescr> foreignPackages = null;
    for (AbstractClassTypeDeclarationDescr typeDescr : packageDescr.getClassAndEnumDeclarationDescrs()) {
        if (context.filterAccepts(ResourceChange.Type.DECLARATION, typeDescr.getNamespace(), typeDescr.getTypeName())) {
            if (!typeDescr.getNamespace().equals(packageDescr.getNamespace())) {
                PackageDescr altDescr;
                if (foreignPackages == null) {
                    foreignPackages = new HashMap<>();
                }
                if (foreignPackages.containsKey(typeDescr.getNamespace())) {
                    altDescr = foreignPackages.get(typeDescr.getNamespace());
                } else {
                    altDescr = new PackageDescr(typeDescr.getNamespace());
                    altDescr.setResource(packageDescr.getResource());
                    foreignPackages.put(typeDescr.getNamespace(), altDescr);
                }
                if (typeDescr instanceof TypeDeclarationDescr) {
                    altDescr.addTypeDeclaration((TypeDeclarationDescr) typeDescr);
                } else if (typeDescr instanceof EnumDeclarationDescr) {
                    altDescr.addEnumDeclaration((EnumDeclarationDescr) typeDescr);
                }
                for (ImportDescr imp : packageDescr.getImports()) {
                    altDescr.addImport(imp);
                }
                context.getOrCreatePackageRegistry(altDescr);
            }
        }
    }
}",java:S3776,39
"public void _setFieldTMS(TraitFieldTMS __$$field_Tms$$){
    this.__$$field_Tms$$ = __$$field_Tms$$;
}",java:S117,12
"public Fact[] loadMetaModel(JarInputStream jis) throws Exception{
    JarEntry entry;
    while ((entry = jis.getNextJarEntry()) != null) {
        if (entry.getName().equals(""factmodel.xml"")) {
            return fromXML(jis);
        }
    }
    throw new IllegalArgumentException(""This is not a valid drools model jar - no factmodel.xml found."");
}",java:S112,4
"private void processFieldsPosition(Class<?> cls, ClassDefinition clsDef, TypeDeclaration typeDeclaration){
    Collection<Field> fields = new ArrayList<>();
    Class<?> tempKlass = cls;
    while (tempKlass != null && tempKlass != Object.class) {
        Collections.addAll(fields, tempKlass.getDeclaredFields());
        tempKlass = tempKlass.getSuperclass();
    }
    FieldDefinition[] orderedFields = new FieldDefinition[fields.size()];
    for (Field fld : fields) {
        Position pos = fld.getAnnotation(Position.class);
        if (pos != null) {
            if (pos.value() < 0 || pos.value() >= fields.size()) {
                results.addBuilderResult(new TypeDeclarationError(typeDeclaration, ""Out of range position "" + pos.value() + "" for field '"" + fld.getName() + ""' on class "" + cls.getName()));
                continue;
            }
            if (orderedFields[pos.value()] != null) {
                results.addBuilderResult(new TypeDeclarationError(typeDeclaration, ""Duplicated position "" + pos.value() + "" for field '"" + fld.getName() + ""' on class "" + cls.getName()));
                continue;
            }
            FieldDefinition fldDef = clsDef.getField(fld.getName());
            if (fldDef == null) {
                fldDef = new FieldDefinition(fld.getName(), fld.getType().getName());
            }
            fldDef.setIndex(pos.value());
            orderedFields[pos.value()] = fldDef;
        }
    }
    for (FieldDefinition fld : orderedFields) {
        if (fld != null) {
            clsDef.addField(fld);
        }
    }
}",java:S3776,39
"public TraitFieldTMS _getFieldTMS(){
    TraitFieldTMS tms = (TraitFieldTMS) _getDynamicProperties().get(FIELDTMS_FIELD_NAME);
    if (tms == null) {
        tms = new TraitFieldTMSImpl();
        _getDynamicProperties().put(FIELDTMS_FIELD_NAME, tms);
    }
    return tms;
}",java:S1161,11
"public void _setFieldTMS(TraitFieldTMS __$$field_Tms$$){
    _getDynamicProperties().put(FIELDTMS_FIELD_NAME, __$$field_Tms$$);
}",java:S1161,11
"public void _setFieldTMS(TraitFieldTMS __$$field_Tms$$){
    _getDynamicProperties().put(FIELDTMS_FIELD_NAME, __$$field_Tms$$);
}",java:S117,12
"public Map<String, Object> _getDynamicProperties(){
    return __$$dynamic_properties_map$$;
}",java:S1161,11
"public void _setDynamicProperties(Map map){
}",java:S1161,11
"public void _setTraitMap(Map map){
    _getDynamicProperties().put(TRAITSET_FIELD_NAME, map);
}",java:S1161,11
"public Map<String, Thing<Map>> _getTraitMap(){
    return (Map<String, Thing<Map>>) _getDynamicProperties().get(TRAITSET_FIELD_NAME);
}",java:S1161,11
"public void init(Map core){
}",java:S1161,11
"public Map getCore(){
    return __$$dynamic_properties_map$$;
}",java:S1161,11
"public void _setTypeCode(BitSet typeCode){
    this.typeCode = typeCode;
}",java:S100,0
"protected void init(ClassDefinition classDef){
}",java:S1186,16
"protected void buildSetter(ClassWriter cw, FieldDefinition field, String name, String type, String generic){
    MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, BuildUtils.setterName(name), ""("" + BuildUtils.getTypeDescriptor(type) + "")V"", generic == null ? null : ""("" + BuildUtils.getTypeDescriptor(type).replace("";"", ""<"" + BuildUtils.getTypeDescriptor(generic) + "">;"") + "")V"", null);
    mv.visitEnd();
}",java:S1172,13
"protected void buildGetter(ClassWriter cw, FieldDefinition field, String name, String type, String generic){
    name = name.substring(0, 1).toUpperCase() + name.substring(1);
    MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, BuildUtils.getterName(name, type), ""()"" + BuildUtils.getTypeDescriptor(type), generic == null ? null : ""()"" + BuildUtils.getTypeDescriptor(type).replace("";"", ""<"" + BuildUtils.getTypeDescriptor(generic) + "">;""), null);
    mv.visitEnd();
}",java:S1172,13
"protected void finalizeCreation(ClassDefinition trait){
}",java:S1186,16
"public void finalizeConfigurator(TypeDeclaration type, AbstractClassTypeDeclarationDescr typeDescr, PackageRegistry pkgRegistry, Map<String, PackageRegistry> pkgRegistryMap, ClassHierarchyManager hierarchyManager){
    if (type.getNature() == TypeDeclaration.Nature.DEFINITION) {
        hierarchyManager.addDeclarationToPackagePreservingOrder(type, typeDescr, pkgRegistry.getPackage(), pkgRegistryMap);
    } else {
        TypeDeclaration oldType = pkgRegistry.getPackage().getTypeDeclaration(type.getTypeName());
        if (oldType == null) {
            pkgRegistry.getPackage().addTypeDeclaration(type);
        } else {
            if (type.getRole() == Role.Type.EVENT) {
                oldType.setRole(Role.Type.EVENT);
                if (type.getDurationAttribute() != null) {
                    oldType.setDurationAttribute(type.getDurationAttribute());
                    oldType.setDurationExtractor(type.getDurationExtractor());
                }
                if (type.getTimestampAttribute() != null) {
                    oldType.setTimestampAttribute(type.getTimestampAttribute());
                    oldType.setTimestampExtractor(type.getTimestampExtractor());
                }
                if (type.getExpirationOffset() >= 0) {
                    oldType.setExpirationOffset(type.getExpirationOffset());
                    oldType.setExpirationType(type.getExpirationPolicy());
                }
            }
            if (type.isPropertyReactive()) {
                oldType.setPropertyReactive(true);
            }
        }
    }
}",java:S3776,39
"protected void checkRedeclaration(AbstractClassTypeDeclarationDescr typeDescr, TypeDeclaration type, PackageRegistry pkgRegistry){
    TypeDeclaration previousTypeDeclaration = context.getPackageRegistry(typeDescr.getNamespace()).getPackage().getTypeDeclaration(typeDescr.getTypeName());
    try {
        if (!type.isDefinition()) {
            Class<?> existingDeclarationClass = TypeDeclarationUtils.getExistingDeclarationClass(typeDescr, pkgRegistry);
            if (!context.getBuilderConfiguration().isPreCompiled() && !GeneratedFact.class.isAssignableFrom(existingDeclarationClass) && !type.getTypeClassDef().getFields().isEmpty()) {
                try {
                    Class existingClass = pkgRegistry.getPackage().getTypeResolver().resolveType(typeDescr.getType().getFullName());
                    ClassFieldInspector cfi = CoreComponentsBuilder.get().createClassFieldInspector(existingClass);
                    int fieldCount = 0;
                    for (String existingFieldName : cfi.getFieldTypesField().keySet()) {
                        if (!cfi.isNonGetter(existingFieldName) && !""class"".equals(existingFieldName) && cfi.getSetterMethods().containsKey(existingFieldName) && cfi.getGetterMethods().containsKey(existingFieldName)) {
                            if (!typeDescr.getFields().containsKey(existingFieldName)) {
                                type.setValid(false);
                                results.addBuilderResult(new TypeDeclarationError(typeDescr, ""New declaration of "" + typeDescr.getType().getFullName() + "" does not include field "" + existingFieldName));
                            } else {
                                String fldType = cfi.getFieldType(existingFieldName).getName();
                                fldType = TypeDeclarationUtils.toBuildableType(fldType, context.getRootClassLoader());
                                TypeFieldDescr declaredField = typeDescr.getFields().get(existingFieldName);
                                if (!fldType.equals(type.getTypeClassDef().getField(existingFieldName).getTypeName())) {
                                    type.setValid(false);
                                    results.addBuilderResult(new TypeDeclarationError(typeDescr, ""New declaration of "" + typeDescr.getType().getFullName() + "" redeclared field "" + existingFieldName + "" : \n"" + ""existing : "" + fldType + "" vs declared : "" + declaredField.getPattern().getObjectType()));
                                } else {
                                    fieldCount++;
                                }
                            }
                        }
                    }
                    if (fieldCount != typeDescr.getFields().size()) {
                        results.addBuilderResult(reportDeclarationDiff(cfi, typeDescr));
                    }
                } catch (IOException e) {
                    LOG.error(""Exception"", e);
                    type.setValid(false);
                    results.addBuilderResult(new TypeDeclarationError(typeDescr, ""Unable to redeclare "" + typeDescr.getType().getFullName() + "" : "" + e.getMessage()));
                } catch (ClassNotFoundException e) {
                    type.setValid(false);
                    results.addBuilderResult(new TypeDeclarationError(typeDescr, ""Unable to redeclare "" + typeDescr.getType().getFullName() + "" : "" + e.getMessage()));
                }
            }
        } else if (previousTypeDeclaration != null) {
            int typeComparisonResult = this.compareTypeDeclarations(previousTypeDeclaration, type);
            if (typeComparisonResult < 0) {
                results.addBuilderResult(new TypeDeclarationError(typeDescr, typeDescr.getType().getFullName() + "" declares more fields than the already existing version""));
                type.setValid(false);
            } else if (typeComparisonResult > 0 && !type.getTypeClassDef().getFields().isEmpty()) {
                results.addBuilderResult(new TypeDeclarationError(typeDescr, typeDescr.getType().getFullName() + "" declares less fields than the already existing version""));
                type.setValid(false);
            }
            if (type.getNature() == TypeDeclaration.Nature.DECLARATION) {
                mergeTypeDeclarations(previousTypeDeclaration, type);
            }
        }
    } catch (IncompatibleClassChangeError error) {
        results.addBuilderResult(new TypeDeclarationError(typeDescr, error.getMessage()));
    }
}",java:S3776,39
"protected int compareTypeDeclarations(TypeDeclaration oldDeclaration, TypeDeclaration newDeclaration) throws IncompatibleClassChangeError{
    if (!oldDeclaration.getFormat().equals(newDeclaration.getFormat())) {
        throw new IncompatibleClassChangeError(""Type Declaration "" + newDeclaration.getTypeName() + "" has a different"" + "" format that its previous definition: "" + newDeclaration.getFormat() + ""!="" + oldDeclaration.getFormat());
    }
    if (!oldDeclaration.getTypeClassDef().getSuperClass().equals(newDeclaration.getTypeClassDef().getSuperClass())) {
        if (oldDeclaration.getNature() != TypeDeclaration.Nature.DEFINITION || newDeclaration.getNature() != TypeDeclaration.Nature.DECLARATION || !Object.class.getName().equals(newDeclaration.getTypeClassDef().getSuperClass())) {
            throw new IncompatibleClassChangeError(""Type Declaration "" + newDeclaration.getTypeName() + "" has a different"" + "" superclass that its previous definition: "" + newDeclaration.getTypeClassDef().getSuperClass() + "" != "" + oldDeclaration.getTypeClassDef().getSuperClass());
        }
    }
    if (!nullSafeEqualityComparison(oldDeclaration.getDurationAttribute(), newDeclaration.getDurationAttribute())) {
        throw new IncompatibleClassChangeError(""Type Declaration "" + newDeclaration.getTypeName() + "" has a different"" + "" duration: "" + newDeclaration.getDurationAttribute() + "" != "" + oldDeclaration.getDurationAttribute());
    }
    if (newDeclaration.getNature().equals(TypeDeclaration.Nature.DEFINITION)) {
        if (oldDeclaration.getSetMask() != newDeclaration.getSetMask()) {
            throw new IncompatibleClassChangeError(""Type Declaration "" + newDeclaration.getTypeName() + "" is incompatible with"" + "" the previous definition: "" + newDeclaration + "" != "" + oldDeclaration);
        }
    }
    List<FactField> oldFields = oldDeclaration.getTypeClassDef().getFields();
    Map<String, FactField> newFieldsMap = new HashMap<>();
    for (FactField factField : newDeclaration.getTypeClassDef().getFields()) {
        newFieldsMap.put(factField.getName(), factField);
    }
    boolean allFieldsInOldDeclarationAreStillPresent = true;
    for (FactField oldFactField : oldFields) {
        FactField newFactField = newFieldsMap.get(oldFactField.getName());
        if (newFactField != null) {
            String newFactType = ((FieldDefinition) newFactField).getTypeName();
            if (!newFactType.equals(((FieldDefinition) oldFactField).getTypeName())) {
                throw new IncompatibleClassChangeError(""Type Declaration "" + newDeclaration.getTypeName() + ""."" + newFactField.getName() + "" has a different"" + "" type that its previous definition: "" + newFactType + "" != "" + oldFactField.getType().getCanonicalName());
            }
        } else {
            allFieldsInOldDeclarationAreStillPresent = false;
        }
    }
    if (oldFields.size() < newFieldsMap.size()) {
        return -1;
    }
    if (oldFields.size() > newFieldsMap.size()) {
        return 1;
    }
    if (allFieldsInOldDeclarationAreStillPresent) {
        return 0;
    }
    throw new IncompatibleClassChangeError(newDeclaration.getTypeName() + "" introduces"" + "" fields that are not present in its previous version."");
}",java:S3776,39
"public static String lookupSimpleNameByImports(String name, AbstractClassTypeDeclarationDescr typeDescr, PackageDescr packageDescr, ClassLoader loader){
    Class<?> typeClass = null;
    if (isQualified(name)) {
        typeClass = getClassForType(name, loader);
    }
    if (typeClass == null) {
        for (ImportDescr id : packageDescr.getImports()) {
            String imp = id.getTarget();
            int separator = imp.lastIndexOf('.');
            String tail = imp.substring(separator + 1);
            if (tail.equals(name)) {
                typeClass = getClassForType(imp, loader);
                if (typeClass != null) {
                    return typeClass.getCanonicalName();
                } else {
                    return imp;
                }
            } else if (tail.equals(""*"")) {
                typeClass = getClassForType(imp.substring(0, imp.length() - 1) + name, loader);
                if (typeClass != null) {
                    String resolvedNamespace = imp.substring(0, separator);
                    if (resolvedNamespace.equals(typeDescr.getNamespace())) {
                        break;
                    } else if (name.equals(typeDescr.getType().getName()) && !isCompatible(typeClass, typeDescr)) {
                        typeClass = null;
                    } else {
                        break;
                    }
                }
            }
        }
    }
    return typeClass != null ? typeClass.getName() : name;
}",java:S3776,39
"public static String resolveType(String klass, PackageDescr packageDescr, PackageRegistry pkgRegistry){
    String arraySuffix = """";
    int arrayIndex = klass.indexOf(""["");
    if (arrayIndex >= 0) {
        arraySuffix = klass.substring(arrayIndex);
        klass = klass.substring(0, arrayIndex);
    }
    String temp = klass;
    while (temp.length() > 0) {
        for (ImportDescr id : packageDescr.getImports()) {
            String fqKlass = id.getTarget();
            if (fqKlass.endsWith(""."" + temp)) {
                fqKlass = fqKlass.substring(0, fqKlass.lastIndexOf(temp)) + klass;
                return arrayIndex < 0 ? fqKlass : fqKlass + arraySuffix;
            }
        }
        temp = temp.substring(0, Math.max(0, temp.lastIndexOf('.')));
    }
    if (pkgRegistry != null) {
        for (String declaredName : pkgRegistry.getPackage().getTypeDeclarations().keySet()) {
            if (declaredName.equals(klass)) {
                TypeDeclaration typeDeclaration = pkgRegistry.getPackage().getTypeDeclaration(declaredName);
                if (typeDeclaration.getTypeClass() != null) {
                    klass = typeDeclaration.getTypeClass().getName();
                }
            }
        }
    }
    if (!klass.contains(""."") && packageDescr.getNamespace() != null && !packageDescr.getNamespace().isEmpty()) {
        for (AbstractClassTypeDeclarationDescr td : packageDescr.getClassAndEnumDeclarationDescrs()) {
            if (klass.equals(td.getTypeName())) {
                if (td.getType().getFullName().contains(""."")) {
                    klass = td.getType().getFullName();
                }
            }
        }
    }
    return arrayIndex < 0 ? klass : klass + arraySuffix;
}",java:S3776,39
"public static String rewriteInitExprWithImports(String expr, TypeResolver typeResolver){
    if (expr == null) {
        return null;
    }
    if (typeResolver == null) {
        return expr;
    }
    StringBuilder sb = new StringBuilder();
    boolean inQuotes = false;
    boolean inTypeName = false;
    boolean afterDot = false;
    int typeStart = 0;
    for (int i = 0; i < expr.length(); i++) {
        char ch = expr.charAt(i);
        if (Character.isJavaIdentifierStart(ch)) {
            if (!inTypeName && !inQuotes && !afterDot) {
                typeStart = i;
                inTypeName = true;
            }
        } else if (!Character.isJavaIdentifierPart(ch)) {
            if (ch == '""') {
                inQuotes = !inQuotes;
            } else if (ch == '.' && !inQuotes) {
                afterDot = true;
            } else if (!Character.isSpaceChar(ch)) {
                afterDot = false;
            }
            if (inTypeName) {
                inTypeName = false;
                String type = expr.substring(typeStart, i);
                sb.append(getFullTypeName(type, typeResolver));
            }
        }
        if (!inTypeName) {
            sb.append(ch);
        }
    }
    if (inTypeName) {
        String type = expr.substring(typeStart);
        sb.append(getFullTypeName(type, typeResolver));
    }
    return sb.toString();
}",java:S3776,39
"public static String unBox(String type){
    if (""java.lang.Byte"".equals(type) || ""Byte"".equals(type)) {
        return getInternalType(""byte"");
    } else if (""java.lang.Character"".equals(type) || ""Character"".equals(type)) {
        return getInternalType(""char"");
    } else if (""java.lang.Double"".equals(type) || ""Double"".equals(type)) {
        return getInternalType(""double"");
    } else if (""java.lang.Float"".equals(type) || ""Float"".equals(type)) {
        return getInternalType(""float"");
    } else if (""java.lang.Integer"".equals(type) || ""Integer"".equals(type)) {
        return getInternalType(""int"");
    } else if (""java.lang.Long"".equals(type) || ""Long"".equals(type)) {
        return getInternalType(""long"");
    } else if (""java.lang.Short"".equals(type) || ""Short"".equals(type)) {
        return getInternalType(""short"");
    } else if (""java.lang.Boolean"".equals(type) || ""Boolean"".equals(type)) {
        return getInternalType(""boolean"");
    } else {
        throw new RuntimeException(""Unable to recognize boxed primitive type "" + type);
    }
}",java:S3776,39
"public static String numericMorph(String type){
    if (""java.lang.Byte"".equals(type) || ""Byte"".equals(type)) {
        return ""byteValue"";
    } else if (""java.lang.Double"".equals(type) || ""Double"".equals(type)) {
        return ""doubleValue"";
    } else if (""java.lang.Character"".equals(type) || ""Character"".equals(type)) {
        return ""charValue"";
    } else if (""java.lang.Boolean"".equals(type) || ""Boolean"".equals(type)) {
        return ""booleanValue"";
    } else if (""java.lang.Float"".equals(type) || ""Float"".equals(type)) {
        return ""floatValue"";
    } else if (""java.lang.Integer"".equals(type) || ""Integer"".equals(type)) {
        return ""intValue"";
    } else if (""java.lang.Long"".equals(type) || ""Long"".equals(type)) {
        return ""longValue"";
    } else if (""java.lang.Short"".equals(type) || ""Short"".equals(type)) {
        return ""shortValue"";
    } else {
        throw new RuntimeException(""Not a numeric type "" + type);
    }
}",java:S3776,39
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException{
    super.readExternal(in);
    this.enumLiterals = (List<EnumLiteralDefinition>) in.readObject();
}",java:S1161,11
"public void writeExternal(ObjectOutput out) throws IOException{
    super.writeExternal(out);
    out.writeObject(enumLiterals);
}",java:S1161,11
"public String toString(){
    final StringBuilder buf = new StringBuilder();
    buf.append(this.message);
    buf.append("" : "");
    buf.append(""\n"");
    if (this.object instanceof CompilationProblem[]) {
        final CompilationProblem[] problem = (CompilationProblem[]) this.object;
        for (CompilationProblem aProblem : problem) {
            buf.append(""\t"");
            buf.append(aProblem);
            buf.append(""\n"");
        }
    } else if (this.object != null) {
        buf.append(this.object);
    }
    return buf.toString();
}",java:S1161,11
" AnnotationDescr doNormalize(AnnotationDescr annotationDescr){
    Class<?> annotationClass = null;
    try {
        annotationClass = typeResolver.resolveType(annotationDescr.getName(), TypeResolver.ONLY_ANNOTATION_CLASS_FILTER);
    } catch (ClassNotFoundException | NoClassDefFoundError e) {
        String className = normalizeAnnotationNonStrictName(annotationDescr.getName());
        try {
            annotationClass = typeResolver.resolveType(className, TypeResolver.ONLY_ANNOTATION_CLASS_FILTER);
        } catch (ClassNotFoundException | NoClassDefFoundError e1) {
        }
    }
    if (annotationClass != null) {
        annotationDescr.setFullyQualifiedName(annotationClass.getCanonicalName());
        for (String key : annotationDescr.getValueMap().keySet()) {
            try {
                Method m = annotationClass.getMethod(key);
                Object val = annotationDescr.getValue(key);
                if (val instanceof Object[] && !m.getReturnType().isArray()) {
                    this.results.add(new AnnotationDeclarationError(annotationDescr, ""Wrong cardinality on property "" + key));
                    return annotationDescr;
                }
                if (m.getReturnType().isArray() && !(val instanceof Object[])) {
                    val = new Object[] { val };
                    annotationDescr.setKeyValue(key, val);
                }
                if (m.getReturnType().isArray()) {
                    int n = Array.getLength(val);
                    for (int j = 0; j < n; j++) {
                        if (Class.class.equals(m.getReturnType().getComponentType())) {
                            String className = Array.get(val, j).toString().replace("".class"", """");
                            Array.set(val, j, typeResolver.resolveType(className).getName() + "".class"");
                        } else if (m.getReturnType().getComponentType().isAnnotation()) {
                            Array.set(val, j, doNormalize((AnnotationDescr) Array.get(val, j)));
                        }
                    }
                } else {
                    if (Class.class.equals(m.getReturnType())) {
                        String className = annotationDescr.getValueAsString(key).replace("".class"", """");
                        annotationDescr.setKeyValue(key, typeResolver.resolveType(className));
                    } else if (m.getReturnType().isAnnotation()) {
                        annotationDescr.setKeyValue(key, doNormalize((AnnotationDescr) annotationDescr.getValue(key)));
                    }
                }
            } catch (NoSuchMethodException e) {
                this.results.add(new AnnotationDeclarationError(annotationDescr, ""Unknown annotation property "" + key));
            } catch (ClassNotFoundException | NoClassDefFoundError e) {
                this.results.add(new AnnotationDeclarationError(annotationDescr, ""Unknown class "" + annotationDescr.getValue(key) + "" used in property "" + key + "" of annotation "" + annotationDescr.getName()));
            }
        }
    }
    return annotationDescr;
}",java:S3776,39
"protected void removeGlobal(InternalKnowledgePackage pkg, String toBeRemoved){
    if (assetFilter != null && AssetFilter.Action.REMOVE.equals(assetFilter.accept(ResourceChange.Type.GLOBAL, pkg.getName(), toBeRemoved))) {
        pkg.removeGlobal(toBeRemoved);
        kBase.removeGlobal(toBeRemoved);
    }
}",java:S1161,11
"protected boolean filterAccepts(ResourceChange.Type type, String namespace, String name){
    return true;
}",java:S1172,13
"private void compileRulesLevel(PackageDescr packageDescr, PackageRegistry pkgRegistry, List<RuleDescr> rules){
    boolean parallelRulesBuild = parallelRulesBuild(rules);
    if (parallelRulesBuild) {
        Map<String, RuleBuildContext> ruleCxts = new ConcurrentHashMap<>();
        try {
            KnowledgeBuilderImpl.ForkJoinPoolHolder.COMPILER_POOL.submit(() -> rules.stream().parallel().filter(ruleDescr -> filterAccepts(ResourceChange.Type.RULE, ruleDescr.getNamespace(), ruleDescr.getName())).forEach(ruleDescr -> {
                initRuleDescr(packageDescr, pkgRegistry, ruleDescr);
                RuleBuildContext context = buildRuleBuilderContext(pkgRegistry, ruleDescr);
                ruleCxts.put(ruleDescr.getName(), context);
                List<? extends KnowledgeBuilderResult> results = addRule(context);
                if (!results.isEmpty()) {
                    synchronized (this.results) {
                        this.results.addAll(results);
                    }
                }
            })).get();
        } catch (InterruptedException | ExecutionException e) {
            throw new RuntimeException(""Rules compilation failed or interrupted"", e);
        }
        for (RuleDescr ruleDescr : rules) {
            RuleBuildContext context = ruleCxts.get(ruleDescr.getName());
            if (context != null) {
                pkgRegistry.getPackage().addRule(context.getRule());
            }
        }
    } else {
        for (RuleDescr ruleDescr : rules) {
            if (filterAccepts(ResourceChange.Type.RULE, ruleDescr.getNamespace(), ruleDescr.getName())) {
                initRuleDescr(packageDescr, pkgRegistry, ruleDescr);
                RuleBuildContext context = buildRuleBuilderContext(pkgRegistry, ruleDescr);
                this.results.addAll(addRule(context));
                pkgRegistry.getPackage().addRule(context.getRule());
            }
        }
    }
}",java:S3776,39
"public static CompilationPhase of(PackageRegistry pkgRegistry, PackageDescr packageDescr, InternalKnowledgeBase kBase, int parallelRulesBuildThreshold, AssetFilter assetFilter, Map<String, AttributeDescr> packageAttributes, Resource resource, TypeDeclarationContext typeDeclarationContext){
    if (kBase == null) {
        return new ImmutableRuleCompilationPhase(pkgRegistry, packageDescr, parallelRulesBuildThreshold, packageAttributes, resource, typeDeclarationContext);
    } else {
        return new RuleCompilationPhase(pkgRegistry, packageDescr, kBase, parallelRulesBuildThreshold, assetFilter, packageAttributes, resource, typeDeclarationContext);
    }
}",java:S107,1
"protected boolean parallelRulesBuild(List<RuleDescr> rules){
    return false;
}",java:S1161,11
"private void preProcessRules(PackageDescr packageDescr, PackageRegistry pkgRegistry){
    InternalKnowledgePackage pkg = pkgRegistry.getPackage();
    boolean needsRemoval = false;
    for (org.kie.api.definition.rule.Rule rule : pkg.getRules()) {
        if (filterAcceptsRemoval(ResourceChange.Type.RULE, rule.getPackageName(), rule.getName())) {
            needsRemoval = true;
            break;
        }
    }
    if (!needsRemoval) {
        for (RuleDescr ruleDescr : packageDescr.getRules()) {
            if (filterAccepts(ResourceChange.Type.RULE, ruleDescr.getNamespace(), ruleDescr.getName())) {
                if (pkg.getRule(ruleDescr.getName()) != null) {
                    needsRemoval = true;
                    break;
                }
            }
        }
    }
    if (needsRemoval) {
        kBase.enqueueModification(() -> {
            Collection<RuleImpl> rulesToBeRemoved = new HashSet<>();
            for (org.kie.api.definition.rule.Rule rule : pkg.getRules()) {
                if (filterAcceptsRemoval(ResourceChange.Type.RULE, rule.getPackageName(), rule.getName())) {
                    rulesToBeRemoved.add(((RuleImpl) rule));
                }
            }
            rulesToBeRemoved.forEach(pkg::removeRule);
            for (RuleDescr ruleDescr : packageDescr.getRules()) {
                if (filterAccepts(ResourceChange.Type.RULE, ruleDescr.getNamespace(), ruleDescr.getName())) {
                    RuleImpl rule = pkg.getRule(ruleDescr.getName());
                    if (rule != null) {
                        rulesToBeRemoved.add(rule);
                    }
                }
            }
            if (!rulesToBeRemoved.isEmpty()) {
                rulesToBeRemoved.addAll(findChildrenRulesToBeRemoved(packageDescr, rulesToBeRemoved));
                kBase.removeRules(rulesToBeRemoved);
            }
        });
    }
}",java:S3776,39
"public void process(){
    final Set<String> names = new HashSet<>();
    InternalKnowledgePackage pkg = null;
    if (pkgRegistry != null) {
        pkg = pkgRegistry.getPackage();
    }
    for (final RuleDescr rule : packageDescr.getRules()) {
        validateRule(packageDescr, rule);
        final String name = rule.getUnitQualifiedName();
        if (names.contains(name)) {
            this.results.add(new ParserError(rule.getResource(), ""Duplicate rule name: "" + name, rule.getLine(), rule.getColumn(), packageDescr.getNamespace()));
        }
        if (pkg != null) {
            RuleImpl duplicatedRule = pkg.getRule(name);
            if (duplicatedRule != null) {
                Resource resource = rule.getResource();
                Resource duplicatedResource = duplicatedRule.getResource();
                if (resource == null || duplicatedResource == null || duplicatedResource.getSourcePath() == null || duplicatedResource.getSourcePath().equals(resource.getSourcePath())) {
                    this.results.add(new DuplicateRule(rule, packageDescr, this.configuration));
                } else {
                    this.results.add(new ParserError(rule.getResource(), ""Duplicate rule name: "" + name, rule.getLine(), rule.getColumn(), packageDescr.getNamespace()));
                }
            }
        }
        names.add(name);
        if (rule.getUnit() != null && (rule.getAttributes().get(""agenda-group"") != null || rule.getAttributes().get(""ruleflow-group"") != null)) {
            this.results.add(new ParserError(rule.getResource(), ""Rule "" + rule.getName() + "" belongs to unit "" + rule.getUnit().getTarget() + "" and cannot have an agenda-group or a ruleflow-group"", rule.getLine(), rule.getColumn(), packageDescr.getNamespace()));
        }
    }
}",java:S3776,39
"private static Object decode(Class returnType, Object value, TypeResolver resolver){
    if (returnType.isArray()) {
        int n = Array.getLength(value);
        Class targetType = returnType.getComponentType().isAnnotation() ? AnnotationDefinition.class : returnType.getComponentType();
        Object ar = java.lang.reflect.Array.newInstance(targetType, n);
        for (int j = 0; j < n; j++) {
            java.lang.reflect.Array.set(ar, j, decode(returnType.getComponentType(), Array.get(value, j), resolver));
        }
        return ar;
    } else if (returnType.isEnum()) {
        if (returnType.isAssignableFrom(value.getClass())) {
            return value;
        }
        try {
            String valueStr = value.toString().trim();
            if (valueStr.indexOf('.') > 0) {
                value = valueStr.substring(valueStr.lastIndexOf(""."") + 1);
            }
            return returnType.getMethod(""valueOf"", String.class).invoke(null, value);
        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
    } else if (String.class.equals(returnType)) {
        return unquote(value.toString().trim());
    } else if (boolean.class.equals(returnType)) {
        return Boolean.valueOf(value.toString());
    } else if (int.class.equals(returnType)) {
        return Integer.valueOf(value.toString());
    } else if (double.class.equals(returnType)) {
        return Double.valueOf(value.toString());
    } else if (long.class.equals(returnType)) {
        return Long.valueOf(value.toString());
    } else if (float.class.equals(returnType)) {
        return Float.valueOf(value.toString());
    } else if (short.class.equals(returnType)) {
        return Short.valueOf(value.toString());
    } else if (char.class.equals(returnType)) {
        return unquote(value.toString()).charAt(0);
    } else if (Class.class.equals(returnType)) {
        if (value instanceof Class) {
            return value;
        }
        try {
            String cName = value.toString().trim().replace("".class"", """");
            return resolver.resolveType(cName);
        } catch (ClassNotFoundException cnfe) {
            LOG.error(""Exception"", cnfe);
            return Object.class;
        }
    } else if (returnType.isAnnotation()) {
        try {
            return build(returnType, ((Supplier<Map<String, Object>>) value).get(), resolver);
        } catch (NoSuchMethodException e) {
            LOG.error(""Exception"", e);
            return null;
        }
    }
    return null;
}",java:S3776,39
"public String toString(){
    final StringBuilder builder = new StringBuilder().append(this.message).append("" : "").append(""\n"");
    return BuilderResultUtils.appendProblems(this.object, builder).toString();
}",java:S1161,11
"public boolean isEmpty(){
    return this.errors.length == 0;
}",java:S1161,11
"public String toString(){
    final StringBuilder buf = new StringBuilder();
    for (int i = 0, length = this.errors.length; i < length; i++) {
        buf.append(errors[i]);
        buf.append(""\n"");
    }
    return buf.toString();
}",java:S1161,11
"public String toString(){
    return this.getMessage();
}",java:S1161,11
"public MemoryFileSystem clone(){
    MemoryFileSystem clone = new MemoryFileSystem();
    for (Map.Entry<PortablePath, InternalResource> entry : fileContents.entrySet()) {
        clone.write(entry.getKey(), entry.getValue());
    }
    return clone;
}",java:S1182,14
"private void indexKieModule(Map<String, InternalKieModule> kJarFromKBaseName, InternalKieModule kJar, boolean isMainModule){
    boolean defaultKieBaseFromMain = false;
    boolean defaultKieSessionFromMain = false;
    boolean defaultStatelessKieSessionFromMain = false;
    KieModuleModel kieProject = kJar.getKieModuleModel();
    for (KieBaseModel kieBaseModel : kieProject.getKieBaseModels().values()) {
        if (kieBaseModel.isDefault()) {
            if (defaultKieBase == null || (isMainModule && !defaultKieBaseFromMain)) {
                defaultKieBase = kieBaseModel;
                defaultKieBaseFromMain = isMainModule;
            } else {
                defaultKieBase = null;
                log.warn(""Found more than one default KieBase: disabling all. KieBases will be accessible only by name"");
            }
        }
        kBaseModels.put(kieBaseModel.getName(), kieBaseModel);
        ((KieBaseModelImpl) kieBaseModel).setKModule(kieProject);
        kJarFromKBaseName.put(kieBaseModel.getName(), kJar);
        for (KieSessionModel kieSessionModel : kieBaseModel.getKieSessionModels().values()) {
            if (kieSessionModel.isDefault()) {
                if (kieSessionModel.getType() == KieSessionModel.KieSessionType.STATEFUL) {
                    if (defaultKieSession == null || (isMainModule && !defaultKieSessionFromMain)) {
                        defaultKieSession = kieSessionModel;
                        defaultKieSessionFromMain = isMainModule;
                    } else {
                        defaultKieSession = null;
                        log.warn(""Found more than one default KieSession: disabling all. KieSessions will be accessible only by name"");
                    }
                } else {
                    if (defaultStatelessKieSession == null || (isMainModule && !defaultStatelessKieSessionFromMain)) {
                        defaultStatelessKieSession = kieSessionModel;
                        defaultStatelessKieSessionFromMain = isMainModule;
                    } else {
                        defaultStatelessKieSession = null;
                        log.warn(""Found more than one default StatelessKieSession: disabling all. StatelessKieSessions will be accessible only by name"");
                    }
                }
            }
            ((KieSessionModelImpl) kieSessionModel).setKBase(kieBaseModel);
            kSessionModels.put(kieSessionModel.getName(), kieSessionModel);
        }
    }
}",java:S3776,39
"public KnowledgeBuilder buildKnowledgePackages(KieBaseModelImpl kBaseModel, BuildContext buildContext, Predicate<String> buildFilter){
    boolean useFolders = useFolders(kBaseModel);
    Set<Asset> assets = new HashSet<>();
    boolean allIncludesAreValid = true;
    for (String include : getTransitiveIncludes(kBaseModel)) {
        if (StringUtils.isEmpty(include)) {
            continue;
        }
        InternalKieModule includeModule = getKieModuleForKBase(include);
        if (includeModule == null) {
            String text = ""Unable to build KieBase, could not find include: "" + include;
            log.error(text);
            buildContext.getMessages().addMessage(Message.Level.ERROR, KieModuleModelImpl.KMODULE_SRC_PATH.asString(), text).setKieBaseName(kBaseModel.getName());
            allIncludesAreValid = false;
            continue;
        }
        if (compileIncludedKieBases()) {
            addFiles(buildFilter, assets, getKieBaseModel(include), includeModule, useFolders);
        }
    }
    if (!allIncludesAreValid) {
        return null;
    }
    InternalKieModule kModule = getKieModuleForKBase(kBaseModel.getName());
    addFiles(buildFilter, assets, kBaseModel, kModule, useFolders);
    KnowledgeBuilder kbuilder;
    if (assets.isEmpty()) {
        if (buildFilter == BUILD_ALL) {
            log.warn(""No files found for KieBase "" + kBaseModel.getName() + (kModule instanceof FileKieModule ? "", searching folder "" + kModule.getFile() : """"));
        }
        kbuilder = new InternalKnowledgeBuilder.Empty(getClassLoader(), () -> provideKnowledgeBuilder(kBaseModel, kModule, buildContext));
    } else {
        kbuilder = provideKnowledgeBuilder(kBaseModel, kModule, buildContext);
        if (kbuilder == null) {
            return null;
        }
        CompositeKnowledgeBuilder ckbuilder = kbuilder.batch();
        for (Asset asset : assets) {
            if (buildContext.registerResourceToBuild(kBaseModel.getName(), asset.name)) {
                asset.kmodule.addResourceToCompiler(ckbuilder, kBaseModel, asset.name);
            }
        }
        ckbuilder.build();
        if (kbuilder.hasErrors()) {
            for (KnowledgeBuilderError error : kbuilder.getErrors()) {
                buildContext.getMessages().addMessage(error).setKieBaseName(kBaseModel.getName());
            }
            log.error(""Unable to build KieBaseModel:"" + kBaseModel.getName() + ""\n"" + kbuilder.getErrors().toString());
        }
        if (kbuilder.hasResults(ResultSeverity.WARNING)) {
            for (KnowledgeBuilderResult warn : kbuilder.getResults(ResultSeverity.WARNING)) {
                buildContext.getMessages().addMessage(warn).setKieBaseName(kBaseModel.getName());
            }
            log.warn(""Warning : "" + kBaseModel.getName() + ""\n"" + kbuilder.getResults(ResultSeverity.WARNING).toString());
        }
    }
    if (buildFilter == BUILD_ALL) {
        kModule.cacheKnowledgeBuilderForKieBase(kBaseModel.getName(), kbuilder);
        kModule.cacheResultsForKieBase(kBaseModel.getName(), buildContext.getMessages());
    }
    return kbuilder;
}",java:S3776,39
"public boolean registerResourceToBuild(String kBaseName, String resource){
    return true;
}",java:S1172,13
"public void discoverKieModules(){
    PortablePath[] configFiles = { KieModuleModelImpl.KMODULE_JAR_PATH, KieModuleModelImpl.KMODULE_SPRING_JAR_PATH };
    for (PortablePath configFile : configFiles) {
        final Set<URL> resources = new HashSet<>();
        try {
            ClassLoader currentClassLoader = classLoader;
            while (currentClassLoader != null) {
                Enumeration<URL> list = currentClassLoader.getResources(configFile.asString());
                while (list.hasMoreElements()) {
                    resources.add(list.nextElement());
                }
                currentClassLoader = currentClassLoader.getParent();
            }
        } catch (IOException exc) {
            log.error(""Unable to find and build index of "" + configFile.asString() + ""."" + exc.getMessage());
            return;
        }
        for (URL url : resources) {
            notifyKieModuleFound(url);
            try {
                InternalKieModule kModule = fetchKModule(url);
                if (kModule != null) {
                    ReleaseId releaseId = kModule.getReleaseId();
                    kieModules.put(releaseId, kModule);
                    log.debug(""Discovered classpath module "" + releaseId.toExternalForm());
                    kieRepository.addKieModule(kModule);
                }
            } catch (Exception exc) {
                log.error(""Unable to build index of kmodule.xml url="" + url.toExternalForm() + ""\n"" + exc.getMessage());
            }
        }
    }
}",java:S3776,39
"private static String getPathForVFS(URL url){
    Method m = null;
    try {
        m = Class.forName(""org.jboss.vfs.VirtualFile"").getMethod(""getPhysicalFile"");
    } catch (Exception e) {
        try {
            m = Class.forName(""org.jboss.vfs.VirtualFile"", true, Thread.currentThread().getContextClassLoader()).getMethod(""getPhysicalFile"");
        } catch (Exception e1) {
            log.warn(""Found virtual file "" + url + "" but org.jboss.vfs.VirtualFile is not available on the classpath"");
        }
    }
    Method m2 = null;
    try {
        m2 = Class.forName(""org.jboss.vfs.VFS"").getMethod(""getChild"", URI.class);
    } catch (Exception e) {
        try {
            m2 = Class.forName(""org.jboss.vfs.VFS"", true, Thread.currentThread().getContextClassLoader()).getMethod(""getChild"", URI.class);
        } catch (Exception e1) {
            log.warn(""Found virtual file "" + url + "" but org.jboss.vfs.VFS is not available on the classpath"");
        }
    }
    if (m == null || m2 == null) {
        return url.getPath();
    }
    String path = null;
    try {
        File f = (File) m.invoke(m2.invoke(null, url.toURI()));
        path = PortablePath.of(f.getPath()).asString();
    } catch (Exception e) {
        log.error(""Error when reading virtual file from "" + url.toString(), e);
    }
    if (path == null) {
        return url.getPath();
    }
    String urlString = url.toString();
    if (!urlString.contains(""/"" + KieModuleModelImpl.KMODULE_JAR_PATH.asString())) {
        return path;
    }
    int kModulePos = urlString.length() - (""/"" + KieModuleModelImpl.KMODULE_JAR_PATH.asString()).length();
    boolean isInJar = urlString.startsWith("".jar"", kModulePos - 4);
    try {
        if (isInJar && path.contains(""contents/"")) {
            String jarName = urlString.substring(0, kModulePos);
            jarName = jarName.substring(jarName.lastIndexOf('/') + 1);
            String jarFolderPath = path.substring(0, path.length() - (""contents/"" + KieModuleModelImpl.KMODULE_JAR_PATH.asString()).length());
            String jarPath = jarFolderPath + jarName;
            path = new File(jarPath).exists() ? jarPath : jarFolderPath + ""content"";
        } else if (path.endsWith(""/"" + KieModuleModelImpl.KMODULE_FILE_NAME)) {
            path = path.substring(0, path.length() - (""/"" + KieModuleModelImpl.KMODULE_JAR_PATH.asString()).length());
        }
        log.info(""Virtual file physical path = "" + path);
        return path;
    } catch (Exception e) {
        log.error(""Error when reading virtual file from "" + url, e);
    }
    return url.getPath();
}",java:S3776,39
"public boolean equals(Object o){
    return (o != null) && this.getName().equals(((FieldDefinition) o).getName());
}",java:S2097,27
"public boolean getDefaultValueAs_boolean(){
    if (StringUtils.isEmpty(initExpr)) {
        return false;
    } else {
        if (""true"".equalsIgnoreCase(initExpr)) {
            return true;
        } else if (""false"".equalsIgnoreCase(initExpr)) {
            return false;
        } else {
            return CoreComponentsBuilder.get().getMVELExecutor().eval(initExpr, Boolean.class);
        }
    }
}",java:S100,0
"private static InternalKieModuleProvider createZipKieModuleProvider(){
    InternalKieModuleProvider provider = KieService.load(InternalKieModuleProvider.class);
    return provider != null ? provider : new DrlBasedKieModuleProvider();
}",java:S3398,35
"public byte getDefaultValueAs_byte(){
    try {
        return initExpr == null ? 0 : Byte.parseByte(initExpr);
    } catch (NumberFormatException nfe) {
        return StringUtils.isEmpty(initExpr) ? 0 : CoreComponentsBuilder.get().getMVELExecutor().eval(initExpr, Byte.class);
    }
}",java:S100,0
"protected int updateResource(InternalKnowledgeBuilder kbuilder, CompositeKnowledgeBuilder ckbuilder, ResourceChangeSet rcs){
    int fileCount = 0;
    if (rcs.getChangeType() != ChangeType.REMOVED) {
        String resourceName = rcs.getResourceName();
        if (!resourceName.endsWith("".properties"") && isFileInKBase(ctx.newKM, ctx.newKieBaseModel, resourceName)) {
            List<ResourceChange> changes = rcs.getChanges();
            if (!changes.isEmpty()) {
                fileCount += AbstractKieModule.updateResource(ckbuilder, ctx.newKM, resourceName, rcs) ? 1 : 0;
            } else {
                if (rcs.getChangeType() == ChangeType.UPDATED) {
                    Resource resource = ctx.currentKM.getResource(resourceName);
                    kbuilder.removeObjectsGeneratedFromResource(resource);
                }
                fileCount += ctx.newKM.addResourceToCompiler(ckbuilder, ctx.newKieBaseModel, resourceName, rcs) ? 1 : 0;
            }
        }
    }
    for (ResourceChangeSet.RuleLoadOrder loadOrder : rcs.getLoadOrder()) {
        KnowledgePackageImpl pkg = (KnowledgePackageImpl) ctx.kBase.getKiePackage(loadOrder.getPkgName());
        if (pkg != null) {
            RuleImpl rule = pkg.getRule(loadOrder.getRuleName());
            if (rule != null) {
                rule.setLoadOrder(loadOrder.getLoadOrder());
            }
        }
    }
    return fileCount;
}",java:S3776,39
"public static boolean isPackageInKieBase(KieBaseModel kieBaseModel, String pkgName){
    for (String candidatePkg : kieBaseModel.getPackages()) {
        boolean isNegative = candidatePkg.startsWith(""!"");
        if (isNegative) {
            candidatePkg = candidatePkg.substring(1);
        }
        if (candidatePkg.equals(""*"") || pkgName.equals(candidatePkg) || pkgName.endsWith(""."" + candidatePkg)) {
            return !isNegative;
        }
        if (candidatePkg.endsWith("".*"")) {
            String relativePkgNameForFile = getRelativePackageName(pkgName);
            String pkgNameNoWildcard = candidatePkg.substring(0, candidatePkg.length() - 2);
            if (relativePkgNameForFile.equals(pkgNameNoWildcard) || relativePkgNameForFile.startsWith(pkgNameNoWildcard + ""."")) {
                return !isNegative;
            }
            if (relativePkgNameForFile.startsWith(kieBaseModel.getName() + ""."")) {
                relativePkgNameForFile = relativePkgNameForFile.substring(kieBaseModel.getName().length() + 1);
                if (relativePkgNameForFile.equals(pkgNameNoWildcard) || relativePkgNameForFile.startsWith(pkgNameNoWildcard + ""."")) {
                    return !isNegative;
                }
            }
        }
    }
    return false;
}",java:S3776,39
"public char getDefaultValueAs_char(){
    if (StringUtils.isEmpty(initExpr)) {
        return '\u0000';
    } else {
        if (initExpr.length() == 1) {
            return initExpr.charAt(0);
        } else {
            return CoreComponentsBuilder.get().getMVELExecutor().eval(initExpr, Character.class);
        }
    }
}",java:S100,0
"private void compileJavaClasses(ClassLoader classLoader, Predicate<String> classFilter){
    List<String> classFiles = new ArrayList<>();
    for (PortablePath filePath : srcMfs.getFilePaths()) {
        if (filePath.endsWith("".class"")) {
            trgMfs.write(filePath, getResource(srcMfs, filePath), true);
            classFiles.add(filePath.substring(0, filePath.asString().length() - "".class"".length()).asString());
        }
    }
    List<String> javaFiles = new ArrayList<>();
    List<String> javaTestFiles = new ArrayList<>();
    for (PortablePath filePath : srcMfs.getFilePaths()) {
        String fileName = filePath.asString();
        if (isJavaSourceFile(fileName) && noClassFileForGivenSourceFile(classFiles, fileName) && notVetoedByFilter(classFilter, fileName)) {
            if (!fileName.startsWith(JAVA_ROOT) && !fileName.startsWith(JAVA_TEST_ROOT)) {
                results.addMessage(Level.WARNING, fileName, ""Found Java file out of the Java source folder: \"""" + fileName + ""\"""");
            } else if (fileName.substring(JAVA_ROOT.length()).indexOf('/') < 0) {
                results.addMessage(Level.ERROR, fileName, ""A Java class must have a package: "" + fileName.substring(JAVA_ROOT.length()) + "" is not allowed"");
            } else {
                if (fileName.startsWith(JAVA_ROOT)) {
                    javaFiles.add(fileName);
                } else {
                    javaTestFiles.add(fileName);
                }
            }
        }
    }
    if (!javaFiles.isEmpty() || !javaTestFiles.isEmpty()) {
        KnowledgeBuilderConfigurationImpl kconf = newKnowledgeBuilderConfiguration(classLoader).as(KnowledgeBuilderConfigurationImpl.KEY);
        JavaConfiguration javaConf = (JavaConfiguration) kconf.getDialectConfiguration(""java"");
        compileJavaClasses(javaConf, classLoader, javaFiles, JAVA_ROOT);
        compileJavaClasses(javaConf, classLoader, javaTestFiles, JAVA_TEST_ROOT);
    }
}",java:S3776,39
"public double getDefaultValueAs_double(){
    try {
        return initExpr == null ? 0.0 : Double.parseDouble(initExpr);
    } catch (NumberFormatException nfe) {
        return StringUtils.isEmpty(initExpr) ? 0.0 : CoreComponentsBuilder.get().getMVELExecutor().eval(initExpr, Double.class);
    }
}",java:S100,0
"public KieFileSystem clone(){
    try {
        final ByteArrayOutputStream byteArray = writeToByteArray(this);
        return readFromByteArray(byteArray);
    } catch (IOException | ClassNotFoundException ioe) {
        logger.warn(""Unable to clone KieFileSystemImpl"", ioe);
        return null;
    }
}",java:S2975,34
"public float getDefaultValueAs_float(){
    try {
        return initExpr == null ? 0.0f : Float.parseFloat(initExpr);
    } catch (NumberFormatException nfe) {
        return StringUtils.isEmpty(initExpr) ? 0.0f : CoreComponentsBuilder.get().getMVELExecutor().eval(initExpr, Float.class);
    }
}",java:S100,0
"public KieFileSystem clone(){
    try {
        final ByteArrayOutputStream byteArray = writeToByteArray(this);
        return readFromByteArray(byteArray);
    } catch (IOException | ClassNotFoundException ioe) {
        logger.warn(""Unable to clone KieFileSystemImpl"", ioe);
        return null;
    }
}",java:S1182,14
"public KieModuleMetaInfo generateKieModuleMetaInfo(ResourceStore trgMfs){
    Map<String, TypeMetaInfo> typeInfos = new HashMap<>();
    Map<String, Set<String>> rulesPerPackage = new HashMap<>();
    KieModuleModel kieModuleModel = kModule.getKieModuleModel();
    for (String kieBaseName : kieModuleModel.getKieBaseModels().keySet()) {
        KnowledgeBuilder kBuilder = kModule.getKnowledgeBuilderForKieBase(kieBaseName);
        for (KiePackage kPkg : kBuilder.getKnowledgePackages()) {
            PackageRegistry pkgRegistry = ((InternalKnowledgeBuilder) kBuilder).getPackageRegistry(kPkg.getName());
            JavaDialectRuntimeData runtimeData = (JavaDialectRuntimeData) pkgRegistry.getDialectRuntimeRegistry().getDialectData(""java"");
            List<String> types = new ArrayList<>();
            for (FactType factType : kPkg.getFactTypes()) {
                Class<?> typeClass = ((ClassDefinition) factType).getDefinedClass();
                TypeDeclaration typeDeclaration = pkgRegistry.getPackage().getTypeDeclaration(typeClass);
                if (typeDeclaration != null) {
                    typeInfos.put(typeClass.getName(), new TypeMetaInfo(typeDeclaration));
                }
                String className = factType.getName();
                String internalName = className.replace('.', '/') + "".class"";
                if (trgMfs != null) {
                    byte[] bytes = runtimeData.getBytecode(internalName);
                    if (bytes != null) {
                        trgMfs.write(internalName, bytes, true);
                    }
                }
                types.add(internalName);
            }
            Set<String> rules = rulesPerPackage.get(kPkg.getName());
            if (rules == null) {
                rules = new HashSet<>();
            }
            for (Rule rule : kPkg.getRules()) {
                rules.add(rule.getName());
            }
            if (!rules.isEmpty()) {
                rulesPerPackage.put(kPkg.getName(), rules);
            }
        }
    }
    return new KieModuleMetaInfo(typeInfos, rulesPerPackage);
}",java:S3776,39
"public int getDefaultValueAs_int(){
    try {
        return initExpr == null ? 0 : Integer.parseInt(initExpr);
    } catch (NumberFormatException nfe) {
        return StringUtils.isEmpty(initExpr) ? 0 : CoreComponentsBuilder.get().getMVELExecutor().eval(initExpr, Integer.class);
    }
}",java:S100,0
"public void start(long pollingInterval){
}",java:S1186,16
"public void stop(){
}",java:S1186,16
"public void shutdown(){
}",java:S1186,16
"public void scanNow(){
}",java:S1186,16
"public void setKieContainer(KieContainer kieContainer){
}",java:S1186,16
"public String getArtifactVersion(ReleaseId releaseId){
    logArtifactNotFetched(releaseId);
    return null;
}",java:S4144,40
"public long getDefaultValueAs_long(){
    try {
        return initExpr == null ? 0L : Long.parseLong(initExpr);
    } catch (NumberFormatException nfe) {
        return StringUtils.isEmpty(initExpr) ? 0L : CoreComponentsBuilder.get().getMVELExecutor().eval(initExpr, Long.class);
    }
}",java:S100,0
"public void addListener(KieScannerEventListener listener){
}",java:S1186,16
"public void removeListener(KieScannerEventListener listener){
}",java:S1186,16
"public short getDefaultValueAs_short(){
    try {
        return initExpr == null ? 0 : Short.parseShort(initExpr);
    } catch (NumberFormatException nfe) {
        return StringUtils.isEmpty(initExpr) ? 0 : CoreComponentsBuilder.get().getMVELExecutor().eval(initExpr, Short.class);
    }
}",java:S100,0
" synchronized KieModule load(InternalKieScanner kieScanner, ReleaseId releaseId, VersionRange versionRange){
    String ga = releaseId.getGroupId() + "":"" + releaseId.getArtifactId();
    NavigableMap<ComparableVersion, KieModule> artifactMap = kieModules.get(ga);
    if (artifactMap == null || artifactMap.isEmpty()) {
        return null;
    }
    KieModule kieModule = artifactMap.get(new ComparableVersion(releaseId.getVersion()));
    if (versionRange.fixed) {
        if (kieModule != null && releaseId.isSnapshot()) {
            String oldSnapshotVersion = ((ReleaseIdImpl) kieModule.getReleaseId()).getSnapshotVersion();
            if (oldSnapshotVersion != null) {
                String currentSnapshotVersion = kieScanner.getArtifactVersion(releaseId);
                if (currentSnapshotVersion != null && new ComparableVersion(currentSnapshotVersion).compareTo(new ComparableVersion(oldSnapshotVersion)) > 0) {
                    return null;
                }
            }
        }
        return kieModule;
    }
    Map.Entry<ComparableVersion, KieModule> entry = versionRange.upperBound == null ? artifactMap.lastEntry() : versionRange.upperInclusive ? artifactMap.floorEntry(new ComparableVersion(versionRange.upperBound)) : artifactMap.lowerEntry(new ComparableVersion(versionRange.upperBound));
    if (entry == null) {
        return null;
    }
    if (versionRange.lowerBound == null) {
        return entry.getValue();
    }
    int comparison = entry.getKey().compareTo(new ComparableVersion(versionRange.lowerBound));
    return comparison > 0 || (comparison == 0 && versionRange.lowerInclusive) ? entry.getValue() : null;
}",java:S3776,39
"public static KieJarChangeSet build(InternalKieModule original, InternalKieModule currentJar){
    KieJarChangeSet result = new KieJarChangeSet();
    Collection<String> originalFiles = original.getFileNames();
    Collection<String> currentFiles = currentJar.getFileNames();
    ArrayList<String> removedFiles = new ArrayList<>(originalFiles);
    removedFiles.removeAll(currentFiles);
    if (!removedFiles.isEmpty()) {
        for (String file : removedFiles) {
            result.removeFile(file);
        }
    }
    List<TypeDeclarationDescr> typeDeclarations = new ArrayList<>();
    Map<String, String> changedClasses = new HashMap<>();
    for (String file : currentFiles) {
        if (originalFiles.contains(file)) {
            byte[] ob = original.getBytes(file);
            byte[] cb = currentJar.getBytes(file);
            if (!Arrays.equals(ob, cb)) {
                if (file.endsWith("".class"")) {
                    changedClasses.put(convertResourceToClassName(file), file);
                } else if (!ResourceType.DRL.matchesExtension(file) || !StringUtils.codeAwareEqualsIgnoreSpaces(new String(ob), new String(cb))) {
                    result.registerChanges(file, diffResource(file, ob, cb, typeDeclarations));
                }
            }
        } else {
            result.addFile(file);
        }
    }
    for (TypeDeclarationDescr typeDeclaration : typeDeclarations) {
        String fqn = typeDeclaration.getFullTypeName();
        if (changedClasses.containsKey(fqn)) {
            continue;
        }
        InternalKnowledgePackage pkg = original.getPackage(typeDeclaration.getNamespace());
        if (pkg == null) {
            continue;
        }
        TypeResolver resolver = pkg.getTypeResolver();
        for (TypeFieldDescr field : typeDeclaration.getFields().values()) {
            String fieldType;
            try {
                fieldType = resolver.resolveType(field.getPattern().getObjectType()).getCanonicalName();
            } catch (ClassNotFoundException e) {
                continue;
            }
            if (changedClasses.containsKey(fieldType)) {
                changedClasses.put(fqn, convertClassToResourcePath(fqn));
                break;
            }
        }
    }
    for (String changedClass : changedClasses.values()) {
        result.registerChanges(changedClass, new ResourceChangeSet(changedClass, ChangeType.UPDATED));
    }
    if (original.getKieModuleModel() != null) {
        for (String kieBaseName : original.getKieModuleModel().getKieBaseModels().keySet()) {
            KnowledgeBuilder originalKbuilder = original.getKnowledgeBuilderForKieBase(kieBaseName);
            if (originalKbuilder != null && currentJar.getKnowledgeBuilderForKieBase(kieBaseName) == null) {
                currentJar.cacheKnowledgeBuilderForKieBase(kieBaseName, originalKbuilder);
            }
        }
    }
    return result;
}",java:S3776,39
"private static ResourceChangeSet diffResource(String file, byte[] originalBytes, byte[] currentBytes, List<TypeDeclarationDescr> typeDeclarations){
    ResourceChangeSet pkgcs = new ResourceChangeSet(file, ChangeType.UPDATED);
    ResourceType type = ResourceType.determineResourceType(file);
    if (ResourceType.DRL.equals(type) || ResourceType.GDRL.equals(type) || ResourceType.RDRL.equals(type) || ResourceType.TDRL.equals(type)) {
        try {
            PackageDescr originalPkg = new DrlParser().parse(new ByteArrayResource(originalBytes));
            PackageDescr currentPkg = new DrlParser().parse(new ByteArrayResource(currentBytes));
            String pkgName = isEmpty(currentPkg.getName()) ? getDefaultPackageName() : currentPkg.getName();
            String oldPkgName = isEmpty(originalPkg.getName()) ? getDefaultPackageName() : originalPkg.getName();
            if (!oldPkgName.equals(pkgName)) {
                return pkgcs;
            }
            pkgcs.setPackageName(pkgName);
            for (RuleDescr crd : currentPkg.getRules()) {
                pkgcs.getLoadOrder().add(new ResourceChangeSet.RuleLoadOrder(pkgName, crd.getName(), crd.getLoadOrder()));
            }
            List<RuleDescr> orules = new ArrayList<>(originalPkg.getRules());
            diffDescrs(originalBytes, currentBytes, pkgcs, orules, currentPkg.getRules(), ResourceChange.Type.RULE, RULE_CONVERTER);
            List<FunctionDescr> ofuncs = new ArrayList<>(originalPkg.getFunctions());
            diffDescrs(originalBytes, currentBytes, pkgcs, ofuncs, currentPkg.getFunctions(), ResourceChange.Type.FUNCTION, FUNC_CONVERTER);
            List<GlobalDescr> oglobals = new ArrayList<>(originalPkg.getGlobals());
            diffDescrs(originalBytes, currentBytes, pkgcs, oglobals, currentPkg.getGlobals(), ResourceChange.Type.GLOBAL, GLOBAL_CONVERTER);
            for (TypeDeclarationDescr typeDeclaration : currentPkg.getTypeDeclarations()) {
                if (isEmpty(typeDeclaration.getNamespace())) {
                    typeDeclaration.setNamespace(isEmpty(currentPkg.getNamespace()) ? DEFAULT_PACKAGE : currentPkg.getNamespace());
                }
                typeDeclarations.add(typeDeclaration);
            }
        } catch (Exception e) {
            logger.error(""Error analyzing the contents of "" + file + "". Skipping."", e);
        }
    }
    pkgcs.getChanges().sort(Comparator.comparingInt(r -> r.getChangeType().ordinal()));
    return pkgcs;
}",java:S3776,39
"private static void diffDescrs(byte[] ob, byte[] cb, ResourceChangeSet pkgcs, List<T> odescrs, List<T> cdescrs, ResourceChange.Type type, DescrNameConverter<T> descrNameConverter){
    Set<String> updatedRules = null;
    if (type == ResourceChange.Type.RULE) {
        updatedRules = new HashSet<>();
        ((List<RuleDescr>) cdescrs).sort(RULE_HIERARCHY_COMPARATOR);
    }
    for (T crd : cdescrs) {
        String cName = descrNameConverter.getName(crd);
        boolean found = false;
        for (Iterator<T> it = odescrs.iterator(); it.hasNext(); ) {
            T ord = it.next();
            if (descrNameConverter.getName(ord).equals(cName)) {
                found = true;
                it.remove();
                if (!StringUtils.codeAwareEqualsIgnoreSpaces(new String(Arrays.copyOfRange(ob, ord.getStartCharacter(), ord.getEndCharacter())), new String(Arrays.copyOfRange(cb, crd.getStartCharacter(), crd.getEndCharacter()))) || (type == ResourceChange.Type.RULE && updatedRules.contains(((RuleDescr) crd).getParentName()))) {
                    pkgcs.getChanges().add(new ResourceChange(ChangeType.UPDATED, type, cName));
                    if (type == ResourceChange.Type.RULE) {
                        updatedRules.add(cName);
                    }
                }
                break;
            }
        }
        if (!found) {
            pkgcs.getChanges().add(new ResourceChange(ChangeType.ADDED, type, cName));
        }
    }
    for (T ord : odescrs) {
        pkgcs.getChanges().add(new ResourceChange(ChangeType.REMOVED, type, descrNameConverter.getName(ord)));
    }
}",java:S3776,39
"private void internalAdd(Resource resource, PackageDescr packageDescr){
    for (ImportDescr descr : packageDescr.getImports()) {
        addImport(descr);
        descr.setResource(resource);
    }
    for (FunctionImportDescr descr : packageDescr.getFunctionImports()) {
        addFunctionImport(descr);
        descr.setResource(resource);
    }
    for (AccumulateImportDescr descr : packageDescr.getAccumulateImports()) {
        addAccumulateImport(descr);
        descr.setResource(resource);
    }
    for (AttributeDescr descr : packageDescr.getAttributes()) {
        addAttribute(descr);
        descr.setResource(resource);
    }
    for (GlobalDescr descr : packageDescr.getGlobals()) {
        addGlobal(descr);
        descr.setResource(resource);
    }
    for (FunctionDescr descr : packageDescr.getFunctions()) {
        addFunction(descr);
        descr.setResource(resource);
    }
    for (RuleDescr descr : packageDescr.getRules()) {
        addRule(descr);
        descr.setResource(resource);
    }
    Set<TypeDeclarationDescr> typeDeclarationDescrs = new HashSet<>(getTypeDeclarations());
    for (TypeDeclarationDescr descr : packageDescr.getTypeDeclarations()) {
        if (!typeDeclarationDescrs.contains(descr)) {
            addTypeDeclaration(descr);
            descr.setResource(resource);
        }
    }
    for (EnumDeclarationDescr enumDescr : packageDescr.getEnumDeclarations()) {
        addEnumDeclaration(enumDescr);
        enumDescr.setResource(resource);
    }
    for (EntryPointDeclarationDescr descr : packageDescr.getEntryPointDeclarations()) {
        addEntryPointDeclaration(descr);
        descr.setResource(resource);
    }
    for (WindowDeclarationDescr descr : packageDescr.getWindowDeclarations()) {
        addWindowDeclaration(descr);
        descr.setResource(resource);
    }
    packageDescr.getPreferredPkgUUID().ifPresent(pkgUUID -> {
        if (getPreferredPkgUUID().isPresent() && !pkgUUID.equals(getPreferredPkgUUID().get())) {
            throw new RuntimeException(String.format(""Trying to overwrite preferredPkgUUID %s with a different value %s"", getPreferredPkgUUID().get(), pkgUUID));
        }
        setPreferredPkgUUID(pkgUUID);
    });
}",java:S3776,39
"private Declaration lookupObjectType(RuleBuildContext context, PatternDescr patternDescr){
    List<? extends BaseDescr> descrs = patternDescr.getConstraint().getDescrs();
    if (descrs.size() != 1 || !(descrs.get(0) instanceof ExprConstraintDescr)) {
        return null;
    }
    ExprConstraintDescr descr = (ExprConstraintDescr) descrs.get(0);
    String expr = descr.getExpression();
    if (expr.charAt(0) != '/') {
        return null;
    }
    XpathAnalysis xpathAnalysis = XpathAnalysis.analyze(expr);
    if (xpathAnalysis.hasError()) {
        registerDescrBuildError(context, patternDescr, ""Invalid xpath expression '"" + expr + ""': "" + xpathAnalysis.getError());
        return null;
    }
    XpathPart firstXpathChunk = xpathAnalysis.getPart(0);
    String identifier = firstXpathChunk.getField();
    DeclarationScopeResolver resolver = context.getDeclarationResolver();
    if (resolver.hasDataSource(identifier)) {
        patternDescr.setObjectType(findObjectType(context, firstXpathChunk, identifier));
        FromDescr fromDescr = new FromDescr();
        fromDescr.setDataSource(new MVELExprDescr(identifier));
        patternDescr.setSource(fromDescr);
        patternDescr.removeAllConstraint();
        firstXpathChunk.getConstraints().forEach(s -> patternDescr.addConstraint(new ExprConstraintDescr(s)));
        if (!xpathAnalysis.isSinglePart()) {
            String xpathExpr = (patternDescr.getIdentifier() == null ? """" : patternDescr.getIdentifier() + "" : "") + expr.substring(xpathAnalysis.getPart(1).getStart());
            patternDescr.addConstraint(new ExprConstraintDescr(xpathExpr));
            patternDescr.setIdentifier(""$void$"");
        }
    } else {
        Declaration declr = resolver.getDeclaration(identifier);
        if (declr == null) {
            registerDescrBuildError(context, patternDescr, ""The identifier '"" + identifier + ""' is not in scope"");
            return null;
        }
        patternDescr.setObjectType(declr.getExtractor().getExtractToClassName());
        expr = (patternDescr.getIdentifier() != null ? patternDescr.getIdentifier() + (patternDescr.isUnification() ? "" := "" : "" : "") : """") + expr.substring(identifier.length() + 1);
        descr.setExpression(expr);
        return declr;
    }
    return null;
}",java:S3776,39
"private RuleConditionElement buildQuery(RuleBuildContext context, PatternDescr descr, PatternDescr patternDescr){
    RuleConditionElement rce = null;
    if (context.getRule().getName().equals(patternDescr.getObjectType())) {
        rce = buildQueryElement(context, descr, (QueryImpl) context.getRule());
    }
    if (rce == null) {
        RuleImpl rule = context.getPkg().getRule(patternDescr.getObjectType());
        if (rule instanceof QueryImpl) {
            rce = buildQueryElement(context, descr, (QueryImpl) rule);
        }
    }
    if (rce == null) {
        for (String importName : context.getDialect().getTypeResolver().getImports()) {
            importName = importName.trim();
            int pos = importName.indexOf('*');
            if (pos >= 0) {
                String pkgName = importName.substring(0, pos - 1);
                PackageRegistry pkgReg = context.getKnowledgeBuilder().getPackageRegistry(pkgName);
                if (pkgReg != null) {
                    RuleImpl rule = pkgReg.getPackage().getRule(patternDescr.getObjectType());
                    if (rule instanceof QueryImpl) {
                        rce = buildQueryElement(context, descr, (QueryImpl) rule);
                        break;
                    }
                }
            }
        }
    }
    if (rce == null) {
        registerDescrBuildError(context, patternDescr, ""Unable to resolve ObjectType '"" + patternDescr.getObjectType() + ""'"");
    }
    return rce;
}",java:S3776,39
"private void processDuplicateBindings(boolean isUnification, PatternDescr patternDescr, Declaration xpathStartDeclaration, Pattern pattern, BaseDescr original, String leftExpression, String rightIdentifier, RuleBuildContext context){
    if (isUnification) {
        build(context, patternDescr, xpathStartDeclaration, pattern, original, leftExpression + "" == "" + rightIdentifier);
    } else {
        registerDescrBuildError(context, patternDescr, ""Duplicate declaration for variable '"" + rightIdentifier + ""' in the rule '"" + context.getRule().getName() + ""'"");
    }
}",java:S107,1
"protected void processListenedPropertiesAnnotation(RuleBuildContext context, PatternDescr patternDescr, Pattern pattern){
    String watchedValues = null;
    try {
        Watch watch = getTypedAnnotation(patternDescr, Watch.class);
        watchedValues = watch == null ? null : watch.value();
    } catch (Exception e) {
        registerDescrBuildError(context, patternDescr, e.getMessage());
    }
    if (watchedValues == null) {
        return;
    }
    Collection<String> settableProperties = getSettableProperties(context, patternDescr, pattern);
    List<String> listenedProperties = new ArrayList<>();
    for (String propertyName : watchedValues.split("","")) {
        propertyName = propertyName.trim();
        if (propertyName.equals(""*"") || propertyName.equals(""!*"")) {
            if (listenedProperties.contains(""*"") || listenedProperties.contains(""!*"")) {
                registerDescrBuildError(context, patternDescr, ""Duplicate usage of wildcard * in @"" + Watch.class.getSimpleName() + "" annotation"");
            } else {
                listenedProperties.add(propertyName);
            }
            continue;
        }
        boolean isNegative = propertyName.startsWith(""!"");
        propertyName = isNegative ? propertyName.substring(1).trim() : propertyName;
        if (settableProperties != null && !settableProperties.contains(propertyName)) {
            registerDescrBuildError(context, patternDescr, ""Unknown property "" + propertyName + "" in @"" + Watch.class.getSimpleName() + "" annotation"");
        } else if (listenedProperties.contains(propertyName) || listenedProperties.contains(""!"" + propertyName)) {
            registerDescrBuildError(context, patternDescr, ""Duplicate property "" + propertyName + "" in @"" + Watch.class.getSimpleName() + "" annotation"");
        } else {
            listenedProperties.add(isNegative ? ""!"" + propertyName : propertyName);
        }
    }
    pattern.addWatchedProperties(listenedProperties);
}",java:S3776,39
"private void processConstraintsAndBinds(RuleBuildContext context, PatternDescr patternDescr, Declaration xpathStartDeclaration, Pattern pattern){
    DumperContext mvelCtx = new DumperContext().setRuleContext(context);
    for (BaseDescr b : patternDescr.getDescrs()) {
        String expression;
        boolean isPositional = false;
        if (b instanceof BindingDescr) {
            BindingDescr bind = (BindingDescr) b;
            expression = bind.getVariable() + (bind.isUnification() ? "" := "" : "" : "") + bind.getExpression();
        } else if (b instanceof ExprConstraintDescr) {
            ExprConstraintDescr descr = (ExprConstraintDescr) b;
            expression = descr.getExpression();
            isPositional = descr.getType() == ExprConstraintDescr.Type.POSITIONAL;
        } else {
            expression = b.getText();
        }
        ConstraintConnectiveDescr result = parseExpression(context, patternDescr, b, expression);
        if (result == null) {
            return;
        }
        result.setNegated(b.isNegated());
        isPositional &= !(result.getDescrs().size() == 1 && result.getDescrs().get(0) instanceof BindingDescr);
        if (isPositional) {
            processPositional(context, patternDescr, xpathStartDeclaration, pattern, (ExprConstraintDescr) b);
        } else {
            List<Constraint> constraints = build(context, patternDescr, xpathStartDeclaration, pattern, result, mvelCtx);
            pattern.addConstraints(constraints);
        }
    }
    TypeDeclaration typeDeclaration = getTypeDeclaration(pattern, context);
    if (typeDeclaration != null && typeDeclaration.isPropertyReactive()) {
        for (String field : lookAheadFieldsOfIdentifier(context.getRuleDescr(), patternDescr)) {
            addFieldToPatternWatchlist(pattern, typeDeclaration, field);
        }
    }
}",java:S3776,39
"public static Collection<String> lookAheadFieldsOfIdentifier(RuleDescr ruleDescr, PatternDescr patternDescr){
    String identifier = patternDescr.getIdentifier();
    if (identifier == null) {
        return Collections.emptyList();
    }
    Collection<String> props = new HashSet<>();
    for (PatternDescr pattern : ruleDescr.getLhs().getAllPatternDescr()) {
        if (pattern == patternDescr) {
            continue;
        }
        if (pattern != null) {
            for (BaseDescr expr : pattern.getDescrs()) {
                if (expr instanceof ExprConstraintDescr) {
                    String text = expr.getText();
                    int pos = text.indexOf(identifier + ""."");
                    if (pos == 0 || (pos > 0 && !Character.isJavaIdentifierPart(text.charAt(pos - 1)))) {
                        String prop = StringUtils.extractFirstIdentifier(text, pos + identifier.length() + 1);
                        String propFromGetter = ClassUtils.getter2property(prop);
                        props.add(propFromGetter != null ? propFromGetter : StringUtils.lcFirst(prop));
                    }
                }
            }
            if (isPassThroughPattern(pattern, identifier)) {
                props.addAll(collectProps(pattern));
            }
        }
    }
    return props;
}",java:S3776,39
"private List<Constraint> build(RuleBuildContext context, PatternDescr patternDescr, Declaration xpathStartDeclaration, Pattern pattern, ConstraintConnectiveDescr descr, DumperContext mvelCtx){
    List<Constraint> constraints = new ArrayList<>();
    List<BaseDescr> initialDescrs = new ArrayList<>(descr.getDescrs());
    for (BaseDescr d : initialDescrs) {
        boolean isXPath = isXPathDescr(d);
        if (isXPath && pattern.hasXPath()) {
            registerDescrBuildError(context, patternDescr, ""More than a single oopath constraint is not allowed in the same pattern"");
            return constraints;
        }
        context.setXpathOffsetadjustment(xpathStartDeclaration == null ? 0 : -1);
        Constraint constraint = isXPath ? buildXPathDescr(context, patternDescr, xpathStartDeclaration, pattern, (ExpressionDescr) d, mvelCtx) : buildCcdDescr(context, patternDescr, xpathStartDeclaration, pattern, d, descr, mvelCtx);
        if (constraint != null) {
            Declaration declCorrXpath = getDeclarationCorrespondingToXpath(pattern, isXPath, constraint);
            if (declCorrXpath == null) {
                constraints.add(constraint);
            } else {
                Pattern modifiedPattern = pattern.clone();
                modifiedPattern.setObjectType(new ClassObjectType(declCorrXpath.getDeclarationClass()));
                constraint = buildCcdDescr(context, patternDescr, xpathStartDeclaration, modifiedPattern, d.replaceVariable(declCorrXpath.getBindingName(), ""this""), descr, mvelCtx);
                if (constraint != null) {
                    pattern.getXpathConstraint().getChunks().getLast().addConstraint(constraint);
                }
            }
        }
    }
    if (descr.getDescrs().size() > initialDescrs.size()) {
        List<BaseDescr> additionalDescrs = new ArrayList<>(descr.getDescrs());
        additionalDescrs.removeAll(initialDescrs);
        if (!additionalDescrs.isEmpty()) {
            List<Constraint> additionalConstraints = new ArrayList<>();
            for (BaseDescr d : additionalDescrs) {
                Constraint constraint = buildCcdDescr(context, patternDescr, xpathStartDeclaration, pattern, d, descr, mvelCtx);
                if (constraint != null) {
                    additionalConstraints.add(constraint);
                }
            }
            constraints.addAll(0, additionalConstraints);
        }
    }
    return constraints;
}",java:S3776,39
"private Constraint buildXPathDescr(RuleBuildContext context, PatternDescr patternDescr, Declaration xpathStartDeclaration, Pattern pattern, ExpressionDescr descr, DumperContext mvelCtx){
    String expression = descr.getExpression();
    XpathAnalysis xpathAnalysis = XpathAnalysis.analyze(expression);
    if (xpathAnalysis.hasError()) {
        registerDescrBuildError(context, patternDescr, ""Invalid xpath expression '"" + expression + ""': "" + xpathAnalysis.getError());
        return null;
    }
    XpathConstraint xpathConstraint = new XpathConstraint();
    ObjectType objectType = pattern.getObjectType();
    if (objectType.isTemplate()) {
        throw new UnsupportedOperationException(""xpath is not supported with fact templates"");
    }
    Class<?> patternClass = ((ClassObjectType) objectType).getClassType();
    List<Class<?>> backReferenceClasses = new ArrayList<>();
    backReferenceClasses.add(patternClass);
    XpathBackReference backRef = new XpathBackReference(pattern, backReferenceClasses);
    pattern.setBackRefDeclarations(backRef);
    ObjectType originalType = pattern.getObjectType();
    ObjectType currentObjectType = originalType;
    mvelCtx.setInXpath(true);
    try {
        for (XpathAnalysis.XpathPart part : xpathAnalysis) {
            XpathConstraint.XpathChunk xpathChunk = xpathConstraint.addChunck(patternClass, part.getField(), part.getIndex(), part.isIterate(), part.isLazy());
            context.getPkg().wireObjectType(currentObjectType, xpathChunk);
            if (xpathChunk == null) {
                registerDescrBuildError(context, patternDescr, ""Invalid xpath expression '"" + expression + ""': cannot access "" + part.getField() + "" on "" + patternClass);
                pattern.setObjectType(originalType);
                return null;
            }
            if (part.getInlineCast() != null) {
                try {
                    patternClass = context.getDialect().getTypeResolver().resolveType(part.getInlineCast());
                } catch (ClassNotFoundException e) {
                    registerDescrBuildError(context, patternDescr, ""Unknown class "" + part.getInlineCast() + "" in xpath expression '"" + expression + ""'"");
                    return null;
                }
                part.addInlineCastConstraint(patternClass);
                currentObjectType = getObjectType(context, patternDescr, patternClass.getName());
                xpathChunk.setReturnedType(currentObjectType);
            } else {
                patternClass = xpathChunk.getReturnedClass();
                currentObjectType = getObjectType(context, patternDescr, patternClass.getName());
            }
            context.increaseXpathChuckNr();
            pattern.setObjectType(currentObjectType);
            backReferenceClasses.add(0, patternClass);
            backRef.reset();
            for (String constraint : part.getConstraints()) {
                ConstraintConnectiveDescr result = parseExpression(context, patternDescr, new ExprConstraintDescr(constraint), constraint);
                if (result == null) {
                    continue;
                }
                int chunkNbr = context.getXpathChuckNr();
                for (Constraint c : build(context, patternDescr, xpathStartDeclaration, pattern, result, mvelCtx)) {
                    xpathChunk.addConstraint(c);
                }
                context.setXpathChuckNr(chunkNbr);
            }
        }
        xpathConstraint.setXpathStartDeclaration(xpathStartDeclaration);
        if (descr instanceof BindingDescr) {
            Declaration pathDeclr = pattern.addDeclaration(((BindingDescr) descr).getVariable());
            pathDeclr.setxPathOffset(context.getXpathChuckNr());
            xpathConstraint.setDeclaration(pathDeclr);
        }
    } finally {
        mvelCtx.setInXpath(false);
        pattern.setBackRefDeclarations(null);
        pattern.setObjectType(originalType);
        context.resetXpathChuckNr();
    }
    return xpathConstraint;
}",java:S3776,39
"private String rewriteCompositeExpressions(RuleBuildContext context, Pattern pattern, ConstraintConnectiveDescr d){
    int i = 0;
    StringBuilder sb = new StringBuilder();
    for (BaseDescr subDescr : d.getDescrs()) {
        if (subDescr instanceof BindingDescr) {
            continue;
        }
        if (i++ > 0) {
            sb.append("" "").append(d.getConnective().getConnective()).append("" "");
        }
        String normalizedExpr;
        if (subDescr instanceof RelationalExprDescr && isSimpleExpr((RelationalExprDescr) subDescr)) {
            RelationalExprDescr relDescr = (RelationalExprDescr) subDescr;
            if (relDescr.getExpression() != null) {
                normalizedExpr = normalizeExpression(context, pattern, relDescr, relDescr.getExpression());
            } else {
                i--;
                normalizedExpr = """";
            }
        } else if (subDescr instanceof ConstraintConnectiveDescr) {
            String rewrittenExpr = rewriteCompositeExpressions(context, pattern, (ConstraintConnectiveDescr) subDescr);
            if (rewrittenExpr == null) {
                return null;
            }
            normalizedExpr = ""("" + rewrittenExpr + "")"";
        } else if (subDescr instanceof AtomicExprDescr) {
            normalizedExpr = ((AtomicExprDescr) subDescr).getRewrittenExpression();
        } else {
            return null;
        }
        sb.append(normalizedExpr);
    }
    return sb.toString();
}",java:S3776,39
"protected Constraint buildConstraintForPattern(final RuleBuildContext context, final Pattern pattern, final RelationalExprDescr relDescr, String expr, String value1, String value2, boolean isConstant, Map<String, OperatorDescr> aliases){
    ReadAccessor extractor = getFieldReadAccessor(context, relDescr, pattern, value1, null, true);
    if (extractor == null) {
        return null;
    }
    if (""contains"".equals(relDescr.getOperator()) && !isTypeCompatibleWithContainsOperator(extractor.getExtractToClass())) {
        registerDescrBuildError(context, relDescr, ""Cannot use contains on "" + extractor.getExtractToClass() + "" in expression '"" + expr + ""'"");
        return null;
    }
    int dotPos = value1.indexOf('.');
    if (dotPos > 0) {
        String part0 = value1.substring(0, dotPos).trim();
        if (""this"".equals(part0.trim())) {
            value1 = value1.substring(dotPos + 1);
        } else if (pattern.getDeclaration() != null && part0.equals(pattern.getDeclaration().getIdentifier())) {
            value1 = value1.substring(dotPos + 1);
            expr = expr.substring(dotPos + 1);
        }
    }
    LiteralRestrictionDescr restrictionDescr = buildLiteralRestrictionDescr(context, relDescr, value2, isConstant);
    if (restrictionDescr != null) {
        ValueType vtype = extractor.getValueType();
        FieldValue field = ConstraintBuilder.get().getMvelFieldValue(context, vtype, restrictionDescr.getText().trim());
        if (field != null) {
            Constraint constraint = getConstraintBuilder().buildLiteralConstraint(context, pattern, vtype, field, expr, value1, relDescr.getOperator(), relDescr.isNegated(), value2, extractor, restrictionDescr, aliases);
            if (constraint != null) {
                return constraint;
            }
        }
    }
    value2 = context.getDeclarationResolver().normalizeValueForUnit(value2);
    Declaration declr = null;
    if (value2.indexOf('(') < 0 && value2.indexOf('.') < 0 && value2.indexOf('[') < 0) {
        declr = context.getDeclarationResolver().getDeclaration(value2);
        if (declr == null) {
            final Pattern thisPattern = (Pattern) context.getDeclarationResolver().peekBuildStack();
            declr = createDeclarationObject(context, value2, thisPattern);
        }
    }
    Declaration[] declarations = null;
    if (declr == null) {
        String[] parts = value2.split(""\\."");
        if (parts.length == 2) {
            if (""this"".equals(parts[0].trim())) {
                declr = createDeclarationObject(context, parts[1].trim(), (Pattern) context.getDeclarationResolver().peekBuildStack());
                value2 = parts[1].trim();
            } else {
                declr = context.getDeclarationResolver().getDeclaration(parts[0].trim());
                if (declr != null) {
                    if (declr.isPatternDeclaration()) {
                        declarations = new Declaration[] { declr };
                        declr = createDeclarationObject(context, parts[1].trim(), declr.getPattern());
                        value2 = parts[1].trim();
                    } else {
                        return null;
                    }
                }
            }
        }
    }
    if (declarations == null) {
        if (declr != null) {
            declarations = new Declaration[] { declr };
        } else {
            declarations = getDeclarationsForReturnValue(context, relDescr, value2);
            if (declarations == null) {
                return null;
            }
        }
    }
    return getConstraintBuilder().buildVariableConstraint(context, pattern, expr, declarations, value1, relDescr.getOperatorDescr(), value2, extractor, declr, relDescr, aliases);
}",java:S3776,39
"protected Constraint buildConstraintForPattern(final RuleBuildContext context, final Pattern pattern, final RelationalExprDescr relDescr, String expr, String value1, String value2, boolean isConstant, Map<String, OperatorDescr> aliases){
    ReadAccessor extractor = getFieldReadAccessor(context, relDescr, pattern, value1, null, true);
    if (extractor == null) {
        return null;
    }
    if (""contains"".equals(relDescr.getOperator()) && !isTypeCompatibleWithContainsOperator(extractor.getExtractToClass())) {
        registerDescrBuildError(context, relDescr, ""Cannot use contains on "" + extractor.getExtractToClass() + "" in expression '"" + expr + ""'"");
        return null;
    }
    int dotPos = value1.indexOf('.');
    if (dotPos > 0) {
        String part0 = value1.substring(0, dotPos).trim();
        if (""this"".equals(part0.trim())) {
            value1 = value1.substring(dotPos + 1);
        } else if (pattern.getDeclaration() != null && part0.equals(pattern.getDeclaration().getIdentifier())) {
            value1 = value1.substring(dotPos + 1);
            expr = expr.substring(dotPos + 1);
        }
    }
    LiteralRestrictionDescr restrictionDescr = buildLiteralRestrictionDescr(context, relDescr, value2, isConstant);
    if (restrictionDescr != null) {
        ValueType vtype = extractor.getValueType();
        FieldValue field = ConstraintBuilder.get().getMvelFieldValue(context, vtype, restrictionDescr.getText().trim());
        if (field != null) {
            Constraint constraint = getConstraintBuilder().buildLiteralConstraint(context, pattern, vtype, field, expr, value1, relDescr.getOperator(), relDescr.isNegated(), value2, extractor, restrictionDescr, aliases);
            if (constraint != null) {
                return constraint;
            }
        }
    }
    value2 = context.getDeclarationResolver().normalizeValueForUnit(value2);
    Declaration declr = null;
    if (value2.indexOf('(') < 0 && value2.indexOf('.') < 0 && value2.indexOf('[') < 0) {
        declr = context.getDeclarationResolver().getDeclaration(value2);
        if (declr == null) {
            final Pattern thisPattern = (Pattern) context.getDeclarationResolver().peekBuildStack();
            declr = createDeclarationObject(context, value2, thisPattern);
        }
    }
    Declaration[] declarations = null;
    if (declr == null) {
        String[] parts = value2.split(""\\."");
        if (parts.length == 2) {
            if (""this"".equals(parts[0].trim())) {
                declr = createDeclarationObject(context, parts[1].trim(), (Pattern) context.getDeclarationResolver().peekBuildStack());
                value2 = parts[1].trim();
            } else {
                declr = context.getDeclarationResolver().getDeclaration(parts[0].trim());
                if (declr != null) {
                    if (declr.isPatternDeclaration()) {
                        declarations = new Declaration[] { declr };
                        declr = createDeclarationObject(context, parts[1].trim(), declr.getPattern());
                        value2 = parts[1].trim();
                    } else {
                        return null;
                    }
                }
            }
        }
    }
    if (declarations == null) {
        if (declr != null) {
            declarations = new Declaration[] { declr };
        } else {
            declarations = getDeclarationsForReturnValue(context, relDescr, value2);
            if (declarations == null) {
                return null;
            }
        }
    }
    return getConstraintBuilder().buildVariableConstraint(context, pattern, expr, declarations, value1, relDescr.getOperatorDescr(), value2, extractor, declr, relDescr, aliases);
}",java:S107,1
"private static Declaration createDeclarationForOperator(RuleBuildContext context, Pattern pattern, String expr){
    Declaration declaration;
    int dotPos = expr.indexOf('.');
    if (dotPos < 0) {
        if (!isIdentifier(expr)) {
            return null;
        }
        declaration = context.getDeclarationResolver().getDeclaration(expr);
        if (declaration == null) {
            if (""this"".equals(expr)) {
                declaration = createDeclarationObject(context, ""this"", pattern);
            } else {
                declaration = new Declaration(""this"", pattern);
                context.getPkg().getReader(pattern.getObjectType().getClassName(), expr, declaration);
            }
        }
    } else {
        String part1 = expr.substring(0, dotPos).trim();
        String part2 = expr.substring(dotPos + 1).trim();
        if (""this"".equals(part1)) {
            declaration = createDeclarationObject(context, part2, (Pattern) context.getDeclarationResolver().peekBuildStack());
        } else {
            declaration = context.getDeclarationResolver().getDeclaration(part1);
            if (declaration != null) {
                declaration = createDeclarationObject(context, part2, declaration.getPattern());
            }
        }
    }
    return declaration;
}",java:S3776,39
"public static ReadAccessor getFieldReadAccessor(final RuleBuildContext context, final BaseDescr descr, final Pattern pattern, final ObjectType objectType, String fieldName, final AcceptsReadAccessor target, final boolean reportError){
    ReadAccessor reader;
    if (ValueType.FACTTEMPLATE_TYPE.equals(objectType.getValueType())) {
        final FactTemplate factTemplate = ((FactTemplateObjectType) objectType).getFactTemplate();
        reader = new FactTemplateFieldExtractor(factTemplate, fieldName);
        if (target != null) {
            target.setReadAccessor(reader);
        }
        return reader;
    }
    boolean isGetter = getterRegexp.matcher(fieldName).matches();
    if (isGetter) {
        fieldName = fieldName.substring(3, fieldName.indexOf('(')).trim();
    }
    if (isGetter || identifierRegexp.matcher(fieldName).matches()) {
        Declaration decl = context.getDeclarationResolver().getDeclarations(context.getRule()).get(fieldName);
        if (decl != null && decl.getExtractor() instanceof FieldNameSupplier && ""this"".equals(((FieldNameSupplier) decl.getExtractor()).getFieldName())) {
            return decl.getExtractor();
        }
        try {
            reader = context.getPkg().getReader(objectType.getClassName(), fieldName, target);
        } catch (final Exception e) {
            if (reportError && context.isTypesafe()) {
                registerDescrBuildError(context, descr, e, ""Unable to create Field Extractor for '"" + fieldName + ""'"" + e.getMessage());
            }
            reader = null;
        } finally {
            if (reportError) {
                Collection<KnowledgeBuilderResult> results = context.getPkg().getWiringResults(((ClassObjectType) objectType).getClassType(), fieldName);
                if (!results.isEmpty()) {
                    for (KnowledgeBuilderResult res : results) {
                        if (res.getSeverity() == ResultSeverity.ERROR) {
                            context.addError(new DroolsErrorWrapper(res));
                        } else {
                            context.addWarning(new DroolsWarningWrapper(res));
                        }
                    }
                }
            }
        }
    } else {
        reader = ConstraintBuilder.get().buildMvelFieldReadAccessor(context, descr, pattern, objectType, fieldName, reportError);
    }
    return reader;
}",java:S3776,39
"protected void postBuild(RuleBuildContext context, QueryDescr queryDescr, QueryImpl query, String[] params, String[] types, Declaration[] declarations){
}",java:S1186,16
"protected String[] getQueryTypes(QueryDescr queryDescr, QueryImpl query){
    return queryDescr.getParameterTypes();
}",java:S1172,13
"public RuleConditionElement build(RuleBuildContext context, BaseDescr descr, QueryImpl query){
    PatternDescr patternDescr = (PatternDescr) descr;
    Declaration[] params = query.getParameters();
    List<BaseDescr> args = (List<BaseDescr>) patternDescr.getDescrs();
    List<Declaration> requiredDeclarations = new ArrayList<>();
    ObjectType argsObjectType = ClassObjectType.ObjectArray_ObjectType;
    ReadAccessor arrayReader = new SelfReferenceClassFieldReader(Object[].class);
    Pattern pattern = new Pattern(context.getNextPatternId(), 0, 0, argsObjectType, null);
    if (!StringUtils.isEmpty(patternDescr.getIdentifier())) {
        if (query.isAbductive()) {
            Declaration declr = context.getDeclarationResolver().getDeclaration(patternDescr.getIdentifier());
            if (declr != null && !patternDescr.isUnification()) {
                context.addError(new DescrBuildError(context.getParentDescr(), descr, null, ""Duplicate declaration "" + patternDescr.getIdentifier() + "", unable to bind abducted value""));
            }
        } else {
            context.addError(new DescrBuildError(context.getParentDescr(), descr, null, ""Query binding is not supported by non-abductive queries : "" + patternDescr.getIdentifier()));
        }
    }
    boolean addAbductiveReturnArgument = query.isAbductive() && !StringUtils.isEmpty(patternDescr.getIdentifier()) && args.size() < params.length;
    if (addAbductiveReturnArgument) {
        ExprConstraintDescr extraDescr = new ExprConstraintDescr(patternDescr.getIdentifier());
        extraDescr.setPosition(patternDescr.getConstraint().getDescrs().size());
        extraDescr.setType(ExprConstraintDescr.Type.POSITIONAL);
        args.add(extraDescr);
    }
    QueryArgument[] arguments = new QueryArgument[params.length];
    for (BaseDescr base : args) {
        String expression = null;
        boolean isPositional = false;
        boolean isBinding = false;
        BindingDescr bind = null;
        ConstraintConnectiveDescr result = null;
        if (base instanceof BindingDescr) {
            bind = (BindingDescr) base;
            expression = bind.getVariable() + (bind.isUnification() ? "" := "" : "" : "") + bind.getExpression();
            isBinding = true;
        } else {
            if (base instanceof ExprConstraintDescr) {
                ExprConstraintDescr ecd = (ExprConstraintDescr) base;
                expression = ecd.getExpression();
                isPositional = ecd.getType() == ExprConstraintDescr.Type.POSITIONAL;
            } else {
                expression = base.getText();
            }
            result = parseExpression(context, patternDescr, expression);
            if (result == null) {
                context.addError(new DescrBuildError(context.getParentDescr(), descr, null, ""Unable to parse constraint: \n"" + expression));
                continue;
            }
            isBinding = result.getDescrs().size() == 1 && result.getDescrs().get(0) instanceof BindingDescr;
            if (isBinding) {
                bind = (BindingDescr) result.getDescrs().get(0);
            }
        }
        if ((!isPositional) && (!isBinding)) {
            context.addError(new DescrBuildError(context.getParentDescr(), descr, null, ""Query's must use positional or bindings, not field constraints:\n"" + expression));
        } else if (isPositional && isBinding) {
            context.addError(new DescrBuildError(context.getParentDescr(), descr, null, ""Query's can't use positional bindings:\n"" + expression));
        } else if (isPositional) {
            processPositional(context, query, params, arguments, requiredDeclarations, arrayReader, pattern, base, expression, result);
        } else {
            processBinding(context, descr, params, arguments, requiredDeclarations, arrayReader, pattern, bind);
        }
    }
    List<Integer> varIndexList = new ArrayList<>();
    for (int i = 0; i < arguments.length; i++) {
        if (!(arguments[i] instanceof QueryArgument.Declr)) {
            if (arguments[i] instanceof QueryArgument.Var) {
                varIndexList.add(i);
            }
            continue;
        }
        Class actual = ((QueryArgument.Declr) arguments[i]).getArgumentClass();
        Declaration formalArgument = query.getParameters()[i];
        Class formal = formalArgument.getDeclarationClass();
        if (!ClassUtils.isTypeCompatibleWithArgumentType(actual, formal) && !ClassUtils.isTypeCompatibleWithArgumentType(formal, actual)) {
            context.addError(new DescrBuildError(context.getParentDescr(), descr, null, ""Query is being invoked with known argument of type "" + actual + "" at position "" + i + "", but the expected query argument is of type "" + formal));
        }
    }
    return new QueryElement(pattern, query.getName(), arguments, toIntArray(varIndexList), requiredDeclarations.toArray(new Declaration[requiredDeclarations.size()]), !patternDescr.isQuery(), query.isAbductive());
}",java:S3776,39
"private void processBinding(RuleBuildContext context, BaseDescr descr, Declaration[] params, QueryArgument[] arguments, List<Declaration> requiredDeclarations, ReadAccessor arrayReader, Pattern pattern, BindingDescr bind){
    Declaration declr = context.getDeclarationResolver().getDeclaration(bind.getVariable());
    if (declr != null) {
        int pos = getPos(bind.getExpression(), params);
        if (pos >= 0) {
            String slot = bind.getExpression();
            String var = bind.getVariable();
            bind.setVariable(slot);
            bind.setExpression(var);
        } else {
        }
    }
    int pos = getPos(bind.getVariable(), params);
    if (pos >= 0) {
        declr = context.getDeclarationResolver().getDeclaration(bind.getExpression());
        if (declr != null) {
            requiredDeclarations.add(declr);
            arguments[pos] = new QueryArgument.Declr(declr);
        } else {
            DrlExprParser parser = new DrlExprParser(context.getConfiguration().getOption(LanguageLevelOption.KEY));
            ConstraintConnectiveDescr bresult = parser.parse(bind.getExpression());
            if (parser.hasErrors()) {
                for (DroolsParserException error : parser.getErrors()) {
                    context.addError(new DescrBuildError(context.getParentDescr(), descr, null, ""Unable to parser pattern expression:\n"" + error.getMessage()));
                }
                return;
            }
            arguments[pos] = getLiteralQueryArgument(context, descr, bresult);
        }
    } else {
        pos = getPos(bind.getExpression(), params);
        if (pos < 0) {
            context.addError(new DescrBuildError(context.getParentDescr(), descr, null, ""named argument does not exist:\n"" + bind.getExpression()));
            return;
        }
        arguments[pos] = getVariableQueryArgument(arrayReader, params, pos, pattern, bind.getVariable());
    }
}",java:S3776,39
"private void processBinding(RuleBuildContext context, BaseDescr descr, Declaration[] params, QueryArgument[] arguments, List<Declaration> requiredDeclarations, ReadAccessor arrayReader, Pattern pattern, BindingDescr bind){
    Declaration declr = context.getDeclarationResolver().getDeclaration(bind.getVariable());
    if (declr != null) {
        int pos = getPos(bind.getExpression(), params);
        if (pos >= 0) {
            String slot = bind.getExpression();
            String var = bind.getVariable();
            bind.setVariable(slot);
            bind.setExpression(var);
        } else {
        }
    }
    int pos = getPos(bind.getVariable(), params);
    if (pos >= 0) {
        declr = context.getDeclarationResolver().getDeclaration(bind.getExpression());
        if (declr != null) {
            requiredDeclarations.add(declr);
            arguments[pos] = new QueryArgument.Declr(declr);
        } else {
            DrlExprParser parser = new DrlExprParser(context.getConfiguration().getOption(LanguageLevelOption.KEY));
            ConstraintConnectiveDescr bresult = parser.parse(bind.getExpression());
            if (parser.hasErrors()) {
                for (DroolsParserException error : parser.getErrors()) {
                    context.addError(new DescrBuildError(context.getParentDescr(), descr, null, ""Unable to parser pattern expression:\n"" + error.getMessage()));
                }
                return;
            }
            arguments[pos] = getLiteralQueryArgument(context, descr, bresult);
        }
    } else {
        pos = getPos(bind.getExpression(), params);
        if (pos < 0) {
            context.addError(new DescrBuildError(context.getParentDescr(), descr, null, ""named argument does not exist:\n"" + bind.getExpression()));
            return;
        }
        arguments[pos] = getVariableQueryArgument(arrayReader, params, pos, pattern, bind.getVariable());
    }
}",java:S107,1
"private void processPositional(RuleBuildContext context, QueryImpl query, Declaration[] params, QueryArgument[] arguments, List<Declaration> requiredDeclarations, ReadAccessor arrayReader, Pattern pattern, BaseDescr base, String expression, ConstraintConnectiveDescr result){
    int pos = ((ExprConstraintDescr) base).getPosition();
    if (pos >= arguments.length) {
        context.addError(new DescrBuildError(context.getParentDescr(), base, null, ""Unable to parse query '"" + query.getName() + ""', as postion "" + pos + "" for expression '"" + expression + ""' does not exist on query size "" + arguments.length));
        return;
    }
    boolean isVariable = isVariable(expression);
    DeclarationScopeResolver declarationResolver = context.getDeclarationResolver();
    Declaration declr = isVariable ? declarationResolver.getDeclaration(expression) : null;
    if (declr != null) {
        requiredDeclarations.add(declr);
        arguments[pos] = new QueryArgument.Declr(declr);
    } else if (isVariable && expression.indexOf('.') < 0) {
        arguments[pos] = getVariableQueryArgument(arrayReader, params, pos, pattern, expression);
    } else {
        AnalysisResult analysisResult = analyzeExpression(context, base, expression);
        if (analysisResult == null || analysisResult.getIdentifiers().isEmpty()) {
            arguments[pos] = getLiteralQueryArgument(context, base, result);
        } else {
            List<Declaration> declarations = new ArrayList<>();
            for (String identifier : analysisResult.getIdentifiers()) {
                Declaration declaration = declarationResolver.getDeclaration(identifier);
                if (declaration != null) {
                    declarations.add(declaration);
                }
            }
            if (declarations.size() == analysisResult.getIdentifiers().size()) {
                arguments[pos] = ConstraintBuilder.get().buildExpressionQueryArgument(context, declarations, expression);
            } else {
                arguments[pos] = getLiteralQueryArgument(context, base, result);
            }
        }
    }
}",java:S3776,39
"private void processPositional(RuleBuildContext context, QueryImpl query, Declaration[] params, QueryArgument[] arguments, List<Declaration> requiredDeclarations, ReadAccessor arrayReader, Pattern pattern, BaseDescr base, String expression, ConstraintConnectiveDescr result){
    int pos = ((ExprConstraintDescr) base).getPosition();
    if (pos >= arguments.length) {
        context.addError(new DescrBuildError(context.getParentDescr(), base, null, ""Unable to parse query '"" + query.getName() + ""', as postion "" + pos + "" for expression '"" + expression + ""' does not exist on query size "" + arguments.length));
        return;
    }
    boolean isVariable = isVariable(expression);
    DeclarationScopeResolver declarationResolver = context.getDeclarationResolver();
    Declaration declr = isVariable ? declarationResolver.getDeclaration(expression) : null;
    if (declr != null) {
        requiredDeclarations.add(declr);
        arguments[pos] = new QueryArgument.Declr(declr);
    } else if (isVariable && expression.indexOf('.') < 0) {
        arguments[pos] = getVariableQueryArgument(arrayReader, params, pos, pattern, expression);
    } else {
        AnalysisResult analysisResult = analyzeExpression(context, base, expression);
        if (analysisResult == null || analysisResult.getIdentifiers().isEmpty()) {
            arguments[pos] = getLiteralQueryArgument(context, base, result);
        } else {
            List<Declaration> declarations = new ArrayList<>();
            for (String identifier : analysisResult.getIdentifiers()) {
                Declaration declaration = declarationResolver.getDeclaration(identifier);
                if (declaration != null) {
                    declarations.add(declaration);
                }
            }
            if (declarations.size() == analysisResult.getIdentifiers().size()) {
                arguments[pos] = ConstraintBuilder.get().buildExpressionQueryArgument(context, declarations, expression);
            } else {
                arguments[pos] = getLiteralQueryArgument(context, base, result);
            }
        }
    }
}",java:S107,1
"private void initRuleUnitClassName(){
    String ruleUnitClassName = rule.getRuleUnitClassName();
    boolean nameInferredFromResource = false;
    if (ruleUnitClassName == null && rule.getResource() != null && rule.getResource().getSourcePath() != null) {
        ruleUnitClassName = extractClassNameFromSourcePath();
        nameInferredFromResource = true;
    }
    if (RuleUnitComponentFactory.get() != null && ruleUnitClassName != null) {
        TypeResolver typeResolver = getPkg().getTypeResolver();
        boolean unitFound = false;
        Class<?> ruleUnitClass = null;
        try {
            ruleUnitClass = typeResolver.resolveType(ruleUnitClassName);
        } catch (ClassNotFoundException e) {
            if (!nameInferredFromResource) {
                addError(new RuleBuildError(rule, getParentDescr(), null, ""Cannot find rule unit class "" + ruleUnitClassName));
                return;
            }
        }
        if (ruleUnitClass != null) {
            unitFound = RuleUnitComponentFactory.get().isRuleUnitClass(ruleUnitClass);
            if (unitFound && nameInferredFromResource) {
                rule.setRuleUnitClassName(ruleUnitClassName);
            }
            try {
                for (PropertyDescriptor prop : Introspector.getBeanInfo(ruleUnitClass).getPropertyDescriptors()) {
                    if (!""class"".equals(prop.getName())) {
                        getPkg().addGlobal(prop.getName(), prop.getPropertyType());
                    }
                }
            } catch (IntrospectionException e) {
                throw new RuntimeException();
            }
        }
        if (!unitFound && !nameInferredFromResource) {
            addError(new RuleBuildError(rule, getParentDescr(), null, ruleUnitClassName + "" must implement RuleUnitData""));
        }
    }
}",java:S3776,39
"public static void buildMetaAttributes(final RuleBuildContext context){
    RuleImpl rule = context.getRule();
    for (String metaAttr : context.getRuleDescr().getAnnotationNames()) {
        AnnotationDescr ad = context.getRuleDescr().getAnnotation(metaAttr);
        String adFqn = ad.getFullyQualifiedName();
        if (adFqn != null) {
            AnnotationDefinition annotationDefinition;
            try {
                annotationDefinition = AnnotationDefinition.build(context.getDialect().getTypeResolver().resolveType(adFqn), ad.getValueMap(), context.getDialect().getTypeResolver());
            } catch (NoSuchMethodException e) {
                throw new RuntimeException(e);
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
            if (annotationDefinition.getValues().size() == 1 && annotationDefinition.getValues().containsKey(AnnotationDescr.VALUE)) {
                rule.addMetaAttribute(metaAttr, annotationDefinition.getPropertyValue(AnnotationDescr.VALUE));
            } else {
                Map<String, Object> map = new HashMap<>(annotationDefinition.getValues().size());
                for (String key : annotationDefinition.getValues().keySet()) {
                    map.put(key, annotationDefinition.getPropertyValue(key));
                }
                rule.addMetaAttribute(metaAttr, map);
            }
        } else {
            if (ad.hasValue()) {
                if (ad.getValueMap().size() == 1) {
                    rule.addMetaAttribute(metaAttr, resolveValue(ad.getSingleValueAsString()));
                } else {
                    rule.addMetaAttribute(metaAttr, ad.getValueMap());
                }
            } else {
                rule.addMetaAttribute(metaAttr, null);
            }
        }
    }
}",java:S3776,39
"public static void buildAttributes(final RuleBuildContext context){
    final RuleImpl rule = context.getRule();
    final RuleDescr ruleDescr = context.getRuleDescr();
    boolean enforceEager = false;
    for (final AttributeDescr attributeDescr : ruleDescr.getAttributes().values()) {
        final String name = attributeDescr.getName();
        switch(name) {
            case ""no-loop"":
                rule.setNoLoop(getBooleanValue(attributeDescr, true));
                enforceEager = true;
                break;
            case ""auto-focus"":
                rule.setAutoFocus(getBooleanValue(attributeDescr, true));
                break;
            case ""agenda-group"":
                if (StringUtils.isEmpty(rule.getRuleFlowGroup())) {
                    rule.setAgendaGroup(attributeDescr.getValue());
                } else {
                    if (rule.getRuleFlowGroup().equals(attributeDescr.getValue())) {
                        DroolsWarning warn = new RuleBuildWarning(rule, context.getParentDescr(), null, ""Both an agenda-group ( "" + attributeDescr.getValue() + "" ) and a ruleflow-group ( "" + rule.getRuleFlowGroup() + "" ) are defined for rule "" + rule.getName() + "". Since version 6.x the "" + ""two concepts have been unified, the ruleflow-group name will override the agenda-group. "");
                        context.addWarning(warn);
                    }
                }
                break;
            case ""activation-group"":
                rule.setActivationGroup(attributeDescr.getValue());
                break;
            case ""ruleflow-group"":
                rule.setRuleFlowGroup(attributeDescr.getValue());
                if (!rule.getAgendaGroup().equals(InternalAgendaGroup.MAIN) && !rule.getAgendaGroup().equals(attributeDescr.getValue())) {
                    DroolsWarning warn = new RuleBuildWarning(rule, context.getParentDescr(), null, ""Both an agenda-group ( "" + attributeDescr.getValue() + "" ) and a ruleflow-group ( "" + rule.getRuleFlowGroup() + "" ) are defined for rule "" + rule.getName() + "". Since version 6.x the "" + ""two concepts have been unified, the ruleflow-group name will override the agenda-group. "");
                    context.addWarning(warn);
                }
                rule.setAgendaGroup(attributeDescr.getValue());
                break;
            case ""lock-on-active"":
                boolean lockOnActive = getBooleanValue(attributeDescr, true);
                rule.setLockOnActive(lockOnActive);
                enforceEager |= lockOnActive;
                break;
            case DroolsSoftKeywords.DURATION:
            case DroolsSoftKeywords.TIMER:
                String duration = attributeDescr.getValue();
                rule.setTimer(buildTimer(rule, duration, context));
                break;
            case ""calendars"":
                buildCalendars(rule, attributeDescr.getValue(), context);
                break;
            case ""date-effective"":
                try {
                    Date date = DateUtils.parseDate(attributeDescr.getValue());
                    final Calendar cal = Calendar.getInstance();
                    cal.setTime(date);
                    rule.setDateEffective(cal);
                } catch (Exception e) {
                    DroolsError err = new RuleBuildError(rule, context.getParentDescr(), null, ""Wrong date-effective value: "" + e.getMessage());
                    context.addError(err);
                }
                break;
            case ""date-expires"":
                try {
                    Date date = DateUtils.parseDate(attributeDescr.getValue());
                    final Calendar cal = Calendar.getInstance();
                    cal.setTime(date);
                    rule.setDateExpires(cal);
                } catch (Exception e) {
                    DroolsError err = new RuleBuildError(rule, context.getParentDescr(), null, ""Wrong date-expires value: "" + e.getMessage());
                    context.addError(err);
                }
                break;
        }
    }
    buildSalience(context);
    buildEnabled(context);
    parseAnnotation(context, rule, ruleDescr, enforceEager);
}",java:S3776,39
"public static Timer buildTimer(String timerString, RuleBuildContext context, Function<String, TimerExpression> exprCreator, Consumer<String> errorManager){
    if (timerString.indexOf('(') >= 0) {
        timerString = timerString.substring(timerString.indexOf('(') + 1, timerString.lastIndexOf(')')).trim();
    }
    int colonPos = timerString.indexOf("":"");
    int semicolonPos = timerString.indexOf("";"");
    String protocol = ""int"";
    if (colonPos == -1) {
        if (timerString.startsWith(""int"") || timerString.startsWith(""cron"") || timerString.startsWith(""expr"")) {
            errorManager.accept(""Incorrect timer definition '"" + timerString + ""' - missing colon?"");
            return null;
        }
    } else {
        protocol = timerString.substring(0, colonPos);
    }
    String startDate = extractParam(timerString, ""start"");
    String endDate = extractParam(timerString, ""end"");
    String repeatLimitString = extractParam(timerString, ""repeat-limit"");
    int repeatLimit = repeatLimitString != null ? Integer.parseInt(repeatLimitString) : -1;
    String body = timerString.substring(colonPos + 1, semicolonPos > 0 ? semicolonPos : timerString.length()).trim();
    if (""cron"".equals(protocol)) {
        try {
            return new CronTimer(exprCreator.apply(startDate), exprCreator.apply(endDate), repeatLimit, new CronExpression(body));
        } catch (ParseException e) {
            errorManager.accept(""Unable to build set timer '"" + timerString + ""'"");
            return null;
        }
    }
    if (""int"".equals(protocol)) {
        String[] times = body.trim().split(""\\s"");
        long delay = 0;
        long period = 0;
        if (times.length > 2) {
            errorManager.accept(""Incorrect number of arguments for interval timer '"" + timerString + ""'"");
            return null;
        }
        try {
            if (times.length == 1) {
                delay = TimeUtils.parseTimeString(times[0]);
            } else {
                delay = TimeUtils.parseTimeString(times[0]);
                period = TimeUtils.parseTimeString(times[1]);
            }
        } catch (RuntimeException e) {
            errorManager.accept(""Incorrect timer definition '"" + timerString + ""' "" + e.getMessage());
            return null;
        }
        return new IntervalTimer(exprCreator.apply(startDate), exprCreator.apply(endDate), repeatLimit, delay, period);
    }
    if (""expr"".equals(protocol)) {
        body = body.trim();
        StringTokenizer tok = new StringTokenizer(body, "",;"");
        if (tok.countTokens() > 2) {
            errorManager.accept(""Incorrect number of arguments for expression timer '"" + timerString + ""'"");
            return null;
        }
        TimerExpression times = createTimerExpression(context, exprCreator, tok.nextToken().trim());
        TimerExpression period = createTimerExpression(context, exprCreator, tok.hasMoreTokens() ? tok.nextToken().trim() : ""0"");
        return new ExpressionIntervalTimer(exprCreator.apply(startDate), exprCreator.apply(endDate), repeatLimit, times, period);
    }
    errorManager.accept(""Protocol for timer does not exist '"" + timerString + ""'"");
    return null;
}",java:S3776,39
"public static XpathAnalysis analyze(String xpath){
    List<XpathPart> parts = new ArrayList<>();
    boolean lazyPath = false;
    int i = 0;
    if (xpath.length() >= 1 && xpath.charAt(0) == '/') {
        i = 1;
    } else if (xpath.length() >= 2 && xpath.charAt(0) == '?' && xpath.charAt(1) == '/') {
        lazyPath = true;
        i = 2;
    } else {
        return new XpathAnalysis(parts, ""An oopath expression has to start with '/' or '?/'"");
    }
    List<String> constraints = new ArrayList<>();
    String inlineCast = null;
    int index = -1;
    int lastStart = i;
    int nestedParam = 0;
    int nestedSquare = 0;
    boolean iterate = true;
    boolean isQuoted = false;
    boolean isDoubleQuoted = false;
    boolean isInlineCast = false;
    String field = null;
    String error = null;
    int partStart = 0;
    for (; i < xpath.length() && error == null; i++) {
        switch(xpath.charAt(i)) {
            case '/':
            case '.':
                if (!isQuoted && nestedParam == 0 && nestedSquare == 0) {
                    if (field == null) {
                        field = xpath.substring(lastStart, xpath.charAt(i - 1) == '?' ? i - 1 : i).trim();
                    } else if (isInlineCast) {
                        inlineCast = xpath.substring(lastStart, xpath.charAt(i - 1) == '?' ? i - 1 : i).trim();
                        isInlineCast = false;
                    }
                    parts.add(new XpathPart(field, iterate, lazyPath, constraints, inlineCast, index, partStart));
                    partStart = i;
                    iterate = xpath.charAt(i) == '/';
                    if (xpath.charAt(i - 1) == '?') {
                        if (lazyPath) {
                            error = ""It is not possible to have 2 non-reactive parts in the same oopath"";
                            break;
                        } else {
                            lazyPath = true;
                        }
                    }
                    constraints = new ArrayList<>();
                    inlineCast = null;
                    index = -1;
                    lastStart = i + 1;
                    field = null;
                }
                break;
            case '(':
                if (!isQuoted) {
                    nestedParam++;
                }
                break;
            case ')':
                if (!isQuoted) {
                    nestedParam--;
                    if (nestedParam < 0) {
                        error = ""Unbalanced parenthesis"";
                    }
                }
                break;
            case '#':
                if (!isQuoted && nestedParam == 0 && nestedSquare == 0) {
                    if (field == null) {
                        field = xpath.substring(lastStart, i).trim();
                    }
                    lastStart = i + 1;
                    isInlineCast = true;
                }
                break;
            case '[':
                if (!isQuoted && nestedParam == 0) {
                    if (nestedSquare == 0) {
                        if (field == null) {
                            field = xpath.substring(lastStart, i).trim();
                        } else if (isInlineCast) {
                            inlineCast = xpath.substring(lastStart, i).trim();
                            isInlineCast = false;
                        }
                        lastStart = i + 1;
                    }
                    nestedSquare++;
                }
                break;
            case ']':
                if (!isQuoted && nestedParam == 0) {
                    nestedSquare--;
                    if (nestedSquare == 0) {
                        String constraint = xpath.substring(lastStart, i).trim();
                        if (Character.isDigit(constraint.charAt(0))) {
                            try {
                                index = Integer.parseInt(constraint);
                            } catch (Exception e) {
                                constraints.add(constraint);
                            }
                        } else {
                            constraints.add(constraint);
                        }
                    } else if (nestedSquare < 0) {
                        error = ""Unbalanced square brackets"";
                    }
                }
                break;
            case ',':
                if (!isQuoted && nestedParam == 0 && nestedSquare == 1) {
                    String constraint = xpath.substring(lastStart, i).trim();
                    constraints.add(constraint);
                    lastStart = i + 1;
                }
                break;
            case '""':
                if (isQuoted) {
                    if (isDoubleQuoted) {
                        isQuoted = false;
                        isDoubleQuoted = false;
                    }
                } else {
                    isQuoted = true;
                    isDoubleQuoted = true;
                }
                break;
            case '\'':
                if (isQuoted) {
                    if (!isDoubleQuoted) {
                        isQuoted = false;
                    }
                } else {
                    isQuoted = true;
                }
                break;
        }
    }
    if (field == null) {
        field = xpath.substring(lastStart).trim();
    } else if (isInlineCast) {
        inlineCast = xpath.substring(lastStart).trim();
        isInlineCast = false;
    }
    parts.add(new XpathPart(field, iterate, lazyPath, constraints, inlineCast, index, partStart));
    return new XpathAnalysis(parts, error);
}",java:S3776,39
"public String toString(){
    return ""[DialectError message='"" + this.message + ""']"";
}",java:S1161,11
" AbstractMediaEntity getMediaEntity(final MediaType expectedMediaType, final String albumId, final String mediaId){
    try {
        final AlbumDetail album = getMediaService().getAlbum(new NodePK(albumId, getComponentId()));
        final Media media = getMediaService().getMedia(new MediaPK(mediaId, getComponentId()));
        checkNotFoundStatus(media);
        verifyUserMediaAccess(media);
        verifyMediaIsInAlbum(media, album);
        if (media.getInternalMedia() != null) {
            checkMediaExistsWithRequestedMimeType(expectedMediaType, media, MediaResolution.PREVIEW);
        }
        return asWebEntity(media, album);
    } catch (final WebApplicationException ex) {
        throw ex;
    } catch (final Exception ex) {
        throw new WebApplicationException(ex, Status.SERVICE_UNAVAILABLE);
    }
}",java:S3740,38
"private static ChartPersonnVO buildFakePersonUnit(){
    ChartPersonnVO chart = new ChartPersonnVO();
    OrganizationBox rootOrganization = new OrganizationBox();
    List<UserVO> mainActors = new ArrayList<>();
    mainActors.add(new UserVO(""Laurent Morel"", ""l.morel"", ""Directeur""));
    mainActors.add(new UserVO(""Dupond Jean"", ""j.dupond"", ""Directeur associ""));
    rootOrganization.setName(""DGS"");
    rootOrganization.setDn(""OU=DGS,OU=Issy,dc=mondomain,dc=com"");
    rootOrganization.setMainActors(mainActors);
    rootOrganization.setParentDn(""OU=Issy,dc=mondomain,dc=com"");
    chart.setRootOrganization(rootOrganization);
    CategoryBox category1 = new CategoryBox();
    category1.setName(""Secrtaire"");
    List<UserVO> letusers = new ArrayList<>();
    letusers.add(new UserVO(""Murielle Dus"", ""m.duc"", null));
    letusers.add(new UserVO(""Camille Bet"", ""c.bet"", null));
    category1.setUsers(letusers);
    CategoryBox category2 = new CategoryBox();
    category2.setName(""Adjoints"");
    List<UserVO> rightusers = new ArrayList<>();
    rightusers.add(new UserVO(""Jeanne Calment"", ""m.duc"", null));
    rightusers.add(new UserVO(""Pierre Le Bon"", ""p.lebon"", null));
    category2.setUsers(rightusers);
    List<CategoryBox> categories = new ArrayList<>();
    categories.add(category1);
    categories.add(category2);
    chart.setCategories(categories);
    return chart;
}",java:S1144,10
"private String getActiveRoles(State state){
    QualifiedUsers workingUsers = state.getWorkingUsers();
    RelatedUser[] relatedUsers = workingUsers.getRelatedUsers();
    StringBuilder role = new StringBuilder();
    if (relatedUsers != null) {
        for (RelatedUser relatedUser : relatedUsers) {
            if (role.length() > 0) {
                role.append("", "");
            }
            Participant participant = relatedUser.getParticipant();
            String relation = relatedUser.getRelation();
            if (participant != null && relation == null) {
                role.append(participant.getLabel(currentRole, getLanguage()));
            } else if (participant != null) {
                String requesterId = getCreatorIdOfCurrentProcessInstance();
                if (requesterId != null) {
                    UserInfo userInfo = getSettingsOfUser(requesterId).getUserInfo(relation);
                    if (userInfo != null) {
                        role.append(getUserDetail(userInfo.getValue()).getDisplayedName());
                    }
                }
            }
            Item item = relatedUser.getFolderItem();
            if (item != null) {
                try {
                    Field field = currentProcessInstance.getField(item.getName());
                    if (field instanceof UserField) {
                        String userId = field.getStringValue();
                        if (userId != null) {
                            UserDetail user = getUserDetail(userId);
                            if (user != null) {
                                role.append(user.getDisplayedName());
                            }
                        }
                    } else if (field instanceof MultipleUserField) {
                        MultipleUserField multipleUserField = (MultipleUserField) field;
                        String[] userIds = multipleUserField.getUserIds();
                        for (String userId : userIds) {
                            if (userId != null) {
                                UserDetail user = getUserDetail(userId);
                                if (user != null) {
                                    if (role.length() > 0) {
                                        role.append("", "");
                                    }
                                    role.append(user.getDisplayedName());
                                }
                            }
                        }
                    }
                } catch (Exception e) {
                    SilverLogger.getLogger(this).warn(e);
                }
            }
        }
    }
    UserInRole[] userInRoles = workingUsers.getUserInRoles();
    if (userInRoles != null) {
        for (UserInRole userInRole : userInRoles) {
            if (role.length() > 0) {
                role.append("", "");
            }
            role.append(processModel.getRole(userInRole.getRoleName()).getLabel(currentRole, getLanguage()));
        }
    }
    RelatedGroup[] relatedGroups = workingUsers.getRelatedGroups();
    if (relatedGroups != null) {
        for (RelatedGroup relatedGroup : relatedGroups) {
            if (relatedGroup != null) {
                if (role.length() > 0) {
                    role.append("", "");
                }
                Item item = relatedGroup.getFolderItem();
                try {
                    if (item != null) {
                        String groupId = currentProcessInstance.getField(item.getName()).getStringValue();
                        if (groupId != null) {
                            Group group = getOrganisationController().getGroup(groupId);
                            if (group != null) {
                                role.append(group.getName());
                            }
                        }
                    }
                } catch (Exception e) {
                    SilverLogger.getLogger(this).warn(e);
                }
            }
        }
    }
    return role.toString();
}",java:S3776,39
"private List<String> getUsers(QualifiedUsers qualifiedUsers, boolean useCurrentRole){
    List<String> users = new ArrayList<>();
    RelatedUser[] relatedUsers = qualifiedUsers.getRelatedUsers();
    RelatedUser relatedUser;
    List<String> roles = new ArrayList<>();
    for (final RelatedUser relatedUser1 : relatedUsers) {
        relatedUser = relatedUser1;
        Participant participant = relatedUser.getParticipant();
        String relation = relatedUser.getRelation();
        if (participant != null && relation == null) {
            if (currentRole.equals(relatedUser.getRole())) {
                users.add(getActiveUser().getUserId());
            }
        } else if (participant != null) {
            String requesterId = getCreatorIdOfCurrentProcessInstance();
            if (requesterId != null) {
                UserInfo userInfo = getSettingsOfUser(requesterId).getUserInfo(relation);
                if (userInfo != null) {
                    users.add(userInfo.getValue());
                }
            }
        }
        Item item = relatedUser.getFolderItem();
        if (item != null) {
            try {
                Field field = currentProcessInstance.getField(item.getName());
                String role = relatedUser.getRole();
                if (field instanceof UserField) {
                    if ((isDefined(role) && currentRole.equals(role)) || StringUtil.isNotDefined(role)) {
                        users.add(field.getStringValue());
                    }
                } else if (field instanceof MultipleUserField) {
                    MultipleUserField multipleUserField = (MultipleUserField) field;
                    if ((isDefined(role) && currentRole.equals(role)) || StringUtil.isNotDefined(role)) {
                        users.addAll(Arrays.asList(multipleUserField.getUserIds()));
                    }
                }
            } catch (WorkflowException we) {
            }
        }
    }
    UserInRole[] userInRoles = qualifiedUsers.getUserInRoles();
    for (final UserInRole userInRole : userInRoles) {
        roles.add(userInRole.getRoleName());
    }
    if (useCurrentRole) {
        if (roles.contains(currentRole)) {
            roles.clear();
            roles.add(currentRole);
        } else {
            roles.clear();
        }
    }
    final boolean lookAlsoForRemoved = getCurrentReplacement() != null;
    final String[] userIds = getOrganisationController().getUsersIdsByRoleNames(getComponentId(), roles, lookAlsoForRemoved);
    users.addAll(Arrays.asList(userIds));
    RelatedGroup[] relatedGroups = qualifiedUsers.getRelatedGroups();
    if (relatedGroups != null) {
        for (RelatedGroup relatedGroup : relatedGroups) {
            if (relatedGroup != null) {
                String role = relatedGroup.getRole();
                if (currentRole.equals(role) || StringUtil.isNotDefined(role)) {
                    Item item = relatedGroup.getFolderItem();
                    if (item != null) {
                        try {
                            String groupId = currentProcessInstance.getField(item.getName()).getStringValue();
                            UserDetail[] usersOfGroup = getOrganisationController().getAllUsersOfGroup(groupId);
                            for (UserDetail userOfGroup : usersOfGroup) {
                                users.add(userOfGroup.getId());
                            }
                        } catch (WorkflowException we) {
                        }
                    }
                }
            }
        }
    }
    return users;
}",java:S3776,39
"private DataRecord getStepRecord(HistoryStep step){
    try {
        final Date actionDate = step.getActionDate();
        if (QUESTION_ACTION.equals(step.getAction())) {
            final Optional<Question> question = Arrays.stream(currentProcessInstance.getQuestions()).filter(q -> {
                if (step.getResolvedState().equals(q.getFromState().getName())) {
                    final Date questionDate = q.getQuestionDate();
                    final long elapsedTimeBetweenActionAndQuestion = questionDate.getTime() - actionDate.getTime();
                    return 0 < elapsedTimeBetweenActionAndQuestion && elapsedTimeBetweenActionAndQuestion < 30000;
                }
                return false;
            }).findFirst();
            return question.<DataRecord>map(q -> new QuestionRecord(q.getQuestionText())).orElse(null);
        } else if (RESPONSE_ACTION.equals(step.getAction())) {
            final Optional<Question> question = Arrays.stream(currentProcessInstance.getQuestions()).filter(q -> {
                if (step.getResolvedState().equals(q.getTargetState().getName())) {
                    final Date responseDate = q.getResponseDate();
                    final long elapsedTimeBetweenActionAndResponse = responseDate != null ? responseDate.getTime() - actionDate.getTime() : -1;
                    return 0 < elapsedTimeBetweenActionAndResponse && elapsedTimeBetweenActionAndResponse < 30000;
                }
                return false;
            }).findFirst();
            return question.<DataRecord>map(q -> new QuestionRecord(q.getResponseText())).orElse(null);
        } else {
            return step.getActionRecord();
        }
    } catch (WorkflowException e) {
        SilverLogger.getLogger(this).silent(e);
        return null;
    }
}",java:S3776,39
"private String getFieldValue(ProcessInstanceRowRecord instance, Item[] items, String fieldName){
    String fieldString;
    try {
        Field field = instance.getFullProcessInstance().getField(fieldName);
        fieldString = field.getValue(getLanguage());
        if (!isDefined(fieldString) || !field.getTypeName().equals(DateField.TYPE)) {
            ItemImpl item = (ItemImpl) getItemByName(items, fieldName);
            if (item != null) {
                Map<String, String> keyValuePairs = item.getKeyValuePairs();
                if (keyValuePairs != null && keyValuePairs.size() > 0) {
                    StringBuilder newValue = new StringBuilder();
                    if (isDefined(fieldString)) {
                        final String delimiter = ""##"";
                        if (fieldString.contains(delimiter)) {
                            StringTokenizer tokenizer = new StringTokenizer(fieldString, delimiter);
                            String token;
                            while (tokenizer.hasMoreTokens()) {
                                token = tokenizer.nextToken();
                                token = keyValuePairs.get(token);
                                newValue.append(token);
                                if (tokenizer.hasMoreTokens()) {
                                    newValue.append("", "");
                                }
                            }
                        } else {
                            newValue.append(keyValuePairs.get(fieldString));
                        }
                    }
                    fieldString = newValue.toString();
                }
            }
        }
    } catch (WorkflowException we) {
        fieldString = """";
    }
    return fieldString;
}",java:S3776,39
"public static List<Answer> extractAnswer(List<FileItem> items, QuestionForm form, String componentId, String subdir) throws IOException{
    List<Answer> answers = new ArrayList<>();
    for (final FileItem item : items) {
        String mpName = item.getFieldName();
        if (item.isFormField() && mpName.startsWith(""answer"")) {
            String answerInput = FileUploadUtil.getOldParameter(items, mpName, """");
            Answer answer = new Answer(null, null, answerInput, 0, false, null, 0, false, null, null);
            String id = mpName.substring(""answer"".length());
            String nbPoints = FileUploadUtil.getOldParameter(items, ""nbPoints"" + id, ""0"");
            answer.setNbPoints(Integer.parseInt(nbPoints));
            if (Integer.parseInt(nbPoints) > 0) {
                answer.setIsSolution(true);
            }
            String comment = FileUploadUtil.getOldParameter(items, ""comment"" + id, """");
            answer.setComment(comment);
            String value = FileUploadUtil.getOldParameter(items, ""valueImageGallery"" + id, """");
            if (StringUtil.isDefined(value)) {
                if (!form.isFile()) {
                    answer.setImage(value);
                }
            }
            FileItem image = FileUploadUtil.getFile(items, ""image"" + id);
            if (image != null) {
                addImageToAnswer(answer, image, form, componentId, subdir);
            }
            answers.add(answer);
        }
    }
    return answers;
}",java:S3776,39
"private void pasteQuizz(QuestionContainerDetail quizz) throws Exception{
    String componentId;
    QuestionContainerPK quizzPk = quizz.getHeader().getPK();
    if (quizz.getHeader().getInstanceId().equals(getComponentId())) {
        componentId = quizz.getHeader().getInstanceId();
    } else {
        componentId = getComponentId();
    }
    Collection<Question> questions = quizz.getQuestions();
    for (final Question question : questions) {
        Collection<Answer> answers = question.getAnswers();
        Iterator<Answer> itA = answers.iterator();
        int attachmentSuffix = 0;
        while (itA.hasNext()) {
            Answer answer = itA.next();
            String physicalName = answer.getImage();
            if (StringUtil.isDefined(physicalName)) {
                SettingBundle srvSettings = ResourceLocator.getSettingBundle(""org.silverpeas.survey.surveySettings"");
                String type = physicalName.substring(physicalName.indexOf('.') + 1, physicalName.length());
                String newPhysicalName = Long.toString(new Date().getTime()) + attachmentSuffix + ""."" + type;
                attachmentSuffix = attachmentSuffix + 1;
                if (quizz.getHeader().getInstanceId().equals(getComponentId())) {
                    String absolutePath = FileRepositoryManager.getAbsolutePath(componentId);
                    String dir = absolutePath + srvSettings.getString(""imagesSubDirectory"") + File.separator;
                    FileRepositoryManager.copyFile(dir + physicalName, dir + newPhysicalName);
                } else {
                    String fromAbsolutePath = FileRepositoryManager.getAbsolutePath(quizz.getHeader().getInstanceId());
                    String toAbsolutePath = FileRepositoryManager.getAbsolutePath(componentId);
                    String fromDir = fromAbsolutePath + srvSettings.getString(""imagesSubDirectory"") + File.separator;
                    String toDir = toAbsolutePath + srvSettings.getString(""imagesSubDirectory"") + File.separator;
                    FileRepositoryManager.copyFile(fromDir + physicalName, toDir + newPhysicalName);
                }
                answer.setImage(newPhysicalName);
            }
        }
    }
    QuestionContainerPK toQuestionContainerPk = createQuizz(quizz, componentId);
    final int fromSilverObjectId = getQuestionContainerService().getSilverObjectId(quizzPk);
    final int toSilverObjectId = getQuestionContainerService().getSilverObjectId(toQuestionContainerPk);
    PdcManager.get().copyPositions(fromSilverObjectId, quizz.getHeader().getInstanceId(), toSilverObjectId, componentId);
}",java:S112,4
"public void performBeforePersist(){
    Date now = new Date();
    setCreationDate(now);
    setUpdateDate(now);
}",java:S1161,11
"public void performBeforeUpdate(){
    setUpdateDate(new Date());
}",java:S1161,11
"private Exception UndefinedForwardRequestHandlerException(){
    return new Exception(""No forward request defines for"" + this.getClass());
}",java:S100,0
"private Period getEventPeriod(){
    final String startDayValue = getFolderValueFromTriggerParam(AlmanachTriggerParam.START_DATE);
    final String endDayValue = getFolderValueFromTriggerParam(AlmanachTriggerParam.END_DATE);
    if (startDayValue != null) {
        final String startHourValue = getFolderValueFromTriggerParam(AlmanachTriggerParam.START_HOUR);
        final String endHourValue = getFolderValueFromTriggerParam(AlmanachTriggerParam.END_HOUR);
        try {
            final Temporal start;
            if (StringUtil.isValidHour(startHourValue)) {
                start = OffsetDateTime.parse(startDayValue + "" "" + startHourValue, DATE_TIME_FORMATTER);
            } else {
                start = LocalDate.parse(startDayValue, DATE_FORMATTER);
            }
            final Temporal end;
            if (endDayValue != null) {
                if (StringUtil.isValidHour(endHourValue)) {
                    end = OffsetDateTime.parse(endDayValue + "" "" + endHourValue, DATE_TIME_FORMATTER);
                } else {
                    end = LocalDate.parse(endDayValue, DATE_FORMATTER).plusDays(1);
                }
            } else {
                if (StringUtil.isValidHour(endHourValue)) {
                    end = OffsetDateTime.parse(startDayValue + "" "" + endHourValue, DATE_TIME_FORMATTER);
                } else {
                    end = start.plus(1, ChronoUnit.DAYS);
                }
            }
            return Period.between(start, end);
        } catch (DateTimeParseException e) {
            SilverLogger.getLogger(this).warn(e);
        }
    }
    return null;
}",java:S3776,39
"public void updateClassification(String idSite, ArrayList<String> arrayTopic) throws WebSitesException{
    try {
        String idPub = getWebSiteService().getIdPublication(getComponentId(), idSite);
        getWebSiteService().updateClassification(new PublicationPK(idPub, getComponentId()), arrayTopic);
    } catch (Exception re) {
        throw new WebSitesException(""WebSiteSessionController.updateClassification"", SilverpeasException.ERROR, ""webSites.EX_PUBLICATION_UPDATE_FAILED"", ""site id ="" + idSite, re);
    }
}",java:S1319,22
"public int getSilverObjectId(String objectId){
    return Integer.parseInt(getCurrentCardContentId());
}",java:S1172,13
"public SortedSet<SearchField> getSearchFields() throws WhitePagesException{
    SortedSet<SearchField> fields = WhitePageServiceProvider.getWhitePagesService().getSearchFields(getComponentId());
    if (!fields.isEmpty()) {
        PublicationTemplate template = null;
        Map<String, String> domainProperties = null;
        try {
            RecordTemplate recordTemplate = null;
            for (SearchField field : fields) {
                if (field.getFieldId().startsWith(SearchFieldsType.XML.getLabelType())) {
                    if (template == null) {
                        template = getTemplate(getComponentId());
                        recordTemplate = template.getRecordTemplate();
                    }
                    field.setLabel(recordTemplate.getFieldTemplate(field.getFieldName()).getLabel(getLanguage()));
                } else if (field.getFieldId().startsWith(SearchFieldsType.LDAP.getLabelType())) {
                    if (domainProperties == null) {
                        domainProperties = getDomainProperties();
                    }
                    field.setLabel(domainProperties.get(field.getFieldName()));
                } else if (field.getFieldId().startsWith(SearchFieldsType.USER.getLabelType())) {
                    if (""name"".equals(field.getFieldName())) {
                        field.setLabel(ResourceLocator.getGeneralLocalizationBundle(getLanguage()).getString(""GML.lastName""));
                    } else if (""surname"".equals(field.getFieldName())) {
                        field.setLabel(ResourceLocator.getGeneralLocalizationBundle(getLanguage()).getString(""GML.surname""));
                    } else if (""email"".equals(field.getFieldName())) {
                        field.setLabel(ResourceLocator.getGeneralLocalizationBundle(getLanguage()).getString(""GML.eMail""));
                    }
                }
            }
        } catch (Exception e) {
            SilverLogger.getLogger(this).error(e);
        }
    }
    return fields;
}",java:S3776,39
"public HashMap<String, Set<ClassifyValue>> getPdcPositions(int cardId) throws PdcException{
    HashMap<String, Set<ClassifyValue>> result = new HashMap<>();
    List<ClassifyPosition> listOfPositions = getPdcManager().getPositions(cardId, getComponentId());
    if (listOfPositions != null && listOfPositions.size() > 0) {
        for (ClassifyPosition position : listOfPositions) {
            for (ClassifyValue value : position.getValues()) {
                List<Value> path = value.getFullPath();
                if (path != null && !path.isEmpty()) {
                    Value axis = path.get(0);
                    String category = axis.getName(getLanguage());
                    if (result.containsKey(category)) {
                        result.get(category).add(value);
                    } else {
                        Set<ClassifyValue> values = new HashSet<>();
                        values.add(value);
                        result.put(category, values);
                    }
                }
            }
        }
    }
    return result;
}",java:S3776,39
"public HashMap<String, Set<ClassifyValue>> getPdcPositions(int cardId) throws PdcException{
    HashMap<String, Set<ClassifyValue>> result = new HashMap<>();
    List<ClassifyPosition> listOfPositions = getPdcManager().getPositions(cardId, getComponentId());
    if (listOfPositions != null && listOfPositions.size() > 0) {
        for (ClassifyPosition position : listOfPositions) {
            for (ClassifyValue value : position.getValues()) {
                List<Value> path = value.getFullPath();
                if (path != null && !path.isEmpty()) {
                    Value axis = path.get(0);
                    String category = axis.getName(getLanguage());
                    if (result.containsKey(category)) {
                        result.get(category).add(value);
                    } else {
                        Set<ClassifyValue> values = new HashSet<>();
                        values.add(value);
                        result.put(category, values);
                    }
                }
            }
        }
    }
    return result;
}",java:S1319,22
"public Collection getFolders(){
    return folders;
}",java:S3740,38
"public List getChildren(){
    return children;
}",java:S3740,38
"private void setMessageColumns(final StringBuilder msgToSend, final List cols){
    Iterator it = cols.iterator();
    while (it.hasNext()) {
        msgToSend.append((String) it.next());
        if (it.hasNext()) {
            msgToSend.append("" | "");
        }
    }
    msgToSend.append(""\n"");
    int msgToSendLength = msgToSend.toString().length();
    for (int i = 0; i < msgToSendLength; i++) {
        msgToSend.append(""-"");
    }
    msgToSend.append(""\n"");
}",java:S3740,38
"public static void displayAllOperations(String id, KmeliaSessionController kmeliaScc, GraphicElementFactory gef, String action, MultiSilverpeasBundle resources, JspWriter out, boolean kmaxMode) throws IOException{
    String routerUrl = URLUtil.getApplicationURL() + URLUtil.getURL(kmeliaScc.getComponentRootName(), kmeliaScc.getSpaceId(), kmeliaScc.getComponentId());
    displayJavascriptAndFormToOperations(kmeliaScc, out);
    boolean enabled = StringUtil.isDefined(id);
    List<String> invisibleTabs = kmeliaScc.getInvisibleTabs();
    TabbedPane tabbedPane = gef.getTabbedPane();
    PublicationDetail pubDetail = kmeliaScc.getSessionPublication().getDetail();
    PublicationDetail cloneDetail = null;
    if (kmeliaScc.getSessionClone() != null) {
        cloneDetail = kmeliaScc.getSessionClone().getDetail();
    }
    String decoration = """";
    String pubId = pubDetail.getPK().getId();
    String previewTabLabel = resources.getString(""PublicationPreview"");
    String sureId = pubId;
    if (cloneDetail != null) {
        decoration = "" *"";
        sureId = cloneDetail.getId();
        previewTabLabel = resources.getString(""kmelia.PublicPreview"");
    }
    if (invisibleTabs.indexOf(KmeliaSessionController.TAB_PREVIEW) == -1) {
        tabbedPane.addTab(previewTabLabel, routerUrl + ""ViewPublication?PubId="" + pubId, ""View"".equals(action) || ""ViewPublication"".equals(action), enabled);
    }
    if (cloneDetail != null) {
        tabbedPane.addTab(resources.getString(""kmelia.ClonePreview"") + decoration, routerUrl + ""ViewClone"", ""ViewClone"".equals(action), enabled);
    }
    if (invisibleTabs.indexOf(KmeliaSessionController.TAB_HEADER) == -1) {
        tabbedPane.addTab(kmeliaScc.getString(""Header"") + decoration, routerUrl + ""ToUpdatePublicationHeader"", ""UpdateView"".equals(action) || ""New"".equals(action) || ""KmaxModifyPublication"".equals(action), enabled);
    }
    if (invisibleTabs.indexOf(KmeliaSessionController.TAB_CONTENT) == -1) {
        tabbedPane.addTab(resources.getString(""Model"") + decoration, ""javaScript:onClick=goToOperation('"" + routerUrl + ""ToPubliContent', '"" + sureId + ""', 'ModelUpdateView')"", ""ModelUpdateView"".equals(action) || ""NewModel"".equals(action) || ""ModelChoice"".equals(action), enabled);
    }
    if (invisibleTabs.indexOf(KmeliaSessionController.TAB_ATTACHMENTS) == -1) {
        if (kmeliaScc.getComponentId().startsWith(""toolbox"")) {
            decoration = """";
            tabbedPane.addTab(resources.getString(""GML.attachments"") + decoration, ""javaScript:onClick=goToOperationByGet('"" + routerUrl + ""ViewAttachments', '"" + pubId + ""', 'ViewAttachments')"", ""ViewAttachments"".equals(action), enabled);
        }
    }
    if (invisibleTabs.indexOf(KmeliaSessionController.TAB_ACCESS_PATHS) == -1 && !kmaxMode && !pubDetail.isAlias()) {
        tabbedPane.addTab(resources.getString(""PubGererChemins"") + "" ("" + kmeliaScc.getPublicationLocations().size() + "")"", routerUrl + ""PublicationPaths?PubId="" + pubId, ""ViewPath"".equals(action), enabled);
    }
    if (kmaxMode) {
        tabbedPane.addTab(kmeliaScc.getString(""PubPositions""), ""KmaxViewCombination?PubId="" + pubId, action.equals(""KmaxViewCombination""), enabled);
    }
    if (invisibleTabs.indexOf(kmeliaScc.TAB_READER_LIST) == -1) {
        tabbedPane.addTab(resources.getString(""PubGererControlesLecture""), routerUrl + ""ReadingControl"", action.equals(""ViewReadingControl""), enabled);
    }
    if (kmeliaScc.isValidationTabVisible()) {
        tabbedPane.addTab(resources.getString(""kmelia.validation""), routerUrl + ""ViewValidationSteps"", ""ViewValidationSteps"".equals(action), enabled);
    }
    out.println(tabbedPane.print());
}",java:S3776,39
"public static void displayUserAttachmentsView(PublicationDetail pubDetail, String webContext, JspWriter out, String lang, boolean showIcon, MultiSilverpeasBundle resources) throws IOException{
    ResourceReference foreignKey = new ResourceReference(pubDetail.getPK());
    List<SimpleDocument> documents = AttachmentServiceProvider.getAttachmentService().listDocumentsByForeignKey(foreignKey, lang);
    if (!documents.isEmpty()) {
        out.println(""<table ALIGN=CENTER CELLPADDING=2 CELLSPACING=0 BORDER=0 WIDTH=\""98%\"" CLASS=intfdcolor>"");
        out.println(""<tr><td>"");
        out.println(""<table ALIGN=CENTER CELLPADDING=5 CELLSPACING=0 BORDER=0 WIDTH=\""100%\"" CLASS=intfdcolor4>"");
        if (showIcon) {
            out.println(""<tr><td align=\""center\""><img src=\"""" + webContext + ""/util/icons/attachedFiles.gif\""></td></tr>"");
        }
        for (SimpleDocument document : documents) {
            SimpleDocument document_version = document.getLastPublicVersion();
            if (document_version != null) {
                String title = document_version.getTitle();
                if (!StringUtil.isDefined(title)) {
                    title = document_version.getFilename();
                }
                out.println(""<tr>"");
                out.print(""<td><img alt=\""\"" src=\"""" + document_version.getDisplayIcon() + ""\"" width=20>&nbsp;<A href=\"""" + webContext + document_version.getAttachmentURL() + ""\"" target=\""_blank\"">"" + title + ""</a>"");
                if (document_version.isVersioned()) {
                    out.println(""&nbsp;(v"" + document_version.getMajorVersion() + ""."" + document_version.getMinorVersion() + "")<br/>"");
                } else {
                    out.println(""&nbsp;<br/>"");
                }
                String separator = """";
                if (!""no"".equals(resources.getSetting(""showFileSize""))) {
                    out.println("" "" + FileRepositoryManager.formatFileSize(document_version.getSize()));
                    separator = "" / "";
                }
                if (!""no"".equals(resources.getSetting(""showDownloadEstimation""))) {
                    out.println(separator + FileRepositoryManager.getFileDownloadTime(document_version.getSize()));
                }
                if (StringUtil.isDefined(document_version.getDescription())) {
                    if (!""no"".equals(resources.getSetting(""showInfo""))) {
                        out.println(""<br><i>"" + document_version.getDescription() + ""</i>"");
                    }
                }
                if (document_version.isVersioned() && document_version.getMajorVersion() > 1) {
                    final String domIdSuffix = formatForDomId(document.getForeignId());
                    final String afManager = ""_afManager"" + domIdSuffix;
                    if (showIcon) {
                        out.println(""<br/> >> <a href=\""javaScript:"" + afManager + "".viewPublicVersions("" + document.getId() + "")\"">Toutes les versions...</a>"");
                    } else {
                        out.println("" (<a href=\""javaScript:"" + afManager + "".viewPublicVersions("" + document.getId() + "")\"">Toutes les versions...</a>)"");
                    }
                }
                out.println(""</td></tr>"");
            }
        }
        out.println(""</table>"");
        out.println(""</td></tr>"");
        out.println(""</table>"");
    }
}",java:S3776,39
"private void displayPublications(List<KmeliaPublication> allPubs, boolean sortAllowed, boolean linksAllowed, boolean seeAlso, boolean toSearch, KmeliaSessionController kmeliaScc, String profile, GraphicElementFactory gef, MultiSilverpeasBundle resources, List<PublicationPK> selectedIds, String pubIdToHighlight, Writer out, boolean linkAttachment) throws IOException{
    String publicationSrc = resources.getIcon(""kmelia.publication"");
    SettingBundle publicationSettings = ResourceLocator.getSettingBundle(""org.silverpeas.publication.publicationSettings"");
    boolean showNoPublisMessage = resources.getSetting(""showNoPublisMessage"", true);
    boolean targetValidationEnabled = kmeliaScc.isTargetValidationEnable() || kmeliaScc.isTargetMultiValidationEnable();
    String language = kmeliaScc.getCurrentLanguage();
    String currentUserId = kmeliaScc.getUserDetail().getId();
    String currentTopicId = kmeliaScc.getCurrentFolderId();
    boolean specificTemplateUsed = kmeliaScc.isCustomPublicationTemplateUsed();
    PublicationFragmentSettings fragmentSettings = new PublicationFragmentSettings();
    fragmentSettings.displayLinks = URLUtil.displayUniversalLinks();
    fragmentSettings.showImportance = kmeliaScc.isFieldImportanceVisible();
    fragmentSettings.fileStorageShowExtraInfoPub = resources.getSetting(""fileStorageShowExtraInfoPub"", false);
    fragmentSettings.showTopicPathNameinSearchResult = resources.getSetting(""showTopicPathNameinSearchResult"", true);
    fragmentSettings.toSearch = toSearch;
    fragmentSettings.rateable = kmeliaScc.isPublicationRatingAllowed();
    int nbPubsPerPage = kmeliaScc.getNbPublicationsPerPage();
    int firstDisplayedItemIndex = kmeliaScc.getIndexOfFirstPubToDisplay();
    int nbPubs = allPubs.size();
    Board board = gef.getBoard();
    Pagination pagination = gef.getPagination(nbPubs, nbPubsPerPage, firstDisplayedItemIndex);
    List<KmeliaPublication> pubs = allPubs.subList(pagination.getFirstItemIndex(), pagination.getLastItemIndex());
    out.write(""<form name=\""publicationsForm\"" onsubmit=\""return false;\"">"");
    if (!pubs.isEmpty()) {
        out.write(board.printBefore());
        displayPublicationsListHeader(allPubs, sortAllowed, pagination, resources, kmeliaScc, out);
        out.write(""<ul>"");
        for (KmeliaPublication aPub : pubs) {
            PublicationDetail pub = aPub.getDetail();
            User currentUser = aPub.getCreator();
            String pubColor = """";
            String pubState = null;
            String highlightClass = """";
            if (StringUtil.isDefined(pubIdToHighlight) && pubIdToHighlight.equals(pub.getPK().getId())) {
                highlightClass = ""highlight"";
            }
            if (pub.getStatus() != null && pub.isValid()) {
                if (pub.haveGotClone() && CLONE_STATUS.equals(pub.getCloneStatus()) && !USER.isInRole(profile)) {
                    pubColor = ""blue"";
                    pubState = resources.getString(""kmelia.UpdateInProgress"");
                } else if (DRAFT_STATUS.equals(pub.getCloneStatus())) {
                    if (currentUserId.equals(currentUser.getId())) {
                        pubColor = ""gray"";
                        pubState = resources.getString(""PubStateDraft"");
                    }
                } else if (TO_VALIDATE_STATUS.equals(pub.getCloneStatus())) {
                    if (ADMIN.isInRole(profile) || PUBLISHER.isInRole(profile) || currentUserId.equals(currentUser.getId())) {
                        pubColor = ""red"";
                        pubState = resources.getString(""kmelia.PubStateToValidate"");
                        if (targetValidationEnabled) {
                            ValidatorsList validatorsList = aPub.getValidators();
                            pubState = getTargetedValidationInfo(validatorsList, resources);
                        }
                    }
                } else {
                    if (pub.isNotYetVisible()) {
                        pubState = resources.getString(""kmelia.VisibleFrom"") + "" "" + resources.getOutputDateAndHour(pub.getBeginDateAndHour());
                    } else if (pub.isNoMoreVisible()) {
                        pubState = resources.getString(""kmelia.VisibleTo"") + "" "" + resources.getOutputDateAndHour(pub.getEndDateAndHour());
                    }
                    if (!pub.isVisible()) {
                        pubColor = ""gray"";
                    }
                }
            } else {
                boolean hasModificationAccess = ADMIN.isInRole(profile) || PUBLISHER.isInRole(profile) || pub.isPublicationEditor(currentUserId) || (!USER.isInRole(profile) && kmeliaScc.isCoWritingEnable());
                if (pub.getStatus() != null && pub.isDraft()) {
                    if (pub.isPublicationEditor(currentUserId) || ((kmeliaScc.isCoWritingEnable() && kmeliaScc.isDraftVisibleWithCoWriting()) && !USER.isInRole(profile))) {
                        pubColor = ""gray"";
                        pubState = resources.getString(""PubStateDraft"");
                    }
                } else if (pub.getStatus() != null && pub.isRefused()) {
                    if (ADMIN.isInRole(profile) || PUBLISHER.isInRole(profile) || (WRITER.isInRole(profile) && (pub.isPublicationEditor(currentUserId) || kmeliaScc.isCoWritingEnable()))) {
                        pubColor = ""red"";
                        pubState = resources.getString(""PublicationRefused"");
                    }
                } else if (hasModificationAccess) {
                    pubColor = ""red"";
                    if (pub.isRefused()) {
                        pubState = resources.getString(""kmelia.PubStateUnvalidate"");
                    } else {
                        pubState = resources.getString(""kmelia.PubStateToValidate"");
                        if (targetValidationEnabled) {
                            ValidatorsList validatorsList = aPub.getValidators();
                            pubState = getTargetedValidationInfo(validatorsList, resources);
                        }
                    }
                }
            }
            if (pub.isAlias()) {
                pubState = resources.getString(""kmelia.Shortcut"");
            }
            String cssClasses = ""important"" + pub.getImportance();
            if (pub.isNew()) {
                cssClasses += "" new-contribution"";
            }
            if (toSearch) {
                if (aPub.isRead()) {
                    cssClasses += "" read"";
                } else {
                    cssClasses += "" unread"";
                }
            }
            out.write(""<li class=\"""");
            out.write(cssClasses);
            out.write(""\"" onmouseover=\""showPublicationOperations(this);\"""");
            out.write("" onmouseout=\""hidePublicationOperations(this);\"">"");
            out.write(""<div class=\""firstColumn\"">"");
            if (!kmeliaScc.getUserDetail().isAnonymous() && !kmeliaScc.isKmaxMode()) {
                String checked = """";
                if (selectedIds != null && selectedIds.contains(pub.getPK())) {
                    checked = ""checked=\""checked\"""";
                }
                out.write(""<span class=\""selection\"">"");
                out.write(""<input type=\""checkbox\"" name=\""C1\"" value=\"""" + pub.getPK().getId() + ""-"" + pub.getPK().getInstanceId() + ""\"" "" + checked + "" onclick=\""sendPubId(this.value, this.checked);\""/>"");
                out.write(END_SPAN);
            }
            if (!seeAlso) {
                Thumbnail thumbnail = pub.getThumbnail();
                if (thumbnail != null && Boolean.valueOf(resources.getSetting(""isVignetteVisible""))) {
                    out.write(""<span class=\""thumbnail\"">"");
                    displayThumbnail(pub, kmeliaScc, publicationSettings, out);
                    out.write(END_SPAN);
                }
            }
            out.write(END_DIV);
            fragmentSettings.pubColor = pubColor;
            fragmentSettings.highlightClass = highlightClass;
            fragmentSettings.pubState = pubState;
            fragmentSettings.linksAllowed = linksAllowed;
            fragmentSettings.seeAlso = seeAlso;
            fragmentSettings.linkAttachment = linkAttachment;
            out.write(""<div class=\""publication\""><a name=\"""" + pub.getPK().getId() + ""\""></a>"");
            displayFragmentOfPublication(specificTemplateUsed, aPub, fragmentSettings, language, currentUserId, currentTopicId, kmeliaScc, resources, out);
            out.write(END_DIV);
            out.write(getPutIntoBasketSelectionHtmlSnippet(String.format(""putPublicationInBasket('%s')"", pub.getIdentifier().asString()), language));
            out.write(""</li>"");
        }
        out.write(""</ul>"");
        out.write(""<div id=\""pagination\"">"");
        out.write(pagination.printIndex(""doPagination"", true));
        out.write(END_DIV);
        displayFilePreviewJavascript(language, out);
        displayFileViewJavascript(language, out);
        out.write(board.printAfter());
    } else if (showNoPublisMessage) {
        String noPublications = kmeliaScc.getString(""PubAucune"");
        if (toSearch) {
            noPublications = kmeliaScc.getString(""NoPubFound"");
        }
        out.write(""<div class=\""tableBoard\"" id=\""noPublicationMessage\"">"");
        out.write(""<div id=\""pubsHeader\""><img src=\"""" + publicationSrc + ""\"" border=\""0\"" /> "");
        out.write(""<span>"" + resources.getString(""GML.publications"") + ""</span></div>"");
        out.write(""<p>"" + noPublications + ""</p>"");
        out.write(END_DIV);
    }
    out.write(""</form>"");
    out.write(scriptContent(""sp.selection.newCheckboxMonitor('form[name=publicationsForm] input[name=C1]')"" + "".addEventListener('change', function(){"" + ""if(typeof showPublicationCheckedBoxes === 'function') {showPublicationCheckedBoxes();}"" + ""}, 'displayPublication');"").toString());
}",java:S107,1
" void displayFragmentOfPublication(boolean specificTemplateUsed, KmeliaPublication aPub, PublicationFragmentSettings fragmentSettings, String language, String userId, String topicId, KmeliaSessionController kmeliaScc, MultiSilverpeasBundle resources, Writer out) throws IOException{
    boolean canBeCut = KmeliaPublicationHelper.isCanBeCut(kmeliaScc.getComponentId(), userId, kmeliaScc.getUserTopicProfile(), aPub.getCreator());
    boolean alias = aPub.isAlias();
    fragmentSettings.draggable = canBeCut && !alias && !KmeliaHelper.isToValidateFolder(topicId);
    if (specificTemplateUsed) {
        displayTemplatedFragmentOfPublication(aPub, fragmentSettings, language, kmeliaScc, resources, out);
    } else {
        displayDefaultFragmentOfPublication(aPub, fragmentSettings, language, kmeliaScc, resources, out);
    }
}",java:S107,1
" void displayDefaultFragmentOfPublication(KmeliaPublication aPub, PublicationFragmentSettings fragmentSettings, String language, KmeliaSessionController kmeliaScc, MultiSilverpeasBundle resources, Writer out) throws IOException{
    PublicationDetail pub = aPub.getDetail();
    String name = Encode.forHtml(pub.getName(language));
    out.write(""<div class=\""publication-name line1\"">"");
    if (fragmentSettings.linksAllowed) {
        out.write(""<div class=\"""");
        out.write(fragmentSettings.pubColor);
        out.write(""\""><a href=\""javascript:onClick=publicationGoTo('"");
        out.write(pub.getPK().getId());
        out.write(""')\""><span class=\"""" + fragmentSettings.highlightClass + ""\"">"");
        if (fragmentSettings.draggable) {
            out.write(""<span class=\""jstree-draggable\"" id=\""pub-"" + pub.getPK().getId() + ""\"">"");
            out.write(name);
            out.write(END_SPAN);
        } else {
            out.write(name);
        }
        out.write(""</span></a></div>"");
    } else {
        String ref = """";
        if (fragmentSettings.seeAlso && resources.getSetting(""linkManagerShowPubId"", false)) {
            ref = "" [ "" + pub.getPK().getId() + "" ] "";
        }
        out.write(""<div class=\"""");
        out.write(fragmentSettings.pubColor);
        out.write(""\""><span class=\"""" + fragmentSettings.highlightClass + ""\"">"");
        out.write(ref);
        out.write(name);
        out.write(""</span></div>"");
    }
    out.write(""&#160;"");
    if (StringUtil.isDefined(fragmentSettings.pubState)) {
        out.write(""<span class=\""state "");
        out.write(fragmentSettings.pubColor);
        out.write(""\"">("");
        out.write(fragmentSettings.pubState);
        out.write("")</span>"");
    }
    if (fragmentSettings.rateable) {
        RaterRatingEntity raterRatingEntity = RaterRatingEntity.fromRateable(pub);
        out.write(raterRatingEntity.toJSonScript(""raterRatingEntity_"" + raterRatingEntity.getContributionId()));
        out.write(""<div silverpeas-rating readonly=\""true\"" shownbraterratings=\""false\"" "" + ""starsize=\""small\"" "" + ""raterrating=\""raterRatingEntity_"" + raterRatingEntity.getContributionId() + ""\""></div>"");
    }
    out.write(END_DIV);
    out.write(""<div class=\""line2 "");
    out.write(fragmentSettings.pubColor);
    out.write(""\"">"");
    if (fragmentSettings.toSearch && fragmentSettings.showTopicPathNameinSearchResult) {
        out.write(displayPublicationFullPath(kmeliaScc, pub));
    }
    boolean showUserNameInList = kmeliaScc.showUserNameInList();
    if (fragmentSettings.linkAttachment) {
        showUserNameInList = showUserNameInList && fragmentSettings.fileStorageShowExtraInfoPub;
    }
    if (showUserNameInList) {
        out.write(""<span class=\""user\"">"");
        out.write(getUserName(aPub, kmeliaScc));
        out.write("" - </span>"");
    }
    boolean showPubDate = true;
    if (fragmentSettings.linkAttachment) {
        showPubDate = showPubDate && fragmentSettings.fileStorageShowExtraInfoPub;
    }
    if (showPubDate) {
        out.write(""<span class=\""date\"">"");
        out.write(displayDate(pub, kmeliaScc, resources));
        out.write(END_SPAN);
    }
    boolean showAuthor = kmeliaScc.isAuthorUsed() && StringUtil.isDefined(pub.getAuthor());
    if (fragmentSettings.linkAttachment) {
        showAuthor = showAuthor && fragmentSettings.fileStorageShowExtraInfoPub;
    }
    if (showAuthor) {
        out.write(""<span class=\""author\"">"");
        out.write(""&#160;-&#160;("");
        out.write(resources.getString(""GML.author""));
        out.write("":&#160;"");
        out.write(pub.getAuthor());
        out.write("")</span>"");
    }
    if (fragmentSettings.displayLinks && !fragmentSettings.seeAlso && !fragmentSettings.linkAttachment) {
        out.write(""<span class=\""permalink\"">"");
        out.write(displayPermalink(pub, kmeliaScc, resources));
        out.write(END_SPAN);
    }
    out.write(END_DIV);
    String description = pub.getDescription(language);
    if (StringUtil.isDefined(description) && !description.equals(name)) {
        out.write(""<p class=\""description line3\"">"");
        out.write(WebEncodeHelper.convertBlanksForHtml(Encode.forHtml(description)));
        out.write(""</p>"");
    }
    out.write(displayFiles(pub, fragmentSettings.linkAttachment, fragmentSettings.seeAlso, kmeliaScc, resources));
}",java:S3776,39
"private String displayFile(String url, String title, String info, String icon, String logicalName, String size, String downloadTime, Date creationDate, String permalink, MultiSilverpeasBundle resources, boolean attachmentLink, boolean previewable, boolean viewable, final boolean isDownloadAllowedForReaders, final boolean isUserAllowedToDownloadFile, String id){
    StringBuilder result = new StringBuilder(1024);
    if (!attachmentLink) {
        String link = isUserAllowedToDownloadFile ? ""<a href=\"""" + url + ""\"" target=\""_blank\"">"" : ""<span class=\""forbidden-download\"">"";
        result.append(""<tr><td valign=\""top\"">"");
        Img iconImg = new Img(icon).setAlignment(Alignment.MIDDLE);
        result.append(link).append(iconImg.toString()).append(""</a>&#160;</td>"");
        result.append(""<td valign=\""top\"">"").append(link);
        boolean showTitle = resources.getSetting(""showTitle"", true);
        String fileTitle = StringUtil.isDefined(title) ? title : logicalName;
        if (StringUtil.isDefined(fileTitle) && showTitle) {
            result.append(fileTitle);
        }
        result.append(isUserAllowedToDownloadFile ? ""</a>"" : END_SPAN);
        if (StringUtil.isDefined(permalink) && isUserAllowedToDownloadFile) {
            result.append(""&#160;<a href=\"""").append(permalink).append(""\"" target=\""_blank\""><img src=\"""").append(resources.getIcon(""kmelia.link"")).append(""\"" border=\""0\"" valign=\""absmiddle\"" alt=\"""").append(""\"" title=\"""").append(""\""/></a>"");
        }
        result.append(NEW_LINE);
        result.append(""<i>"");
        if (StringUtil.isDefined(logicalName) && (!logicalName.equals(fileTitle) || !showTitle)) {
            result.append(logicalName).append("" / "");
        }
        if (resources.getSetting(""showFileSize"", true)) {
            result.append(size);
        }
        if (resources.getSetting(""showDownloadEstimation"", false)) {
            result.append("" / "").append(downloadTime).append("" / "").append(resources.getOutputDate(creationDate));
        }
        if (previewable) {
            result.append("" <img onclick=\""javascript:previewFile(this, '"").append(id).append(""');\"" class=\""preview-file\"" src=\"""").append(resources.getIcon(""kmelia.file.preview"")).append(""\"" alt=\"""").append(resources.getString(""GML.preview.file"")).append(""\"" title=\"""").append(resources.getString(""GML.preview.file"")).append(""\""/>"");
        }
        if (viewable) {
            result.append("" <img onclick=\""javascript:viewFile(this, '"").append(id).append(""');\"" class=\""view-file\"" src=\"""").append(resources.getIcon(""kmelia.file.view"")).append(""\"" alt=\"""").append(resources.getString(""GML.view.file"")).append(""\"" title=\"""").append(resources.getString(""GML.view.file"")).append(""\""/>"");
        }
        if (!isDownloadAllowedForReaders) {
            String forbiddenDownloadHelp = isUserAllowedToDownloadFile ? resources.getString(""GML.download.forbidden.readers"") : resources.getString(""GML.download.forbidden"");
            result.append("" <img class=\""forbidden-download-file\"" src=\"""").append(resources.getIcon(""kmelia.file.forbidden-download"")).append(""\"" alt=\"""").append(forbiddenDownloadHelp).append(""\"" title=\"""").append(forbiddenDownloadHelp).append(""\""/>"");
        }
        result.append(""</i>"");
        if (StringUtil.isDefined(info) && resources.getSetting(""showInfo"", true)) {
            result.append(NEW_LINE).append(WebEncodeHelper.convertBlanksForHtml(info));
        }
        result.append(""</td></tr>"");
    } else {
        String displayedTitle;
        if (!StringUtil.isDefined(title)) {
            displayedTitle = logicalName;
        } else {
            displayedTitle = title;
        }
        String javascriptFunction = ""selectAttachment('"" + url + ""','"" + icon + ""','"" + displayedTitle + ""')"";
        String link = ""<a href=\""javascript:"" + javascriptFunction + ""\"" >"";
        result.append(""<tr><td valign=\""top\"">"");
        result.append(link).append(""<img src=\"""").append(icon).append(""\"" border=\""0\"" align=\""absmiddle\""/></a>&#160;</td>"");
        result.append(""<td valign=\""top\"">"").append(link);
        result.append(displayedTitle);
        result.append(""</a>"");
        if (StringUtil.isDefined(permalink)) {
            result.append(""&#160;<a href=\"""").append(permalink).append(""\"" target=\""_blank\""><img src=\"""").append(resources.getIcon(""kmelia.link"")).append(""\"" border=\""0\"" valign=\""absmiddle\"" alt=\"""").append(resources.getString(""kmelia.CopyFileLink"")).append(""\"" title=\"""").append(resources.getString(""kmelia.CopyFileLink"")).append(""\""/></a>"");
        }
        result.append(NEW_LINE);
        if (resources.getSetting(""fileStorageShowExtraInfoAttachment"", false)) {
            result.append(""<i>"");
            if (StringUtil.isDefined(title)) {
                result.append(logicalName).append("" / "");
            }
            result.append(size);
            result.append("" / "").append(downloadTime).append("" / "").append(resources.getOutputDate(creationDate));
            result.append(""</i>"");
            if (StringUtil.isDefined(info)) {
                result.append(NEW_LINE).append(WebEncodeHelper.javaStringToHtmlParagraphe(info));
            }
        }
    }
    return result.toString();
}",java:S3776,39
"private String displayFile(String url, String title, String info, String icon, String logicalName, String size, String downloadTime, Date creationDate, String permalink, MultiSilverpeasBundle resources, boolean attachmentLink, boolean previewable, boolean viewable, final boolean isDownloadAllowedForReaders, final boolean isUserAllowedToDownloadFile, String id){
    StringBuilder result = new StringBuilder(1024);
    if (!attachmentLink) {
        String link = isUserAllowedToDownloadFile ? ""<a href=\"""" + url + ""\"" target=\""_blank\"">"" : ""<span class=\""forbidden-download\"">"";
        result.append(""<tr><td valign=\""top\"">"");
        Img iconImg = new Img(icon).setAlignment(Alignment.MIDDLE);
        result.append(link).append(iconImg.toString()).append(""</a>&#160;</td>"");
        result.append(""<td valign=\""top\"">"").append(link);
        boolean showTitle = resources.getSetting(""showTitle"", true);
        String fileTitle = StringUtil.isDefined(title) ? title : logicalName;
        if (StringUtil.isDefined(fileTitle) && showTitle) {
            result.append(fileTitle);
        }
        result.append(isUserAllowedToDownloadFile ? ""</a>"" : END_SPAN);
        if (StringUtil.isDefined(permalink) && isUserAllowedToDownloadFile) {
            result.append(""&#160;<a href=\"""").append(permalink).append(""\"" target=\""_blank\""><img src=\"""").append(resources.getIcon(""kmelia.link"")).append(""\"" border=\""0\"" valign=\""absmiddle\"" alt=\"""").append(""\"" title=\"""").append(""\""/></a>"");
        }
        result.append(NEW_LINE);
        result.append(""<i>"");
        if (StringUtil.isDefined(logicalName) && (!logicalName.equals(fileTitle) || !showTitle)) {
            result.append(logicalName).append("" / "");
        }
        if (resources.getSetting(""showFileSize"", true)) {
            result.append(size);
        }
        if (resources.getSetting(""showDownloadEstimation"", false)) {
            result.append("" / "").append(downloadTime).append("" / "").append(resources.getOutputDate(creationDate));
        }
        if (previewable) {
            result.append("" <img onclick=\""javascript:previewFile(this, '"").append(id).append(""');\"" class=\""preview-file\"" src=\"""").append(resources.getIcon(""kmelia.file.preview"")).append(""\"" alt=\"""").append(resources.getString(""GML.preview.file"")).append(""\"" title=\"""").append(resources.getString(""GML.preview.file"")).append(""\""/>"");
        }
        if (viewable) {
            result.append("" <img onclick=\""javascript:viewFile(this, '"").append(id).append(""');\"" class=\""view-file\"" src=\"""").append(resources.getIcon(""kmelia.file.view"")).append(""\"" alt=\"""").append(resources.getString(""GML.view.file"")).append(""\"" title=\"""").append(resources.getString(""GML.view.file"")).append(""\""/>"");
        }
        if (!isDownloadAllowedForReaders) {
            String forbiddenDownloadHelp = isUserAllowedToDownloadFile ? resources.getString(""GML.download.forbidden.readers"") : resources.getString(""GML.download.forbidden"");
            result.append("" <img class=\""forbidden-download-file\"" src=\"""").append(resources.getIcon(""kmelia.file.forbidden-download"")).append(""\"" alt=\"""").append(forbiddenDownloadHelp).append(""\"" title=\"""").append(forbiddenDownloadHelp).append(""\""/>"");
        }
        result.append(""</i>"");
        if (StringUtil.isDefined(info) && resources.getSetting(""showInfo"", true)) {
            result.append(NEW_LINE).append(WebEncodeHelper.convertBlanksForHtml(info));
        }
        result.append(""</td></tr>"");
    } else {
        String displayedTitle;
        if (!StringUtil.isDefined(title)) {
            displayedTitle = logicalName;
        } else {
            displayedTitle = title;
        }
        String javascriptFunction = ""selectAttachment('"" + url + ""','"" + icon + ""','"" + displayedTitle + ""')"";
        String link = ""<a href=\""javascript:"" + javascriptFunction + ""\"" >"";
        result.append(""<tr><td valign=\""top\"">"");
        result.append(link).append(""<img src=\"""").append(icon).append(""\"" border=\""0\"" align=\""absmiddle\""/></a>&#160;</td>"");
        result.append(""<td valign=\""top\"">"").append(link);
        result.append(displayedTitle);
        result.append(""</a>"");
        if (StringUtil.isDefined(permalink)) {
            result.append(""&#160;<a href=\"""").append(permalink).append(""\"" target=\""_blank\""><img src=\"""").append(resources.getIcon(""kmelia.link"")).append(""\"" border=\""0\"" valign=\""absmiddle\"" alt=\"""").append(resources.getString(""kmelia.CopyFileLink"")).append(""\"" title=\"""").append(resources.getString(""kmelia.CopyFileLink"")).append(""\""/></a>"");
        }
        result.append(NEW_LINE);
        if (resources.getSetting(""fileStorageShowExtraInfoAttachment"", false)) {
            result.append(""<i>"");
            if (StringUtil.isDefined(title)) {
                result.append(logicalName).append("" / "");
            }
            result.append(size);
            result.append("" / "").append(downloadTime).append("" / "").append(resources.getOutputDate(creationDate));
            result.append(""</i>"");
            if (StringUtil.isDefined(info)) {
                result.append(NEW_LINE).append(WebEncodeHelper.javaStringToHtmlParagraphe(info));
            }
        }
    }
    return result.toString();
}",java:S107,1
"public String buildOptions(List ar, String selectValue, String selectText, boolean bSorted){
    StringBuilder valret = new StringBuilder();
    Properties elmt;
    String selected;
    List arToDisplay = ar;
    int i;
    if (selectText != null) {
        if (selectValue == null || selectValue.length() <= 0) {
            selected = ""SELECTED"";
        } else {
            selected = """";
        }
        valret.append(""<option value=\""\"" "").append(selected).append("">"").append(WebEncodeHelper.javaStringToHtmlString(selectText)).append(""</option>\n"");
    }
    if (bSorted) {
        Properties[] theList = (Properties[]) ar.toArray(new Properties[0]);
        Arrays.sort(theList, new Comparator() {

            @Override
            public int compare(Object o1, Object o2) {
                return (((Properties) o1).getProperty(""name"")).toUpperCase().compareTo(((Properties) o2).getProperty(""name"").toUpperCase());
            }
        });
        arToDisplay = new ArrayList(theList.length);
        for (i = 0; i < theList.length; i++) {
            arToDisplay.add(theList[i]);
        }
    }
    if (arToDisplay != null) {
        for (i = 0; i < arToDisplay.size(); i++) {
            elmt = (Properties) arToDisplay.get(i);
            if (elmt.getProperty(""id"").equalsIgnoreCase(selectValue)) {
                selected = ""SELECTED"";
            } else {
                selected = """";
            }
            valret.append(""<option value=\"""").append(elmt.getProperty(""id"")).append(""\"" "").append(selected).append("">"").append(WebEncodeHelper.javaStringToHtmlString(elmt.getProperty(""name""))).append(""</option>\n"");
        }
    }
    return valret.toString();
}",java:S3740,38
"private String processStatisticGroupSelectionRequestHandler(HttpServletRequest request, KmeliaSessionController kmelia){
    String m_context = ResourceLocator.getGeneralSettingBundle().getString(""ApplicationURL"");
    Pair<String, String>[] hostPath = new Pair[1];
    hostPath[0] = new Pair<>(kmelia.getString(""kmelia.SelectValidator""), """");
    Selection sel = kmelia.getSelection();
    sel.resetAll();
    sel.setHostSpaceName(kmelia.getSpaceLabel());
    sel.setHostComponentName(new Pair<>(kmelia.getComponentLabel(), """"));
    sel.setHostPath(hostPath);
    sel.setMultiSelect(false);
    sel.setSetSelectable(true);
    sel.setElementSelectable(false);
    String hostUrl = m_context + URLUtil.getURL(""useless"", kmelia.getComponentId()) + ""StatisticSetGroup?Role="";
    String cancelUrl = m_context + URLUtil.getURL(""useless"", kmelia.getComponentId()) + ""CloseWindow"";
    sel.setGoBackURL(hostUrl);
    sel.setCancelURL(cancelUrl);
    sel.setHtmlFormName(""statForm"");
    sel.setHtmlFormElementName(""filterLibGroup"");
    sel.setHtmlFormElementId(""filterIdGroup"");
    SelectionUsersGroups sug = new SelectionUsersGroups();
    sug.setComponentId(kmelia.getComponentId());
    ProfileInst writerProfile = kmelia.getProfile(KmeliaHelper.ROLE_WRITER);
    ProfileInst readerProfile = kmelia.getProfile(KmeliaHelper.ROLE_READER);
    List<String> profileNames = new ArrayList<>();
    profileNames.add(readerProfile.getName());
    profileNames.add(writerProfile.getName());
    sug.setProfileNames(profileNames);
    sel.setExtraParams(sug);
    return Selection.getSelectionURL();
}",java:S1172,13
"public void endElement(QName element, Augmentations augs) throws XNIException{
    if (fElementDepth <= fRemovalElementDepth && elementAccepted(element.rawname)) {
        super.endElement(element, augs);
    }
    fElementDepth--;
    if (fElementDepth == fRemovalElementDepth) {
        fRemovalElementDepth = Integer.MAX_VALUE;
    }
    XMLString string = new XMLString();
    string.setValues(new char[] { ' ', ' ' }, 0, 1);
    characters(string, augs);
}",java:S1161,11
"public static String processMailingList(RestRequest rest, HttpServletRequest request){
    switch(rest.getAction()) {
        case RestRequest.DELETE:
        case RestRequest.UPDATE:
        case RestRequest.FIND:
        default:
            int page = 0;
            if (request.getParameter(CURRENT_PAGE_PARAM) != null) {
                try {
                    page = Integer.parseInt(request.getParameter(CURRENT_PAGE_PARAM));
                } catch (NumberFormatException nfex) {
                }
            }
            int year = -1;
            if (rest.getElements().get(CURRENT_YEAR_PARAM) != null) {
                try {
                    year = Integer.parseInt(rest.getElements().get(CURRENT_YEAR_PARAM));
                } catch (NumberFormatException nfex) {
                    year = -1;
                }
            }
            int month = -1;
            if (rest.getElements().get(CURRENT_MONTH_PARAM) != null) {
                try {
                    month = Integer.parseInt(rest.getElements().get(CURRENT_MONTH_PARAM));
                } catch (NumberFormatException nfex) {
                    month = -1;
                }
            }
            String id = rest.getElements().get(DESTINATION_LIST);
            MailingList list = MailingListServicesProvider.getMailingListService().findMailingList(id);
            String orderParam = request.getParameter(ORDER_BY_PARAM);
            String ascendantParam = request.getParameter(ORDER_ASC_PARAM);
            boolean asc = false;
            if (orderParam == null) {
                orderParam = ""sentDate"";
            }
            if (ascendantParam != null) {
                asc = Boolean.valueOf(ascendantParam);
            }
            request.setAttribute(orderParam, !asc);
            OrderBy orderBy = new OrderBy(orderParam, asc);
            List<Message> messages = MailingListServicesProvider.getMessageService().listDisplayableMessages(list, month, year, page, orderBy);
            request.setAttribute(MESSAGES_LIST_ATT, messages);
            int nbPages = MailingListServicesProvider.getMessageService().getNumberOfPagesForDisplayableMessages(list);
            request.setAttribute(NB_PAGE_ATT, nbPages);
            request.setAttribute(CURRENT_PAGE_ATT, page);
            return JSP_BASE + DESTINATION_DISPLAY_LIST;
    }
}",java:S3776,39
"public static String processMessage(RestRequest rest, HttpServletRequest request){
    String id = rest.getElements().get(DESTINATION_MESSAGE);
    switch(rest.getAction()) {
        case RestRequest.DELETE:
            if ((Boolean) request.getAttribute(IS_USER_ADMIN_ATT) || (Boolean) request.getAttribute(IS_USER_MODERATOR_ATT)) {
                String[] ids = request.getParameterValues(SELECTED_MESSAGE_PARAM);
                if (ids != null && ids.length > 0) {
                    for (final String id1 : ids) {
                        deleteMessage(id1);
                    }
                } else {
                    if (id != null && !DELETE_ACTION.equalsIgnoreCase(id) && !UPDATE_ACTION.equalsIgnoreCase(id)) {
                        deleteMessage(id);
                    }
                }
            }
            if (MODERATION_VALUE.equalsIgnoreCase(rest.getElements().get(DESTINATION_ELEMENT))) {
                return buildRedirectUrl(request, rest.getComponentId() + '/' + DESTINATION_MODERATION + '/' + rest.getComponentId());
            }
            return buildRedirectUrl(request, rest.getComponentId() + '/' + DESTINATION_LIST + '/' + rest.getComponentId());
        case RestRequest.UPDATE:
            boolean isAuthorized = ((Boolean) request.getAttribute(IS_USER_ADMIN_ATT) || (Boolean) request.getAttribute(IS_USER_MODERATOR_ATT));
            if (!isAuthorized) {
                return buildRedirectUrl(request, rest.getComponentId() + '/' + DESTINATION_LIST + '/' + rest.getComponentId());
            }
            String[] ids = request.getParameterValues(SELECTED_MESSAGE_PARAM);
            if (ids != null && ids.length > 0) {
                for (final String id1 : ids) {
                    moderateMessage(id1);
                }
                if (ids.length != 1) {
                    return buildRedirectUrl(request, rest.getComponentId() + '/' + DESTINATION_MODERATION + '/' + rest.getComponentId());
                }
                id = ids[0];
            } else {
                if (id != null && !DELETE_ACTION.equalsIgnoreCase(id) && !UPDATE_ACTION.equalsIgnoreCase(id)) {
                    moderateMessage(id);
                } else {
                    return buildRedirectUrl(request, rest.getComponentId() + '/' + DESTINATION_LIST + '/' + rest.getComponentId());
                }
            }
            rest.getElements().put(DESTINATION_ELEMENT, DESTINATION_MODERATION);
            setMessage(id, request);
            request.setAttribute(PREVIOUS_PATH_ATT, rest.getElements().get(DESTINATION_ELEMENT));
            return JSP_BASE + DESTINATION_DISPLAY_MESSAGE;
        case RestRequest.FIND:
            setMessage(id, request);
            request.setAttribute(PREVIOUS_PATH_ATT, rest.getElements().get(DESTINATION_ELEMENT));
            return JSP_BASE + DESTINATION_DISPLAY_MESSAGE;
        default:
            return buildRedirectUrl(request, rest.getComponentId() + '/' + DESTINATION_LIST + '/' + rest.getComponentId());
    }
}",java:S3776,39
"public static String processUsers(RestRequest rest, HttpServletRequest request){
    String id = rest.getElements().get(DESTINATION_USERS);
    switch(rest.getAction()) {
        case RestRequest.DELETE:
            if ((Boolean) request.getAttribute(IS_USER_ADMIN_ATT)) {
                String[] emails = request.getParameterValues(SELECTED_USERS_PARAM);
                if (emails != null && emails.length > 0) {
                    Set<ExternalUser> users = new HashSet<>(emails.length);
                    for (final String email : emails) {
                        ExternalUser user = new ExternalUser();
                        user.setComponentId(rest.getComponentId());
                        user.setEmail(email);
                        users.add(user);
                    }
                    MailingListServicesProvider.getMailingListService().removeExternalUsers(rest.getComponentId(), users);
                } else {
                    if (id != null && !DELETE_ACTION.equalsIgnoreCase(id) && !UPDATE_ACTION.equalsIgnoreCase(id)) {
                        ExternalUser user = new ExternalUser();
                        user.setComponentId(rest.getComponentId());
                        user.setEmail(id);
                        MailingListServicesProvider.getMailingListService().removeExternalUser(rest.getComponentId(), user);
                    }
                }
            }
            break;
        case RestRequest.CREATE:
            if ((Boolean) request.getAttribute(IS_USER_ADMIN_ATT)) {
                String emails = request.getParameter(USERS_LIST_PARAM);
                if (emails != null) {
                    StringTokenizer tokenizer = new StringTokenizer(emails, "";"", false);
                    Set<ExternalUser> users = new HashSet<>(100);
                    while (tokenizer.hasMoreTokens()) {
                        String email = tokenizer.nextToken();
                        boolean isValid = false;
                        try {
                            isValid = (new InternetAddress(email) != null);
                        } catch (AddressException ex) {
                        }
                        if (email != null && isValid) {
                            ExternalUser user = new ExternalUser();
                            user.setComponentId(rest.getComponentId());
                            user.setEmail(email);
                            users.add(user);
                        }
                    }
                    MailingListServicesProvider.getMailingListService().addExternalUsers(rest.getComponentId(), users);
                }
            }
            break;
        case RestRequest.UPDATE:
        case RestRequest.FIND:
        default:
    }
    return prepareUsersList(request, rest);
}",java:S3776,39
"private List<OrganizationalPerson> getMembers(String groupId, String[] userIds, OrganizationalChartType type){
    List<OrganizationalPerson> personList = new ArrayList<>(userIds.length);
    for (String userId : userIds) {
        OrganizationalPerson person = loadOrganizationalPerson(userId, type);
        if (person != null) {
            personList.add(person);
        }
    }
    Collections.sort(personList, new OrganizationalPersonComparator());
    return personList;
}",java:S1172,13
"private static ChartPersonnVO buildFakePersonUnit(){
    ChartPersonnVO chart = new ChartPersonnVO();
    OrganizationBox rootOrganization = new OrganizationBox();
    List<UserVO> mainActors = new ArrayList<>();
    mainActors.add(new UserVO(""Laurent Morel"", ""l.morel"", ""Directeur""));
    mainActors.add(new UserVO(""Dupond Jean"", ""j.dupond"", ""Directeur associ""));
    rootOrganization.setName(""DGS"");
    rootOrganization.setDn(""OU=DGS,OU=Issy,dc=mondomain,dc=com"");
    rootOrganization.setMainActors(mainActors);
    rootOrganization.setParentDn(""OU=Issy,dc=mondomain,dc=com"");
    chart.setRootOrganization(rootOrganization);
    CategoryBox category1 = new CategoryBox();
    category1.setName(""Secrtaire"");
    List<UserVO> letusers = new ArrayList<>();
    letusers.add(new UserVO(""Murielle Dus"", ""m.duc"", null));
    letusers.add(new UserVO(""Camille Bet"", ""c.bet"", null));
    category1.setUsers(letusers);
    CategoryBox category2 = new CategoryBox();
    category2.setName(""Adjoints"");
    List<UserVO> rightusers = new ArrayList<>();
    rightusers.add(new UserVO(""Jeanne Calment"", ""m.duc"", null));
    rightusers.add(new UserVO(""Pierre Le Bon"", ""p.lebon"", null));
    category2.setUsers(rightusers);
    List<CategoryBox> categories = new ArrayList<>();
    categories.add(category1);
    categories.add(category2);
    chart.setCategories(categories);
    return chart;
}",java:S1144,10
"private String getActiveRoles(State state){
    QualifiedUsers workingUsers = state.getWorkingUsers();
    RelatedUser[] relatedUsers = workingUsers.getRelatedUsers();
    StringBuilder role = new StringBuilder();
    if (relatedUsers != null) {
        for (RelatedUser relatedUser : relatedUsers) {
            if (role.length() > 0) {
                role.append("", "");
            }
            Participant participant = relatedUser.getParticipant();
            String relation = relatedUser.getRelation();
            if (participant != null && relation == null) {
                role.append(participant.getLabel(currentRole, getLanguage()));
            } else if (participant != null) {
                String requesterId = getCreatorIdOfCurrentProcessInstance();
                if (requesterId != null) {
                    UserInfo userInfo = getSettingsOfUser(requesterId).getUserInfo(relation);
                    if (userInfo != null) {
                        role.append(getUserDetail(userInfo.getValue()).getDisplayedName());
                    }
                }
            }
            Item item = relatedUser.getFolderItem();
            if (item != null) {
                try {
                    Field field = currentProcessInstance.getField(item.getName());
                    if (field instanceof UserField) {
                        String userId = field.getStringValue();
                        if (userId != null) {
                            UserDetail user = getUserDetail(userId);
                            if (user != null) {
                                role.append(user.getDisplayedName());
                            }
                        }
                    } else if (field instanceof MultipleUserField) {
                        MultipleUserField multipleUserField = (MultipleUserField) field;
                        String[] userIds = multipleUserField.getUserIds();
                        for (String userId : userIds) {
                            if (userId != null) {
                                UserDetail user = getUserDetail(userId);
                                if (user != null) {
                                    if (role.length() > 0) {
                                        role.append("", "");
                                    }
                                    role.append(user.getDisplayedName());
                                }
                            }
                        }
                    }
                } catch (Exception e) {
                    SilverLogger.getLogger(this).warn(e);
                }
            }
        }
    }
    UserInRole[] userInRoles = workingUsers.getUserInRoles();
    if (userInRoles != null) {
        for (UserInRole userInRole : userInRoles) {
            if (role.length() > 0) {
                role.append("", "");
            }
            role.append(processModel.getRole(userInRole.getRoleName()).getLabel(currentRole, getLanguage()));
        }
    }
    RelatedGroup[] relatedGroups = workingUsers.getRelatedGroups();
    if (relatedGroups != null) {
        for (RelatedGroup relatedGroup : relatedGroups) {
            if (relatedGroup != null) {
                if (role.length() > 0) {
                    role.append("", "");
                }
                Item item = relatedGroup.getFolderItem();
                try {
                    if (item != null) {
                        String groupId = currentProcessInstance.getField(item.getName()).getStringValue();
                        if (groupId != null) {
                            Group group = getOrganisationController().getGroup(groupId);
                            if (group != null) {
                                role.append(group.getName());
                            }
                        }
                    }
                } catch (Exception e) {
                    SilverLogger.getLogger(this).warn(e);
                }
            }
        }
    }
    return role.toString();
}",java:S3776,39
"private List<String> getUsers(QualifiedUsers qualifiedUsers, boolean useCurrentRole){
    List<String> users = new ArrayList<>();
    RelatedUser[] relatedUsers = qualifiedUsers.getRelatedUsers();
    RelatedUser relatedUser;
    List<String> roles = new ArrayList<>();
    for (final RelatedUser relatedUser1 : relatedUsers) {
        relatedUser = relatedUser1;
        Participant participant = relatedUser.getParticipant();
        String relation = relatedUser.getRelation();
        if (participant != null && relation == null) {
            if (currentRole.equals(relatedUser.getRole())) {
                users.add(getActiveUser().getUserId());
            }
        } else if (participant != null) {
            String requesterId = getCreatorIdOfCurrentProcessInstance();
            if (requesterId != null) {
                UserInfo userInfo = getSettingsOfUser(requesterId).getUserInfo(relation);
                if (userInfo != null) {
                    users.add(userInfo.getValue());
                }
            }
        }
        Item item = relatedUser.getFolderItem();
        if (item != null) {
            try {
                Field field = currentProcessInstance.getField(item.getName());
                String role = relatedUser.getRole();
                if (field instanceof UserField) {
                    if ((isDefined(role) && currentRole.equals(role)) || StringUtil.isNotDefined(role)) {
                        users.add(field.getStringValue());
                    }
                } else if (field instanceof MultipleUserField) {
                    MultipleUserField multipleUserField = (MultipleUserField) field;
                    if ((isDefined(role) && currentRole.equals(role)) || StringUtil.isNotDefined(role)) {
                        users.addAll(Arrays.asList(multipleUserField.getUserIds()));
                    }
                }
            } catch (WorkflowException we) {
            }
        }
    }
    UserInRole[] userInRoles = qualifiedUsers.getUserInRoles();
    for (final UserInRole userInRole : userInRoles) {
        roles.add(userInRole.getRoleName());
    }
    if (useCurrentRole) {
        if (roles.contains(currentRole)) {
            roles.clear();
            roles.add(currentRole);
        } else {
            roles.clear();
        }
    }
    final boolean lookAlsoForRemoved = getCurrentReplacement() != null;
    final String[] userIds = getOrganisationController().getUsersIdsByRoleNames(getComponentId(), roles, lookAlsoForRemoved);
    users.addAll(Arrays.asList(userIds));
    RelatedGroup[] relatedGroups = qualifiedUsers.getRelatedGroups();
    if (relatedGroups != null) {
        for (RelatedGroup relatedGroup : relatedGroups) {
            if (relatedGroup != null) {
                String role = relatedGroup.getRole();
                if (currentRole.equals(role) || StringUtil.isNotDefined(role)) {
                    Item item = relatedGroup.getFolderItem();
                    if (item != null) {
                        try {
                            String groupId = currentProcessInstance.getField(item.getName()).getStringValue();
                            UserDetail[] usersOfGroup = getOrganisationController().getAllUsersOfGroup(groupId);
                            for (UserDetail userOfGroup : usersOfGroup) {
                                users.add(userOfGroup.getId());
                            }
                        } catch (WorkflowException we) {
                        }
                    }
                }
            }
        }
    }
    return users;
}",java:S3776,39
"private DataRecord getStepRecord(HistoryStep step){
    try {
        final Date actionDate = step.getActionDate();
        if (QUESTION_ACTION.equals(step.getAction())) {
            final Optional<Question> question = Arrays.stream(currentProcessInstance.getQuestions()).filter(q -> {
                if (step.getResolvedState().equals(q.getFromState().getName())) {
                    final Date questionDate = q.getQuestionDate();
                    final long elapsedTimeBetweenActionAndQuestion = questionDate.getTime() - actionDate.getTime();
                    return 0 < elapsedTimeBetweenActionAndQuestion && elapsedTimeBetweenActionAndQuestion < 30000;
                }
                return false;
            }).findFirst();
            return question.<DataRecord>map(q -> new QuestionRecord(q.getQuestionText())).orElse(null);
        } else if (RESPONSE_ACTION.equals(step.getAction())) {
            final Optional<Question> question = Arrays.stream(currentProcessInstance.getQuestions()).filter(q -> {
                if (step.getResolvedState().equals(q.getTargetState().getName())) {
                    final Date responseDate = q.getResponseDate();
                    final long elapsedTimeBetweenActionAndResponse = responseDate != null ? responseDate.getTime() - actionDate.getTime() : -1;
                    return 0 < elapsedTimeBetweenActionAndResponse && elapsedTimeBetweenActionAndResponse < 30000;
                }
                return false;
            }).findFirst();
            return question.<DataRecord>map(q -> new QuestionRecord(q.getResponseText())).orElse(null);
        } else {
            return step.getActionRecord();
        }
    } catch (WorkflowException e) {
        SilverLogger.getLogger(this).silent(e);
        return null;
    }
}",java:S3776,39
"private String getFieldValue(ProcessInstanceRowRecord instance, Item[] items, String fieldName){
    String fieldString;
    try {
        Field field = instance.getFullProcessInstance().getField(fieldName);
        fieldString = field.getValue(getLanguage());
        if (!isDefined(fieldString) || !field.getTypeName().equals(DateField.TYPE)) {
            ItemImpl item = (ItemImpl) getItemByName(items, fieldName);
            if (item != null) {
                Map<String, String> keyValuePairs = item.getKeyValuePairs();
                if (keyValuePairs != null && keyValuePairs.size() > 0) {
                    StringBuilder newValue = new StringBuilder();
                    if (isDefined(fieldString)) {
                        final String delimiter = ""##"";
                        if (fieldString.contains(delimiter)) {
                            StringTokenizer tokenizer = new StringTokenizer(fieldString, delimiter);
                            String token;
                            while (tokenizer.hasMoreTokens()) {
                                token = tokenizer.nextToken();
                                token = keyValuePairs.get(token);
                                newValue.append(token);
                                if (tokenizer.hasMoreTokens()) {
                                    newValue.append("", "");
                                }
                            }
                        } else {
                            newValue.append(keyValuePairs.get(fieldString));
                        }
                    }
                    fieldString = newValue.toString();
                }
            }
        }
    } catch (WorkflowException we) {
        fieldString = """";
    }
    return fieldString;
}",java:S3776,39
"public int hashCode(){
    return super.hashCode();
}",java:S1161,11
"public String getTitle(){
    return title;
}",java:S1161,11
"public static List<Answer> extractAnswer(List<FileItem> items, QuestionForm form, String componentId, String subdir) throws IOException{
    List<Answer> answers = new ArrayList<>();
    for (final FileItem item : items) {
        String mpName = item.getFieldName();
        if (item.isFormField() && mpName.startsWith(""answer"")) {
            String answerInput = FileUploadUtil.getOldParameter(items, mpName, """");
            Answer answer = new Answer(null, null, answerInput, 0, false, null, 0, false, null, null);
            String id = mpName.substring(""answer"".length());
            String nbPoints = FileUploadUtil.getOldParameter(items, ""nbPoints"" + id, ""0"");
            answer.setNbPoints(Integer.parseInt(nbPoints));
            if (Integer.parseInt(nbPoints) > 0) {
                answer.setIsSolution(true);
            }
            String comment = FileUploadUtil.getOldParameter(items, ""comment"" + id, """");
            answer.setComment(comment);
            String value = FileUploadUtil.getOldParameter(items, ""valueImageGallery"" + id, """");
            if (StringUtil.isDefined(value)) {
                if (!form.isFile()) {
                    answer.setImage(value);
                }
            }
            FileItem image = FileUploadUtil.getFile(items, ""image"" + id);
            if (image != null) {
                addImageToAnswer(answer, image, form, componentId, subdir);
            }
            answers.add(answer);
        }
    }
    return answers;
}",java:S3776,39
"private void pasteQuizz(QuestionContainerDetail quizz) throws Exception{
    String componentId;
    QuestionContainerPK quizzPk = quizz.getHeader().getPK();
    if (quizz.getHeader().getInstanceId().equals(getComponentId())) {
        componentId = quizz.getHeader().getInstanceId();
    } else {
        componentId = getComponentId();
    }
    Collection<Question> questions = quizz.getQuestions();
    for (final Question question : questions) {
        Collection<Answer> answers = question.getAnswers();
        Iterator<Answer> itA = answers.iterator();
        int attachmentSuffix = 0;
        while (itA.hasNext()) {
            Answer answer = itA.next();
            String physicalName = answer.getImage();
            if (StringUtil.isDefined(physicalName)) {
                SettingBundle srvSettings = ResourceLocator.getSettingBundle(""org.silverpeas.survey.surveySettings"");
                String type = physicalName.substring(physicalName.indexOf('.') + 1, physicalName.length());
                String newPhysicalName = Long.toString(new Date().getTime()) + attachmentSuffix + ""."" + type;
                attachmentSuffix = attachmentSuffix + 1;
                if (quizz.getHeader().getInstanceId().equals(getComponentId())) {
                    String absolutePath = FileRepositoryManager.getAbsolutePath(componentId);
                    String dir = absolutePath + srvSettings.getString(""imagesSubDirectory"") + File.separator;
                    FileRepositoryManager.copyFile(dir + physicalName, dir + newPhysicalName);
                } else {
                    String fromAbsolutePath = FileRepositoryManager.getAbsolutePath(quizz.getHeader().getInstanceId());
                    String toAbsolutePath = FileRepositoryManager.getAbsolutePath(componentId);
                    String fromDir = fromAbsolutePath + srvSettings.getString(""imagesSubDirectory"") + File.separator;
                    String toDir = toAbsolutePath + srvSettings.getString(""imagesSubDirectory"") + File.separator;
                    FileRepositoryManager.copyFile(fromDir + physicalName, toDir + newPhysicalName);
                }
                answer.setImage(newPhysicalName);
            }
        }
    }
    QuestionContainerPK toQuestionContainerPk = createQuizz(quizz, componentId);
    final int fromSilverObjectId = getQuestionContainerService().getSilverObjectId(quizzPk);
    final int toSilverObjectId = getQuestionContainerService().getSilverObjectId(toQuestionContainerPk);
    PdcManager.get().copyPositions(fromSilverObjectId, quizz.getHeader().getInstanceId(), toSilverObjectId, componentId);
}",java:S112,4
"public static void displayForumsList(JspWriter out, MultiSilverpeasBundle resources, boolean admin, boolean moderator, boolean reader, int currentForumId, String call, ForumsSessionController fsc, String categoryId, String nom, String description, boolean isSubscriberByInheritance){
    try {
        Forum[] forums = fsc.getForumsListByCategory(categoryId);
        if (forums != null) {
            out.println(""<tr>"");
            out.print(""<td colspan=\""7\"" class=\""titreCateg\"">"" + nom);
            if (description != null && description.length() > 0) {
                out.print("" - <i>"" + description + ""<i>"");
            }
            out.println(""</td>"");
            if (admin || moderator) {
                out.print(""<td class=\""titreCateg\"" align=\""center\"" nowrap>"");
                if (categoryId != null) {
                    out.print(""<a href=\""EditCategory?CategoryId="" + categoryId + ""\"">"");
                    out.print(""<img src=\"""" + ForumHelper.IMAGE_UPDATE + ""\"" border=\""0\"" align=\""middle\"" alt=\"""" + resources.getString(""forums.editCategory"") + ""\"" title=\"""" + resources.getString(""forums.editCategory"") + ""\""/></a>"");
                    out.print(""&nbsp;&nbsp;"");
                    out.print(""<a href=\""javascript:confirmDeleteCategory('"" + String.valueOf(categoryId) + ""');\"">"");
                    out.print(""<img src=\"""" + ForumHelper.IMAGE_DELETE + ""\"" border=\""0\"" align=\""middle\"" alt=\"""" + resources.getString(""forums.deleteCategory"") + ""\"" title=\"""" + resources.getString(""forums.deleteCategory"") + ""\""/></a>"");
                    out.print(""&nbsp;"");
                    out.print(""<img src=\""icons/1px.gif\"" width=\""15\"" height=\""15\"" border=\""0\"" "" + ""align=\""middle\""/>"");
                }
                out.println(""</td>"");
            }
            out.println(""</tr>"");
            scanForum(forums, resources, out, currentForumId, call, admin, moderator, reader, currentForumId, 0, fsc, isSubscriberByInheritance);
        }
    } catch (IOException ioe) {
        SilverLogger.getLogger(ForumListHelper.class).error(ioe);
    }
}",java:S107,1
"public void performBeforePersist(){
    Date now = new Date();
    setCreationDate(now);
    setUpdateDate(now);
}",java:S1161,11
"public void performBeforeUpdate(){
    setUpdateDate(new Date());
}",java:S1161,11
"public static void displayChildForums(JspWriter out, MultiSilverpeasBundle resources, boolean admin, boolean moderator, boolean reader, int currentForumId, String call, ForumsSessionController fsc, boolean isSubscriberByInheritance){
    int[] forumIds = fsc.getForumSonsIds(currentForumId);
    for (int forumId : forumIds) {
        boolean isForumSubscriberByInheritance = isSubscriberByInheritance;
        if (!isForumSubscriberByInheritance) {
            isForumSubscriberByInheritance = fsc.isForumSubscriberByInheritance(forumId);
        }
        Forum forum = fsc.getForum(forumId);
        displayForumLine(forum, resources, out, forum.getParentId(), call, admin, moderator, reader, 0, fsc, isForumSubscriberByInheritance);
    }
}",java:S107,1
"private String[] buildSearchPeriod(Period period){
    return new String[] { String.valueOf(period.getBeginDate().getTime()), String.valueOf(period.getEndDate().getTime()) };
}",java:S1874,25
"private static void scanForum(Forum[] forums, MultiSilverpeasBundle resources, JspWriter out, int currentPage, String call, boolean admin, boolean moderator, boolean reader, int currentForumId, int depth, ForumsSessionController fsc, boolean isSubscriberByInheritance){
    for (final Forum forum : forums) {
        int forumParent = forum.getParentId();
        if (forumParent == currentForumId) {
            int forumId = forum.getId();
            boolean isForumSubscriberByInheritance = isSubscriberByInheritance;
            if (!isForumSubscriberByInheritance) {
                isForumSubscriberByInheritance = fsc.isForumSubscriberByInheritance(forumId);
            }
            boolean hasChildren = hasChildren(forums, forumId);
            boolean isDeployed = fsc.forumIsDeployed(forumId);
            displayForumLine(forum, resources, out, currentPage, call, admin, moderator, reader, depth, fsc, isForumSubscriberByInheritance);
            if (hasChildren && isDeployed) {
                scanForum(forums, resources, out, currentPage, call, admin, moderator, reader, forumId, depth + 1, fsc, isForumSubscriberByInheritance);
            }
        }
    }
}",java:S107,1
"public String getRootTableName(){
    return ""SC_Rss_Channels"";
}",java:S1161,11
"public String getTableName(){
    return ""SC_Rss_Channels"";
}",java:S1161,11
"public int hashCode(){
    return toString().hashCode();
}",java:S1161,11
"private Exception UndefinedForwardRequestHandlerException(){
    return new Exception(""No forward request defines for"" + this.getClass());
}",java:S100,0
"private Exception UndefinedForwardRequestHandlerException(){
    return new Exception(""No forward request defines for"" + this.getClass());
}",java:S100,0
"private Exception UndefinedForwardRequestHandlerException(){
    return new Exception(""No forward request defines for"" + this.getClass());
}",java:S100,0
"private Exception UndefinedForwardRequestHandlerException(){
    return new Exception(""No forward request defines for"" + this.getClass());
}",java:S100,0
"private Exception UndefinedForwardRequestHandlerException(){
    return new Exception(""No forward request defines for"" + this.getClass());
}",java:S100,0
"private void addTime(HalfDayPart halfDayPart, DateOption date) throws Exception{
    switch(halfDayPart) {
        case MORNING:
            morning = makeMorning(date);
            break;
        case AFTERNOON:
            afternoon = makeAfternoon(date);
            break;
        default:
            throw new Exception(""addTime: "" + halfDayPart + "" not supported"");
    }
}",java:S112,4
"public void setPartOfDayFromHour(DateOption dateOption) throws Exception{
    if (isSameDateAs(dateOption)) {
        setPartOfDayFromHour(dateOption.getHour());
    } else {
        throw new Exception(""Cannot assign a part of day for two different dates"");
    }
}",java:S112,4
"private void setPartOfDayFromHour(int hour){
    setAfternoon(true);
    setMorning(true);
}",java:S1172,13
"public static final String formatInPercent(double rate){
    NumberFormat percent = NumberFormat.getPercentInstance();
    percent.setMaximumFractionDigits(PERCENT_FORMAT_DIGITS_PRECISION);
    return percent.format(rate);
}",java:S1124,6
"protected void setCommentCount(int count){
}",java:S1186,16
"protected void setContributionType(String type){
}",java:S1186,16
"protected void setAuthorName(String author){
}",java:S1186,16
"protected void setCreateDate(Date validationDate){
}",java:S1186,16
"protected void setApprobationDate(final String dateInISO8601){
}",java:S1186,16
"protected void setRaterRating(final RaterRatingEntity raterRatingEntity){
}",java:S1186,16
"public synchronized NodePK updateFolderHeader(NodeDetail nd, String alertType) throws WebSitesException{
    try {
        return getWebSiteService().updateFolder(nd, sessionTopic.getNodePK());
    } catch (Exception re) {
        throw new WebSitesException(""WebSiteSessionController.updateFolderHeader()"", SilverpeasException.ERROR, ""webSites.EX_UPDATE_FOLDER_HEADER_FAILED"", re);
    }
}",java:S1172,13
"public synchronized NodePK addFolder(NodeDetail nd, String alertType) throws WebSitesException{
    try {
        return getWebSiteService().addFolder(nd, sessionTopic.getNodePK(), getUserDetail());
    } catch (Exception re) {
        throw new WebSitesException(""WebSiteSessionController.addFolder()"", SilverpeasException.ERROR, ""webSites.EX_ADD_FOLDER_FAILED"", re);
    }
}",java:S1172,13
"public static List<SocialInformation> getAllMediaIdByUserId(String userId, Period period) throws SQLException{
    return create(""(select createDate AS dateinformation, mediaId, 'new' as type from SC_Gallery_Media "" + ""where createdBy = ? and createDate >= ? and createDate <= ? ) "" + ""union (select lastUpdateDate AS dateinformation, mediaId , "" + ""'update' as type from SC_Gallery_Media where lastUpdatedBy = ? and lastUpdateDate <>"" + "" createDate and lastUpdateDate >= ? and lastUpdateDate <= ? ) order by "" + ""dateinformation desc, mediaId desc"", userId, period.getBeginDatable(), period.getEndDatable(), userId, period.getBeginDatable(), period.getEndDatable()).execute(row -> {
        Media media = getByCriteria(MediaCriteria.fromMediaId(row.getString(2)).withVisibility(MediaCriteria.VISIBILITY.FORCE_GET_ALL));
        MediaWithStatus withStatus = new MediaWithStatus(media, ""update"".equalsIgnoreCase(row.getString(3)));
        return new SocialInformationGallery(withStatus);
    });
}",java:S1874,25
"public void updateClassification(String idSite, ArrayList<String> arrayTopic) throws WebSitesException{
    try {
        String idPub = getWebSiteService().getIdPublication(getComponentId(), idSite);
        getWebSiteService().updateClassification(new PublicationPK(idPub, getComponentId()), arrayTopic);
    } catch (Exception re) {
        throw new WebSitesException(""WebSiteSessionController.updateClassification"", SilverpeasException.ERROR, ""webSites.EX_PUBLICATION_UPDATE_FAILED"", ""site id ="" + idSite, re);
    }
}",java:S1319,22
"private void deleteIndex(WAPrimaryKey pk){
    IndexEngineProxy.removeIndexEntry(new IndexEntryKey(pk.getComponentName(), ""card"", pk.getId()));
}",java:S1874,25
"private SilverpeasBeanDAO getCardDAO() throws PersistenceException{
    return SilverpeasBeanDAOFactory.getDAO(""org.silverpeas.components.whitepages.model.Card"");
}",java:S3740,38
"private SilverpeasBeanDAO getCardDAO() throws PersistenceException{
    return SilverpeasBeanDAOFactory.getDAO(""org.silverpeas.components.whitepages.model.Card"");
}",java:S1874,25
"protected ArrayList getRow(int row){
    if (values.size() > row) {
        return (ArrayList) values.get(row);
    } else {
        return new ArrayList();
    }
}",java:S3740,38
"public int getSilverObjectId(String objectId){
    return Integer.parseInt(getCurrentCardContentId());
}",java:S1172,13
"public SortedSet<SearchField> getSearchFields() throws WhitePagesException{
    SortedSet<SearchField> fields = WhitePageServiceProvider.getWhitePagesService().getSearchFields(getComponentId());
    if (!fields.isEmpty()) {
        PublicationTemplate template = null;
        Map<String, String> domainProperties = null;
        try {
            RecordTemplate recordTemplate = null;
            for (SearchField field : fields) {
                if (field.getFieldId().startsWith(SearchFieldsType.XML.getLabelType())) {
                    if (template == null) {
                        template = getTemplate(getComponentId());
                        recordTemplate = template.getRecordTemplate();
                    }
                    field.setLabel(recordTemplate.getFieldTemplate(field.getFieldName()).getLabel(getLanguage()));
                } else if (field.getFieldId().startsWith(SearchFieldsType.LDAP.getLabelType())) {
                    if (domainProperties == null) {
                        domainProperties = getDomainProperties();
                    }
                    field.setLabel(domainProperties.get(field.getFieldName()));
                } else if (field.getFieldId().startsWith(SearchFieldsType.USER.getLabelType())) {
                    if (""name"".equals(field.getFieldName())) {
                        field.setLabel(ResourceLocator.getGeneralLocalizationBundle(getLanguage()).getString(""GML.lastName""));
                    } else if (""surname"".equals(field.getFieldName())) {
                        field.setLabel(ResourceLocator.getGeneralLocalizationBundle(getLanguage()).getString(""GML.surname""));
                    } else if (""email"".equals(field.getFieldName())) {
                        field.setLabel(ResourceLocator.getGeneralLocalizationBundle(getLanguage()).getString(""GML.eMail""));
                    }
                }
            }
        } catch (Exception e) {
            SilverLogger.getLogger(this).error(e);
        }
    }
    return fields;
}",java:S3776,39
"public HashMap<String, Set<ClassifyValue>> getPdcPositions(int cardId) throws PdcException{
    HashMap<String, Set<ClassifyValue>> result = new HashMap<>();
    List<ClassifyPosition> listOfPositions = getPdcManager().getPositions(cardId, getComponentId());
    if (listOfPositions != null && listOfPositions.size() > 0) {
        for (ClassifyPosition position : listOfPositions) {
            for (ClassifyValue value : position.getValues()) {
                List<Value> path = value.getFullPath();
                if (path != null && !path.isEmpty()) {
                    Value axis = path.get(0);
                    String category = axis.getName(getLanguage());
                    if (result.containsKey(category)) {
                        result.get(category).add(value);
                    } else {
                        Set<ClassifyValue> values = new HashSet<>();
                        values.add(value);
                        result.put(category, values);
                    }
                }
            }
        }
    }
    return result;
}",java:S3776,39
"public HashMap<String, Set<ClassifyValue>> getPdcPositions(int cardId) throws PdcException{
    HashMap<String, Set<ClassifyValue>> result = new HashMap<>();
    List<ClassifyPosition> listOfPositions = getPdcManager().getPositions(cardId, getComponentId());
    if (listOfPositions != null && listOfPositions.size() > 0) {
        for (ClassifyPosition position : listOfPositions) {
            for (ClassifyValue value : position.getValues()) {
                List<Value> path = value.getFullPath();
                if (path != null && !path.isEmpty()) {
                    Value axis = path.get(0);
                    String category = axis.getName(getLanguage());
                    if (result.containsKey(category)) {
                        result.get(category).add(value);
                    } else {
                        Set<ClassifyValue> values = new HashSet<>();
                        values.add(value);
                        result.put(category, values);
                    }
                }
            }
        }
    }
    return result;
}",java:S1319,22
"public List getValues(String userId){
    if (isPersoEnabled()) {
        String userPersoValue = returnPersoValue(userId);
        List<List> valret = new ArrayList<>();
        for (int i = 0; i < values.size(); i++) {
            List valeur = (List) getValues().get(i);
            if (valeur.size() > 1 && valeur.get(persoColumnNumber).equals(userPersoValue)) {
                valret.add(valeur);
            }
        }
        return valret;
    } else {
        return getValues();
    }
}",java:S3740,38
"public List getPersoColumns(){
    if (isPersoEnabled()) {
        ArrayList clo = ((ArrayList) columns.clone());
        if (clo.size() > persoColumnNumber) {
            clo.remove(persoColumnNumber);
        }
        return clo;
    } else {
        return columns;
    }
}",java:S3740,38
"private AbstractMediaEntity asWebEntity(Media media, AlbumDetail album){
    final AbstractMediaEntity entity;
    switch(media.getType()) {
        case Photo:
            entity = PhotoEntity.createFrom(media.getPhoto()).withNormalUrl(GalleryResourceURIs.buildMediaContentURI(media, MediaResolution.NORMAL)).withPreviewUrl(GalleryResourceURIs.buildMediaContentURI(media, MediaResolution.PREVIEW)).withThumbUrl(URI.create(media.getApplicationThumbnailUrl(MediaResolution.SMALL)));
            break;
        case Video:
            entity = VideoEntity.createFrom(media.getVideo()).withThumbUrl(URI.create(media.getApplicationThumbnailUrl(MediaResolution.MEDIUM)));
            break;
        case Sound:
            entity = SoundEntity.createFrom(media.getSound()).withThumbUrl(URI.create(media.getApplicationThumbnailUrl(MediaResolution.MEDIUM)));
            break;
        case Streaming:
            entity = StreamingEntity.createFrom(media.getStreaming()).withOriginalUrl(URI.create(media.getStreaming().getHomepageUrl())).withThumbUrl(URI.create(media.getApplicationThumbnailUrl(MediaResolution.MEDIUM)));
            break;
        default:
            throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);
    }
    if (media.getInternalMedia() != null) {
        entity.withOriginalUrl(GalleryResourceURIs.buildMediaContentURI(media, MediaResolution.ORIGINAL));
    }
    return entity.withURI(GalleryResourceURIs.buildMediaInAlbumURI(album, media)).withParentURI(GalleryResourceURIs.buildAlbumURI(album));
}",java:S3740,38
